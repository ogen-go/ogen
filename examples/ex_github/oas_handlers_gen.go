// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"math/big"
	"math/bits"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/instrument/syncint64"
	"go.opentelemetry.io/otel/metric/nonrecording"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = bits.LeadingZeros64
	_ = big.Rat{}
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = attribute.KeyValue{}
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.MeterConfig{}
	_ = syncint64.Counter(nil)
	_ = nonrecording.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
	_ = codes.Unset
)

// HandleActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/add-repo-access-to-self-hosted-runner-group-in-org operation.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
func (s *Server) handleActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-repo-access-to-self-hosted-runner-group-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsAddSelectedRepoToOrgSecretRequest handles actions/add-selected-repo-to-org-secret operation.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
func (s *Server) handleActionsAddSelectedRepoToOrgSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-selected-repo-to-org-secret"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsAddSelectedRepoToOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsAddSelectedRepoToOrgSecretParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsAddSelectedRepoToOrgSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsAddSelectedRepoToOrgSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsAddSelfHostedRunnerToGroupForOrgRequest handles actions/add-self-hosted-runner-to-group-for-org operation.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) handleActionsAddSelfHostedRunnerToGroupForOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-self-hosted-runner-to-group-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsAddSelfHostedRunnerToGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsAddSelfHostedRunnerToGroupForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsAddSelfHostedRunnerToGroupForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsAddSelfHostedRunnerToGroupForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsApproveWorkflowRunRequest handles actions/approve-workflow-run operation.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve
func (s *Server) handleActionsApproveWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/approve-workflow-run"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsApproveWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsApproveWorkflowRunParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsApproveWorkflowRun(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsApproveWorkflowRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsCancelWorkflowRunRequest handles actions/cancel-workflow-run operation.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel
func (s *Server) handleActionsCancelWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/cancel-workflow-run"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCancelWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsCancelWorkflowRunParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsCancelWorkflowRun(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCancelWorkflowRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsCreateOrUpdateEnvironmentSecretRequest handles actions/create-or-update-environment-secret operation.
//
// PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (s *Server) handleActionsCreateOrUpdateEnvironmentSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-environment-secret"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateOrUpdateEnvironmentSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsCreateOrUpdateEnvironmentSecretParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActionsCreateOrUpdateEnvironmentSecretRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsCreateOrUpdateEnvironmentSecret(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCreateOrUpdateEnvironmentSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsCreateOrUpdateOrgSecretRequest handles actions/create-or-update-org-secret operation.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}
func (s *Server) handleActionsCreateOrUpdateOrgSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-org-secret"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateOrUpdateOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsCreateOrUpdateOrgSecretParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActionsCreateOrUpdateOrgSecretRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsCreateOrUpdateOrgSecret(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCreateOrUpdateOrgSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsCreateOrUpdateRepoSecretRequest handles actions/create-or-update-repo-secret operation.
//
// PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (s *Server) handleActionsCreateOrUpdateRepoSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-repo-secret"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateOrUpdateRepoSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsCreateOrUpdateRepoSecretParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActionsCreateOrUpdateRepoSecretRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsCreateOrUpdateRepoSecret(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCreateOrUpdateRepoSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsCreateRegistrationTokenForOrgRequest handles actions/create-registration-token-for-org operation.
//
// POST /orgs/{org}/actions/runners/registration-token
func (s *Server) handleActionsCreateRegistrationTokenForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-registration-token-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateRegistrationTokenForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsCreateRegistrationTokenForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsCreateRegistrationTokenForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCreateRegistrationTokenForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsCreateRegistrationTokenForRepoRequest handles actions/create-registration-token-for-repo operation.
//
// POST /repos/{owner}/{repo}/actions/runners/registration-token
func (s *Server) handleActionsCreateRegistrationTokenForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-registration-token-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateRegistrationTokenForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsCreateRegistrationTokenForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsCreateRegistrationTokenForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCreateRegistrationTokenForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsCreateRemoveTokenForOrgRequest handles actions/create-remove-token-for-org operation.
//
// POST /orgs/{org}/actions/runners/remove-token
func (s *Server) handleActionsCreateRemoveTokenForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-remove-token-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateRemoveTokenForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsCreateRemoveTokenForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsCreateRemoveTokenForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCreateRemoveTokenForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsCreateRemoveTokenForRepoRequest handles actions/create-remove-token-for-repo operation.
//
// POST /repos/{owner}/{repo}/actions/runners/remove-token
func (s *Server) handleActionsCreateRemoveTokenForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-remove-token-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateRemoveTokenForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsCreateRemoveTokenForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsCreateRemoveTokenForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCreateRemoveTokenForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsCreateSelfHostedRunnerGroupForOrgRequest handles actions/create-self-hosted-runner-group-for-org operation.
//
// POST /orgs/{org}/actions/runner-groups
func (s *Server) handleActionsCreateSelfHostedRunnerGroupForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-self-hosted-runner-group-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsCreateSelfHostedRunnerGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsCreateSelfHostedRunnerGroupForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActionsCreateSelfHostedRunnerGroupForOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsCreateSelfHostedRunnerGroupForOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsCreateSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsDeleteArtifactRequest handles actions/delete-artifact operation.
//
// DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
func (s *Server) handleActionsDeleteArtifactRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-artifact"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteArtifact",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsDeleteArtifactParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsDeleteArtifact(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteArtifactResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsDeleteEnvironmentSecretRequest handles actions/delete-environment-secret operation.
//
// DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (s *Server) handleActionsDeleteEnvironmentSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-environment-secret"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteEnvironmentSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsDeleteEnvironmentSecretParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsDeleteEnvironmentSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteEnvironmentSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsDeleteOrgSecretRequest handles actions/delete-org-secret operation.
//
// DELETE /orgs/{org}/actions/secrets/{secret_name}
func (s *Server) handleActionsDeleteOrgSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-org-secret"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsDeleteOrgSecretParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsDeleteOrgSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteOrgSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsDeleteRepoSecretRequest handles actions/delete-repo-secret operation.
//
// DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (s *Server) handleActionsDeleteRepoSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-repo-secret"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteRepoSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsDeleteRepoSecretParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsDeleteRepoSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteRepoSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsDeleteSelfHostedRunnerFromOrgRequest handles actions/delete-self-hosted-runner-from-org operation.
//
// DELETE /orgs/{org}/actions/runners/{runner_id}
func (s *Server) handleActionsDeleteSelfHostedRunnerFromOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-from-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteSelfHostedRunnerFromOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsDeleteSelfHostedRunnerFromOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsDeleteSelfHostedRunnerFromOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteSelfHostedRunnerFromOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsDeleteSelfHostedRunnerFromRepoRequest handles actions/delete-self-hosted-runner-from-repo operation.
//
// DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}
func (s *Server) handleActionsDeleteSelfHostedRunnerFromRepoRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-from-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteSelfHostedRunnerFromRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsDeleteSelfHostedRunnerFromRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsDeleteSelfHostedRunnerFromRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteSelfHostedRunnerFromRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsDeleteSelfHostedRunnerGroupFromOrgRequest handles actions/delete-self-hosted-runner-group-from-org operation.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}
func (s *Server) handleActionsDeleteSelfHostedRunnerGroupFromOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-group-from-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteSelfHostedRunnerGroupFromOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsDeleteSelfHostedRunnerGroupFromOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsDeleteSelfHostedRunnerGroupFromOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteSelfHostedRunnerGroupFromOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsDeleteWorkflowRunRequest handles actions/delete-workflow-run operation.
//
// DELETE /repos/{owner}/{repo}/actions/runs/{run_id}
func (s *Server) handleActionsDeleteWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-workflow-run"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsDeleteWorkflowRunParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsDeleteWorkflowRun(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteWorkflowRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsDeleteWorkflowRunLogsRequest handles actions/delete-workflow-run-logs operation.
//
// DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs
func (s *Server) handleActionsDeleteWorkflowRunLogsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-workflow-run-logs"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDeleteWorkflowRunLogs",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsDeleteWorkflowRunLogsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsDeleteWorkflowRunLogs(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDeleteWorkflowRunLogsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsDisableSelectedRepositoryGithubActionsOrganizationRequest handles actions/disable-selected-repository-github-actions-organization operation.
//
// DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}
func (s *Server) handleActionsDisableSelectedRepositoryGithubActionsOrganizationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/disable-selected-repository-github-actions-organization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDisableSelectedRepositoryGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsDisableSelectedRepositoryGithubActionsOrganizationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsDisableSelectedRepositoryGithubActionsOrganization(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDisableSelectedRepositoryGithubActionsOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsDownloadArtifactRequest handles actions/download-artifact operation.
//
// GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}
func (s *Server) handleActionsDownloadArtifactRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-artifact"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDownloadArtifact",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsDownloadArtifactParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsDownloadArtifact(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDownloadArtifactResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsDownloadJobLogsForWorkflowRunRequest handles actions/download-job-logs-for-workflow-run operation.
//
// GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs
func (s *Server) handleActionsDownloadJobLogsForWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-job-logs-for-workflow-run"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDownloadJobLogsForWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsDownloadJobLogsForWorkflowRunParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsDownloadJobLogsForWorkflowRun(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDownloadJobLogsForWorkflowRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsDownloadWorkflowRunLogsRequest handles actions/download-workflow-run-logs operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs
func (s *Server) handleActionsDownloadWorkflowRunLogsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-workflow-run-logs"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsDownloadWorkflowRunLogs",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsDownloadWorkflowRunLogsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsDownloadWorkflowRunLogs(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsDownloadWorkflowRunLogsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsEnableSelectedRepositoryGithubActionsOrganizationRequest handles actions/enable-selected-repository-github-actions-organization operation.
//
// PUT /orgs/{org}/actions/permissions/repositories/{repository_id}
func (s *Server) handleActionsEnableSelectedRepositoryGithubActionsOrganizationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/enable-selected-repository-github-actions-organization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsEnableSelectedRepositoryGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsEnableSelectedRepositoryGithubActionsOrganizationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsEnableSelectedRepositoryGithubActionsOrganization(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsEnableSelectedRepositoryGithubActionsOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetAllowedActionsOrganizationRequest handles actions/get-allowed-actions-organization operation.
//
// GET /orgs/{org}/actions/permissions/selected-actions
func (s *Server) handleActionsGetAllowedActionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-allowed-actions-organization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetAllowedActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetAllowedActionsOrganizationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetAllowedActionsOrganization(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetAllowedActionsOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetAllowedActionsRepositoryRequest handles actions/get-allowed-actions-repository operation.
//
// GET /repos/{owner}/{repo}/actions/permissions/selected-actions
func (s *Server) handleActionsGetAllowedActionsRepositoryRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-allowed-actions-repository"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetAllowedActionsRepository",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetAllowedActionsRepositoryParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetAllowedActionsRepository(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetAllowedActionsRepositoryResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetArtifactRequest handles actions/get-artifact operation.
//
// GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
func (s *Server) handleActionsGetArtifactRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-artifact"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetArtifact",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetArtifactParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetArtifact(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetArtifactResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetEnvironmentPublicKeyRequest handles actions/get-environment-public-key operation.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key
func (s *Server) handleActionsGetEnvironmentPublicKeyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-environment-public-key"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetEnvironmentPublicKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetEnvironmentPublicKeyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetEnvironmentPublicKey(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetEnvironmentPublicKeyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetEnvironmentSecretRequest handles actions/get-environment-secret operation.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (s *Server) handleActionsGetEnvironmentSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-environment-secret"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetEnvironmentSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetEnvironmentSecretParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetEnvironmentSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetEnvironmentSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetGithubActionsPermissionsOrganizationRequest handles actions/get-github-actions-permissions-organization operation.
//
// GET /orgs/{org}/actions/permissions
func (s *Server) handleActionsGetGithubActionsPermissionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-github-actions-permissions-organization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetGithubActionsPermissionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetGithubActionsPermissionsOrganizationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetGithubActionsPermissionsOrganization(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetGithubActionsPermissionsOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetGithubActionsPermissionsRepositoryRequest handles actions/get-github-actions-permissions-repository operation.
//
// GET /repos/{owner}/{repo}/actions/permissions
func (s *Server) handleActionsGetGithubActionsPermissionsRepositoryRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-github-actions-permissions-repository"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetGithubActionsPermissionsRepository",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetGithubActionsPermissionsRepositoryParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetGithubActionsPermissionsRepository(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetGithubActionsPermissionsRepositoryResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetJobForWorkflowRunRequest handles actions/get-job-for-workflow-run operation.
//
// GET /repos/{owner}/{repo}/actions/jobs/{job_id}
func (s *Server) handleActionsGetJobForWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-job-for-workflow-run"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetJobForWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetJobForWorkflowRunParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetJobForWorkflowRun(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetJobForWorkflowRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetOrgPublicKeyRequest handles actions/get-org-public-key operation.
//
// GET /orgs/{org}/actions/secrets/public-key
func (s *Server) handleActionsGetOrgPublicKeyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-org-public-key"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetOrgPublicKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetOrgPublicKeyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetOrgPublicKey(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetOrgPublicKeyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetOrgSecretRequest handles actions/get-org-secret operation.
//
// GET /orgs/{org}/actions/secrets/{secret_name}
func (s *Server) handleActionsGetOrgSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-org-secret"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetOrgSecretParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetOrgSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetOrgSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetRepoPublicKeyRequest handles actions/get-repo-public-key operation.
//
// GET /repos/{owner}/{repo}/actions/secrets/public-key
func (s *Server) handleActionsGetRepoPublicKeyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-repo-public-key"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetRepoPublicKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetRepoPublicKeyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetRepoPublicKey(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetRepoPublicKeyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetRepoSecretRequest handles actions/get-repo-secret operation.
//
// GET /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (s *Server) handleActionsGetRepoSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-repo-secret"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetRepoSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetRepoSecretParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetRepoSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetRepoSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetReviewsForRunRequest handles actions/get-reviews-for-run operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals
func (s *Server) handleActionsGetReviewsForRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-reviews-for-run"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetReviewsForRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetReviewsForRunParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetReviewsForRun(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetReviewsForRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetSelfHostedRunnerForOrgRequest handles actions/get-self-hosted-runner-for-org operation.
//
// GET /orgs/{org}/actions/runners/{runner_id}
func (s *Server) handleActionsGetSelfHostedRunnerForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetSelfHostedRunnerForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetSelfHostedRunnerForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetSelfHostedRunnerForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetSelfHostedRunnerForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetSelfHostedRunnerForRepoRequest handles actions/get-self-hosted-runner-for-repo operation.
//
// GET /repos/{owner}/{repo}/actions/runners/{runner_id}
func (s *Server) handleActionsGetSelfHostedRunnerForRepoRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetSelfHostedRunnerForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetSelfHostedRunnerForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetSelfHostedRunnerForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetSelfHostedRunnerForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetSelfHostedRunnerGroupForOrgRequest handles actions/get-self-hosted-runner-group-for-org operation.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}
func (s *Server) handleActionsGetSelfHostedRunnerGroupForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-group-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetSelfHostedRunnerGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetSelfHostedRunnerGroupForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetSelfHostedRunnerGroupForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetWorkflowRunRequest handles actions/get-workflow-run operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}
func (s *Server) handleActionsGetWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-workflow-run"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetWorkflowRunParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetWorkflowRun(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetWorkflowRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsGetWorkflowRunUsageRequest handles actions/get-workflow-run-usage operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing
func (s *Server) handleActionsGetWorkflowRunUsageRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-workflow-run-usage"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsGetWorkflowRunUsage",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsGetWorkflowRunUsageParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsGetWorkflowRunUsage(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsGetWorkflowRunUsageResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListArtifactsForRepoRequest handles actions/list-artifacts-for-repo operation.
//
// GET /repos/{owner}/{repo}/actions/artifacts
func (s *Server) handleActionsListArtifactsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-artifacts-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListArtifactsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListArtifactsForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListArtifactsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListArtifactsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListEnvironmentSecretsRequest handles actions/list-environment-secrets operation.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets
func (s *Server) handleActionsListEnvironmentSecretsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-environment-secrets"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListEnvironmentSecrets",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListEnvironmentSecretsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListEnvironmentSecrets(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListEnvironmentSecretsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListJobsForWorkflowRunRequest handles actions/list-jobs-for-workflow-run operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs
func (s *Server) handleActionsListJobsForWorkflowRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-jobs-for-workflow-run"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListJobsForWorkflowRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListJobsForWorkflowRunParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListJobsForWorkflowRun(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListJobsForWorkflowRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListOrgSecretsRequest handles actions/list-org-secrets operation.
//
// GET /orgs/{org}/actions/secrets
func (s *Server) handleActionsListOrgSecretsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-org-secrets"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListOrgSecrets",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListOrgSecretsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListOrgSecrets(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListOrgSecretsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/list-repo-access-to-self-hosted-runner-group-in-org operation.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
func (s *Server) handleActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-access-to-self-hosted-runner-group-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListRepoSecretsRequest handles actions/list-repo-secrets operation.
//
// GET /repos/{owner}/{repo}/actions/secrets
func (s *Server) handleActionsListRepoSecretsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-secrets"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListRepoSecrets",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListRepoSecretsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListRepoSecrets(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListRepoSecretsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListRepoWorkflowsRequest handles actions/list-repo-workflows operation.
//
// GET /repos/{owner}/{repo}/actions/workflows
func (s *Server) handleActionsListRepoWorkflowsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-workflows"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListRepoWorkflows",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListRepoWorkflowsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListRepoWorkflows(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListRepoWorkflowsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListRunnerApplicationsForOrgRequest handles actions/list-runner-applications-for-org operation.
//
// GET /orgs/{org}/actions/runners/downloads
func (s *Server) handleActionsListRunnerApplicationsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-runner-applications-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListRunnerApplicationsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListRunnerApplicationsForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListRunnerApplicationsForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListRunnerApplicationsForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListRunnerApplicationsForRepoRequest handles actions/list-runner-applications-for-repo operation.
//
// GET /repos/{owner}/{repo}/actions/runners/downloads
func (s *Server) handleActionsListRunnerApplicationsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-runner-applications-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListRunnerApplicationsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListRunnerApplicationsForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListRunnerApplicationsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListRunnerApplicationsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListSelectedReposForOrgSecretRequest handles actions/list-selected-repos-for-org-secret operation.
//
// GET /orgs/{org}/actions/secrets/{secret_name}/repositories
func (s *Server) handleActionsListSelectedReposForOrgSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-selected-repos-for-org-secret"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelectedReposForOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListSelectedReposForOrgSecretParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListSelectedReposForOrgSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListSelectedReposForOrgSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest handles actions/list-selected-repositories-enabled-github-actions-organization operation.
//
// GET /orgs/{org}/actions/permissions/repositories
func (s *Server) handleActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-selected-repositories-enabled-github-actions-organization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelectedRepositoriesEnabledGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListSelfHostedRunnerGroupsForOrgRequest handles actions/list-self-hosted-runner-groups-for-org operation.
//
// GET /orgs/{org}/actions/runner-groups
func (s *Server) handleActionsListSelfHostedRunnerGroupsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runner-groups-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelfHostedRunnerGroupsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListSelfHostedRunnerGroupsForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListSelfHostedRunnerGroupsForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnerGroupsForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListSelfHostedRunnersForOrgRequest handles actions/list-self-hosted-runners-for-org operation.
//
// GET /orgs/{org}/actions/runners
func (s *Server) handleActionsListSelfHostedRunnersForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelfHostedRunnersForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListSelfHostedRunnersForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListSelfHostedRunnersForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnersForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListSelfHostedRunnersForRepoRequest handles actions/list-self-hosted-runners-for-repo operation.
//
// GET /repos/{owner}/{repo}/actions/runners
func (s *Server) handleActionsListSelfHostedRunnersForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelfHostedRunnersForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListSelfHostedRunnersForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListSelfHostedRunnersForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnersForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListSelfHostedRunnersInGroupForOrgRequest handles actions/list-self-hosted-runners-in-group-for-org operation.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) handleActionsListSelfHostedRunnersInGroupForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-in-group-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListSelfHostedRunnersInGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListSelfHostedRunnersInGroupForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListSelfHostedRunnersInGroupForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnersInGroupForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListWorkflowRunArtifactsRequest handles actions/list-workflow-run-artifacts operation.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts
func (s *Server) handleActionsListWorkflowRunArtifactsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-workflow-run-artifacts"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListWorkflowRunArtifacts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListWorkflowRunArtifactsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListWorkflowRunArtifacts(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListWorkflowRunArtifactsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsListWorkflowRunsForRepoRequest handles actions/list-workflow-runs-for-repo operation.
//
// GET /repos/{owner}/{repo}/actions/runs
func (s *Server) handleActionsListWorkflowRunsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-workflow-runs-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsListWorkflowRunsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsListWorkflowRunsForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsListWorkflowRunsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsListWorkflowRunsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsReRunWorkflowRequest handles actions/re-run-workflow operation.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun
func (s *Server) handleActionsReRunWorkflowRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/re-run-workflow"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsReRunWorkflow",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsReRunWorkflowParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsReRunWorkflow(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsReRunWorkflowResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/remove-repo-access-to-self-hosted-runner-group-in-org operation.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
func (s *Server) handleActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-repo-access-to-self-hosted-runner-group-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsRemoveSelectedRepoFromOrgSecretRequest handles actions/remove-selected-repo-from-org-secret operation.
//
// DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
func (s *Server) handleActionsRemoveSelectedRepoFromOrgSecretRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-selected-repo-from-org-secret"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsRemoveSelectedRepoFromOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsRemoveSelectedRepoFromOrgSecretParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsRemoveSelectedRepoFromOrgSecret(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsRemoveSelectedRepoFromOrgSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsRemoveSelfHostedRunnerFromGroupForOrgRequest handles actions/remove-self-hosted-runner-from-group-for-org operation.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) handleActionsRemoveSelfHostedRunnerFromGroupForOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-self-hosted-runner-from-group-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsRemoveSelfHostedRunnerFromGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsRemoveSelfHostedRunnerFromGroupForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsRemoveSelfHostedRunnerFromGroupForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsRetryWorkflowRequest handles actions/retry-workflow operation.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/retry
func (s *Server) handleActionsRetryWorkflowRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/retry-workflow"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsRetryWorkflow",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsRetryWorkflowParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsRetryWorkflow(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsRetryWorkflowResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsReviewPendingDeploymentsForRunRequest handles actions/review-pending-deployments-for-run operation.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments
func (s *Server) handleActionsReviewPendingDeploymentsForRunRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/review-pending-deployments-for-run"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsReviewPendingDeploymentsForRun",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsReviewPendingDeploymentsForRunParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActionsReviewPendingDeploymentsForRunRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsReviewPendingDeploymentsForRun(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsReviewPendingDeploymentsForRunResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsSetAllowedActionsOrganizationRequest handles actions/set-allowed-actions-organization operation.
//
// PUT /orgs/{org}/actions/permissions/selected-actions
func (s *Server) handleActionsSetAllowedActionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-allowed-actions-organization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetAllowedActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsSetAllowedActionsOrganizationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActionsSetAllowedActionsOrganizationRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsSetAllowedActionsOrganization(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsSetAllowedActionsOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsSetAllowedActionsRepositoryRequest handles actions/set-allowed-actions-repository operation.
//
// PUT /repos/{owner}/{repo}/actions/permissions/selected-actions
func (s *Server) handleActionsSetAllowedActionsRepositoryRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-allowed-actions-repository"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetAllowedActionsRepository",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsSetAllowedActionsRepositoryParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActionsSetAllowedActionsRepositoryRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsSetAllowedActionsRepository(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsSetAllowedActionsRepositoryResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsSetGithubActionsPermissionsOrganizationRequest handles actions/set-github-actions-permissions-organization operation.
//
// PUT /orgs/{org}/actions/permissions
func (s *Server) handleActionsSetGithubActionsPermissionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-github-actions-permissions-organization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetGithubActionsPermissionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsSetGithubActionsPermissionsOrganizationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActionsSetGithubActionsPermissionsOrganizationRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsSetGithubActionsPermissionsOrganization(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsSetGithubActionsPermissionsOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsSetGithubActionsPermissionsRepositoryRequest handles actions/set-github-actions-permissions-repository operation.
//
// PUT /repos/{owner}/{repo}/actions/permissions
func (s *Server) handleActionsSetGithubActionsPermissionsRepositoryRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-github-actions-permissions-repository"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetGithubActionsPermissionsRepository",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsSetGithubActionsPermissionsRepositoryParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActionsSetGithubActionsPermissionsRepositoryRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsSetGithubActionsPermissionsRepository(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsSetGithubActionsPermissionsRepositoryResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/set-repo-access-to-self-hosted-runner-group-in-org operation.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
func (s *Server) handleActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-repo-access-to-self-hosted-runner-group-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsSetSelectedReposForOrgSecretRequest handles actions/set-selected-repos-for-org-secret operation.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}/repositories
func (s *Server) handleActionsSetSelectedReposForOrgSecretRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-selected-repos-for-org-secret"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetSelectedReposForOrgSecret",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsSetSelectedReposForOrgSecretParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActionsSetSelectedReposForOrgSecretRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsSetSelectedReposForOrgSecret(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsSetSelectedReposForOrgSecretResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest handles actions/set-selected-repositories-enabled-github-actions-organization operation.
//
// PUT /orgs/{org}/actions/permissions/repositories
func (s *Server) handleActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-selected-repositories-enabled-github-actions-organization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsSetSelfHostedRunnersInGroupForOrgRequest handles actions/set-self-hosted-runners-in-group-for-org operation.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) handleActionsSetSelfHostedRunnersInGroupForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-self-hosted-runners-in-group-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsSetSelfHostedRunnersInGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsSetSelfHostedRunnersInGroupForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActionsSetSelfHostedRunnersInGroupForOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsSetSelfHostedRunnersInGroupForOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsSetSelfHostedRunnersInGroupForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActionsUpdateSelfHostedRunnerGroupForOrgRequest handles actions/update-self-hosted-runner-group-for-org operation.
//
// PATCH /orgs/{org}/actions/runner-groups/{runner_group_id}
func (s *Server) handleActionsUpdateSelfHostedRunnerGroupForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/update-self-hosted-runner-group-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActionsUpdateSelfHostedRunnerGroupForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActionsUpdateSelfHostedRunnerGroupForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActionsUpdateSelfHostedRunnerGroupForOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActionsUpdateSelfHostedRunnerGroupForOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActionsUpdateSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityCheckRepoIsStarredByAuthenticatedUserRequest handles activity/check-repo-is-starred-by-authenticated-user operation.
//
// GET /user/starred/{owner}/{repo}
func (s *Server) handleActivityCheckRepoIsStarredByAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/check-repo-is-starred-by-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityCheckRepoIsStarredByAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityCheckRepoIsStarredByAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityCheckRepoIsStarredByAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityCheckRepoIsStarredByAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityDeleteRepoSubscriptionRequest handles activity/delete-repo-subscription operation.
//
// DELETE /repos/{owner}/{repo}/subscription
func (s *Server) handleActivityDeleteRepoSubscriptionRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/delete-repo-subscription"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityDeleteRepoSubscription",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityDeleteRepoSubscriptionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityDeleteRepoSubscription(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityDeleteRepoSubscriptionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityDeleteThreadSubscriptionRequest handles activity/delete-thread-subscription operation.
//
// DELETE /notifications/threads/{thread_id}/subscription
func (s *Server) handleActivityDeleteThreadSubscriptionRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/delete-thread-subscription"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityDeleteThreadSubscription",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityDeleteThreadSubscriptionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityDeleteThreadSubscription(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityDeleteThreadSubscriptionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityGetFeedsRequest handles activity/get-feeds operation.
//
// GET /feeds
func (s *Server) handleActivityGetFeedsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-feeds"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityGetFeeds",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error

	response, err := s.h.ActivityGetFeeds(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityGetFeedsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityGetRepoSubscriptionRequest handles activity/get-repo-subscription operation.
//
// GET /repos/{owner}/{repo}/subscription
func (s *Server) handleActivityGetRepoSubscriptionRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-repo-subscription"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityGetRepoSubscription",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityGetRepoSubscriptionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityGetRepoSubscription(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityGetRepoSubscriptionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityGetThreadRequest handles activity/get-thread operation.
//
// GET /notifications/threads/{thread_id}
func (s *Server) handleActivityGetThreadRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-thread"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityGetThread",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityGetThreadParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityGetThread(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityGetThreadResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityGetThreadSubscriptionForAuthenticatedUserRequest handles activity/get-thread-subscription-for-authenticated-user operation.
//
// GET /notifications/threads/{thread_id}/subscription
func (s *Server) handleActivityGetThreadSubscriptionForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-thread-subscription-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityGetThreadSubscriptionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityGetThreadSubscriptionForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityGetThreadSubscriptionForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityGetThreadSubscriptionForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityListEventsForAuthenticatedUserRequest handles activity/list-events-for-authenticated-user operation.
//
// GET /users/{username}/events
func (s *Server) handleActivityListEventsForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-events-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListEventsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityListEventsForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityListEventsForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListEventsForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityListNotificationsForAuthenticatedUserRequest handles activity/list-notifications-for-authenticated-user operation.
//
// GET /notifications
func (s *Server) handleActivityListNotificationsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-notifications-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListNotificationsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityListNotificationsForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityListNotificationsForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListNotificationsForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityListOrgEventsForAuthenticatedUserRequest handles activity/list-org-events-for-authenticated-user operation.
//
// GET /users/{username}/events/orgs/{org}
func (s *Server) handleActivityListOrgEventsForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-org-events-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListOrgEventsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityListOrgEventsForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityListOrgEventsForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListOrgEventsForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityListPublicEventsRequest handles activity/list-public-events operation.
//
// GET /events
func (s *Server) handleActivityListPublicEventsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListPublicEvents",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityListPublicEventsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityListPublicEvents(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListPublicEventsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityListPublicEventsForRepoNetworkRequest handles activity/list-public-events-for-repo-network operation.
//
// GET /networks/{owner}/{repo}/events
func (s *Server) handleActivityListPublicEventsForRepoNetworkRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events-for-repo-network"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListPublicEventsForRepoNetwork",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityListPublicEventsForRepoNetworkParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityListPublicEventsForRepoNetwork(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListPublicEventsForRepoNetworkResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityListPublicEventsForUserRequest handles activity/list-public-events-for-user operation.
//
// GET /users/{username}/events/public
func (s *Server) handleActivityListPublicEventsForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListPublicEventsForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityListPublicEventsForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityListPublicEventsForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListPublicEventsForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityListPublicOrgEventsRequest handles activity/list-public-org-events operation.
//
// GET /orgs/{org}/events
func (s *Server) handleActivityListPublicOrgEventsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-org-events"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListPublicOrgEvents",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityListPublicOrgEventsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityListPublicOrgEvents(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListPublicOrgEventsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityListReceivedEventsForUserRequest handles activity/list-received-events-for-user operation.
//
// GET /users/{username}/received_events
func (s *Server) handleActivityListReceivedEventsForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-received-events-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListReceivedEventsForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityListReceivedEventsForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityListReceivedEventsForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListReceivedEventsForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityListReceivedPublicEventsForUserRequest handles activity/list-received-public-events-for-user operation.
//
// GET /users/{username}/received_events/public
func (s *Server) handleActivityListReceivedPublicEventsForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-received-public-events-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListReceivedPublicEventsForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityListReceivedPublicEventsForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityListReceivedPublicEventsForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListReceivedPublicEventsForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityListRepoEventsRequest handles activity/list-repo-events operation.
//
// GET /repos/{owner}/{repo}/events
func (s *Server) handleActivityListRepoEventsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repo-events"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListRepoEvents",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityListRepoEventsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityListRepoEvents(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListRepoEventsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityListRepoNotificationsForAuthenticatedUserRequest handles activity/list-repo-notifications-for-authenticated-user operation.
//
// GET /repos/{owner}/{repo}/notifications
func (s *Server) handleActivityListRepoNotificationsForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repo-notifications-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListRepoNotificationsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityListRepoNotificationsForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityListRepoNotificationsForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListRepoNotificationsForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityListReposStarredByAuthenticatedUserRequest handles activity/list-repos-starred-by-authenticated-user operation.
//
// GET /user/starred
func (s *Server) handleActivityListReposStarredByAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repos-starred-by-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListReposStarredByAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityListReposStarredByAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityListReposStarredByAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListReposStarredByAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityListReposWatchedByUserRequest handles activity/list-repos-watched-by-user operation.
//
// GET /users/{username}/subscriptions
func (s *Server) handleActivityListReposWatchedByUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repos-watched-by-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListReposWatchedByUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityListReposWatchedByUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityListReposWatchedByUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListReposWatchedByUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityListWatchedReposForAuthenticatedUserRequest handles activity/list-watched-repos-for-authenticated-user operation.
//
// GET /user/subscriptions
func (s *Server) handleActivityListWatchedReposForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-watched-repos-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListWatchedReposForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityListWatchedReposForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityListWatchedReposForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListWatchedReposForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityListWatchersForRepoRequest handles activity/list-watchers-for-repo operation.
//
// GET /repos/{owner}/{repo}/subscribers
func (s *Server) handleActivityListWatchersForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-watchers-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityListWatchersForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityListWatchersForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityListWatchersForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityListWatchersForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityMarkNotificationsAsReadRequest handles activity/mark-notifications-as-read operation.
//
// PUT /notifications
func (s *Server) handleActivityMarkNotificationsAsReadRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-notifications-as-read"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityMarkNotificationsAsRead",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	request, err := decodeActivityMarkNotificationsAsReadRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityMarkNotificationsAsRead(ctx, request)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityMarkNotificationsAsReadResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityMarkRepoNotificationsAsReadRequest handles activity/mark-repo-notifications-as-read operation.
//
// PUT /repos/{owner}/{repo}/notifications
func (s *Server) handleActivityMarkRepoNotificationsAsReadRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-repo-notifications-as-read"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityMarkRepoNotificationsAsRead",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityMarkRepoNotificationsAsReadParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActivityMarkRepoNotificationsAsReadRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityMarkRepoNotificationsAsRead(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityMarkRepoNotificationsAsReadResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityMarkThreadAsReadRequest handles activity/mark-thread-as-read operation.
//
// PATCH /notifications/threads/{thread_id}
func (s *Server) handleActivityMarkThreadAsReadRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-thread-as-read"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityMarkThreadAsRead",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityMarkThreadAsReadParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityMarkThreadAsRead(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityMarkThreadAsReadResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivitySetRepoSubscriptionRequest handles activity/set-repo-subscription operation.
//
// PUT /repos/{owner}/{repo}/subscription
func (s *Server) handleActivitySetRepoSubscriptionRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/set-repo-subscription"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivitySetRepoSubscription",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivitySetRepoSubscriptionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActivitySetRepoSubscriptionRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivitySetRepoSubscription(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivitySetRepoSubscriptionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivitySetThreadSubscriptionRequest handles activity/set-thread-subscription operation.
//
// PUT /notifications/threads/{thread_id}/subscription
func (s *Server) handleActivitySetThreadSubscriptionRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/set-thread-subscription"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivitySetThreadSubscription",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivitySetThreadSubscriptionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeActivitySetThreadSubscriptionRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivitySetThreadSubscription(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivitySetThreadSubscriptionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityStarRepoForAuthenticatedUserRequest handles activity/star-repo-for-authenticated-user operation.
//
// PUT /user/starred/{owner}/{repo}
func (s *Server) handleActivityStarRepoForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/star-repo-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityStarRepoForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityStarRepoForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityStarRepoForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityStarRepoForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleActivityUnstarRepoForAuthenticatedUserRequest handles activity/unstar-repo-for-authenticated-user operation.
//
// DELETE /user/starred/{owner}/{repo}
func (s *Server) handleActivityUnstarRepoForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/unstar-repo-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ActivityUnstarRepoForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeActivityUnstarRepoForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ActivityUnstarRepoForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeActivityUnstarRepoForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsAddRepoToInstallationRequest handles apps/add-repo-to-installation operation.
//
// PUT /user/installations/{installation_id}/repositories/{repository_id}
func (s *Server) handleAppsAddRepoToInstallationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/add-repo-to-installation"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsAddRepoToInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsAddRepoToInstallationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsAddRepoToInstallation(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsAddRepoToInstallationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsCheckTokenRequest handles apps/check-token operation.
//
// POST /applications/{client_id}/token
func (s *Server) handleAppsCheckTokenRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/check-token"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsCheckToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsCheckTokenParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeAppsCheckTokenRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsCheckToken(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsCheckTokenResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsCreateContentAttachmentRequest handles apps/create-content-attachment operation.
//
// POST /repos/{owner}/{repo}/content_references/{content_reference_id}/attachments
func (s *Server) handleAppsCreateContentAttachmentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/create-content-attachment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsCreateContentAttachment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsCreateContentAttachmentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeAppsCreateContentAttachmentRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsCreateContentAttachment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsCreateContentAttachmentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsCreateInstallationAccessTokenRequest handles apps/create-installation-access-token operation.
//
// POST /app/installations/{installation_id}/access_tokens
func (s *Server) handleAppsCreateInstallationAccessTokenRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/create-installation-access-token"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsCreateInstallationAccessToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsCreateInstallationAccessTokenParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeAppsCreateInstallationAccessTokenRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsCreateInstallationAccessToken(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsCreateInstallationAccessTokenResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsDeleteAuthorizationRequest handles apps/delete-authorization operation.
//
// DELETE /applications/{client_id}/grant
func (s *Server) handleAppsDeleteAuthorizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-authorization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsDeleteAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsDeleteAuthorizationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeAppsDeleteAuthorizationRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsDeleteAuthorization(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsDeleteAuthorizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsDeleteInstallationRequest handles apps/delete-installation operation.
//
// DELETE /app/installations/{installation_id}
func (s *Server) handleAppsDeleteInstallationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-installation"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsDeleteInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsDeleteInstallationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsDeleteInstallation(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsDeleteInstallationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsDeleteTokenRequest handles apps/delete-token operation.
//
// DELETE /applications/{client_id}/token
func (s *Server) handleAppsDeleteTokenRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-token"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsDeleteToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsDeleteTokenParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeAppsDeleteTokenRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsDeleteToken(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsDeleteTokenResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsGetAuthenticatedRequest handles apps/get-authenticated operation.
//
// GET /app
func (s *Server) handleAppsGetAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error

	response, err := s.h.AppsGetAuthenticated(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsGetAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsGetBySlugRequest handles apps/get-by-slug operation.
//
// GET /apps/{app_slug}
func (s *Server) handleAppsGetBySlugRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-by-slug"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetBySlug",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsGetBySlugParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsGetBySlug(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsGetBySlugResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsGetSubscriptionPlanForAccountRequest handles apps/get-subscription-plan-for-account operation.
//
// GET /marketplace_listing/accounts/{account_id}
func (s *Server) handleAppsGetSubscriptionPlanForAccountRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-subscription-plan-for-account"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetSubscriptionPlanForAccount",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsGetSubscriptionPlanForAccountParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsGetSubscriptionPlanForAccount(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsGetSubscriptionPlanForAccountResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsGetSubscriptionPlanForAccountStubbedRequest handles apps/get-subscription-plan-for-account-stubbed operation.
//
// GET /marketplace_listing/stubbed/accounts/{account_id}
func (s *Server) handleAppsGetSubscriptionPlanForAccountStubbedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-subscription-plan-for-account-stubbed"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetSubscriptionPlanForAccountStubbed",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsGetSubscriptionPlanForAccountStubbedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsGetSubscriptionPlanForAccountStubbed(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsGetSubscriptionPlanForAccountStubbedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsGetWebhookConfigForAppRequest handles apps/get-webhook-config-for-app operation.
//
// GET /app/hook/config
func (s *Server) handleAppsGetWebhookConfigForAppRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-webhook-config-for-app"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetWebhookConfigForApp",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error

	response, err := s.h.AppsGetWebhookConfigForApp(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsGetWebhookConfigForAppResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsGetWebhookDeliveryRequest handles apps/get-webhook-delivery operation.
//
// GET /app/hook/deliveries/{delivery_id}
func (s *Server) handleAppsGetWebhookDeliveryRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-webhook-delivery"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsGetWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsGetWebhookDeliveryParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsGetWebhookDelivery(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsGetWebhookDeliveryResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsListAccountsForPlanRequest handles apps/list-accounts-for-plan operation.
//
// GET /marketplace_listing/plans/{plan_id}/accounts
func (s *Server) handleAppsListAccountsForPlanRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-accounts-for-plan"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListAccountsForPlan",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsListAccountsForPlanParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsListAccountsForPlan(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsListAccountsForPlanResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsListAccountsForPlanStubbedRequest handles apps/list-accounts-for-plan-stubbed operation.
//
// GET /marketplace_listing/stubbed/plans/{plan_id}/accounts
func (s *Server) handleAppsListAccountsForPlanStubbedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-accounts-for-plan-stubbed"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListAccountsForPlanStubbed",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsListAccountsForPlanStubbedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsListAccountsForPlanStubbed(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsListAccountsForPlanStubbedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsListInstallationReposForAuthenticatedUserRequest handles apps/list-installation-repos-for-authenticated-user operation.
//
// GET /user/installations/{installation_id}/repositories
func (s *Server) handleAppsListInstallationReposForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-installation-repos-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListInstallationReposForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsListInstallationReposForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsListInstallationReposForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsListInstallationReposForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsListPlansRequest handles apps/list-plans operation.
//
// GET /marketplace_listing/plans
func (s *Server) handleAppsListPlansRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-plans"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListPlans",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsListPlansParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsListPlans(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsListPlansResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsListPlansStubbedRequest handles apps/list-plans-stubbed operation.
//
// GET /marketplace_listing/stubbed/plans
func (s *Server) handleAppsListPlansStubbedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-plans-stubbed"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListPlansStubbed",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsListPlansStubbedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsListPlansStubbed(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsListPlansStubbedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsListReposAccessibleToInstallationRequest handles apps/list-repos-accessible-to-installation operation.
//
// GET /installation/repositories
func (s *Server) handleAppsListReposAccessibleToInstallationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-repos-accessible-to-installation"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListReposAccessibleToInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsListReposAccessibleToInstallationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsListReposAccessibleToInstallation(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsListReposAccessibleToInstallationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsListSubscriptionsForAuthenticatedUserRequest handles apps/list-subscriptions-for-authenticated-user operation.
//
// GET /user/marketplace_purchases
func (s *Server) handleAppsListSubscriptionsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-subscriptions-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListSubscriptionsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsListSubscriptionsForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsListSubscriptionsForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsListSubscriptionsForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsListSubscriptionsForAuthenticatedUserStubbedRequest handles apps/list-subscriptions-for-authenticated-user-stubbed operation.
//
// GET /user/marketplace_purchases/stubbed
func (s *Server) handleAppsListSubscriptionsForAuthenticatedUserStubbedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-subscriptions-for-authenticated-user-stubbed"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListSubscriptionsForAuthenticatedUserStubbed",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsListSubscriptionsForAuthenticatedUserStubbedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsListSubscriptionsForAuthenticatedUserStubbed(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsListSubscriptionsForAuthenticatedUserStubbedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsListWebhookDeliveriesRequest handles apps/list-webhook-deliveries operation.
//
// GET /app/hook/deliveries
func (s *Server) handleAppsListWebhookDeliveriesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-webhook-deliveries"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsListWebhookDeliveries",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsListWebhookDeliveriesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsListWebhookDeliveries(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsListWebhookDeliveriesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsRedeliverWebhookDeliveryRequest handles apps/redeliver-webhook-delivery operation.
//
// POST /app/hook/deliveries/{delivery_id}/attempts
func (s *Server) handleAppsRedeliverWebhookDeliveryRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/redeliver-webhook-delivery"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsRedeliverWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsRedeliverWebhookDeliveryParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsRedeliverWebhookDelivery(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsRedeliverWebhookDeliveryResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsRemoveRepoFromInstallationRequest handles apps/remove-repo-from-installation operation.
//
// DELETE /user/installations/{installation_id}/repositories/{repository_id}
func (s *Server) handleAppsRemoveRepoFromInstallationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/remove-repo-from-installation"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsRemoveRepoFromInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsRemoveRepoFromInstallationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsRemoveRepoFromInstallation(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsRemoveRepoFromInstallationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsResetTokenRequest handles apps/reset-token operation.
//
// PATCH /applications/{client_id}/token
func (s *Server) handleAppsResetTokenRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/reset-token"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsResetToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsResetTokenParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeAppsResetTokenRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsResetToken(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsResetTokenResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsRevokeInstallationAccessTokenRequest handles apps/revoke-installation-access-token operation.
//
// DELETE /installation/token
func (s *Server) handleAppsRevokeInstallationAccessTokenRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/revoke-installation-access-token"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsRevokeInstallationAccessToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error

	response, err := s.h.AppsRevokeInstallationAccessToken(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsRevokeInstallationAccessTokenResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsScopeTokenRequest handles apps/scope-token operation.
//
// POST /applications/{client_id}/token/scoped
func (s *Server) handleAppsScopeTokenRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/scope-token"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsScopeToken",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsScopeTokenParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeAppsScopeTokenRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsScopeToken(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsScopeTokenResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsSuspendInstallationRequest handles apps/suspend-installation operation.
//
// PUT /app/installations/{installation_id}/suspended
func (s *Server) handleAppsSuspendInstallationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/suspend-installation"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsSuspendInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsSuspendInstallationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsSuspendInstallation(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsSuspendInstallationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsUnsuspendInstallationRequest handles apps/unsuspend-installation operation.
//
// DELETE /app/installations/{installation_id}/suspended
func (s *Server) handleAppsUnsuspendInstallationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/unsuspend-installation"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsUnsuspendInstallation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeAppsUnsuspendInstallationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsUnsuspendInstallation(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsUnsuspendInstallationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleAppsUpdateWebhookConfigForAppRequest handles apps/update-webhook-config-for-app operation.
//
// PATCH /app/hook/config
func (s *Server) handleAppsUpdateWebhookConfigForAppRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/update-webhook-config-for-app"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "AppsUpdateWebhookConfigForApp",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	request, err := decodeAppsUpdateWebhookConfigForAppRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.AppsUpdateWebhookConfigForApp(ctx, request)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeAppsUpdateWebhookConfigForAppResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleBillingGetGithubActionsBillingGheRequest handles billing/get-github-actions-billing-ghe operation.
//
// GET /enterprises/{enterprise}/settings/billing/actions
func (s *Server) handleBillingGetGithubActionsBillingGheRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-ghe"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubActionsBillingGhe",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeBillingGetGithubActionsBillingGheParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.BillingGetGithubActionsBillingGhe(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetGithubActionsBillingGheResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleBillingGetGithubActionsBillingOrgRequest handles billing/get-github-actions-billing-org operation.
//
// GET /orgs/{org}/settings/billing/actions
func (s *Server) handleBillingGetGithubActionsBillingOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubActionsBillingOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeBillingGetGithubActionsBillingOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.BillingGetGithubActionsBillingOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetGithubActionsBillingOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleBillingGetGithubActionsBillingUserRequest handles billing/get-github-actions-billing-user operation.
//
// GET /users/{username}/settings/billing/actions
func (s *Server) handleBillingGetGithubActionsBillingUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubActionsBillingUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeBillingGetGithubActionsBillingUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.BillingGetGithubActionsBillingUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetGithubActionsBillingUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleBillingGetGithubPackagesBillingGheRequest handles billing/get-github-packages-billing-ghe operation.
//
// GET /enterprises/{enterprise}/settings/billing/packages
func (s *Server) handleBillingGetGithubPackagesBillingGheRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-ghe"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubPackagesBillingGhe",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeBillingGetGithubPackagesBillingGheParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.BillingGetGithubPackagesBillingGhe(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetGithubPackagesBillingGheResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleBillingGetGithubPackagesBillingOrgRequest handles billing/get-github-packages-billing-org operation.
//
// GET /orgs/{org}/settings/billing/packages
func (s *Server) handleBillingGetGithubPackagesBillingOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubPackagesBillingOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeBillingGetGithubPackagesBillingOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.BillingGetGithubPackagesBillingOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetGithubPackagesBillingOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleBillingGetGithubPackagesBillingUserRequest handles billing/get-github-packages-billing-user operation.
//
// GET /users/{username}/settings/billing/packages
func (s *Server) handleBillingGetGithubPackagesBillingUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetGithubPackagesBillingUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeBillingGetGithubPackagesBillingUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.BillingGetGithubPackagesBillingUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetGithubPackagesBillingUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleBillingGetSharedStorageBillingGheRequest handles billing/get-shared-storage-billing-ghe operation.
//
// GET /enterprises/{enterprise}/settings/billing/shared-storage
func (s *Server) handleBillingGetSharedStorageBillingGheRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-ghe"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetSharedStorageBillingGhe",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeBillingGetSharedStorageBillingGheParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.BillingGetSharedStorageBillingGhe(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetSharedStorageBillingGheResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleBillingGetSharedStorageBillingOrgRequest handles billing/get-shared-storage-billing-org operation.
//
// GET /orgs/{org}/settings/billing/shared-storage
func (s *Server) handleBillingGetSharedStorageBillingOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetSharedStorageBillingOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeBillingGetSharedStorageBillingOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.BillingGetSharedStorageBillingOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetSharedStorageBillingOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleBillingGetSharedStorageBillingUserRequest handles billing/get-shared-storage-billing-user operation.
//
// GET /users/{username}/settings/billing/shared-storage
func (s *Server) handleBillingGetSharedStorageBillingUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "BillingGetSharedStorageBillingUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeBillingGetSharedStorageBillingUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.BillingGetSharedStorageBillingUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeBillingGetSharedStorageBillingUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleChecksCreateSuiteRequest handles checks/create-suite operation.
//
// POST /repos/{owner}/{repo}/check-suites
func (s *Server) handleChecksCreateSuiteRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/create-suite"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksCreateSuite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeChecksCreateSuiteParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeChecksCreateSuiteRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ChecksCreateSuite(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksCreateSuiteResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleChecksGetRequest handles checks/get operation.
//
// GET /repos/{owner}/{repo}/check-runs/{check_run_id}
func (s *Server) handleChecksGetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/get"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeChecksGetParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ChecksGet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleChecksGetSuiteRequest handles checks/get-suite operation.
//
// GET /repos/{owner}/{repo}/check-suites/{check_suite_id}
func (s *Server) handleChecksGetSuiteRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/get-suite"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksGetSuite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeChecksGetSuiteParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ChecksGetSuite(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksGetSuiteResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleChecksListAnnotationsRequest handles checks/list-annotations operation.
//
// GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations
func (s *Server) handleChecksListAnnotationsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-annotations"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksListAnnotations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeChecksListAnnotationsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ChecksListAnnotations(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksListAnnotationsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleChecksListForRefRequest handles checks/list-for-ref operation.
//
// GET /repos/{owner}/{repo}/commits/{ref}/check-runs
func (s *Server) handleChecksListForRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-for-ref"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksListForRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeChecksListForRefParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ChecksListForRef(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksListForRefResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleChecksListForSuiteRequest handles checks/list-for-suite operation.
//
// GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs
func (s *Server) handleChecksListForSuiteRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-for-suite"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksListForSuite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeChecksListForSuiteParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ChecksListForSuite(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksListForSuiteResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleChecksListSuitesForRefRequest handles checks/list-suites-for-ref operation.
//
// GET /repos/{owner}/{repo}/commits/{ref}/check-suites
func (s *Server) handleChecksListSuitesForRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-suites-for-ref"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksListSuitesForRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeChecksListSuitesForRefParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ChecksListSuitesForRef(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksListSuitesForRefResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleChecksRerequestSuiteRequest handles checks/rerequest-suite operation.
//
// POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest
func (s *Server) handleChecksRerequestSuiteRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/rerequest-suite"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksRerequestSuite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeChecksRerequestSuiteParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ChecksRerequestSuite(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksRerequestSuiteResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleChecksSetSuitesPreferencesRequest handles checks/set-suites-preferences operation.
//
// PATCH /repos/{owner}/{repo}/check-suites/preferences
func (s *Server) handleChecksSetSuitesPreferencesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/set-suites-preferences"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ChecksSetSuitesPreferences",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeChecksSetSuitesPreferencesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeChecksSetSuitesPreferencesRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ChecksSetSuitesPreferences(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeChecksSetSuitesPreferencesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleCodeScanningDeleteAnalysisRequest handles code-scanning/delete-analysis operation.
//
// DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
func (s *Server) handleCodeScanningDeleteAnalysisRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/delete-analysis"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningDeleteAnalysis",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeCodeScanningDeleteAnalysisParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.CodeScanningDeleteAnalysis(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningDeleteAnalysisResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleCodeScanningGetAlertRequest handles code-scanning/get-alert operation.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
func (s *Server) handleCodeScanningGetAlertRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-alert"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningGetAlert",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeCodeScanningGetAlertParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.CodeScanningGetAlert(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningGetAlertResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleCodeScanningGetAnalysisRequest handles code-scanning/get-analysis operation.
//
// GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
func (s *Server) handleCodeScanningGetAnalysisRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-analysis"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningGetAnalysis",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeCodeScanningGetAnalysisParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.CodeScanningGetAnalysis(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningGetAnalysisResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleCodeScanningGetSarifRequest handles code-scanning/get-sarif operation.
//
// GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}
func (s *Server) handleCodeScanningGetSarifRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-sarif"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningGetSarif",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeCodeScanningGetSarifParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.CodeScanningGetSarif(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningGetSarifResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleCodeScanningListAlertInstancesRequest handles code-scanning/list-alert-instances operation.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances
func (s *Server) handleCodeScanningListAlertInstancesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-alert-instances"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningListAlertInstances",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeCodeScanningListAlertInstancesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.CodeScanningListAlertInstances(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningListAlertInstancesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleCodeScanningListAlertsForRepoRequest handles code-scanning/list-alerts-for-repo operation.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts
func (s *Server) handleCodeScanningListAlertsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-alerts-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningListAlertsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeCodeScanningListAlertsForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.CodeScanningListAlertsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningListAlertsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleCodeScanningListRecentAnalysesRequest handles code-scanning/list-recent-analyses operation.
//
// GET /repos/{owner}/{repo}/code-scanning/analyses
func (s *Server) handleCodeScanningListRecentAnalysesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-recent-analyses"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningListRecentAnalyses",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeCodeScanningListRecentAnalysesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.CodeScanningListRecentAnalyses(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningListRecentAnalysesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleCodeScanningUpdateAlertRequest handles code-scanning/update-alert operation.
//
// PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
func (s *Server) handleCodeScanningUpdateAlertRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/update-alert"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningUpdateAlert",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeCodeScanningUpdateAlertParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeCodeScanningUpdateAlertRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.CodeScanningUpdateAlert(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningUpdateAlertResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleCodeScanningUploadSarifRequest handles code-scanning/upload-sarif operation.
//
// POST /repos/{owner}/{repo}/code-scanning/sarifs
func (s *Server) handleCodeScanningUploadSarifRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/upload-sarif"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodeScanningUploadSarif",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeCodeScanningUploadSarifParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeCodeScanningUploadSarifRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.CodeScanningUploadSarif(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodeScanningUploadSarifResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleCodesOfConductGetAllCodesOfConductRequest handles codes-of-conduct/get-all-codes-of-conduct operation.
//
// GET /codes_of_conduct
func (s *Server) handleCodesOfConductGetAllCodesOfConductRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("codes-of-conduct/get-all-codes-of-conduct"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodesOfConductGetAllCodesOfConduct",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error

	response, err := s.h.CodesOfConductGetAllCodesOfConduct(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodesOfConductGetAllCodesOfConductResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleCodesOfConductGetConductCodeRequest handles codes-of-conduct/get-conduct-code operation.
//
// GET /codes_of_conduct/{key}
func (s *Server) handleCodesOfConductGetConductCodeRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("codes-of-conduct/get-conduct-code"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "CodesOfConductGetConductCode",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeCodesOfConductGetConductCodeParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.CodesOfConductGetConductCode(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeCodesOfConductGetConductCodeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEmojisGetRequest handles emojis/get operation.
//
// GET /emojis
func (s *Server) handleEmojisGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("emojis/get"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EmojisGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error

	response, err := s.h.EmojisGet(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEmojisGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
func (s *Server) handleEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest handles enterprise-admin/add-self-hosted-runner-to-group-for-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) handleEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/add-self-hosted-runner-to-group-for-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminCreateRegistrationTokenForEnterpriseRequest handles enterprise-admin/create-registration-token-for-enterprise operation.
//
// POST /enterprises/{enterprise}/actions/runners/registration-token
func (s *Server) handleEnterpriseAdminCreateRegistrationTokenForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-registration-token-for-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminCreateRegistrationTokenForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminCreateRegistrationTokenForEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminCreateRegistrationTokenForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminCreateRegistrationTokenForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminCreateRemoveTokenForEnterpriseRequest handles enterprise-admin/create-remove-token-for-enterprise operation.
//
// POST /enterprises/{enterprise}/actions/runners/remove-token
func (s *Server) handleEnterpriseAdminCreateRemoveTokenForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-remove-token-for-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminCreateRemoveTokenForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminCreateRemoveTokenForEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminCreateRemoveTokenForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminCreateRemoveTokenForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest handles enterprise-admin/create-self-hosted-runner-group-for-enterprise operation.
//
// POST /enterprises/{enterprise}/actions/runner-groups
func (s *Server) handleEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-self-hosted-runner-group-for-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminDeleteScimGroupFromEnterpriseRequest handles enterprise-admin/delete-scim-group-from-enterprise operation.
//
// DELETE /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) handleEnterpriseAdminDeleteScimGroupFromEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-scim-group-from-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminDeleteScimGroupFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminDeleteScimGroupFromEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminDeleteScimGroupFromEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteScimGroupFromEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest handles enterprise-admin/delete-self-hosted-runner-from-enterprise operation.
//
// DELETE /enterprises/{enterprise}/actions/runners/{runner_id}
func (s *Server) handleEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-self-hosted-runner-from-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest handles enterprise-admin/delete-self-hosted-runner-group-from-enterprise operation.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (s *Server) handleEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-self-hosted-runner-group-from-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminDeleteUserFromEnterpriseRequest handles enterprise-admin/delete-user-from-enterprise operation.
//
// DELETE /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) handleEnterpriseAdminDeleteUserFromEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-user-from-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminDeleteUserFromEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminDeleteUserFromEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminDeleteUserFromEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteUserFromEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest handles enterprise-admin/disable-selected-organization-github-actions-enterprise operation.
//
// DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}
func (s *Server) handleEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/disable-selected-organization-github-actions-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest handles enterprise-admin/enable-selected-organization-github-actions-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}
func (s *Server) handleEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/enable-selected-organization-github-actions-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminGetAllowedActionsEnterpriseRequest handles enterprise-admin/get-allowed-actions-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/permissions/selected-actions
func (s *Server) handleEnterpriseAdminGetAllowedActionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-allowed-actions-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetAllowedActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminGetAllowedActionsEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminGetAllowedActionsEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminGetAllowedActionsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminGetAuditLogRequest handles enterprise-admin/get-audit-log operation.
//
// GET /enterprises/{enterprise}/audit-log
func (s *Server) handleEnterpriseAdminGetAuditLogRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-audit-log"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetAuditLog",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminGetAuditLogParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminGetAuditLog(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminGetAuditLogResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest handles enterprise-admin/get-github-actions-permissions-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/permissions
func (s *Server) handleEnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-github-actions-permissions-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetGithubActionsPermissionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminGetGithubActionsPermissionsEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest handles enterprise-admin/get-provisioning-information-for-enterprise-group operation.
//
// GET /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) handleEnterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-provisioning-information-for-enterprise-group"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetProvisioningInformationForEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminGetProvisioningInformationForEnterpriseGroup(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminGetProvisioningInformationForEnterpriseUserRequest handles enterprise-admin/get-provisioning-information-for-enterprise-user operation.
//
// GET /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) handleEnterpriseAdminGetProvisioningInformationForEnterpriseUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-provisioning-information-for-enterprise-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetProvisioningInformationForEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminGetProvisioningInformationForEnterpriseUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest handles enterprise-admin/get-self-hosted-runner-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runners/{runner_id}
func (s *Server) handleEnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-self-hosted-runner-for-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetSelfHostedRunnerForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminGetSelfHostedRunnerForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest handles enterprise-admin/get-self-hosted-runner-group-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (s *Server) handleEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-self-hosted-runner-group-for-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
func (s *Server) handleEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminListProvisionedGroupsEnterpriseRequest handles enterprise-admin/list-provisioned-groups-enterprise operation.
//
// GET /scim/v2/enterprises/{enterprise}/Groups
func (s *Server) handleEnterpriseAdminListProvisionedGroupsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-provisioned-groups-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListProvisionedGroupsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminListProvisionedGroupsEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminListProvisionedGroupsEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminListProvisionedGroupsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminListProvisionedIdentitiesEnterpriseRequest handles enterprise-admin/list-provisioned-identities-enterprise operation.
//
// GET /scim/v2/enterprises/{enterprise}/Users
func (s *Server) handleEnterpriseAdminListProvisionedIdentitiesEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-provisioned-identities-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListProvisionedIdentitiesEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminListProvisionedIdentitiesEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminListProvisionedIdentitiesEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminListProvisionedIdentitiesEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminListRunnerApplicationsForEnterpriseRequest handles enterprise-admin/list-runner-applications-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runners/downloads
func (s *Server) handleEnterpriseAdminListRunnerApplicationsForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-runner-applications-for-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListRunnerApplicationsForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminListRunnerApplicationsForEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminListRunnerApplicationsForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminListRunnerApplicationsForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest handles enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/permissions/organizations
func (s *Server) handleEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest handles enterprise-admin/list-self-hosted-runner-groups-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runner-groups
func (s *Server) handleEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runner-groups-for-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminListSelfHostedRunnersForEnterpriseRequest handles enterprise-admin/list-self-hosted-runners-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runners
func (s *Server) handleEnterpriseAdminListSelfHostedRunnersForEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runners-for-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListSelfHostedRunnersForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminListSelfHostedRunnersForEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminListSelfHostedRunnersForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminListSelfHostedRunnersForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest handles enterprise-admin/list-self-hosted-runners-in-group-for-enterprise operation.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) handleEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runners-in-group-for-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest handles enterprise-admin/provision-and-invite-enterprise-group operation.
//
// POST /scim/v2/enterprises/{enterprise}/Groups
func (s *Server) handleEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/provision-and-invite-enterprise-group"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminProvisionAndInviteEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminProvisionAndInviteEnterpriseGroup(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminProvisionAndInviteEnterpriseGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminProvisionAndInviteEnterpriseUserRequest handles enterprise-admin/provision-and-invite-enterprise-user operation.
//
// POST /scim/v2/enterprises/{enterprise}/Users
func (s *Server) handleEnterpriseAdminProvisionAndInviteEnterpriseUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/provision-and-invite-enterprise-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminProvisionAndInviteEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseUserRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminProvisionAndInviteEnterpriseUser(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminProvisionAndInviteEnterpriseUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
func (s *Server) handleEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest handles enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise operation.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) handleEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminSetAllowedActionsEnterpriseRequest handles enterprise-admin/set-allowed-actions-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/permissions/selected-actions
func (s *Server) handleEnterpriseAdminSetAllowedActionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-allowed-actions-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetAllowedActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminSetAllowedActionsEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeEnterpriseAdminSetAllowedActionsEnterpriseRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminSetAllowedActionsEnterprise(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminSetAllowedActionsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest handles enterprise-admin/set-github-actions-permissions-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/permissions
func (s *Server) handleEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-github-actions-permissions-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetGithubActionsPermissionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminSetGithubActionsPermissionsEnterprise(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest handles enterprise-admin/set-information-for-provisioned-enterprise-group operation.
//
// PUT /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) handleEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-information-for-provisioned-enterprise-group"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetInformationForProvisionedEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminSetInformationForProvisionedEnterpriseGroup(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest handles enterprise-admin/set-information-for-provisioned-enterprise-user operation.
//
// PUT /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) handleEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-information-for-provisioned-enterprise-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetInformationForProvisionedEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminSetInformationForProvisionedEnterpriseUser(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
func (s *Server) handleEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest handles enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/permissions/organizations
func (s *Server) handleEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest handles enterprise-admin/set-self-hosted-runners-in-group-for-enterprise operation.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) handleEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-self-hosted-runners-in-group-for-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest handles enterprise-admin/update-attribute-for-enterprise-group operation.
//
// PATCH /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) handleEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-attribute-for-enterprise-group"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminUpdateAttributeForEnterpriseGroup",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseGroupParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminUpdateAttributeForEnterpriseGroup(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminUpdateAttributeForEnterpriseGroupResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminUpdateAttributeForEnterpriseUserRequest handles enterprise-admin/update-attribute-for-enterprise-user operation.
//
// PATCH /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) handleEnterpriseAdminUpdateAttributeForEnterpriseUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-attribute-for-enterprise-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminUpdateAttributeForEnterpriseUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseUserRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminUpdateAttributeForEnterpriseUser(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminUpdateAttributeForEnterpriseUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest handles enterprise-admin/update-self-hosted-runner-group-for-enterprise operation.
//
// PATCH /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (s *Server) handleEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-self-hosted-runner-group-for-enterprise"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsCheckIsStarredRequest handles gists/check-is-starred operation.
//
// GET /gists/{gist_id}/star
func (s *Server) handleGistsCheckIsStarredRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/check-is-starred"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsCheckIsStarred",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsCheckIsStarredParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsCheckIsStarred(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsCheckIsStarredResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsCreateRequest handles gists/create operation.
//
// POST /gists
func (s *Server) handleGistsCreateRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/create"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsCreate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	request, err := decodeGistsCreateRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsCreate(ctx, request)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsCreateResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsCreateCommentRequest handles gists/create-comment operation.
//
// POST /gists/{gist_id}/comments
func (s *Server) handleGistsCreateCommentRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/create-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsCreateComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsCreateCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeGistsCreateCommentRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsCreateComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsCreateCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsDeleteRequest handles gists/delete operation.
//
// DELETE /gists/{gist_id}
func (s *Server) handleGistsDeleteRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/delete"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsDelete",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsDeleteParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsDelete(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsDeleteResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsDeleteCommentRequest handles gists/delete-comment operation.
//
// DELETE /gists/{gist_id}/comments/{comment_id}
func (s *Server) handleGistsDeleteCommentRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/delete-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsDeleteComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsDeleteCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsDeleteComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsDeleteCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsForkRequest handles gists/fork operation.
//
// POST /gists/{gist_id}/forks
func (s *Server) handleGistsForkRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/fork"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsFork",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsForkParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsFork(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsForkResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsGetRequest handles gists/get operation.
//
// GET /gists/{gist_id}
func (s *Server) handleGistsGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsGetParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsGet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsGetCommentRequest handles gists/get-comment operation.
//
// GET /gists/{gist_id}/comments/{comment_id}
func (s *Server) handleGistsGetCommentRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsGetComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsGetCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsGetComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsGetCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsGetRevisionRequest handles gists/get-revision operation.
//
// GET /gists/{gist_id}/{sha}
func (s *Server) handleGistsGetRevisionRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get-revision"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsGetRevision",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsGetRevisionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsGetRevision(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsGetRevisionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsListRequest handles gists/list operation.
//
// GET /gists
func (s *Server) handleGistsListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsListParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsListCommentsRequest handles gists/list-comments operation.
//
// GET /gists/{gist_id}/comments
func (s *Server) handleGistsListCommentsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-comments"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListComments",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsListCommentsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsListComments(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsListCommentsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsListCommitsRequest handles gists/list-commits operation.
//
// GET /gists/{gist_id}/commits
func (s *Server) handleGistsListCommitsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-commits"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListCommits",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsListCommitsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsListCommits(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsListCommitsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsListForUserRequest handles gists/list-for-user operation.
//
// GET /users/{username}/gists
func (s *Server) handleGistsListForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsListForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsListForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsListForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsListForksRequest handles gists/list-forks operation.
//
// GET /gists/{gist_id}/forks
func (s *Server) handleGistsListForksRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-forks"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListForks",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsListForksParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsListForks(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsListForksResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsListPublicRequest handles gists/list-public operation.
//
// GET /gists/public
func (s *Server) handleGistsListPublicRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-public"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListPublic",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsListPublicParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsListPublic(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsListPublicResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsListStarredRequest handles gists/list-starred operation.
//
// GET /gists/starred
func (s *Server) handleGistsListStarredRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-starred"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsListStarred",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsListStarredParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsListStarred(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsListStarredResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsStarRequest handles gists/star operation.
//
// PUT /gists/{gist_id}/star
func (s *Server) handleGistsStarRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/star"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsStar",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsStarParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsStar(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsStarResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsUnstarRequest handles gists/unstar operation.
//
// DELETE /gists/{gist_id}/star
func (s *Server) handleGistsUnstarRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/unstar"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsUnstar",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsUnstarParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsUnstar(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsUnstarResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGistsUpdateCommentRequest handles gists/update-comment operation.
//
// PATCH /gists/{gist_id}/comments/{comment_id}
func (s *Server) handleGistsUpdateCommentRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/update-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GistsUpdateComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGistsUpdateCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeGistsUpdateCommentRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GistsUpdateComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGistsUpdateCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGitCreateBlobRequest handles git/create-blob operation.
//
// POST /repos/{owner}/{repo}/git/blobs
func (s *Server) handleGitCreateBlobRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-blob"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitCreateBlob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGitCreateBlobParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeGitCreateBlobRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GitCreateBlob(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitCreateBlobResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGitCreateCommitRequest handles git/create-commit operation.
//
// POST /repos/{owner}/{repo}/git/commits
func (s *Server) handleGitCreateCommitRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-commit"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitCreateCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGitCreateCommitParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeGitCreateCommitRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GitCreateCommit(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitCreateCommitResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGitCreateRefRequest handles git/create-ref operation.
//
// POST /repos/{owner}/{repo}/git/refs
func (s *Server) handleGitCreateRefRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-ref"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitCreateRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGitCreateRefParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeGitCreateRefRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GitCreateRef(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitCreateRefResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGitCreateTagRequest handles git/create-tag operation.
//
// POST /repos/{owner}/{repo}/git/tags
func (s *Server) handleGitCreateTagRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-tag"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitCreateTag",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGitCreateTagParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeGitCreateTagRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GitCreateTag(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitCreateTagResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGitCreateTreeRequest handles git/create-tree operation.
//
// POST /repos/{owner}/{repo}/git/trees
func (s *Server) handleGitCreateTreeRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-tree"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitCreateTree",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGitCreateTreeParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeGitCreateTreeRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GitCreateTree(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitCreateTreeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGitDeleteRefRequest handles git/delete-ref operation.
//
// DELETE /repos/{owner}/{repo}/git/refs/{ref}
func (s *Server) handleGitDeleteRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/delete-ref"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitDeleteRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGitDeleteRefParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GitDeleteRef(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitDeleteRefResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGitGetBlobRequest handles git/get-blob operation.
//
// GET /repos/{owner}/{repo}/git/blobs/{file_sha}
func (s *Server) handleGitGetBlobRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-blob"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitGetBlob",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGitGetBlobParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GitGetBlob(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitGetBlobResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGitGetCommitRequest handles git/get-commit operation.
//
// GET /repos/{owner}/{repo}/git/commits/{commit_sha}
func (s *Server) handleGitGetCommitRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-commit"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitGetCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGitGetCommitParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GitGetCommit(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitGetCommitResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGitGetRefRequest handles git/get-ref operation.
//
// GET /repos/{owner}/{repo}/git/ref/{ref}
func (s *Server) handleGitGetRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-ref"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitGetRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGitGetRefParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GitGetRef(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitGetRefResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGitGetTagRequest handles git/get-tag operation.
//
// GET /repos/{owner}/{repo}/git/tags/{tag_sha}
func (s *Server) handleGitGetTagRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-tag"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitGetTag",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGitGetTagParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GitGetTag(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitGetTagResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGitGetTreeRequest handles git/get-tree operation.
//
// GET /repos/{owner}/{repo}/git/trees/{tree_sha}
func (s *Server) handleGitGetTreeRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-tree"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitGetTree",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGitGetTreeParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GitGetTree(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitGetTreeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGitListMatchingRefsRequest handles git/list-matching-refs operation.
//
// GET /repos/{owner}/{repo}/git/matching-refs/{ref}
func (s *Server) handleGitListMatchingRefsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/list-matching-refs"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitListMatchingRefs",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGitListMatchingRefsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GitListMatchingRefs(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitListMatchingRefsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGitUpdateRefRequest handles git/update-ref operation.
//
// PATCH /repos/{owner}/{repo}/git/refs/{ref}
func (s *Server) handleGitUpdateRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/update-ref"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitUpdateRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGitUpdateRefParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeGitUpdateRefRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GitUpdateRef(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitUpdateRefResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGitignoreGetAllTemplatesRequest handles gitignore/get-all-templates operation.
//
// GET /gitignore/templates
func (s *Server) handleGitignoreGetAllTemplatesRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gitignore/get-all-templates"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitignoreGetAllTemplates",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error

	response, err := s.h.GitignoreGetAllTemplates(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitignoreGetAllTemplatesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleGitignoreGetTemplateRequest handles gitignore/get-template operation.
//
// GET /gitignore/templates/{name}
func (s *Server) handleGitignoreGetTemplateRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gitignore/get-template"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "GitignoreGetTemplate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeGitignoreGetTemplateParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.GitignoreGetTemplate(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeGitignoreGetTemplateResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleInteractionsRemoveRestrictionsForAuthenticatedUserRequest handles interactions/remove-restrictions-for-authenticated-user operation.
//
// DELETE /user/interaction-limits
func (s *Server) handleInteractionsRemoveRestrictionsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsRemoveRestrictionsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error

	response, err := s.h.InteractionsRemoveRestrictionsForAuthenticatedUser(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeInteractionsRemoveRestrictionsForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleInteractionsRemoveRestrictionsForOrgRequest handles interactions/remove-restrictions-for-org operation.
//
// DELETE /orgs/{org}/interaction-limits
func (s *Server) handleInteractionsRemoveRestrictionsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsRemoveRestrictionsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeInteractionsRemoveRestrictionsForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.InteractionsRemoveRestrictionsForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeInteractionsRemoveRestrictionsForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleInteractionsRemoveRestrictionsForRepoRequest handles interactions/remove-restrictions-for-repo operation.
//
// DELETE /repos/{owner}/{repo}/interaction-limits
func (s *Server) handleInteractionsRemoveRestrictionsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsRemoveRestrictionsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeInteractionsRemoveRestrictionsForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.InteractionsRemoveRestrictionsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeInteractionsRemoveRestrictionsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleInteractionsSetRestrictionsForAuthenticatedUserRequest handles interactions/set-restrictions-for-authenticated-user operation.
//
// PUT /user/interaction-limits
func (s *Server) handleInteractionsSetRestrictionsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsSetRestrictionsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	request, err := decodeInteractionsSetRestrictionsForAuthenticatedUserRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.InteractionsSetRestrictionsForAuthenticatedUser(ctx, request)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeInteractionsSetRestrictionsForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleInteractionsSetRestrictionsForOrgRequest handles interactions/set-restrictions-for-org operation.
//
// PUT /orgs/{org}/interaction-limits
func (s *Server) handleInteractionsSetRestrictionsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsSetRestrictionsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeInteractionsSetRestrictionsForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeInteractionsSetRestrictionsForOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.InteractionsSetRestrictionsForOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeInteractionsSetRestrictionsForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleInteractionsSetRestrictionsForRepoRequest handles interactions/set-restrictions-for-repo operation.
//
// PUT /repos/{owner}/{repo}/interaction-limits
func (s *Server) handleInteractionsSetRestrictionsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "InteractionsSetRestrictionsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeInteractionsSetRestrictionsForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeInteractionsSetRestrictionsForRepoRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.InteractionsSetRestrictionsForRepo(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeInteractionsSetRestrictionsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesAddAssigneesRequest handles issues/add-assignees operation.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/assignees
func (s *Server) handleIssuesAddAssigneesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/add-assignees"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesAddAssignees",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesAddAssigneesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeIssuesAddAssigneesRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesAddAssignees(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesAddAssigneesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesCheckUserCanBeAssignedRequest handles issues/check-user-can-be-assigned operation.
//
// GET /repos/{owner}/{repo}/assignees/{assignee}
func (s *Server) handleIssuesCheckUserCanBeAssignedRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/check-user-can-be-assigned"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesCheckUserCanBeAssigned",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesCheckUserCanBeAssignedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesCheckUserCanBeAssigned(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesCheckUserCanBeAssignedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesCreateRequest handles issues/create operation.
//
// POST /repos/{owner}/{repo}/issues
func (s *Server) handleIssuesCreateRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesCreate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesCreateParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeIssuesCreateRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesCreate(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesCreateResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesCreateCommentRequest handles issues/create-comment operation.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/comments
func (s *Server) handleIssuesCreateCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesCreateComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesCreateCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeIssuesCreateCommentRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesCreateComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesCreateCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesCreateLabelRequest handles issues/create-label operation.
//
// POST /repos/{owner}/{repo}/labels
func (s *Server) handleIssuesCreateLabelRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-label"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesCreateLabel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesCreateLabelParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeIssuesCreateLabelRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesCreateLabel(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesCreateLabelResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesCreateMilestoneRequest handles issues/create-milestone operation.
//
// POST /repos/{owner}/{repo}/milestones
func (s *Server) handleIssuesCreateMilestoneRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-milestone"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesCreateMilestone",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesCreateMilestoneParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeIssuesCreateMilestoneRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesCreateMilestone(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesCreateMilestoneResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesDeleteCommentRequest handles issues/delete-comment operation.
//
// DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}
func (s *Server) handleIssuesDeleteCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesDeleteComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesDeleteCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesDeleteComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesDeleteCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesDeleteLabelRequest handles issues/delete-label operation.
//
// DELETE /repos/{owner}/{repo}/labels/{name}
func (s *Server) handleIssuesDeleteLabelRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-label"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesDeleteLabel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesDeleteLabelParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesDeleteLabel(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesDeleteLabelResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesDeleteMilestoneRequest handles issues/delete-milestone operation.
//
// DELETE /repos/{owner}/{repo}/milestones/{milestone_number}
func (s *Server) handleIssuesDeleteMilestoneRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-milestone"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesDeleteMilestone",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesDeleteMilestoneParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesDeleteMilestone(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesDeleteMilestoneResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesGetRequest handles issues/get operation.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}
func (s *Server) handleIssuesGetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesGetParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesGet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesGetCommentRequest handles issues/get-comment operation.
//
// GET /repos/{owner}/{repo}/issues/comments/{comment_id}
func (s *Server) handleIssuesGetCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesGetComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesGetCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesGetComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesGetCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesGetEventRequest handles issues/get-event operation.
//
// GET /repos/{owner}/{repo}/issues/events/{event_id}
func (s *Server) handleIssuesGetEventRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-event"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesGetEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesGetEventParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesGetEvent(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesGetEventResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesGetLabelRequest handles issues/get-label operation.
//
// GET /repos/{owner}/{repo}/labels/{name}
func (s *Server) handleIssuesGetLabelRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-label"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesGetLabel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesGetLabelParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesGetLabel(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesGetLabelResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesGetMilestoneRequest handles issues/get-milestone operation.
//
// GET /repos/{owner}/{repo}/milestones/{milestone_number}
func (s *Server) handleIssuesGetMilestoneRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-milestone"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesGetMilestone",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesGetMilestoneParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesGetMilestone(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesGetMilestoneResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesListRequest handles issues/list operation.
//
// GET /issues
func (s *Server) handleIssuesListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesListParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesListAssigneesRequest handles issues/list-assignees operation.
//
// GET /repos/{owner}/{repo}/assignees
func (s *Server) handleIssuesListAssigneesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-assignees"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListAssignees",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesListAssigneesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesListAssignees(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListAssigneesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesListCommentsRequest handles issues/list-comments operation.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/comments
func (s *Server) handleIssuesListCommentsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-comments"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListComments",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesListCommentsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesListComments(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListCommentsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesListCommentsForRepoRequest handles issues/list-comments-for-repo operation.
//
// GET /repos/{owner}/{repo}/issues/comments
func (s *Server) handleIssuesListCommentsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-comments-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListCommentsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesListCommentsForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesListCommentsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListCommentsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesListEventsForRepoRequest handles issues/list-events-for-repo operation.
//
// GET /repos/{owner}/{repo}/issues/events
func (s *Server) handleIssuesListEventsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-events-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListEventsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesListEventsForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesListEventsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListEventsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesListForAuthenticatedUserRequest handles issues/list-for-authenticated-user operation.
//
// GET /user/issues
func (s *Server) handleIssuesListForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesListForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesListForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesListForOrgRequest handles issues/list-for-org operation.
//
// GET /orgs/{org}/issues
func (s *Server) handleIssuesListForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesListForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesListForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesListForRepoRequest handles issues/list-for-repo operation.
//
// GET /repos/{owner}/{repo}/issues
func (s *Server) handleIssuesListForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesListForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesListForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesListLabelsForMilestoneRequest handles issues/list-labels-for-milestone operation.
//
// GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels
func (s *Server) handleIssuesListLabelsForMilestoneRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-for-milestone"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListLabelsForMilestone",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesListLabelsForMilestoneParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesListLabelsForMilestone(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListLabelsForMilestoneResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesListLabelsForRepoRequest handles issues/list-labels-for-repo operation.
//
// GET /repos/{owner}/{repo}/labels
func (s *Server) handleIssuesListLabelsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListLabelsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesListLabelsForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesListLabelsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListLabelsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesListLabelsOnIssueRequest handles issues/list-labels-on-issue operation.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/labels
func (s *Server) handleIssuesListLabelsOnIssueRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-on-issue"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListLabelsOnIssue",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesListLabelsOnIssueParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesListLabelsOnIssue(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListLabelsOnIssueResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesListMilestonesRequest handles issues/list-milestones operation.
//
// GET /repos/{owner}/{repo}/milestones
func (s *Server) handleIssuesListMilestonesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-milestones"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesListMilestones",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesListMilestonesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesListMilestones(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesListMilestonesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesLockRequest handles issues/lock operation.
//
// PUT /repos/{owner}/{repo}/issues/{issue_number}/lock
func (s *Server) handleIssuesLockRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/lock"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesLock",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesLockParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeIssuesLockRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesLock(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesLockResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesRemoveAllLabelsRequest handles issues/remove-all-labels operation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels
func (s *Server) handleIssuesRemoveAllLabelsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-all-labels"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesRemoveAllLabels",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesRemoveAllLabelsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesRemoveAllLabels(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesRemoveAllLabelsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesRemoveAssigneesRequest handles issues/remove-assignees operation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees
func (s *Server) handleIssuesRemoveAssigneesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-assignees"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesRemoveAssignees",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesRemoveAssigneesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeIssuesRemoveAssigneesRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesRemoveAssignees(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesRemoveAssigneesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesRemoveLabelRequest handles issues/remove-label operation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}
func (s *Server) handleIssuesRemoveLabelRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-label"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesRemoveLabel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesRemoveLabelParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesRemoveLabel(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesRemoveLabelResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesUnlockRequest handles issues/unlock operation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock
func (s *Server) handleIssuesUnlockRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/unlock"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesUnlock",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesUnlockParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesUnlock(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesUnlockResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesUpdateRequest handles issues/update operation.
//
// PATCH /repos/{owner}/{repo}/issues/{issue_number}
func (s *Server) handleIssuesUpdateRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesUpdate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesUpdateParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeIssuesUpdateRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesUpdate(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesUpdateResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesUpdateCommentRequest handles issues/update-comment operation.
//
// PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}
func (s *Server) handleIssuesUpdateCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesUpdateComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesUpdateCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeIssuesUpdateCommentRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesUpdateComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesUpdateCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesUpdateLabelRequest handles issues/update-label operation.
//
// PATCH /repos/{owner}/{repo}/labels/{name}
func (s *Server) handleIssuesUpdateLabelRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-label"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesUpdateLabel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesUpdateLabelParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeIssuesUpdateLabelRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesUpdateLabel(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesUpdateLabelResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleIssuesUpdateMilestoneRequest handles issues/update-milestone operation.
//
// PATCH /repos/{owner}/{repo}/milestones/{milestone_number}
func (s *Server) handleIssuesUpdateMilestoneRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-milestone"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "IssuesUpdateMilestone",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeIssuesUpdateMilestoneParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeIssuesUpdateMilestoneRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.IssuesUpdateMilestone(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeIssuesUpdateMilestoneResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleLicensesGetRequest handles licenses/get operation.
//
// GET /licenses/{license}
func (s *Server) handleLicensesGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "LicensesGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeLicensesGetParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.LicensesGet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeLicensesGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleLicensesGetAllCommonlyUsedRequest handles licenses/get-all-commonly-used operation.
//
// GET /licenses
func (s *Server) handleLicensesGetAllCommonlyUsedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get-all-commonly-used"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "LicensesGetAllCommonlyUsed",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeLicensesGetAllCommonlyUsedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.LicensesGetAllCommonlyUsed(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeLicensesGetAllCommonlyUsedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleLicensesGetForRepoRequest handles licenses/get-for-repo operation.
//
// GET /repos/{owner}/{repo}/license
func (s *Server) handleLicensesGetForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "LicensesGetForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeLicensesGetForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.LicensesGetForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeLicensesGetForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMetaGetRequest handles meta/get operation.
//
// GET /meta
func (s *Server) handleMetaGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/get"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MetaGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error

	response, err := s.h.MetaGet(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMetaGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMetaRootRequest handles meta/root operation.
//
// GET /
func (s *Server) handleMetaRootRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/root"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MetaRoot",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error

	response, err := s.h.MetaRoot(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMetaRootResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsCancelImportRequest handles migrations/cancel-import operation.
//
// DELETE /repos/{owner}/{repo}/import
func (s *Server) handleMigrationsCancelImportRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/cancel-import"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsCancelImport",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsCancelImportParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsCancelImport(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsCancelImportResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsDeleteArchiveForAuthenticatedUserRequest handles migrations/delete-archive-for-authenticated-user operation.
//
// DELETE /user/migrations/{migration_id}/archive
func (s *Server) handleMigrationsDeleteArchiveForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/delete-archive-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsDeleteArchiveForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsDeleteArchiveForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsDeleteArchiveForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsDeleteArchiveForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsDeleteArchiveForOrgRequest handles migrations/delete-archive-for-org operation.
//
// DELETE /orgs/{org}/migrations/{migration_id}/archive
func (s *Server) handleMigrationsDeleteArchiveForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/delete-archive-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsDeleteArchiveForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsDeleteArchiveForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsDeleteArchiveForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsDeleteArchiveForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsDownloadArchiveForOrgRequest handles migrations/download-archive-for-org operation.
//
// GET /orgs/{org}/migrations/{migration_id}/archive
func (s *Server) handleMigrationsDownloadArchiveForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/download-archive-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsDownloadArchiveForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsDownloadArchiveForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsDownloadArchiveForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsDownloadArchiveForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsGetArchiveForAuthenticatedUserRequest handles migrations/get-archive-for-authenticated-user operation.
//
// GET /user/migrations/{migration_id}/archive
func (s *Server) handleMigrationsGetArchiveForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-archive-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetArchiveForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsGetArchiveForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsGetArchiveForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsGetArchiveForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsGetCommitAuthorsRequest handles migrations/get-commit-authors operation.
//
// GET /repos/{owner}/{repo}/import/authors
func (s *Server) handleMigrationsGetCommitAuthorsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-commit-authors"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetCommitAuthors",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsGetCommitAuthorsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsGetCommitAuthors(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsGetCommitAuthorsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsGetImportStatusRequest handles migrations/get-import-status operation.
//
// GET /repos/{owner}/{repo}/import
func (s *Server) handleMigrationsGetImportStatusRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-import-status"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetImportStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsGetImportStatusParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsGetImportStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsGetImportStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsGetLargeFilesRequest handles migrations/get-large-files operation.
//
// GET /repos/{owner}/{repo}/import/large_files
func (s *Server) handleMigrationsGetLargeFilesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-large-files"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetLargeFiles",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsGetLargeFilesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsGetLargeFiles(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsGetLargeFilesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsGetStatusForAuthenticatedUserRequest handles migrations/get-status-for-authenticated-user operation.
//
// GET /user/migrations/{migration_id}
func (s *Server) handleMigrationsGetStatusForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-status-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetStatusForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsGetStatusForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsGetStatusForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsGetStatusForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsGetStatusForOrgRequest handles migrations/get-status-for-org operation.
//
// GET /orgs/{org}/migrations/{migration_id}
func (s *Server) handleMigrationsGetStatusForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-status-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsGetStatusForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsGetStatusForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsGetStatusForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsGetStatusForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsListForAuthenticatedUserRequest handles migrations/list-for-authenticated-user operation.
//
// GET /user/migrations
func (s *Server) handleMigrationsListForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsListForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsListForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsListForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsListForOrgRequest handles migrations/list-for-org operation.
//
// GET /orgs/{org}/migrations
func (s *Server) handleMigrationsListForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsListForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsListForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsListForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsListForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsListReposForOrgRequest handles migrations/list-repos-for-org operation.
//
// GET /orgs/{org}/migrations/{migration_id}/repositories
func (s *Server) handleMigrationsListReposForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-repos-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsListReposForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsListReposForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsListReposForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsListReposForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsListReposForUserRequest handles migrations/list-repos-for-user operation.
//
// GET /user/migrations/{migration_id}/repositories
func (s *Server) handleMigrationsListReposForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-repos-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsListReposForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsListReposForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsListReposForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsListReposForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsMapCommitAuthorRequest handles migrations/map-commit-author operation.
//
// PATCH /repos/{owner}/{repo}/import/authors/{author_id}
func (s *Server) handleMigrationsMapCommitAuthorRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/map-commit-author"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsMapCommitAuthor",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsMapCommitAuthorParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeMigrationsMapCommitAuthorRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsMapCommitAuthor(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsMapCommitAuthorResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsSetLfsPreferenceRequest handles migrations/set-lfs-preference operation.
//
// PATCH /repos/{owner}/{repo}/import/lfs
func (s *Server) handleMigrationsSetLfsPreferenceRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/set-lfs-preference"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsSetLfsPreference",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsSetLfsPreferenceParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeMigrationsSetLfsPreferenceRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsSetLfsPreference(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsSetLfsPreferenceResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsStartForAuthenticatedUserRequest handles migrations/start-for-authenticated-user operation.
//
// POST /user/migrations
func (s *Server) handleMigrationsStartForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsStartForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	request, err := decodeMigrationsStartForAuthenticatedUserRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsStartForAuthenticatedUser(ctx, request)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsStartForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsStartForOrgRequest handles migrations/start-for-org operation.
//
// POST /orgs/{org}/migrations
func (s *Server) handleMigrationsStartForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsStartForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsStartForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeMigrationsStartForOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsStartForOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsStartForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsStartImportRequest handles migrations/start-import operation.
//
// PUT /repos/{owner}/{repo}/import
func (s *Server) handleMigrationsStartImportRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-import"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsStartImport",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsStartImportParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeMigrationsStartImportRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsStartImport(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsStartImportResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsUnlockRepoForAuthenticatedUserRequest handles migrations/unlock-repo-for-authenticated-user operation.
//
// DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock
func (s *Server) handleMigrationsUnlockRepoForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/unlock-repo-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsUnlockRepoForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsUnlockRepoForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsUnlockRepoForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsUnlockRepoForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsUnlockRepoForOrgRequest handles migrations/unlock-repo-for-org operation.
//
// DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock
func (s *Server) handleMigrationsUnlockRepoForOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/unlock-repo-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsUnlockRepoForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsUnlockRepoForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsUnlockRepoForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsUnlockRepoForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleMigrationsUpdateImportRequest handles migrations/update-import operation.
//
// PATCH /repos/{owner}/{repo}/import
func (s *Server) handleMigrationsUpdateImportRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/update-import"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "MigrationsUpdateImport",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeMigrationsUpdateImportParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeMigrationsUpdateImportRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.MigrationsUpdateImport(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeMigrationsUpdateImportResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOAuthAuthorizationsCreateAuthorizationRequest handles oauth-authorizations/create-authorization operation.
//
// POST /authorizations
func (s *Server) handleOAuthAuthorizationsCreateAuthorizationRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/create-authorization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsCreateAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	request, err := decodeOAuthAuthorizationsCreateAuthorizationRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OAuthAuthorizationsCreateAuthorization(ctx, request)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOAuthAuthorizationsCreateAuthorizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOAuthAuthorizationsDeleteAuthorizationRequest handles oauth-authorizations/delete-authorization operation.
//
// DELETE /authorizations/{authorization_id}
func (s *Server) handleOAuthAuthorizationsDeleteAuthorizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/delete-authorization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsDeleteAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOAuthAuthorizationsDeleteAuthorizationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OAuthAuthorizationsDeleteAuthorization(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOAuthAuthorizationsDeleteAuthorizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOAuthAuthorizationsDeleteGrantRequest handles oauth-authorizations/delete-grant operation.
//
// DELETE /applications/grants/{grant_id}
func (s *Server) handleOAuthAuthorizationsDeleteGrantRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/delete-grant"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsDeleteGrant",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOAuthAuthorizationsDeleteGrantParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OAuthAuthorizationsDeleteGrant(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOAuthAuthorizationsDeleteGrantResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOAuthAuthorizationsGetAuthorizationRequest handles oauth-authorizations/get-authorization operation.
//
// GET /authorizations/{authorization_id}
func (s *Server) handleOAuthAuthorizationsGetAuthorizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-authorization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsGetAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOAuthAuthorizationsGetAuthorizationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OAuthAuthorizationsGetAuthorization(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetAuthorizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOAuthAuthorizationsGetGrantRequest handles oauth-authorizations/get-grant operation.
//
// GET /applications/grants/{grant_id}
func (s *Server) handleOAuthAuthorizationsGetGrantRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-grant"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsGetGrant",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOAuthAuthorizationsGetGrantParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OAuthAuthorizationsGetGrant(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetGrantResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest handles oauth-authorizations/get-or-create-authorization-for-app operation.
//
// PUT /authorizations/clients/{client_id}
func (s *Server) handleOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-or-create-authorization-for-app"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsGetOrCreateAuthorizationForApp",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OAuthAuthorizationsGetOrCreateAuthorizationForApp(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetOrCreateAuthorizationForAppResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest handles oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint operation.
//
// PUT /authorizations/clients/{client_id}/{fingerprint}
func (s *Server) handleOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOAuthAuthorizationsListAuthorizationsRequest handles oauth-authorizations/list-authorizations operation.
//
// GET /authorizations
func (s *Server) handleOAuthAuthorizationsListAuthorizationsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/list-authorizations"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsListAuthorizations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOAuthAuthorizationsListAuthorizationsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OAuthAuthorizationsListAuthorizations(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOAuthAuthorizationsListAuthorizationsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOAuthAuthorizationsListGrantsRequest handles oauth-authorizations/list-grants operation.
//
// GET /applications/grants
func (s *Server) handleOAuthAuthorizationsListGrantsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/list-grants"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsListGrants",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOAuthAuthorizationsListGrantsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OAuthAuthorizationsListGrants(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOAuthAuthorizationsListGrantsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOAuthAuthorizationsUpdateAuthorizationRequest handles oauth-authorizations/update-authorization operation.
//
// PATCH /authorizations/{authorization_id}
func (s *Server) handleOAuthAuthorizationsUpdateAuthorizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/update-authorization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OAuthAuthorizationsUpdateAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOAuthAuthorizationsUpdateAuthorizationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeOAuthAuthorizationsUpdateAuthorizationRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OAuthAuthorizationsUpdateAuthorization(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOAuthAuthorizationsUpdateAuthorizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsBlockUserRequest handles orgs/block-user operation.
//
// PUT /orgs/{org}/blocks/{username}
func (s *Server) handleOrgsBlockUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/block-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsBlockUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsBlockUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsBlockUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsBlockUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsCancelInvitationRequest handles orgs/cancel-invitation operation.
//
// DELETE /orgs/{org}/invitations/{invitation_id}
func (s *Server) handleOrgsCancelInvitationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/cancel-invitation"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCancelInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsCancelInvitationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsCancelInvitation(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsCancelInvitationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsCheckBlockedUserRequest handles orgs/check-blocked-user operation.
//
// GET /orgs/{org}/blocks/{username}
func (s *Server) handleOrgsCheckBlockedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-blocked-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCheckBlockedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsCheckBlockedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsCheckBlockedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsCheckBlockedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsCheckMembershipForUserRequest handles orgs/check-membership-for-user operation.
//
// GET /orgs/{org}/members/{username}
func (s *Server) handleOrgsCheckMembershipForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-membership-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCheckMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsCheckMembershipForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsCheckMembershipForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsCheckMembershipForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsCheckPublicMembershipForUserRequest handles orgs/check-public-membership-for-user operation.
//
// GET /orgs/{org}/public_members/{username}
func (s *Server) handleOrgsCheckPublicMembershipForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-public-membership-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCheckPublicMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsCheckPublicMembershipForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsCheckPublicMembershipForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsCheckPublicMembershipForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsConvertMemberToOutsideCollaboratorRequest handles orgs/convert-member-to-outside-collaborator operation.
//
// PUT /orgs/{org}/outside_collaborators/{username}
func (s *Server) handleOrgsConvertMemberToOutsideCollaboratorRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/convert-member-to-outside-collaborator"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsConvertMemberToOutsideCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsConvertMemberToOutsideCollaboratorParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsConvertMemberToOutsideCollaborator(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsConvertMemberToOutsideCollaboratorResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsCreateInvitationRequest handles orgs/create-invitation operation.
//
// POST /orgs/{org}/invitations
func (s *Server) handleOrgsCreateInvitationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/create-invitation"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCreateInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsCreateInvitationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeOrgsCreateInvitationRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsCreateInvitation(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsCreateInvitationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsCreateWebhookRequest handles orgs/create-webhook operation.
//
// POST /orgs/{org}/hooks
func (s *Server) handleOrgsCreateWebhookRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/create-webhook"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsCreateWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsCreateWebhookParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeOrgsCreateWebhookRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsCreateWebhook(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsCreateWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsDeleteWebhookRequest handles orgs/delete-webhook operation.
//
// DELETE /orgs/{org}/hooks/{hook_id}
func (s *Server) handleOrgsDeleteWebhookRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/delete-webhook"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsDeleteWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsDeleteWebhookParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsDeleteWebhook(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsDeleteWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsGetRequest handles orgs/get operation.
//
// GET /orgs/{org}
func (s *Server) handleOrgsGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsGetParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsGet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsGetAuditLogRequest handles orgs/get-audit-log operation.
//
// GET /orgs/{org}/audit-log
func (s *Server) handleOrgsGetAuditLogRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-audit-log"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetAuditLog",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsGetAuditLogParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsGetAuditLog(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsGetAuditLogResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsGetMembershipForAuthenticatedUserRequest handles orgs/get-membership-for-authenticated-user operation.
//
// GET /user/memberships/orgs/{org}
func (s *Server) handleOrgsGetMembershipForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-membership-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsGetMembershipForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsGetMembershipForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsGetMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsGetMembershipForUserRequest handles orgs/get-membership-for-user operation.
//
// GET /orgs/{org}/memberships/{username}
func (s *Server) handleOrgsGetMembershipForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-membership-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsGetMembershipForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsGetMembershipForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsGetMembershipForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsGetWebhookRequest handles orgs/get-webhook operation.
//
// GET /orgs/{org}/hooks/{hook_id}
func (s *Server) handleOrgsGetWebhookRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsGetWebhookParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsGetWebhook(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsGetWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsGetWebhookConfigForOrgRequest handles orgs/get-webhook-config-for-org operation.
//
// GET /orgs/{org}/hooks/{hook_id}/config
func (s *Server) handleOrgsGetWebhookConfigForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook-config-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetWebhookConfigForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsGetWebhookConfigForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsGetWebhookConfigForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsGetWebhookConfigForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsGetWebhookDeliveryRequest handles orgs/get-webhook-delivery operation.
//
// GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}
func (s *Server) handleOrgsGetWebhookDeliveryRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook-delivery"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsGetWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsGetWebhookDeliveryParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsGetWebhookDelivery(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsGetWebhookDeliveryResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsListRequest handles orgs/list operation.
//
// GET /organizations
func (s *Server) handleOrgsListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsListParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsListBlockedUsersRequest handles orgs/list-blocked-users operation.
//
// GET /orgs/{org}/blocks
func (s *Server) handleOrgsListBlockedUsersRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-blocked-users"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListBlockedUsers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsListBlockedUsersParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsListBlockedUsers(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListBlockedUsersResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsListFailedInvitationsRequest handles orgs/list-failed-invitations operation.
//
// GET /orgs/{org}/failed_invitations
func (s *Server) handleOrgsListFailedInvitationsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-failed-invitations"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListFailedInvitations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsListFailedInvitationsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsListFailedInvitations(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListFailedInvitationsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsListForAuthenticatedUserRequest handles orgs/list-for-authenticated-user operation.
//
// GET /user/orgs
func (s *Server) handleOrgsListForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsListForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsListForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsListForUserRequest handles orgs/list-for-user operation.
//
// GET /users/{username}/orgs
func (s *Server) handleOrgsListForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsListForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsListForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsListInvitationTeamsRequest handles orgs/list-invitation-teams operation.
//
// GET /orgs/{org}/invitations/{invitation_id}/teams
func (s *Server) handleOrgsListInvitationTeamsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-invitation-teams"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListInvitationTeams",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsListInvitationTeamsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsListInvitationTeams(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListInvitationTeamsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsListMembersRequest handles orgs/list-members operation.
//
// GET /orgs/{org}/members
func (s *Server) handleOrgsListMembersRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-members"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListMembers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsListMembersParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsListMembers(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListMembersResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsListMembershipsForAuthenticatedUserRequest handles orgs/list-memberships-for-authenticated-user operation.
//
// GET /user/memberships/orgs
func (s *Server) handleOrgsListMembershipsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-memberships-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListMembershipsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsListMembershipsForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsListMembershipsForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListMembershipsForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsListOutsideCollaboratorsRequest handles orgs/list-outside-collaborators operation.
//
// GET /orgs/{org}/outside_collaborators
func (s *Server) handleOrgsListOutsideCollaboratorsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-outside-collaborators"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListOutsideCollaborators",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsListOutsideCollaboratorsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsListOutsideCollaborators(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListOutsideCollaboratorsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsListPendingInvitationsRequest handles orgs/list-pending-invitations operation.
//
// GET /orgs/{org}/invitations
func (s *Server) handleOrgsListPendingInvitationsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-pending-invitations"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListPendingInvitations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsListPendingInvitationsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsListPendingInvitations(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListPendingInvitationsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsListPublicMembersRequest handles orgs/list-public-members operation.
//
// GET /orgs/{org}/public_members
func (s *Server) handleOrgsListPublicMembersRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-public-members"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListPublicMembers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsListPublicMembersParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsListPublicMembers(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListPublicMembersResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsListSamlSSOAuthorizationsRequest handles orgs/list-saml-sso-authorizations operation.
//
// GET /orgs/{org}/credential-authorizations
func (s *Server) handleOrgsListSamlSSOAuthorizationsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-saml-sso-authorizations"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListSamlSSOAuthorizations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsListSamlSSOAuthorizationsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsListSamlSSOAuthorizations(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListSamlSSOAuthorizationsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsListWebhookDeliveriesRequest handles orgs/list-webhook-deliveries operation.
//
// GET /orgs/{org}/hooks/{hook_id}/deliveries
func (s *Server) handleOrgsListWebhookDeliveriesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-webhook-deliveries"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListWebhookDeliveries",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsListWebhookDeliveriesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsListWebhookDeliveries(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListWebhookDeliveriesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsListWebhooksRequest handles orgs/list-webhooks operation.
//
// GET /orgs/{org}/hooks
func (s *Server) handleOrgsListWebhooksRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-webhooks"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsListWebhooks",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsListWebhooksParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsListWebhooks(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsListWebhooksResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsPingWebhookRequest handles orgs/ping-webhook operation.
//
// POST /orgs/{org}/hooks/{hook_id}/pings
func (s *Server) handleOrgsPingWebhookRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/ping-webhook"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsPingWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsPingWebhookParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsPingWebhook(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsPingWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsRedeliverWebhookDeliveryRequest handles orgs/redeliver-webhook-delivery operation.
//
// POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
func (s *Server) handleOrgsRedeliverWebhookDeliveryRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/redeliver-webhook-delivery"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRedeliverWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsRedeliverWebhookDeliveryParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsRedeliverWebhookDelivery(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsRedeliverWebhookDeliveryResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsRemoveMemberRequest handles orgs/remove-member operation.
//
// DELETE /orgs/{org}/members/{username}
func (s *Server) handleOrgsRemoveMemberRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-member"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRemoveMember",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsRemoveMemberParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsRemoveMember(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsRemoveMemberResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsRemoveMembershipForUserRequest handles orgs/remove-membership-for-user operation.
//
// DELETE /orgs/{org}/memberships/{username}
func (s *Server) handleOrgsRemoveMembershipForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-membership-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRemoveMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsRemoveMembershipForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsRemoveMembershipForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsRemoveMembershipForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsRemoveOutsideCollaboratorRequest handles orgs/remove-outside-collaborator operation.
//
// DELETE /orgs/{org}/outside_collaborators/{username}
func (s *Server) handleOrgsRemoveOutsideCollaboratorRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-outside-collaborator"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRemoveOutsideCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsRemoveOutsideCollaboratorParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsRemoveOutsideCollaborator(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsRemoveOutsideCollaboratorResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsRemovePublicMembershipForAuthenticatedUserRequest handles orgs/remove-public-membership-for-authenticated-user operation.
//
// DELETE /orgs/{org}/public_members/{username}
func (s *Server) handleOrgsRemovePublicMembershipForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-public-membership-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRemovePublicMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsRemovePublicMembershipForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsRemovePublicMembershipForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsRemovePublicMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsRemoveSamlSSOAuthorizationRequest handles orgs/remove-saml-sso-authorization operation.
//
// DELETE /orgs/{org}/credential-authorizations/{credential_id}
func (s *Server) handleOrgsRemoveSamlSSOAuthorizationRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-saml-sso-authorization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsRemoveSamlSSOAuthorization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsRemoveSamlSSOAuthorizationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsRemoveSamlSSOAuthorization(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsRemoveSamlSSOAuthorizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsSetMembershipForUserRequest handles orgs/set-membership-for-user operation.
//
// PUT /orgs/{org}/memberships/{username}
func (s *Server) handleOrgsSetMembershipForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/set-membership-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsSetMembershipForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsSetMembershipForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeOrgsSetMembershipForUserRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsSetMembershipForUser(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsSetMembershipForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsSetPublicMembershipForAuthenticatedUserRequest handles orgs/set-public-membership-for-authenticated-user operation.
//
// PUT /orgs/{org}/public_members/{username}
func (s *Server) handleOrgsSetPublicMembershipForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/set-public-membership-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsSetPublicMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsSetPublicMembershipForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsSetPublicMembershipForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsSetPublicMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsUnblockUserRequest handles orgs/unblock-user operation.
//
// DELETE /orgs/{org}/blocks/{username}
func (s *Server) handleOrgsUnblockUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/unblock-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsUnblockUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsUnblockUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsUnblockUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsUnblockUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsUpdateMembershipForAuthenticatedUserRequest handles orgs/update-membership-for-authenticated-user operation.
//
// PATCH /user/memberships/orgs/{org}
func (s *Server) handleOrgsUpdateMembershipForAuthenticatedUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-membership-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsUpdateMembershipForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsUpdateMembershipForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeOrgsUpdateMembershipForAuthenticatedUserRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsUpdateMembershipForAuthenticatedUser(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsUpdateMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsUpdateWebhookRequest handles orgs/update-webhook operation.
//
// PATCH /orgs/{org}/hooks/{hook_id}
func (s *Server) handleOrgsUpdateWebhookRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-webhook"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsUpdateWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsUpdateWebhookParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeOrgsUpdateWebhookRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsUpdateWebhook(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsUpdateWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleOrgsUpdateWebhookConfigForOrgRequest handles orgs/update-webhook-config-for-org operation.
//
// PATCH /orgs/{org}/hooks/{hook_id}/config
func (s *Server) handleOrgsUpdateWebhookConfigForOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-webhook-config-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "OrgsUpdateWebhookConfigForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeOrgsUpdateWebhookConfigForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeOrgsUpdateWebhookConfigForOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.OrgsUpdateWebhookConfigForOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeOrgsUpdateWebhookConfigForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesDeletePackageForAuthenticatedUserRequest handles packages/delete-package-for-authenticated-user operation.
//
// DELETE /user/packages/{package_type}/{package_name}
func (s *Server) handlePackagesDeletePackageForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesDeletePackageForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesDeletePackageForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesDeletePackageForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesDeletePackageForOrgRequest handles packages/delete-package-for-org operation.
//
// DELETE /orgs/{org}/packages/{package_type}/{package_name}
func (s *Server) handlePackagesDeletePackageForOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesDeletePackageForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesDeletePackageForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesDeletePackageForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesDeletePackageForUserRequest handles packages/delete-package-for-user operation.
//
// DELETE /users/{username}/packages/{package_type}/{package_name}
func (s *Server) handlePackagesDeletePackageForUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesDeletePackageForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesDeletePackageForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesDeletePackageForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesDeletePackageVersionForAuthenticatedUserRequest handles packages/delete-package-version-for-authenticated-user operation.
//
// DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesDeletePackageVersionForAuthenticatedUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageVersionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesDeletePackageVersionForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesDeletePackageVersionForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesDeletePackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesDeletePackageVersionForOrgRequest handles packages/delete-package-version-for-org operation.
//
// DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesDeletePackageVersionForOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageVersionForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesDeletePackageVersionForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesDeletePackageVersionForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesDeletePackageVersionForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesDeletePackageVersionForUserRequest handles packages/delete-package-version-for-user operation.
//
// DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesDeletePackageVersionForUserRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesDeletePackageVersionForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesDeletePackageVersionForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesDeletePackageVersionForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesDeletePackageVersionForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest handles packages/get-all-package-versions-for-package-owned-by-authenticated-user operation.
//
// GET /user/packages/{package_type}/{package_name}/versions
func (s *Server) handlePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest handles packages/get-all-package-versions-for-package-owned-by-org operation.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}/versions
func (s *Server) handlePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetAllPackageVersionsForPackageOwnedByOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetAllPackageVersionsForPackageOwnedByOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesGetAllPackageVersionsForPackageOwnedByUserRequest handles packages/get-all-package-versions-for-package-owned-by-user operation.
//
// GET /users/{username}/packages/{package_type}/{package_name}/versions
func (s *Server) handlePackagesGetAllPackageVersionsForPackageOwnedByUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetAllPackageVersionsForPackageOwnedByUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesGetAllPackageVersionsForPackageOwnedByUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetAllPackageVersionsForPackageOwnedByUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesGetPackageForAuthenticatedUserRequest handles packages/get-package-for-authenticated-user operation.
//
// GET /user/packages/{package_type}/{package_name}
func (s *Server) handlePackagesGetPackageForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesGetPackageForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesGetPackageForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetPackageForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesGetPackageForOrganizationRequest handles packages/get-package-for-organization operation.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}
func (s *Server) handlePackagesGetPackageForOrganizationRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-organization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageForOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesGetPackageForOrganizationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesGetPackageForOrganization(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetPackageForOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesGetPackageForUserRequest handles packages/get-package-for-user operation.
//
// GET /users/{username}/packages/{package_type}/{package_name}
func (s *Server) handlePackagesGetPackageForUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesGetPackageForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesGetPackageForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetPackageForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesGetPackageVersionForAuthenticatedUserRequest handles packages/get-package-version-for-authenticated-user operation.
//
// GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesGetPackageVersionForAuthenticatedUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageVersionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesGetPackageVersionForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesGetPackageVersionForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetPackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesGetPackageVersionForOrganizationRequest handles packages/get-package-version-for-organization operation.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesGetPackageVersionForOrganizationRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-organization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageVersionForOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesGetPackageVersionForOrganizationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesGetPackageVersionForOrganization(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetPackageVersionForOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesGetPackageVersionForUserRequest handles packages/get-package-version-for-user operation.
//
// GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesGetPackageVersionForUserRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesGetPackageVersionForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesGetPackageVersionForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesGetPackageVersionForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesGetPackageVersionForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesListPackagesForAuthenticatedUserRequest handles packages/list-packages-for-authenticated-user operation.
//
// GET /user/packages
func (s *Server) handlePackagesListPackagesForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesListPackagesForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesListPackagesForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesListPackagesForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesListPackagesForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesListPackagesForOrganizationRequest handles packages/list-packages-for-organization operation.
//
// GET /orgs/{org}/packages
func (s *Server) handlePackagesListPackagesForOrganizationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-organization"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesListPackagesForOrganization",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesListPackagesForOrganizationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesListPackagesForOrganization(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesListPackagesForOrganizationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesListPackagesForUserRequest handles packages/list-packages-for-user operation.
//
// GET /users/{username}/packages
func (s *Server) handlePackagesListPackagesForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesListPackagesForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesListPackagesForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesListPackagesForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesListPackagesForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesRestorePackageForAuthenticatedUserRequest handles packages/restore-package-for-authenticated-user operation.
//
// POST /user/packages/{package_type}/{package_name}/restore
func (s *Server) handlePackagesRestorePackageForAuthenticatedUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesRestorePackageForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesRestorePackageForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesRestorePackageForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesRestorePackageForOrgRequest handles packages/restore-package-for-org operation.
//
// POST /orgs/{org}/packages/{package_type}/{package_name}/restore
func (s *Server) handlePackagesRestorePackageForOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesRestorePackageForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesRestorePackageForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesRestorePackageForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesRestorePackageForUserRequest handles packages/restore-package-for-user operation.
//
// POST /users/{username}/packages/{package_type}/{package_name}/restore
func (s *Server) handlePackagesRestorePackageForUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesRestorePackageForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesRestorePackageForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesRestorePackageForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesRestorePackageVersionForAuthenticatedUserRequest handles packages/restore-package-version-for-authenticated-user operation.
//
// POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (s *Server) handlePackagesRestorePackageVersionForAuthenticatedUserRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageVersionForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesRestorePackageVersionForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesRestorePackageVersionForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesRestorePackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesRestorePackageVersionForOrgRequest handles packages/restore-package-version-for-org operation.
//
// POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (s *Server) handlePackagesRestorePackageVersionForOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageVersionForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesRestorePackageVersionForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesRestorePackageVersionForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesRestorePackageVersionForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePackagesRestorePackageVersionForUserRequest handles packages/restore-package-version-for-user operation.
//
// POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (s *Server) handlePackagesRestorePackageVersionForUserRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PackagesRestorePackageVersionForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePackagesRestorePackageVersionForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PackagesRestorePackageVersionForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePackagesRestorePackageVersionForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsAddCollaboratorRequest handles projects/add-collaborator operation.
//
// PUT /projects/{project_id}/collaborators/{username}
func (s *Server) handleProjectsAddCollaboratorRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/add-collaborator"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsAddCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsAddCollaboratorParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeProjectsAddCollaboratorRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsAddCollaborator(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsAddCollaboratorResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsCreateColumnRequest handles projects/create-column operation.
//
// POST /projects/{project_id}/columns
func (s *Server) handleProjectsCreateColumnRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-column"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsCreateColumn",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsCreateColumnParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeProjectsCreateColumnRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsCreateColumn(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsCreateColumnResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsCreateForAuthenticatedUserRequest handles projects/create-for-authenticated-user operation.
//
// POST /user/projects
func (s *Server) handleProjectsCreateForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsCreateForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	request, err := decodeProjectsCreateForAuthenticatedUserRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsCreateForAuthenticatedUser(ctx, request)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsCreateForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsCreateForOrgRequest handles projects/create-for-org operation.
//
// POST /orgs/{org}/projects
func (s *Server) handleProjectsCreateForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsCreateForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsCreateForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeProjectsCreateForOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsCreateForOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsCreateForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsCreateForRepoRequest handles projects/create-for-repo operation.
//
// POST /repos/{owner}/{repo}/projects
func (s *Server) handleProjectsCreateForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsCreateForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsCreateForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeProjectsCreateForRepoRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsCreateForRepo(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsCreateForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsDeleteRequest handles projects/delete operation.
//
// DELETE /projects/{project_id}
func (s *Server) handleProjectsDeleteRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsDelete",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsDeleteParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsDelete(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsDeleteResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsDeleteCardRequest handles projects/delete-card operation.
//
// DELETE /projects/columns/cards/{card_id}
func (s *Server) handleProjectsDeleteCardRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete-card"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsDeleteCard",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsDeleteCardParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsDeleteCard(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsDeleteCardResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsDeleteColumnRequest handles projects/delete-column operation.
//
// DELETE /projects/columns/{column_id}
func (s *Server) handleProjectsDeleteColumnRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete-column"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsDeleteColumn",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsDeleteColumnParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsDeleteColumn(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsDeleteColumnResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsGetRequest handles projects/get operation.
//
// GET /projects/{project_id}
func (s *Server) handleProjectsGetRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsGetParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsGet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsGetCardRequest handles projects/get-card operation.
//
// GET /projects/columns/cards/{card_id}
func (s *Server) handleProjectsGetCardRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-card"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsGetCard",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsGetCardParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsGetCard(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsGetCardResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsGetColumnRequest handles projects/get-column operation.
//
// GET /projects/columns/{column_id}
func (s *Server) handleProjectsGetColumnRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-column"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsGetColumn",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsGetColumnParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsGetColumn(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsGetColumnResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsGetPermissionForUserRequest handles projects/get-permission-for-user operation.
//
// GET /projects/{project_id}/collaborators/{username}/permission
func (s *Server) handleProjectsGetPermissionForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-permission-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsGetPermissionForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsGetPermissionForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsGetPermissionForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsGetPermissionForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsListCardsRequest handles projects/list-cards operation.
//
// GET /projects/columns/{column_id}/cards
func (s *Server) handleProjectsListCardsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-cards"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListCards",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsListCardsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsListCards(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsListCardsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsListCollaboratorsRequest handles projects/list-collaborators operation.
//
// GET /projects/{project_id}/collaborators
func (s *Server) handleProjectsListCollaboratorsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-collaborators"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListCollaborators",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsListCollaboratorsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsListCollaborators(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsListCollaboratorsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsListColumnsRequest handles projects/list-columns operation.
//
// GET /projects/{project_id}/columns
func (s *Server) handleProjectsListColumnsRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-columns"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListColumns",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsListColumnsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsListColumns(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsListColumnsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsListForOrgRequest handles projects/list-for-org operation.
//
// GET /orgs/{org}/projects
func (s *Server) handleProjectsListForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsListForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsListForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsListForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsListForRepoRequest handles projects/list-for-repo operation.
//
// GET /repos/{owner}/{repo}/projects
func (s *Server) handleProjectsListForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsListForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsListForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsListForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsListForUserRequest handles projects/list-for-user operation.
//
// GET /users/{username}/projects
func (s *Server) handleProjectsListForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsListForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsListForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsListForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsListForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsMoveCardRequest handles projects/move-card operation.
//
// POST /projects/columns/cards/{card_id}/moves
func (s *Server) handleProjectsMoveCardRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/move-card"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsMoveCard",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsMoveCardParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeProjectsMoveCardRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsMoveCard(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsMoveCardResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsMoveColumnRequest handles projects/move-column operation.
//
// POST /projects/columns/{column_id}/moves
func (s *Server) handleProjectsMoveColumnRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/move-column"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsMoveColumn",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsMoveColumnParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeProjectsMoveColumnRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsMoveColumn(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsMoveColumnResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsRemoveCollaboratorRequest handles projects/remove-collaborator operation.
//
// DELETE /projects/{project_id}/collaborators/{username}
func (s *Server) handleProjectsRemoveCollaboratorRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/remove-collaborator"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsRemoveCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsRemoveCollaboratorParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsRemoveCollaborator(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsRemoveCollaboratorResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsUpdateRequest handles projects/update operation.
//
// PATCH /projects/{project_id}
func (s *Server) handleProjectsUpdateRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsUpdate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsUpdateParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeProjectsUpdateRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsUpdate(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsUpdateResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsUpdateCardRequest handles projects/update-card operation.
//
// PATCH /projects/columns/cards/{card_id}
func (s *Server) handleProjectsUpdateCardRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update-card"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsUpdateCard",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsUpdateCardParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeProjectsUpdateCardRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsUpdateCard(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsUpdateCardResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleProjectsUpdateColumnRequest handles projects/update-column operation.
//
// PATCH /projects/columns/{column_id}
func (s *Server) handleProjectsUpdateColumnRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update-column"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ProjectsUpdateColumn",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeProjectsUpdateColumnParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeProjectsUpdateColumnRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ProjectsUpdateColumn(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeProjectsUpdateColumnResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsCheckIfMergedRequest handles pulls/check-if-merged operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/merge
func (s *Server) handlePullsCheckIfMergedRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/check-if-merged"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsCheckIfMerged",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsCheckIfMergedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsCheckIfMerged(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsCheckIfMergedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsCreateRequest handles pulls/create operation.
//
// POST /repos/{owner}/{repo}/pulls
func (s *Server) handlePullsCreateRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsCreate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsCreateParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodePullsCreateRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsCreate(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsCreateResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsCreateReplyForReviewCommentRequest handles pulls/create-reply-for-review-comment operation.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies
func (s *Server) handlePullsCreateReplyForReviewCommentRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-reply-for-review-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsCreateReplyForReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsCreateReplyForReviewCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodePullsCreateReplyForReviewCommentRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsCreateReplyForReviewComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsCreateReplyForReviewCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsCreateReviewRequest handles pulls/create-review operation.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews
func (s *Server) handlePullsCreateReviewRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-review"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsCreateReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsCreateReviewParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodePullsCreateReviewRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsCreateReview(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsCreateReviewResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsCreateReviewCommentRequest handles pulls/create-review-comment operation.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/comments
func (s *Server) handlePullsCreateReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-review-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsCreateReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsCreateReviewCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodePullsCreateReviewCommentRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsCreateReviewComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsCreateReviewCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsDeletePendingReviewRequest handles pulls/delete-pending-review operation.
//
// DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (s *Server) handlePullsDeletePendingReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/delete-pending-review"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsDeletePendingReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsDeletePendingReviewParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsDeletePendingReview(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsDeletePendingReviewResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsDeleteReviewCommentRequest handles pulls/delete-review-comment operation.
//
// DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (s *Server) handlePullsDeleteReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/delete-review-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsDeleteReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsDeleteReviewCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsDeleteReviewComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsDeleteReviewCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsDismissReviewRequest handles pulls/dismiss-review operation.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals
func (s *Server) handlePullsDismissReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/dismiss-review"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsDismissReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsDismissReviewParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodePullsDismissReviewRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsDismissReview(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsDismissReviewResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsGetRequest handles pulls/get operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}
func (s *Server) handlePullsGetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsGetParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsGet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsGetReviewRequest handles pulls/get-review operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (s *Server) handlePullsGetReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get-review"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsGetReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsGetReviewParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsGetReview(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsGetReviewResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsGetReviewCommentRequest handles pulls/get-review-comment operation.
//
// GET /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (s *Server) handlePullsGetReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get-review-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsGetReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsGetReviewCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsGetReviewComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsGetReviewCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsListRequest handles pulls/list operation.
//
// GET /repos/{owner}/{repo}/pulls
func (s *Server) handlePullsListRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsListParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsListCommentsForReviewRequest handles pulls/list-comments-for-review operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments
func (s *Server) handlePullsListCommentsForReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-comments-for-review"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListCommentsForReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsListCommentsForReviewParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsListCommentsForReview(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsListCommentsForReviewResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsListCommitsRequest handles pulls/list-commits operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/commits
func (s *Server) handlePullsListCommitsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-commits"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListCommits",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsListCommitsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsListCommits(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsListCommitsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsListFilesRequest handles pulls/list-files operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/files
func (s *Server) handlePullsListFilesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-files"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListFiles",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsListFilesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsListFiles(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsListFilesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsListRequestedReviewersRequest handles pulls/list-requested-reviewers operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
func (s *Server) handlePullsListRequestedReviewersRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-requested-reviewers"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListRequestedReviewers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsListRequestedReviewersParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsListRequestedReviewers(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsListRequestedReviewersResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsListReviewCommentsRequest handles pulls/list-review-comments operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/comments
func (s *Server) handlePullsListReviewCommentsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-review-comments"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListReviewComments",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsListReviewCommentsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsListReviewComments(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsListReviewCommentsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsListReviewCommentsForRepoRequest handles pulls/list-review-comments-for-repo operation.
//
// GET /repos/{owner}/{repo}/pulls/comments
func (s *Server) handlePullsListReviewCommentsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-review-comments-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListReviewCommentsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsListReviewCommentsForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsListReviewCommentsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsListReviewCommentsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsListReviewsRequest handles pulls/list-reviews operation.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews
func (s *Server) handlePullsListReviewsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-reviews"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsListReviews",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsListReviewsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsListReviews(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsListReviewsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsMergeRequest handles pulls/merge operation.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge
func (s *Server) handlePullsMergeRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/merge"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsMerge",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsMergeParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodePullsMergeRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsMerge(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsMergeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsRemoveRequestedReviewersRequest handles pulls/remove-requested-reviewers operation.
//
// DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
func (s *Server) handlePullsRemoveRequestedReviewersRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/remove-requested-reviewers"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsRemoveRequestedReviewers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsRemoveRequestedReviewersParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodePullsRemoveRequestedReviewersRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsRemoveRequestedReviewers(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsRemoveRequestedReviewersResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsSubmitReviewRequest handles pulls/submit-review operation.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events
func (s *Server) handlePullsSubmitReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/submit-review"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsSubmitReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsSubmitReviewParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodePullsSubmitReviewRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsSubmitReview(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsSubmitReviewResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsUpdateRequest handles pulls/update operation.
//
// PATCH /repos/{owner}/{repo}/pulls/{pull_number}
func (s *Server) handlePullsUpdateRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsUpdate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsUpdateParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodePullsUpdateRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsUpdate(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsUpdateResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsUpdateBranchRequest handles pulls/update-branch operation.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch
func (s *Server) handlePullsUpdateBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-branch"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsUpdateBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsUpdateBranchParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodePullsUpdateBranchRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsUpdateBranch(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsUpdateBranchResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsUpdateReviewRequest handles pulls/update-review operation.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (s *Server) handlePullsUpdateReviewRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-review"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsUpdateReview",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsUpdateReviewParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodePullsUpdateReviewRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsUpdateReview(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsUpdateReviewResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandlePullsUpdateReviewCommentRequest handles pulls/update-review-comment operation.
//
// PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (s *Server) handlePullsUpdateReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-review-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "PullsUpdateReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodePullsUpdateReviewCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodePullsUpdateReviewCommentRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.PullsUpdateReviewComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodePullsUpdateReviewCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleRateLimitGetRequest handles rate-limit/get operation.
//
// GET /rate_limit
func (s *Server) handleRateLimitGetRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("rate-limit/get"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "RateLimitGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error

	response, err := s.h.RateLimitGet(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeRateLimitGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsCreateForCommitCommentRequest handles reactions/create-for-commit-comment operation.
//
// POST /repos/{owner}/{repo}/comments/{comment_id}/reactions
func (s *Server) handleReactionsCreateForCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-commit-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsCreateForCommitCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReactionsCreateForCommitCommentRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsCreateForCommitComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsCreateForCommitCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsCreateForIssueRequest handles reactions/create-for-issue operation.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/reactions
func (s *Server) handleReactionsCreateForIssueRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-issue"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForIssue",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsCreateForIssueParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReactionsCreateForIssueRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsCreateForIssue(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsCreateForIssueResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsCreateForIssueCommentRequest handles reactions/create-for-issue-comment operation.
//
// POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
func (s *Server) handleReactionsCreateForIssueCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-issue-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForIssueComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsCreateForIssueCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReactionsCreateForIssueCommentRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsCreateForIssueComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsCreateForIssueCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsCreateForPullRequestReviewCommentRequest handles reactions/create-for-pull-request-review-comment operation.
//
// POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
func (s *Server) handleReactionsCreateForPullRequestReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-pull-request-review-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForPullRequestReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsCreateForPullRequestReviewCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReactionsCreateForPullRequestReviewCommentRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsCreateForPullRequestReviewComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsCreateForPullRequestReviewCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsCreateForReleaseRequest handles reactions/create-for-release operation.
//
// POST /repos/{owner}/{repo}/releases/{release_id}/reactions
func (s *Server) handleReactionsCreateForReleaseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-release"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsCreateForReleaseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReactionsCreateForReleaseRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsCreateForRelease(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsCreateForReleaseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsCreateForTeamDiscussionCommentInOrgRequest handles reactions/create-for-team-discussion-comment-in-org operation.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) handleReactionsCreateForTeamDiscussionCommentInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-comment-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForTeamDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsCreateForTeamDiscussionCommentInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReactionsCreateForTeamDiscussionCommentInOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsCreateForTeamDiscussionCommentInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionCommentInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsCreateForTeamDiscussionCommentLegacyRequest handles reactions/create-for-team-discussion-comment-legacy operation.
//
// POST /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) handleReactionsCreateForTeamDiscussionCommentLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-comment-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForTeamDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsCreateForTeamDiscussionCommentLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReactionsCreateForTeamDiscussionCommentLegacyRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsCreateForTeamDiscussionCommentLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionCommentLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsCreateForTeamDiscussionInOrgRequest handles reactions/create-for-team-discussion-in-org operation.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
func (s *Server) handleReactionsCreateForTeamDiscussionInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForTeamDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsCreateForTeamDiscussionInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReactionsCreateForTeamDiscussionInOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsCreateForTeamDiscussionInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsCreateForTeamDiscussionLegacyRequest handles reactions/create-for-team-discussion-legacy operation.
//
// POST /teams/{team_id}/discussions/{discussion_number}/reactions
func (s *Server) handleReactionsCreateForTeamDiscussionLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsCreateForTeamDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsCreateForTeamDiscussionLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReactionsCreateForTeamDiscussionLegacyRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsCreateForTeamDiscussionLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsDeleteForCommitCommentRequest handles reactions/delete-for-commit-comment operation.
//
// DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForCommitCommentRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-commit-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsDeleteForCommitCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsDeleteForCommitComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsDeleteForCommitCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsDeleteForIssueRequest handles reactions/delete-for-issue operation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForIssueRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-issue"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForIssue",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsDeleteForIssueParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsDeleteForIssue(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsDeleteForIssueResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsDeleteForIssueCommentRequest handles reactions/delete-for-issue-comment operation.
//
// DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForIssueCommentRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-issue-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForIssueComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsDeleteForIssueCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsDeleteForIssueComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsDeleteForIssueCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsDeleteForPullRequestCommentRequest handles reactions/delete-for-pull-request-comment operation.
//
// DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForPullRequestCommentRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-pull-request-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForPullRequestComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsDeleteForPullRequestCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsDeleteForPullRequestComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsDeleteForPullRequestCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsDeleteForTeamDiscussionRequest handles reactions/delete-for-team-discussion operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForTeamDiscussionRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-team-discussion"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForTeamDiscussion",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsDeleteForTeamDiscussionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsDeleteForTeamDiscussion(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsDeleteForTeamDiscussionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsDeleteForTeamDiscussionCommentRequest handles reactions/delete-for-team-discussion-comment operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForTeamDiscussionCommentRequest(args [5]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-team-discussion-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteForTeamDiscussionComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsDeleteForTeamDiscussionCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsDeleteForTeamDiscussionComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsDeleteForTeamDiscussionCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsDeleteLegacyRequest handles reactions/delete-legacy operation.
//
// DELETE /reactions/{reaction_id}
func (s *Server) handleReactionsDeleteLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsDeleteLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsDeleteLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsDeleteLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsDeleteLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsListForCommitCommentRequest handles reactions/list-for-commit-comment operation.
//
// GET /repos/{owner}/{repo}/comments/{comment_id}/reactions
func (s *Server) handleReactionsListForCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-commit-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsListForCommitCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsListForCommitComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsListForCommitCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsListForIssueRequest handles reactions/list-for-issue operation.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/reactions
func (s *Server) handleReactionsListForIssueRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-issue"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForIssue",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsListForIssueParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsListForIssue(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsListForIssueResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsListForIssueCommentRequest handles reactions/list-for-issue-comment operation.
//
// GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
func (s *Server) handleReactionsListForIssueCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-issue-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForIssueComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsListForIssueCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsListForIssueComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsListForIssueCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsListForPullRequestReviewCommentRequest handles reactions/list-for-pull-request-review-comment operation.
//
// GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
func (s *Server) handleReactionsListForPullRequestReviewCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-pull-request-review-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForPullRequestReviewComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsListForPullRequestReviewCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsListForPullRequestReviewComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsListForPullRequestReviewCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsListForTeamDiscussionCommentInOrgRequest handles reactions/list-for-team-discussion-comment-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) handleReactionsListForTeamDiscussionCommentInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-comment-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForTeamDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsListForTeamDiscussionCommentInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsListForTeamDiscussionCommentInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionCommentInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsListForTeamDiscussionCommentLegacyRequest handles reactions/list-for-team-discussion-comment-legacy operation.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) handleReactionsListForTeamDiscussionCommentLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-comment-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForTeamDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsListForTeamDiscussionCommentLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsListForTeamDiscussionCommentLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionCommentLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsListForTeamDiscussionInOrgRequest handles reactions/list-for-team-discussion-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
func (s *Server) handleReactionsListForTeamDiscussionInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForTeamDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsListForTeamDiscussionInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsListForTeamDiscussionInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReactionsListForTeamDiscussionLegacyRequest handles reactions/list-for-team-discussion-legacy operation.
//
// GET /teams/{team_id}/discussions/{discussion_number}/reactions
func (s *Server) handleReactionsListForTeamDiscussionLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReactionsListForTeamDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReactionsListForTeamDiscussionLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReactionsListForTeamDiscussionLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposAcceptInvitationRequest handles repos/accept-invitation operation.
//
// PATCH /user/repository_invitations/{invitation_id}
func (s *Server) handleReposAcceptInvitationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/accept-invitation"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAcceptInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposAcceptInvitationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposAcceptInvitation(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposAcceptInvitationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposAddAppAccessRestrictionsRequest handles repos/add-app-access-restrictions operation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) handleReposAddAppAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-app-access-restrictions"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAddAppAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposAddAppAccessRestrictionsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposAddAppAccessRestrictionsRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposAddAppAccessRestrictions(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposAddAppAccessRestrictionsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposAddCollaboratorRequest handles repos/add-collaborator operation.
//
// PUT /repos/{owner}/{repo}/collaborators/{username}
func (s *Server) handleReposAddCollaboratorRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-collaborator"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAddCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposAddCollaboratorParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposAddCollaboratorRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposAddCollaborator(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposAddCollaboratorResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposAddStatusCheckContextsRequest handles repos/add-status-check-contexts operation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) handleReposAddStatusCheckContextsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-status-check-contexts"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAddStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposAddStatusCheckContextsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposAddStatusCheckContextsRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposAddStatusCheckContexts(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposAddStatusCheckContextsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposAddTeamAccessRestrictionsRequest handles repos/add-team-access-restrictions operation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) handleReposAddTeamAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-team-access-restrictions"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAddTeamAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposAddTeamAccessRestrictionsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposAddTeamAccessRestrictionsRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposAddTeamAccessRestrictions(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposAddTeamAccessRestrictionsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposAddUserAccessRestrictionsRequest handles repos/add-user-access-restrictions operation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) handleReposAddUserAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-user-access-restrictions"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposAddUserAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposAddUserAccessRestrictionsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposAddUserAccessRestrictionsRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposAddUserAccessRestrictions(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposAddUserAccessRestrictionsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCheckCollaboratorRequest handles repos/check-collaborator operation.
//
// GET /repos/{owner}/{repo}/collaborators/{username}
func (s *Server) handleReposCheckCollaboratorRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/check-collaborator"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCheckCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCheckCollaboratorParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCheckCollaborator(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCheckCollaboratorResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCheckVulnerabilityAlertsRequest handles repos/check-vulnerability-alerts operation.
//
// GET /repos/{owner}/{repo}/vulnerability-alerts
func (s *Server) handleReposCheckVulnerabilityAlertsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/check-vulnerability-alerts"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCheckVulnerabilityAlerts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCheckVulnerabilityAlertsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCheckVulnerabilityAlerts(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCheckVulnerabilityAlertsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCompareCommitsRequest handles repos/compare-commits operation.
//
// GET /repos/{owner}/{repo}/compare/{basehead}
func (s *Server) handleReposCompareCommitsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/compare-commits"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCompareCommits",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCompareCommitsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCompareCommits(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCompareCommitsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCreateAutolinkRequest handles repos/create-autolink operation.
//
// POST /repos/{owner}/{repo}/autolinks
func (s *Server) handleReposCreateAutolinkRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-autolink"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateAutolink",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCreateAutolinkParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposCreateAutolinkRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCreateAutolink(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateAutolinkResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCreateCommitCommentRequest handles repos/create-commit-comment operation.
//
// POST /repos/{owner}/{repo}/commits/{commit_sha}/comments
func (s *Server) handleReposCreateCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCreateCommitCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposCreateCommitCommentRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCreateCommitComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateCommitCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCreateCommitSignatureProtectionRequest handles repos/create-commit-signature-protection operation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (s *Server) handleReposCreateCommitSignatureProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-signature-protection"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateCommitSignatureProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCreateCommitSignatureProtectionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCreateCommitSignatureProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateCommitSignatureProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCreateCommitStatusRequest handles repos/create-commit-status operation.
//
// POST /repos/{owner}/{repo}/statuses/{sha}
func (s *Server) handleReposCreateCommitStatusRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-status"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateCommitStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCreateCommitStatusParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposCreateCommitStatusRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCreateCommitStatus(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateCommitStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCreateDeployKeyRequest handles repos/create-deploy-key operation.
//
// POST /repos/{owner}/{repo}/keys
func (s *Server) handleReposCreateDeployKeyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deploy-key"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateDeployKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCreateDeployKeyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposCreateDeployKeyRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCreateDeployKey(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateDeployKeyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCreateDeploymentRequest handles repos/create-deployment operation.
//
// POST /repos/{owner}/{repo}/deployments
func (s *Server) handleReposCreateDeploymentRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deployment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateDeployment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCreateDeploymentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposCreateDeploymentRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCreateDeployment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateDeploymentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCreateDeploymentStatusRequest handles repos/create-deployment-status operation.
//
// POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
func (s *Server) handleReposCreateDeploymentStatusRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deployment-status"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateDeploymentStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCreateDeploymentStatusParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposCreateDeploymentStatusRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCreateDeploymentStatus(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateDeploymentStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCreateDispatchEventRequest handles repos/create-dispatch-event operation.
//
// POST /repos/{owner}/{repo}/dispatches
func (s *Server) handleReposCreateDispatchEventRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-dispatch-event"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateDispatchEvent",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCreateDispatchEventParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposCreateDispatchEventRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCreateDispatchEvent(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateDispatchEventResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCreateForAuthenticatedUserRequest handles repos/create-for-authenticated-user operation.
//
// POST /user/repos
func (s *Server) handleReposCreateForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	request, err := decodeReposCreateForAuthenticatedUserRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCreateForAuthenticatedUser(ctx, request)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCreateForkRequest handles repos/create-fork operation.
//
// POST /repos/{owner}/{repo}/forks
func (s *Server) handleReposCreateForkRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-fork"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateFork",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCreateForkParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposCreateForkRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCreateFork(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateForkResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCreateInOrgRequest handles repos/create-in-org operation.
//
// POST /orgs/{org}/repos
func (s *Server) handleReposCreateInOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCreateInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposCreateInOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCreateInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCreateOrUpdateFileContentsRequest handles repos/create-or-update-file-contents operation.
//
// PUT /repos/{owner}/{repo}/contents/{path}
func (s *Server) handleReposCreateOrUpdateFileContentsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-or-update-file-contents"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateOrUpdateFileContents",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCreateOrUpdateFileContentsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposCreateOrUpdateFileContentsRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCreateOrUpdateFileContents(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateOrUpdateFileContentsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCreatePagesSiteRequest handles repos/create-pages-site operation.
//
// POST /repos/{owner}/{repo}/pages
func (s *Server) handleReposCreatePagesSiteRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-pages-site"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreatePagesSite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCreatePagesSiteParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposCreatePagesSiteRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCreatePagesSite(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreatePagesSiteResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCreateReleaseRequest handles repos/create-release operation.
//
// POST /repos/{owner}/{repo}/releases
func (s *Server) handleReposCreateReleaseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-release"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCreateReleaseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposCreateReleaseRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCreateRelease(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateReleaseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCreateUsingTemplateRequest handles repos/create-using-template operation.
//
// POST /repos/{template_owner}/{template_repo}/generate
func (s *Server) handleReposCreateUsingTemplateRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-using-template"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateUsingTemplate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCreateUsingTemplateParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposCreateUsingTemplateRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCreateUsingTemplate(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateUsingTemplateResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposCreateWebhookRequest handles repos/create-webhook operation.
//
// POST /repos/{owner}/{repo}/hooks
func (s *Server) handleReposCreateWebhookRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-webhook"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposCreateWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposCreateWebhookParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposCreateWebhookRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposCreateWebhook(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposCreateWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeclineInvitationRequest handles repos/decline-invitation operation.
//
// DELETE /user/repository_invitations/{invitation_id}
func (s *Server) handleReposDeclineInvitationRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/decline-invitation"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeclineInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeclineInvitationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeclineInvitation(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeclineInvitationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeleteRequest handles repos/delete operation.
//
// DELETE /repos/{owner}/{repo}
func (s *Server) handleReposDeleteRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDelete",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeleteParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDelete(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeleteAccessRestrictionsRequest handles repos/delete-access-restrictions operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
func (s *Server) handleReposDeleteAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-access-restrictions"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeleteAccessRestrictionsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeleteAccessRestrictions(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteAccessRestrictionsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeleteAdminBranchProtectionRequest handles repos/delete-admin-branch-protection operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (s *Server) handleReposDeleteAdminBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-admin-branch-protection"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteAdminBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeleteAdminBranchProtectionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeleteAdminBranchProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteAdminBranchProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeleteAnEnvironmentRequest handles repos/delete-an-environment operation.
//
// DELETE /repos/{owner}/{repo}/environments/{environment_name}
func (s *Server) handleReposDeleteAnEnvironmentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-an-environment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteAnEnvironment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeleteAnEnvironmentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeleteAnEnvironment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteAnEnvironmentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeleteAutolinkRequest handles repos/delete-autolink operation.
//
// DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}
func (s *Server) handleReposDeleteAutolinkRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-autolink"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteAutolink",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeleteAutolinkParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeleteAutolink(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteAutolinkResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeleteBranchProtectionRequest handles repos/delete-branch-protection operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection
func (s *Server) handleReposDeleteBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-branch-protection"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeleteBranchProtectionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeleteBranchProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteBranchProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeleteCommitCommentRequest handles repos/delete-commit-comment operation.
//
// DELETE /repos/{owner}/{repo}/comments/{comment_id}
func (s *Server) handleReposDeleteCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-commit-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeleteCommitCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeleteCommitComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteCommitCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeleteCommitSignatureProtectionRequest handles repos/delete-commit-signature-protection operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (s *Server) handleReposDeleteCommitSignatureProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-commit-signature-protection"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteCommitSignatureProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeleteCommitSignatureProtectionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeleteCommitSignatureProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteCommitSignatureProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeleteDeployKeyRequest handles repos/delete-deploy-key operation.
//
// DELETE /repos/{owner}/{repo}/keys/{key_id}
func (s *Server) handleReposDeleteDeployKeyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-deploy-key"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteDeployKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeleteDeployKeyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeleteDeployKey(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteDeployKeyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeleteDeploymentRequest handles repos/delete-deployment operation.
//
// DELETE /repos/{owner}/{repo}/deployments/{deployment_id}
func (s *Server) handleReposDeleteDeploymentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-deployment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteDeployment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeleteDeploymentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeleteDeployment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteDeploymentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeleteFileRequest handles repos/delete-file operation.
//
// DELETE /repos/{owner}/{repo}/contents/{path}
func (s *Server) handleReposDeleteFileRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-file"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteFile",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeleteFileParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposDeleteFileRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeleteFile(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteFileResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeleteInvitationRequest handles repos/delete-invitation operation.
//
// DELETE /repos/{owner}/{repo}/invitations/{invitation_id}
func (s *Server) handleReposDeleteInvitationRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-invitation"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeleteInvitationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeleteInvitation(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteInvitationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeletePagesSiteRequest handles repos/delete-pages-site operation.
//
// DELETE /repos/{owner}/{repo}/pages
func (s *Server) handleReposDeletePagesSiteRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-pages-site"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeletePagesSite",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeletePagesSiteParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeletePagesSite(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeletePagesSiteResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeletePullRequestReviewProtectionRequest handles repos/delete-pull-request-review-protection operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (s *Server) handleReposDeletePullRequestReviewProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-pull-request-review-protection"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeletePullRequestReviewProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeletePullRequestReviewProtectionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeletePullRequestReviewProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeletePullRequestReviewProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeleteReleaseRequest handles repos/delete-release operation.
//
// DELETE /repos/{owner}/{repo}/releases/{release_id}
func (s *Server) handleReposDeleteReleaseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-release"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeleteReleaseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeleteRelease(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteReleaseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeleteReleaseAssetRequest handles repos/delete-release-asset operation.
//
// DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}
func (s *Server) handleReposDeleteReleaseAssetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-release-asset"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeleteReleaseAssetParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeleteReleaseAsset(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteReleaseAssetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDeleteWebhookRequest handles repos/delete-webhook operation.
//
// DELETE /repos/{owner}/{repo}/hooks/{hook_id}
func (s *Server) handleReposDeleteWebhookRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-webhook"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDeleteWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDeleteWebhookParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDeleteWebhook(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDeleteWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDisableAutomatedSecurityFixesRequest handles repos/disable-automated-security-fixes operation.
//
// DELETE /repos/{owner}/{repo}/automated-security-fixes
func (s *Server) handleReposDisableAutomatedSecurityFixesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-automated-security-fixes"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDisableAutomatedSecurityFixes",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDisableAutomatedSecurityFixesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDisableAutomatedSecurityFixes(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDisableAutomatedSecurityFixesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDisableLfsForRepoRequest handles repos/disable-lfs-for-repo operation.
//
// DELETE /repos/{owner}/{repo}/lfs
func (s *Server) handleReposDisableLfsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-lfs-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDisableLfsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDisableLfsForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDisableLfsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDisableLfsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDisableVulnerabilityAlertsRequest handles repos/disable-vulnerability-alerts operation.
//
// DELETE /repos/{owner}/{repo}/vulnerability-alerts
func (s *Server) handleReposDisableVulnerabilityAlertsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-vulnerability-alerts"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDisableVulnerabilityAlerts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDisableVulnerabilityAlertsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDisableVulnerabilityAlerts(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDisableVulnerabilityAlertsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDownloadTarballArchiveRequest handles repos/download-tarball-archive operation.
//
// GET /repos/{owner}/{repo}/tarball/{ref}
func (s *Server) handleReposDownloadTarballArchiveRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/download-tarball-archive"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDownloadTarballArchive",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDownloadTarballArchiveParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDownloadTarballArchive(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDownloadTarballArchiveResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposDownloadZipballArchiveRequest handles repos/download-zipball-archive operation.
//
// GET /repos/{owner}/{repo}/zipball/{ref}
func (s *Server) handleReposDownloadZipballArchiveRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/download-zipball-archive"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposDownloadZipballArchive",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposDownloadZipballArchiveParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposDownloadZipballArchive(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposDownloadZipballArchiveResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposEnableAutomatedSecurityFixesRequest handles repos/enable-automated-security-fixes operation.
//
// PUT /repos/{owner}/{repo}/automated-security-fixes
func (s *Server) handleReposEnableAutomatedSecurityFixesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-automated-security-fixes"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposEnableAutomatedSecurityFixes",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposEnableAutomatedSecurityFixesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposEnableAutomatedSecurityFixes(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposEnableAutomatedSecurityFixesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposEnableLfsForRepoRequest handles repos/enable-lfs-for-repo operation.
//
// PUT /repos/{owner}/{repo}/lfs
func (s *Server) handleReposEnableLfsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-lfs-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposEnableLfsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposEnableLfsForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposEnableLfsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposEnableLfsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposEnableVulnerabilityAlertsRequest handles repos/enable-vulnerability-alerts operation.
//
// PUT /repos/{owner}/{repo}/vulnerability-alerts
func (s *Server) handleReposEnableVulnerabilityAlertsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-vulnerability-alerts"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposEnableVulnerabilityAlerts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposEnableVulnerabilityAlertsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposEnableVulnerabilityAlerts(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposEnableVulnerabilityAlertsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetRequest handles repos/get operation.
//
// GET /repos/{owner}/{repo}
func (s *Server) handleReposGetRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGet",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGet(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetAccessRestrictionsRequest handles repos/get-access-restrictions operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
func (s *Server) handleReposGetAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-access-restrictions"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetAccessRestrictionsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetAccessRestrictions(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetAccessRestrictionsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetAdminBranchProtectionRequest handles repos/get-admin-branch-protection operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (s *Server) handleReposGetAdminBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-admin-branch-protection"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAdminBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetAdminBranchProtectionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetAdminBranchProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetAdminBranchProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetAllStatusCheckContextsRequest handles repos/get-all-status-check-contexts operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) handleReposGetAllStatusCheckContextsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-all-status-check-contexts"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAllStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetAllStatusCheckContextsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetAllStatusCheckContexts(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetAllStatusCheckContextsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetAllTopicsRequest handles repos/get-all-topics operation.
//
// GET /repos/{owner}/{repo}/topics
func (s *Server) handleReposGetAllTopicsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-all-topics"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAllTopics",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetAllTopicsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetAllTopics(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetAllTopicsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetAppsWithAccessToProtectedBranchRequest handles repos/get-apps-with-access-to-protected-branch operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) handleReposGetAppsWithAccessToProtectedBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-apps-with-access-to-protected-branch"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAppsWithAccessToProtectedBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetAppsWithAccessToProtectedBranchParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetAppsWithAccessToProtectedBranch(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetAppsWithAccessToProtectedBranchResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetAutolinkRequest handles repos/get-autolink operation.
//
// GET /repos/{owner}/{repo}/autolinks/{autolink_id}
func (s *Server) handleReposGetAutolinkRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-autolink"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetAutolink",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetAutolinkParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetAutolink(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetAutolinkResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetBranchRequest handles repos/get-branch operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}
func (s *Server) handleReposGetBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-branch"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetBranchParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetBranch(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetBranchResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetBranchProtectionRequest handles repos/get-branch-protection operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection
func (s *Server) handleReposGetBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-branch-protection"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetBranchProtectionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetBranchProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetBranchProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetClonesRequest handles repos/get-clones operation.
//
// GET /repos/{owner}/{repo}/traffic/clones
func (s *Server) handleReposGetClonesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-clones"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetClones",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetClonesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetClones(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetClonesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetCodeFrequencyStatsRequest handles repos/get-code-frequency-stats operation.
//
// GET /repos/{owner}/{repo}/stats/code_frequency
func (s *Server) handleReposGetCodeFrequencyStatsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-code-frequency-stats"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCodeFrequencyStats",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetCodeFrequencyStatsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetCodeFrequencyStats(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetCodeFrequencyStatsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetCollaboratorPermissionLevelRequest handles repos/get-collaborator-permission-level operation.
//
// GET /repos/{owner}/{repo}/collaborators/{username}/permission
func (s *Server) handleReposGetCollaboratorPermissionLevelRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-collaborator-permission-level"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCollaboratorPermissionLevel",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetCollaboratorPermissionLevelParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetCollaboratorPermissionLevel(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetCollaboratorPermissionLevelResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetCombinedStatusForRefRequest handles repos/get-combined-status-for-ref operation.
//
// GET /repos/{owner}/{repo}/commits/{ref}/status
func (s *Server) handleReposGetCombinedStatusForRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-combined-status-for-ref"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCombinedStatusForRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetCombinedStatusForRefParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetCombinedStatusForRef(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetCombinedStatusForRefResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetCommitRequest handles repos/get-commit operation.
//
// GET /repos/{owner}/{repo}/commits/{ref}
func (s *Server) handleReposGetCommitRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetCommitParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetCommit(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetCommitResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetCommitActivityStatsRequest handles repos/get-commit-activity-stats operation.
//
// GET /repos/{owner}/{repo}/stats/commit_activity
func (s *Server) handleReposGetCommitActivityStatsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-activity-stats"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCommitActivityStats",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetCommitActivityStatsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetCommitActivityStats(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetCommitActivityStatsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetCommitCommentRequest handles repos/get-commit-comment operation.
//
// GET /repos/{owner}/{repo}/comments/{comment_id}
func (s *Server) handleReposGetCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetCommitCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetCommitComment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetCommitCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetCommitSignatureProtectionRequest handles repos/get-commit-signature-protection operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (s *Server) handleReposGetCommitSignatureProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-signature-protection"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCommitSignatureProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetCommitSignatureProtectionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetCommitSignatureProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetCommitSignatureProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetCommunityProfileMetricsRequest handles repos/get-community-profile-metrics operation.
//
// GET /repos/{owner}/{repo}/community/profile
func (s *Server) handleReposGetCommunityProfileMetricsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-community-profile-metrics"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetCommunityProfileMetrics",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetCommunityProfileMetricsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetCommunityProfileMetrics(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetCommunityProfileMetricsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetContributorsStatsRequest handles repos/get-contributors-stats operation.
//
// GET /repos/{owner}/{repo}/stats/contributors
func (s *Server) handleReposGetContributorsStatsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-contributors-stats"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetContributorsStats",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetContributorsStatsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetContributorsStats(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetContributorsStatsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetDeployKeyRequest handles repos/get-deploy-key operation.
//
// GET /repos/{owner}/{repo}/keys/{key_id}
func (s *Server) handleReposGetDeployKeyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deploy-key"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetDeployKey",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetDeployKeyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetDeployKey(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetDeployKeyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetDeploymentRequest handles repos/get-deployment operation.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}
func (s *Server) handleReposGetDeploymentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deployment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetDeployment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetDeploymentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetDeployment(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetDeploymentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetDeploymentStatusRequest handles repos/get-deployment-status operation.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}
func (s *Server) handleReposGetDeploymentStatusRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deployment-status"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetDeploymentStatus",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetDeploymentStatusParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetDeploymentStatus(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetDeploymentStatusResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetLatestPagesBuildRequest handles repos/get-latest-pages-build operation.
//
// GET /repos/{owner}/{repo}/pages/builds/latest
func (s *Server) handleReposGetLatestPagesBuildRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-latest-pages-build"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetLatestPagesBuild",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetLatestPagesBuildParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetLatestPagesBuild(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetLatestPagesBuildResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetLatestReleaseRequest handles repos/get-latest-release operation.
//
// GET /repos/{owner}/{repo}/releases/latest
func (s *Server) handleReposGetLatestReleaseRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-latest-release"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetLatestRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetLatestReleaseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetLatestRelease(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetLatestReleaseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetPagesRequest handles repos/get-pages operation.
//
// GET /repos/{owner}/{repo}/pages
func (s *Server) handleReposGetPagesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetPages",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetPagesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetPages(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetPagesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetPagesBuildRequest handles repos/get-pages-build operation.
//
// GET /repos/{owner}/{repo}/pages/builds/{build_id}
func (s *Server) handleReposGetPagesBuildRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages-build"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetPagesBuild",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetPagesBuildParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetPagesBuild(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetPagesBuildResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetPagesHealthCheckRequest handles repos/get-pages-health-check operation.
//
// GET /repos/{owner}/{repo}/pages/health
func (s *Server) handleReposGetPagesHealthCheckRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages-health-check"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetPagesHealthCheck",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetPagesHealthCheckParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetPagesHealthCheck(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetPagesHealthCheckResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetParticipationStatsRequest handles repos/get-participation-stats operation.
//
// GET /repos/{owner}/{repo}/stats/participation
func (s *Server) handleReposGetParticipationStatsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-participation-stats"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetParticipationStats",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetParticipationStatsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetParticipationStats(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetParticipationStatsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetPullRequestReviewProtectionRequest handles repos/get-pull-request-review-protection operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (s *Server) handleReposGetPullRequestReviewProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pull-request-review-protection"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetPullRequestReviewProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetPullRequestReviewProtectionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetPullRequestReviewProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetPullRequestReviewProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetPunchCardStatsRequest handles repos/get-punch-card-stats operation.
//
// GET /repos/{owner}/{repo}/stats/punch_card
func (s *Server) handleReposGetPunchCardStatsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-punch-card-stats"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetPunchCardStats",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetPunchCardStatsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetPunchCardStats(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetPunchCardStatsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetReadmeRequest handles repos/get-readme operation.
//
// GET /repos/{owner}/{repo}/readme
func (s *Server) handleReposGetReadmeRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-readme"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetReadme",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetReadmeParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetReadme(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetReadmeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetReadmeInDirectoryRequest handles repos/get-readme-in-directory operation.
//
// GET /repos/{owner}/{repo}/readme/{dir}
func (s *Server) handleReposGetReadmeInDirectoryRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-readme-in-directory"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetReadmeInDirectory",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetReadmeInDirectoryParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetReadmeInDirectory(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetReadmeInDirectoryResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetReleaseRequest handles repos/get-release operation.
//
// GET /repos/{owner}/{repo}/releases/{release_id}
func (s *Server) handleReposGetReleaseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetReleaseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetRelease(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetReleaseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetReleaseAssetRequest handles repos/get-release-asset operation.
//
// GET /repos/{owner}/{repo}/releases/assets/{asset_id}
func (s *Server) handleReposGetReleaseAssetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release-asset"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetReleaseAssetParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetReleaseAsset(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetReleaseAssetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetReleaseByTagRequest handles repos/get-release-by-tag operation.
//
// GET /repos/{owner}/{repo}/releases/tags/{tag}
func (s *Server) handleReposGetReleaseByTagRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release-by-tag"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetReleaseByTag",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetReleaseByTagParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetReleaseByTag(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetReleaseByTagResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetStatusChecksProtectionRequest handles repos/get-status-checks-protection operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (s *Server) handleReposGetStatusChecksProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-status-checks-protection"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetStatusChecksProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetStatusChecksProtectionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetStatusChecksProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetStatusChecksProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetTeamsWithAccessToProtectedBranchRequest handles repos/get-teams-with-access-to-protected-branch operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) handleReposGetTeamsWithAccessToProtectedBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-teams-with-access-to-protected-branch"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetTeamsWithAccessToProtectedBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetTeamsWithAccessToProtectedBranchParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetTeamsWithAccessToProtectedBranch(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetTeamsWithAccessToProtectedBranchResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetTopPathsRequest handles repos/get-top-paths operation.
//
// GET /repos/{owner}/{repo}/traffic/popular/paths
func (s *Server) handleReposGetTopPathsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-top-paths"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetTopPaths",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetTopPathsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetTopPaths(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetTopPathsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetTopReferrersRequest handles repos/get-top-referrers operation.
//
// GET /repos/{owner}/{repo}/traffic/popular/referrers
func (s *Server) handleReposGetTopReferrersRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-top-referrers"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetTopReferrers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetTopReferrersParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetTopReferrers(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetTopReferrersResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetUsersWithAccessToProtectedBranchRequest handles repos/get-users-with-access-to-protected-branch operation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) handleReposGetUsersWithAccessToProtectedBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-users-with-access-to-protected-branch"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetUsersWithAccessToProtectedBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetUsersWithAccessToProtectedBranchParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetUsersWithAccessToProtectedBranch(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetUsersWithAccessToProtectedBranchResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetViewsRequest handles repos/get-views operation.
//
// GET /repos/{owner}/{repo}/traffic/views
func (s *Server) handleReposGetViewsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-views"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetViews",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetViewsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetViews(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetViewsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetWebhookRequest handles repos/get-webhook operation.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}
func (s *Server) handleReposGetWebhookRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetWebhookParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetWebhook(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetWebhookConfigForRepoRequest handles repos/get-webhook-config-for-repo operation.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/config
func (s *Server) handleReposGetWebhookConfigForRepoRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook-config-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetWebhookConfigForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetWebhookConfigForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetWebhookConfigForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetWebhookConfigForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposGetWebhookDeliveryRequest handles repos/get-webhook-delivery operation.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}
func (s *Server) handleReposGetWebhookDeliveryRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook-delivery"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposGetWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposGetWebhookDeliveryParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposGetWebhookDelivery(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposGetWebhookDeliveryResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListAutolinksRequest handles repos/list-autolinks operation.
//
// GET /repos/{owner}/{repo}/autolinks
func (s *Server) handleReposListAutolinksRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-autolinks"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListAutolinks",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListAutolinksParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListAutolinks(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListAutolinksResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListBranchesRequest handles repos/list-branches operation.
//
// GET /repos/{owner}/{repo}/branches
func (s *Server) handleReposListBranchesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-branches"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListBranches",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListBranchesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListBranches(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListBranchesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListBranchesForHeadCommitRequest handles repos/list-branches-for-head-commit operation.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head
func (s *Server) handleReposListBranchesForHeadCommitRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-branches-for-head-commit"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListBranchesForHeadCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListBranchesForHeadCommitParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListBranchesForHeadCommit(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListBranchesForHeadCommitResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListCollaboratorsRequest handles repos/list-collaborators operation.
//
// GET /repos/{owner}/{repo}/collaborators
func (s *Server) handleReposListCollaboratorsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-collaborators"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListCollaborators",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListCollaboratorsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListCollaborators(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListCollaboratorsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListCommentsForCommitRequest handles repos/list-comments-for-commit operation.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/comments
func (s *Server) handleReposListCommentsForCommitRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-comments-for-commit"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListCommentsForCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListCommentsForCommitParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListCommentsForCommit(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListCommentsForCommitResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListCommitCommentsForRepoRequest handles repos/list-commit-comments-for-repo operation.
//
// GET /repos/{owner}/{repo}/comments
func (s *Server) handleReposListCommitCommentsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commit-comments-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListCommitCommentsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListCommitCommentsForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListCommitCommentsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListCommitCommentsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListCommitStatusesForRefRequest handles repos/list-commit-statuses-for-ref operation.
//
// GET /repos/{owner}/{repo}/commits/{ref}/statuses
func (s *Server) handleReposListCommitStatusesForRefRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commit-statuses-for-ref"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListCommitStatusesForRef",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListCommitStatusesForRefParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListCommitStatusesForRef(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListCommitStatusesForRefResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListCommitsRequest handles repos/list-commits operation.
//
// GET /repos/{owner}/{repo}/commits
func (s *Server) handleReposListCommitsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commits"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListCommits",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListCommitsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListCommits(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListCommitsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListContributorsRequest handles repos/list-contributors operation.
//
// GET /repos/{owner}/{repo}/contributors
func (s *Server) handleReposListContributorsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-contributors"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListContributors",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListContributorsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListContributors(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListContributorsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListDeployKeysRequest handles repos/list-deploy-keys operation.
//
// GET /repos/{owner}/{repo}/keys
func (s *Server) handleReposListDeployKeysRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deploy-keys"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListDeployKeys",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListDeployKeysParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListDeployKeys(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListDeployKeysResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListDeploymentStatusesRequest handles repos/list-deployment-statuses operation.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
func (s *Server) handleReposListDeploymentStatusesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deployment-statuses"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListDeploymentStatuses",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListDeploymentStatusesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListDeploymentStatuses(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListDeploymentStatusesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListDeploymentsRequest handles repos/list-deployments operation.
//
// GET /repos/{owner}/{repo}/deployments
func (s *Server) handleReposListDeploymentsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deployments"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListDeployments",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListDeploymentsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListDeployments(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListDeploymentsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListForAuthenticatedUserRequest handles repos/list-for-authenticated-user operation.
//
// GET /user/repos
func (s *Server) handleReposListForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListForOrgRequest handles repos/list-for-org operation.
//
// GET /orgs/{org}/repos
func (s *Server) handleReposListForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListForUserRequest handles repos/list-for-user operation.
//
// GET /users/{username}/repos
func (s *Server) handleReposListForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListForksRequest handles repos/list-forks operation.
//
// GET /repos/{owner}/{repo}/forks
func (s *Server) handleReposListForksRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-forks"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListForks",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListForksParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListForks(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListForksResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListInvitationsRequest handles repos/list-invitations operation.
//
// GET /repos/{owner}/{repo}/invitations
func (s *Server) handleReposListInvitationsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-invitations"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListInvitations",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListInvitationsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListInvitations(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListInvitationsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListInvitationsForAuthenticatedUserRequest handles repos/list-invitations-for-authenticated-user operation.
//
// GET /user/repository_invitations
func (s *Server) handleReposListInvitationsForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-invitations-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListInvitationsForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListInvitationsForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListInvitationsForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListInvitationsForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListLanguagesRequest handles repos/list-languages operation.
//
// GET /repos/{owner}/{repo}/languages
func (s *Server) handleReposListLanguagesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-languages"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListLanguages",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListLanguagesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListLanguages(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListLanguagesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListPagesBuildsRequest handles repos/list-pages-builds operation.
//
// GET /repos/{owner}/{repo}/pages/builds
func (s *Server) handleReposListPagesBuildsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-pages-builds"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListPagesBuilds",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListPagesBuildsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListPagesBuilds(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListPagesBuildsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListPublicRequest handles repos/list-public operation.
//
// GET /repositories
func (s *Server) handleReposListPublicRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-public"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListPublic",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListPublicParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListPublic(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListPublicResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListPullRequestsAssociatedWithCommitRequest handles repos/list-pull-requests-associated-with-commit operation.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls
func (s *Server) handleReposListPullRequestsAssociatedWithCommitRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-pull-requests-associated-with-commit"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListPullRequestsAssociatedWithCommit",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListPullRequestsAssociatedWithCommitParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListPullRequestsAssociatedWithCommit(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListPullRequestsAssociatedWithCommitResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListReleaseAssetsRequest handles repos/list-release-assets operation.
//
// GET /repos/{owner}/{repo}/releases/{release_id}/assets
func (s *Server) handleReposListReleaseAssetsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-release-assets"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListReleaseAssets",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListReleaseAssetsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListReleaseAssets(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListReleaseAssetsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListReleasesRequest handles repos/list-releases operation.
//
// GET /repos/{owner}/{repo}/releases
func (s *Server) handleReposListReleasesRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-releases"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListReleases",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListReleasesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListReleases(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListReleasesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListTagsRequest handles repos/list-tags operation.
//
// GET /repos/{owner}/{repo}/tags
func (s *Server) handleReposListTagsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-tags"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListTags",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListTagsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListTags(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListTagsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListTeamsRequest handles repos/list-teams operation.
//
// GET /repos/{owner}/{repo}/teams
func (s *Server) handleReposListTeamsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-teams"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListTeams",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListTeamsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListTeams(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListTeamsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListWebhookDeliveriesRequest handles repos/list-webhook-deliveries operation.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries
func (s *Server) handleReposListWebhookDeliveriesRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-webhook-deliveries"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListWebhookDeliveries",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListWebhookDeliveriesParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListWebhookDeliveries(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListWebhookDeliveriesResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposListWebhooksRequest handles repos/list-webhooks operation.
//
// GET /repos/{owner}/{repo}/hooks
func (s *Server) handleReposListWebhooksRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-webhooks"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposListWebhooks",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposListWebhooksParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposListWebhooks(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposListWebhooksResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposMergeRequest handles repos/merge operation.
//
// POST /repos/{owner}/{repo}/merges
func (s *Server) handleReposMergeRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/merge"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposMerge",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposMergeParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposMergeRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposMerge(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposMergeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposMergeUpstreamRequest handles repos/merge-upstream operation.
//
// POST /repos/{owner}/{repo}/merge-upstream
func (s *Server) handleReposMergeUpstreamRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/merge-upstream"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposMergeUpstream",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposMergeUpstreamParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposMergeUpstreamRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposMergeUpstream(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposMergeUpstreamResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposPingWebhookRequest handles repos/ping-webhook operation.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/pings
func (s *Server) handleReposPingWebhookRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/ping-webhook"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposPingWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposPingWebhookParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposPingWebhook(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposPingWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposRedeliverWebhookDeliveryRequest handles repos/redeliver-webhook-delivery operation.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
func (s *Server) handleReposRedeliverWebhookDeliveryRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/redeliver-webhook-delivery"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRedeliverWebhookDelivery",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposRedeliverWebhookDeliveryParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposRedeliverWebhookDelivery(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposRedeliverWebhookDeliveryResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposRemoveAppAccessRestrictionsRequest handles repos/remove-app-access-restrictions operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) handleReposRemoveAppAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-app-access-restrictions"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveAppAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposRemoveAppAccessRestrictionsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposRemoveAppAccessRestrictionsRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposRemoveAppAccessRestrictions(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposRemoveAppAccessRestrictionsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposRemoveCollaboratorRequest handles repos/remove-collaborator operation.
//
// DELETE /repos/{owner}/{repo}/collaborators/{username}
func (s *Server) handleReposRemoveCollaboratorRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-collaborator"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveCollaborator",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposRemoveCollaboratorParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposRemoveCollaborator(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposRemoveCollaboratorResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposRemoveStatusCheckContextsRequest handles repos/remove-status-check-contexts operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) handleReposRemoveStatusCheckContextsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-status-check-contexts"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposRemoveStatusCheckContextsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposRemoveStatusCheckContextsRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposRemoveStatusCheckContexts(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposRemoveStatusCheckContextsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposRemoveStatusCheckProtectionRequest handles repos/remove-status-check-protection operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (s *Server) handleReposRemoveStatusCheckProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-status-check-protection"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveStatusCheckProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposRemoveStatusCheckProtectionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposRemoveStatusCheckProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposRemoveStatusCheckProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposRemoveTeamAccessRestrictionsRequest handles repos/remove-team-access-restrictions operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) handleReposRemoveTeamAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-team-access-restrictions"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveTeamAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposRemoveTeamAccessRestrictionsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposRemoveTeamAccessRestrictionsRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposRemoveTeamAccessRestrictions(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposRemoveTeamAccessRestrictionsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposRemoveUserAccessRestrictionsRequest handles repos/remove-user-access-restrictions operation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) handleReposRemoveUserAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-user-access-restrictions"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRemoveUserAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposRemoveUserAccessRestrictionsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposRemoveUserAccessRestrictionsRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposRemoveUserAccessRestrictions(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposRemoveUserAccessRestrictionsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposRenameBranchRequest handles repos/rename-branch operation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/rename
func (s *Server) handleReposRenameBranchRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/rename-branch"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRenameBranch",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposRenameBranchParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposRenameBranchRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposRenameBranch(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposRenameBranchResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposReplaceAllTopicsRequest handles repos/replace-all-topics operation.
//
// PUT /repos/{owner}/{repo}/topics
func (s *Server) handleReposReplaceAllTopicsRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/replace-all-topics"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposReplaceAllTopics",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposReplaceAllTopicsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposReplaceAllTopicsRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposReplaceAllTopics(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposReplaceAllTopicsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposRequestPagesBuildRequest handles repos/request-pages-build operation.
//
// POST /repos/{owner}/{repo}/pages/builds
func (s *Server) handleReposRequestPagesBuildRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/request-pages-build"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposRequestPagesBuild",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposRequestPagesBuildParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposRequestPagesBuild(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposRequestPagesBuildResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposSetAdminBranchProtectionRequest handles repos/set-admin-branch-protection operation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (s *Server) handleReposSetAdminBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-admin-branch-protection"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposSetAdminBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposSetAdminBranchProtectionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposSetAdminBranchProtection(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposSetAdminBranchProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposSetAppAccessRestrictionsRequest handles repos/set-app-access-restrictions operation.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) handleReposSetAppAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-app-access-restrictions"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposSetAppAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposSetAppAccessRestrictionsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposSetAppAccessRestrictionsRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposSetAppAccessRestrictions(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposSetAppAccessRestrictionsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposSetStatusCheckContextsRequest handles repos/set-status-check-contexts operation.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) handleReposSetStatusCheckContextsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-status-check-contexts"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposSetStatusCheckContexts",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposSetStatusCheckContextsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposSetStatusCheckContextsRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposSetStatusCheckContexts(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposSetStatusCheckContextsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposSetTeamAccessRestrictionsRequest handles repos/set-team-access-restrictions operation.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) handleReposSetTeamAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-team-access-restrictions"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposSetTeamAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposSetTeamAccessRestrictionsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposSetTeamAccessRestrictionsRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposSetTeamAccessRestrictions(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposSetTeamAccessRestrictionsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposSetUserAccessRestrictionsRequest handles repos/set-user-access-restrictions operation.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) handleReposSetUserAccessRestrictionsRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-user-access-restrictions"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposSetUserAccessRestrictions",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposSetUserAccessRestrictionsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposSetUserAccessRestrictionsRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposSetUserAccessRestrictions(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposSetUserAccessRestrictionsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposTestPushWebhookRequest handles repos/test-push-webhook operation.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/tests
func (s *Server) handleReposTestPushWebhookRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/test-push-webhook"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposTestPushWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposTestPushWebhookParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposTestPushWebhook(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposTestPushWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposTransferRequest handles repos/transfer operation.
//
// POST /repos/{owner}/{repo}/transfer
func (s *Server) handleReposTransferRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/transfer"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposTransfer",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposTransferParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposTransferRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposTransfer(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposTransferResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposUpdateRequest handles repos/update operation.
//
// PATCH /repos/{owner}/{repo}
func (s *Server) handleReposUpdateRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposUpdateParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposUpdateRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposUpdate(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposUpdateResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposUpdateBranchProtectionRequest handles repos/update-branch-protection operation.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection
func (s *Server) handleReposUpdateBranchProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-branch-protection"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateBranchProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposUpdateBranchProtectionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposUpdateBranchProtectionRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposUpdateBranchProtection(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposUpdateBranchProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposUpdateCommitCommentRequest handles repos/update-commit-comment operation.
//
// PATCH /repos/{owner}/{repo}/comments/{comment_id}
func (s *Server) handleReposUpdateCommitCommentRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-commit-comment"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateCommitComment",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposUpdateCommitCommentParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposUpdateCommitCommentRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposUpdateCommitComment(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposUpdateCommitCommentResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposUpdateInvitationRequest handles repos/update-invitation operation.
//
// PATCH /repos/{owner}/{repo}/invitations/{invitation_id}
func (s *Server) handleReposUpdateInvitationRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-invitation"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateInvitation",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposUpdateInvitationParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposUpdateInvitationRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposUpdateInvitation(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposUpdateInvitationResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposUpdatePullRequestReviewProtectionRequest handles repos/update-pull-request-review-protection operation.
//
// PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (s *Server) handleReposUpdatePullRequestReviewProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-pull-request-review-protection"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdatePullRequestReviewProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposUpdatePullRequestReviewProtectionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposUpdatePullRequestReviewProtectionRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposUpdatePullRequestReviewProtection(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposUpdatePullRequestReviewProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposUpdateReleaseRequest handles repos/update-release operation.
//
// PATCH /repos/{owner}/{repo}/releases/{release_id}
func (s *Server) handleReposUpdateReleaseRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-release"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateRelease",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposUpdateReleaseParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposUpdateReleaseRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposUpdateRelease(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposUpdateReleaseResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposUpdateReleaseAssetRequest handles repos/update-release-asset operation.
//
// PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}
func (s *Server) handleReposUpdateReleaseAssetRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-release-asset"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateReleaseAsset",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposUpdateReleaseAssetParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposUpdateReleaseAssetRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposUpdateReleaseAsset(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposUpdateReleaseAssetResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposUpdateStatusCheckProtectionRequest handles repos/update-status-check-protection operation.
//
// PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (s *Server) handleReposUpdateStatusCheckProtectionRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-status-check-protection"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateStatusCheckProtection",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposUpdateStatusCheckProtectionParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposUpdateStatusCheckProtectionRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposUpdateStatusCheckProtection(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposUpdateStatusCheckProtectionResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposUpdateWebhookRequest handles repos/update-webhook operation.
//
// PATCH /repos/{owner}/{repo}/hooks/{hook_id}
func (s *Server) handleReposUpdateWebhookRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-webhook"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateWebhook",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposUpdateWebhookParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposUpdateWebhookRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposUpdateWebhook(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposUpdateWebhookResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleReposUpdateWebhookConfigForRepoRequest handles repos/update-webhook-config-for-repo operation.
//
// PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config
func (s *Server) handleReposUpdateWebhookConfigForRepoRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-webhook-config-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ReposUpdateWebhookConfigForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeReposUpdateWebhookConfigForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeReposUpdateWebhookConfigForRepoRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ReposUpdateWebhookConfigForRepo(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeReposUpdateWebhookConfigForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleScimDeleteUserFromOrgRequest handles scim/delete-user-from-org operation.
//
// DELETE /scim/v2/organizations/{org}/Users/{scim_user_id}
func (s *Server) handleScimDeleteUserFromOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("scim/delete-user-from-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "ScimDeleteUserFromOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeScimDeleteUserFromOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.ScimDeleteUserFromOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeScimDeleteUserFromOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleSearchCodeRequest handles search/code operation.
//
// GET /search/code
func (s *Server) handleSearchCodeRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/code"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchCode",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeSearchCodeParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.SearchCode(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSearchCodeResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleSearchCommitsRequest handles search/commits operation.
//
// GET /search/commits
func (s *Server) handleSearchCommitsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/commits"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchCommits",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeSearchCommitsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.SearchCommits(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSearchCommitsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleSearchIssuesAndPullRequestsRequest handles search/issues-and-pull-requests operation.
//
// GET /search/issues
func (s *Server) handleSearchIssuesAndPullRequestsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/issues-and-pull-requests"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchIssuesAndPullRequests",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeSearchIssuesAndPullRequestsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.SearchIssuesAndPullRequests(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSearchIssuesAndPullRequestsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleSearchLabelsRequest handles search/labels operation.
//
// GET /search/labels
func (s *Server) handleSearchLabelsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/labels"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchLabels",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeSearchLabelsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.SearchLabels(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSearchLabelsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleSearchReposRequest handles search/repos operation.
//
// GET /search/repositories
func (s *Server) handleSearchReposRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/repos"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchRepos",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeSearchReposParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.SearchRepos(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSearchReposResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleSearchTopicsRequest handles search/topics operation.
//
// GET /search/topics
func (s *Server) handleSearchTopicsRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/topics"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchTopics",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeSearchTopicsParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.SearchTopics(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSearchTopicsResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleSearchUsersRequest handles search/users operation.
//
// GET /search/users
func (s *Server) handleSearchUsersRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/users"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SearchUsers",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeSearchUsersParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.SearchUsers(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSearchUsersResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleSecretScanningGetAlertRequest handles secret-scanning/get-alert operation.
//
// GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
func (s *Server) handleSecretScanningGetAlertRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/get-alert"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SecretScanningGetAlert",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeSecretScanningGetAlertParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.SecretScanningGetAlert(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSecretScanningGetAlertResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleSecretScanningListAlertsForOrgRequest handles secret-scanning/list-alerts-for-org operation.
//
// GET /orgs/{org}/secret-scanning/alerts
func (s *Server) handleSecretScanningListAlertsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/list-alerts-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SecretScanningListAlertsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeSecretScanningListAlertsForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.SecretScanningListAlertsForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSecretScanningListAlertsForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleSecretScanningListAlertsForRepoRequest handles secret-scanning/list-alerts-for-repo operation.
//
// GET /repos/{owner}/{repo}/secret-scanning/alerts
func (s *Server) handleSecretScanningListAlertsForRepoRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/list-alerts-for-repo"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SecretScanningListAlertsForRepo",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeSecretScanningListAlertsForRepoParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.SecretScanningListAlertsForRepo(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSecretScanningListAlertsForRepoResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleSecretScanningUpdateAlertRequest handles secret-scanning/update-alert operation.
//
// PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
func (s *Server) handleSecretScanningUpdateAlertRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/update-alert"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "SecretScanningUpdateAlert",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeSecretScanningUpdateAlertParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeSecretScanningUpdateAlertRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.SecretScanningUpdateAlert(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeSecretScanningUpdateAlertResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsAddMemberLegacyRequest handles teams/add-member-legacy operation.
//
// PUT /teams/{team_id}/members/{username}
func (s *Server) handleTeamsAddMemberLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-member-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddMemberLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsAddMemberLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsAddMemberLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsAddMemberLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsAddOrUpdateMembershipForUserInOrgRequest handles teams/add-or-update-membership-for-user-in-org operation.
//
// PUT /orgs/{org}/teams/{team_slug}/memberships/{username}
func (s *Server) handleTeamsAddOrUpdateMembershipForUserInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-membership-for-user-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateMembershipForUserInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsAddOrUpdateMembershipForUserInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsAddOrUpdateMembershipForUserInOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsAddOrUpdateMembershipForUserInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsAddOrUpdateMembershipForUserInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsAddOrUpdateMembershipForUserLegacyRequest handles teams/add-or-update-membership-for-user-legacy operation.
//
// PUT /teams/{team_id}/memberships/{username}
func (s *Server) handleTeamsAddOrUpdateMembershipForUserLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-membership-for-user-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateMembershipForUserLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsAddOrUpdateMembershipForUserLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsAddOrUpdateMembershipForUserLegacyRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsAddOrUpdateMembershipForUserLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsAddOrUpdateMembershipForUserLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsAddOrUpdateProjectPermissionsInOrgRequest handles teams/add-or-update-project-permissions-in-org operation.
//
// PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (s *Server) handleTeamsAddOrUpdateProjectPermissionsInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-project-permissions-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateProjectPermissionsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsAddOrUpdateProjectPermissionsInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsAddOrUpdateProjectPermissionsInOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsAddOrUpdateProjectPermissionsInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsAddOrUpdateProjectPermissionsInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsAddOrUpdateProjectPermissionsLegacyRequest handles teams/add-or-update-project-permissions-legacy operation.
//
// PUT /teams/{team_id}/projects/{project_id}
func (s *Server) handleTeamsAddOrUpdateProjectPermissionsLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-project-permissions-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateProjectPermissionsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsAddOrUpdateProjectPermissionsLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsAddOrUpdateProjectPermissionsLegacyRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsAddOrUpdateProjectPermissionsLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsAddOrUpdateProjectPermissionsLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsAddOrUpdateRepoPermissionsInOrgRequest handles teams/add-or-update-repo-permissions-in-org operation.
//
// PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (s *Server) handleTeamsAddOrUpdateRepoPermissionsInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-repo-permissions-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateRepoPermissionsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsAddOrUpdateRepoPermissionsInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsAddOrUpdateRepoPermissionsInOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsAddOrUpdateRepoPermissionsInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsAddOrUpdateRepoPermissionsInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsAddOrUpdateRepoPermissionsLegacyRequest handles teams/add-or-update-repo-permissions-legacy operation.
//
// PUT /teams/{team_id}/repos/{owner}/{repo}
func (s *Server) handleTeamsAddOrUpdateRepoPermissionsLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-repo-permissions-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsAddOrUpdateRepoPermissionsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsAddOrUpdateRepoPermissionsLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsAddOrUpdateRepoPermissionsLegacyRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsAddOrUpdateRepoPermissionsLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsAddOrUpdateRepoPermissionsLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsCheckPermissionsForProjectInOrgRequest handles teams/check-permissions-for-project-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (s *Server) handleTeamsCheckPermissionsForProjectInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-project-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCheckPermissionsForProjectInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsCheckPermissionsForProjectInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsCheckPermissionsForProjectInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForProjectInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsCheckPermissionsForProjectLegacyRequest handles teams/check-permissions-for-project-legacy operation.
//
// GET /teams/{team_id}/projects/{project_id}
func (s *Server) handleTeamsCheckPermissionsForProjectLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-project-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCheckPermissionsForProjectLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsCheckPermissionsForProjectLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsCheckPermissionsForProjectLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForProjectLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsCheckPermissionsForRepoInOrgRequest handles teams/check-permissions-for-repo-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (s *Server) handleTeamsCheckPermissionsForRepoInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-repo-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCheckPermissionsForRepoInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsCheckPermissionsForRepoInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsCheckPermissionsForRepoInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForRepoInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsCheckPermissionsForRepoLegacyRequest handles teams/check-permissions-for-repo-legacy operation.
//
// GET /teams/{team_id}/repos/{owner}/{repo}
func (s *Server) handleTeamsCheckPermissionsForRepoLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-repo-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCheckPermissionsForRepoLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsCheckPermissionsForRepoLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsCheckPermissionsForRepoLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForRepoLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsCreateRequest handles teams/create operation.
//
// POST /orgs/{org}/teams
func (s *Server) handleTeamsCreateRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreate",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsCreateParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsCreateRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsCreate(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCreateResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsCreateDiscussionCommentInOrgRequest handles teams/create-discussion-comment-in-org operation.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
func (s *Server) handleTeamsCreateDiscussionCommentInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-comment-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsCreateDiscussionCommentInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsCreateDiscussionCommentInOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsCreateDiscussionCommentInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCreateDiscussionCommentInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsCreateDiscussionCommentLegacyRequest handles teams/create-discussion-comment-legacy operation.
//
// POST /teams/{team_id}/discussions/{discussion_number}/comments
func (s *Server) handleTeamsCreateDiscussionCommentLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-comment-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsCreateDiscussionCommentLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsCreateDiscussionCommentLegacyRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsCreateDiscussionCommentLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCreateDiscussionCommentLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsCreateDiscussionInOrgRequest handles teams/create-discussion-in-org operation.
//
// POST /orgs/{org}/teams/{team_slug}/discussions
func (s *Server) handleTeamsCreateDiscussionInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsCreateDiscussionInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsCreateDiscussionInOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsCreateDiscussionInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCreateDiscussionInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsCreateDiscussionLegacyRequest handles teams/create-discussion-legacy operation.
//
// POST /teams/{team_id}/discussions
func (s *Server) handleTeamsCreateDiscussionLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsCreateDiscussionLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsCreateDiscussionLegacyRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsCreateDiscussionLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCreateDiscussionLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest handles teams/create-or-update-idp-group-connections-in-org operation.
//
// PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings
func (s *Server) handleTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-or-update-idp-group-connections-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateOrUpdateIdpGroupConnectionsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest handles teams/create-or-update-idp-group-connections-legacy operation.
//
// PATCH /teams/{team_id}/team-sync/group-mappings
func (s *Server) handleTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-or-update-idp-group-connections-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsCreateOrUpdateIdpGroupConnectionsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsDeleteDiscussionCommentInOrgRequest handles teams/delete-discussion-comment-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsDeleteDiscussionCommentInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-comment-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsDeleteDiscussionCommentInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsDeleteDiscussionCommentInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionCommentInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsDeleteDiscussionCommentLegacyRequest handles teams/delete-discussion-comment-legacy operation.
//
// DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsDeleteDiscussionCommentLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-comment-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsDeleteDiscussionCommentLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsDeleteDiscussionCommentLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionCommentLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsDeleteDiscussionInOrgRequest handles teams/delete-discussion-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (s *Server) handleTeamsDeleteDiscussionInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsDeleteDiscussionInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsDeleteDiscussionInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsDeleteDiscussionLegacyRequest handles teams/delete-discussion-legacy operation.
//
// DELETE /teams/{team_id}/discussions/{discussion_number}
func (s *Server) handleTeamsDeleteDiscussionLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsDeleteDiscussionLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsDeleteDiscussionLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsDeleteInOrgRequest handles teams/delete-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}
func (s *Server) handleTeamsDeleteInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsDeleteInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsDeleteInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsDeleteInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsDeleteLegacyRequest handles teams/delete-legacy operation.
//
// DELETE /teams/{team_id}
func (s *Server) handleTeamsDeleteLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsDeleteLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsDeleteLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsDeleteLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsDeleteLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsGetByNameRequest handles teams/get-by-name operation.
//
// GET /orgs/{org}/teams/{team_slug}
func (s *Server) handleTeamsGetByNameRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-by-name"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetByName",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsGetByNameParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsGetByName(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetByNameResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsGetDiscussionCommentInOrgRequest handles teams/get-discussion-comment-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsGetDiscussionCommentInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-comment-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsGetDiscussionCommentInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsGetDiscussionCommentInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetDiscussionCommentInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsGetDiscussionCommentLegacyRequest handles teams/get-discussion-comment-legacy operation.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsGetDiscussionCommentLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-comment-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsGetDiscussionCommentLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsGetDiscussionCommentLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetDiscussionCommentLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsGetDiscussionInOrgRequest handles teams/get-discussion-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (s *Server) handleTeamsGetDiscussionInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsGetDiscussionInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsGetDiscussionInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetDiscussionInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsGetDiscussionLegacyRequest handles teams/get-discussion-legacy operation.
//
// GET /teams/{team_id}/discussions/{discussion_number}
func (s *Server) handleTeamsGetDiscussionLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsGetDiscussionLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsGetDiscussionLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetDiscussionLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsGetLegacyRequest handles teams/get-legacy operation.
//
// GET /teams/{team_id}
func (s *Server) handleTeamsGetLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsGetLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsGetLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsGetMemberLegacyRequest handles teams/get-member-legacy operation.
//
// GET /teams/{team_id}/members/{username}
func (s *Server) handleTeamsGetMemberLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-member-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetMemberLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsGetMemberLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsGetMemberLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetMemberLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsGetMembershipForUserInOrgRequest handles teams/get-membership-for-user-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/memberships/{username}
func (s *Server) handleTeamsGetMembershipForUserInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-membership-for-user-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetMembershipForUserInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsGetMembershipForUserInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsGetMembershipForUserInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetMembershipForUserInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsGetMembershipForUserLegacyRequest handles teams/get-membership-for-user-legacy operation.
//
// GET /teams/{team_id}/memberships/{username}
func (s *Server) handleTeamsGetMembershipForUserLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-membership-for-user-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsGetMembershipForUserLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsGetMembershipForUserLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsGetMembershipForUserLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsGetMembershipForUserLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListRequest handles teams/list operation.
//
// GET /orgs/{org}/teams
func (s *Server) handleTeamsListRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListChildInOrgRequest handles teams/list-child-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/teams
func (s *Server) handleTeamsListChildInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-child-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListChildInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListChildInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListChildInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListChildInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListChildLegacyRequest handles teams/list-child-legacy operation.
//
// GET /teams/{team_id}/teams
func (s *Server) handleTeamsListChildLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-child-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListChildLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListChildLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListChildLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListChildLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListDiscussionCommentsInOrgRequest handles teams/list-discussion-comments-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
func (s *Server) handleTeamsListDiscussionCommentsInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussion-comments-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListDiscussionCommentsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListDiscussionCommentsInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListDiscussionCommentsInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListDiscussionCommentsInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListDiscussionCommentsLegacyRequest handles teams/list-discussion-comments-legacy operation.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments
func (s *Server) handleTeamsListDiscussionCommentsLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussion-comments-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListDiscussionCommentsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListDiscussionCommentsLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListDiscussionCommentsLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListDiscussionCommentsLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListDiscussionsInOrgRequest handles teams/list-discussions-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/discussions
func (s *Server) handleTeamsListDiscussionsInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussions-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListDiscussionsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListDiscussionsInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListDiscussionsInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListDiscussionsInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListDiscussionsLegacyRequest handles teams/list-discussions-legacy operation.
//
// GET /teams/{team_id}/discussions
func (s *Server) handleTeamsListDiscussionsLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussions-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListDiscussionsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListDiscussionsLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListDiscussionsLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListDiscussionsLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListForAuthenticatedUserRequest handles teams/list-for-authenticated-user operation.
//
// GET /user/teams
func (s *Server) handleTeamsListForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListIdpGroupsForLegacyRequest handles teams/list-idp-groups-for-legacy operation.
//
// GET /teams/{team_id}/team-sync/group-mappings
func (s *Server) handleTeamsListIdpGroupsForLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-for-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListIdpGroupsForLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListIdpGroupsForLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListIdpGroupsForLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListIdpGroupsForLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListIdpGroupsForOrgRequest handles teams/list-idp-groups-for-org operation.
//
// GET /orgs/{org}/team-sync/groups
func (s *Server) handleTeamsListIdpGroupsForOrgRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-for-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListIdpGroupsForOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListIdpGroupsForOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListIdpGroupsForOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListIdpGroupsForOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListIdpGroupsInOrgRequest handles teams/list-idp-groups-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings
func (s *Server) handleTeamsListIdpGroupsInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListIdpGroupsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListIdpGroupsInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListIdpGroupsInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListIdpGroupsInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListMembersInOrgRequest handles teams/list-members-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/members
func (s *Server) handleTeamsListMembersInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-members-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListMembersInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListMembersInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListMembersInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListMembersInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListMembersLegacyRequest handles teams/list-members-legacy operation.
//
// GET /teams/{team_id}/members
func (s *Server) handleTeamsListMembersLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-members-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListMembersLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListMembersLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListMembersLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListMembersLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListPendingInvitationsInOrgRequest handles teams/list-pending-invitations-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/invitations
func (s *Server) handleTeamsListPendingInvitationsInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-pending-invitations-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListPendingInvitationsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListPendingInvitationsInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListPendingInvitationsInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListPendingInvitationsInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListPendingInvitationsLegacyRequest handles teams/list-pending-invitations-legacy operation.
//
// GET /teams/{team_id}/invitations
func (s *Server) handleTeamsListPendingInvitationsLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-pending-invitations-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListPendingInvitationsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListPendingInvitationsLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListPendingInvitationsLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListPendingInvitationsLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListProjectsInOrgRequest handles teams/list-projects-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/projects
func (s *Server) handleTeamsListProjectsInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-projects-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListProjectsInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListProjectsInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListProjectsInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListProjectsInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListProjectsLegacyRequest handles teams/list-projects-legacy operation.
//
// GET /teams/{team_id}/projects
func (s *Server) handleTeamsListProjectsLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-projects-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListProjectsLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListProjectsLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListProjectsLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListProjectsLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListReposInOrgRequest handles teams/list-repos-in-org operation.
//
// GET /orgs/{org}/teams/{team_slug}/repos
func (s *Server) handleTeamsListReposInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-repos-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListReposInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListReposInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListReposInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListReposInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsListReposLegacyRequest handles teams/list-repos-legacy operation.
//
// GET /teams/{team_id}/repos
func (s *Server) handleTeamsListReposLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-repos-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsListReposLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsListReposLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsListReposLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsListReposLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsRemoveMemberLegacyRequest handles teams/remove-member-legacy operation.
//
// DELETE /teams/{team_id}/members/{username}
func (s *Server) handleTeamsRemoveMemberLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-member-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveMemberLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsRemoveMemberLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsRemoveMemberLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsRemoveMemberLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsRemoveMembershipForUserInOrgRequest handles teams/remove-membership-for-user-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}
func (s *Server) handleTeamsRemoveMembershipForUserInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-membership-for-user-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveMembershipForUserInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsRemoveMembershipForUserInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsRemoveMembershipForUserInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsRemoveMembershipForUserInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsRemoveMembershipForUserLegacyRequest handles teams/remove-membership-for-user-legacy operation.
//
// DELETE /teams/{team_id}/memberships/{username}
func (s *Server) handleTeamsRemoveMembershipForUserLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-membership-for-user-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveMembershipForUserLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsRemoveMembershipForUserLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsRemoveMembershipForUserLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsRemoveMembershipForUserLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsRemoveProjectInOrgRequest handles teams/remove-project-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (s *Server) handleTeamsRemoveProjectInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-project-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveProjectInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsRemoveProjectInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsRemoveProjectInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsRemoveProjectInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsRemoveProjectLegacyRequest handles teams/remove-project-legacy operation.
//
// DELETE /teams/{team_id}/projects/{project_id}
func (s *Server) handleTeamsRemoveProjectLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-project-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveProjectLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsRemoveProjectLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsRemoveProjectLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsRemoveProjectLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsRemoveRepoInOrgRequest handles teams/remove-repo-in-org operation.
//
// DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (s *Server) handleTeamsRemoveRepoInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-repo-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveRepoInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsRemoveRepoInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsRemoveRepoInOrg(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsRemoveRepoInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsRemoveRepoLegacyRequest handles teams/remove-repo-legacy operation.
//
// DELETE /teams/{team_id}/repos/{owner}/{repo}
func (s *Server) handleTeamsRemoveRepoLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-repo-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsRemoveRepoLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsRemoveRepoLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsRemoveRepoLegacy(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsRemoveRepoLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsUpdateDiscussionCommentInOrgRequest handles teams/update-discussion-comment-in-org operation.
//
// PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsUpdateDiscussionCommentInOrgRequest(args [4]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-comment-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateDiscussionCommentInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsUpdateDiscussionCommentInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsUpdateDiscussionCommentInOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsUpdateDiscussionCommentInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionCommentInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsUpdateDiscussionCommentLegacyRequest handles teams/update-discussion-comment-legacy operation.
//
// PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsUpdateDiscussionCommentLegacyRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-comment-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateDiscussionCommentLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsUpdateDiscussionCommentLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsUpdateDiscussionCommentLegacyRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsUpdateDiscussionCommentLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionCommentLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsUpdateDiscussionInOrgRequest handles teams/update-discussion-in-org operation.
//
// PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (s *Server) handleTeamsUpdateDiscussionInOrgRequest(args [3]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateDiscussionInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsUpdateDiscussionInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsUpdateDiscussionInOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsUpdateDiscussionInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsUpdateDiscussionLegacyRequest handles teams/update-discussion-legacy operation.
//
// PATCH /teams/{team_id}/discussions/{discussion_number}
func (s *Server) handleTeamsUpdateDiscussionLegacyRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateDiscussionLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsUpdateDiscussionLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsUpdateDiscussionLegacyRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsUpdateDiscussionLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsUpdateInOrgRequest handles teams/update-in-org operation.
//
// PATCH /orgs/{org}/teams/{team_slug}
func (s *Server) handleTeamsUpdateInOrgRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-in-org"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateInOrg",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsUpdateInOrgParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsUpdateInOrgRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsUpdateInOrg(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsUpdateInOrgResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleTeamsUpdateLegacyRequest handles teams/update-legacy operation.
//
// PATCH /teams/{team_id}
func (s *Server) handleTeamsUpdateLegacyRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-legacy"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "TeamsUpdateLegacy",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeTeamsUpdateLegacyParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}
	request, err := decodeTeamsUpdateLegacyRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.TeamsUpdateLegacy(ctx, request, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeTeamsUpdateLegacyResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersAddEmailForAuthenticatedRequest handles users/add-email-for-authenticated operation.
//
// POST /user/emails
func (s *Server) handleUsersAddEmailForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/add-email-for-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersAddEmailForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	request, err := decodeUsersAddEmailForAuthenticatedRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersAddEmailForAuthenticated(ctx, request)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersAddEmailForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersBlockRequest handles users/block operation.
//
// PUT /user/blocks/{username}
func (s *Server) handleUsersBlockRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/block"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersBlock",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersBlockParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersBlock(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersBlockResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersCheckBlockedRequest handles users/check-blocked operation.
//
// GET /user/blocks/{username}
func (s *Server) handleUsersCheckBlockedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-blocked"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersCheckBlocked",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersCheckBlockedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersCheckBlocked(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersCheckBlockedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersCheckFollowingForUserRequest handles users/check-following-for-user operation.
//
// GET /users/{username}/following/{target_user}
func (s *Server) handleUsersCheckFollowingForUserRequest(args [2]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-following-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersCheckFollowingForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersCheckFollowingForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersCheckFollowingForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersCheckFollowingForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersCheckPersonIsFollowedByAuthenticatedRequest handles users/check-person-is-followed-by-authenticated operation.
//
// GET /user/following/{username}
func (s *Server) handleUsersCheckPersonIsFollowedByAuthenticatedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-person-is-followed-by-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersCheckPersonIsFollowedByAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersCheckPersonIsFollowedByAuthenticatedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersCheckPersonIsFollowedByAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersCheckPersonIsFollowedByAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersCreateGpgKeyForAuthenticatedRequest handles users/create-gpg-key-for-authenticated operation.
//
// POST /user/gpg_keys
func (s *Server) handleUsersCreateGpgKeyForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/create-gpg-key-for-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersCreateGpgKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	request, err := decodeUsersCreateGpgKeyForAuthenticatedRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersCreateGpgKeyForAuthenticated(ctx, request)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersCreateGpgKeyForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersCreatePublicSSHKeyForAuthenticatedRequest handles users/create-public-ssh-key-for-authenticated operation.
//
// POST /user/keys
func (s *Server) handleUsersCreatePublicSSHKeyForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/create-public-ssh-key-for-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersCreatePublicSSHKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	request, err := decodeUsersCreatePublicSSHKeyForAuthenticatedRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersCreatePublicSSHKeyForAuthenticated(ctx, request)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersCreatePublicSSHKeyForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersDeleteEmailForAuthenticatedRequest handles users/delete-email-for-authenticated operation.
//
// DELETE /user/emails
func (s *Server) handleUsersDeleteEmailForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-email-for-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersDeleteEmailForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	request, err := decodeUsersDeleteEmailForAuthenticatedRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersDeleteEmailForAuthenticated(ctx, request)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersDeleteEmailForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersDeleteGpgKeyForAuthenticatedRequest handles users/delete-gpg-key-for-authenticated operation.
//
// DELETE /user/gpg_keys/{gpg_key_id}
func (s *Server) handleUsersDeleteGpgKeyForAuthenticatedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-gpg-key-for-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersDeleteGpgKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersDeleteGpgKeyForAuthenticatedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersDeleteGpgKeyForAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersDeleteGpgKeyForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersDeletePublicSSHKeyForAuthenticatedRequest handles users/delete-public-ssh-key-for-authenticated operation.
//
// DELETE /user/keys/{key_id}
func (s *Server) handleUsersDeletePublicSSHKeyForAuthenticatedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-public-ssh-key-for-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersDeletePublicSSHKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersDeletePublicSSHKeyForAuthenticatedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersDeletePublicSSHKeyForAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersDeletePublicSSHKeyForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersFollowRequest handles users/follow operation.
//
// PUT /user/following/{username}
func (s *Server) handleUsersFollowRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/follow"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersFollow",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersFollowParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersFollow(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersFollowResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersGetAuthenticatedRequest handles users/get-authenticated operation.
//
// GET /user
func (s *Server) handleUsersGetAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersGetAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error

	response, err := s.h.UsersGetAuthenticated(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersGetAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersGetByUsernameRequest handles users/get-by-username operation.
//
// GET /users/{username}
func (s *Server) handleUsersGetByUsernameRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-by-username"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersGetByUsername",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersGetByUsernameParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersGetByUsername(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersGetByUsernameResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersGetContextForUserRequest handles users/get-context-for-user operation.
//
// GET /users/{username}/hovercard
func (s *Server) handleUsersGetContextForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-context-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersGetContextForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersGetContextForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersGetContextForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersGetContextForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersGetGpgKeyForAuthenticatedRequest handles users/get-gpg-key-for-authenticated operation.
//
// GET /user/gpg_keys/{gpg_key_id}
func (s *Server) handleUsersGetGpgKeyForAuthenticatedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-gpg-key-for-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersGetGpgKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersGetGpgKeyForAuthenticatedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersGetGpgKeyForAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersGetGpgKeyForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersGetPublicSSHKeyForAuthenticatedRequest handles users/get-public-ssh-key-for-authenticated operation.
//
// GET /user/keys/{key_id}
func (s *Server) handleUsersGetPublicSSHKeyForAuthenticatedRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-public-ssh-key-for-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersGetPublicSSHKeyForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersGetPublicSSHKeyForAuthenticatedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersGetPublicSSHKeyForAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersGetPublicSSHKeyForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersListRequest handles users/list operation.
//
// GET /users
func (s *Server) handleUsersListRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersList",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersListParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersList(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersListBlockedByAuthenticatedRequest handles users/list-blocked-by-authenticated operation.
//
// GET /user/blocks
func (s *Server) handleUsersListBlockedByAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-blocked-by-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListBlockedByAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error

	response, err := s.h.UsersListBlockedByAuthenticated(ctx)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListBlockedByAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersListEmailsForAuthenticatedRequest handles users/list-emails-for-authenticated operation.
//
// GET /user/emails
func (s *Server) handleUsersListEmailsForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-emails-for-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListEmailsForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersListEmailsForAuthenticatedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersListEmailsForAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListEmailsForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersListFollowedByAuthenticatedRequest handles users/list-followed-by-authenticated operation.
//
// GET /user/following
func (s *Server) handleUsersListFollowedByAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followed-by-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListFollowedByAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersListFollowedByAuthenticatedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersListFollowedByAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListFollowedByAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersListFollowersForAuthenticatedUserRequest handles users/list-followers-for-authenticated-user operation.
//
// GET /user/followers
func (s *Server) handleUsersListFollowersForAuthenticatedUserRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followers-for-authenticated-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListFollowersForAuthenticatedUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersListFollowersForAuthenticatedUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersListFollowersForAuthenticatedUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListFollowersForAuthenticatedUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersListFollowersForUserRequest handles users/list-followers-for-user operation.
//
// GET /users/{username}/followers
func (s *Server) handleUsersListFollowersForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followers-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListFollowersForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersListFollowersForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersListFollowersForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListFollowersForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersListFollowingForUserRequest handles users/list-following-for-user operation.
//
// GET /users/{username}/following
func (s *Server) handleUsersListFollowingForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-following-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListFollowingForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersListFollowingForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersListFollowingForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListFollowingForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersListGpgKeysForAuthenticatedRequest handles users/list-gpg-keys-for-authenticated operation.
//
// GET /user/gpg_keys
func (s *Server) handleUsersListGpgKeysForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-gpg-keys-for-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListGpgKeysForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersListGpgKeysForAuthenticatedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersListGpgKeysForAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListGpgKeysForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersListGpgKeysForUserRequest handles users/list-gpg-keys-for-user operation.
//
// GET /users/{username}/gpg_keys
func (s *Server) handleUsersListGpgKeysForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-gpg-keys-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListGpgKeysForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersListGpgKeysForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersListGpgKeysForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListGpgKeysForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersListPublicEmailsForAuthenticatedRequest handles users/list-public-emails-for-authenticated operation.
//
// GET /user/public_emails
func (s *Server) handleUsersListPublicEmailsForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-emails-for-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListPublicEmailsForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersListPublicEmailsForAuthenticatedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersListPublicEmailsForAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListPublicEmailsForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersListPublicKeysForUserRequest handles users/list-public-keys-for-user operation.
//
// GET /users/{username}/keys
func (s *Server) handleUsersListPublicKeysForUserRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-keys-for-user"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListPublicKeysForUser",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersListPublicKeysForUserParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersListPublicKeysForUser(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListPublicKeysForUserResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersListPublicSSHKeysForAuthenticatedRequest handles users/list-public-ssh-keys-for-authenticated operation.
//
// GET /user/keys
func (s *Server) handleUsersListPublicSSHKeysForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-ssh-keys-for-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersListPublicSSHKeysForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersListPublicSSHKeysForAuthenticatedParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersListPublicSSHKeysForAuthenticated(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersListPublicSSHKeysForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersSetPrimaryEmailVisibilityForAuthenticatedRequest handles users/set-primary-email-visibility-for-authenticated operation.
//
// PATCH /user/email/visibility
func (s *Server) handleUsersSetPrimaryEmailVisibilityForAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/set-primary-email-visibility-for-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersSetPrimaryEmailVisibilityForAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	request, err := decodeUsersSetPrimaryEmailVisibilityForAuthenticatedRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersSetPrimaryEmailVisibilityForAuthenticated(ctx, request)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersSetPrimaryEmailVisibilityForAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersUnblockRequest handles users/unblock operation.
//
// DELETE /user/blocks/{username}
func (s *Server) handleUsersUnblockRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/unblock"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersUnblock",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersUnblockParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersUnblock(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersUnblockResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersUnfollowRequest handles users/unfollow operation.
//
// DELETE /user/following/{username}
func (s *Server) handleUsersUnfollowRequest(args [1]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/unfollow"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersUnfollow",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	params, err := decodeUsersUnfollowParams(args, r)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersUnfollow(ctx, params)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersUnfollowResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

// HandleUsersUpdateAuthenticatedRequest handles users/update-authenticated operation.
//
// PATCH /user
func (s *Server) handleUsersUpdateAuthenticatedRequest(args [0]string, w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/update-authenticated"),
	}
	ctx, span := s.cfg.Tracer.Start(r.Context(), "UsersUpdateAuthenticated",
		trace.WithAttributes(otelAttrs...),
		trace.WithSpanKind(trace.SpanKindServer),
	)
	s.requests.Add(ctx, 1, otelAttrs...)
	defer span.End()

	var err error
	request, err := decodeUsersUpdateAuthenticatedRequest(r, span)
	if err != nil {
		s.badRequest(ctx, w, span, otelAttrs, err)
		return
	}

	response, err := s.h.UsersUpdateAuthenticated(ctx, request)
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Internal")
		s.errors.Add(ctx, 1, otelAttrs...)
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if err := encodeUsersUpdateAuthenticatedResponse(response, w, span); err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, "Response")
		s.errors.Add(ctx, 1, otelAttrs...)
		return
	}
	elapsedDuration := time.Since(startTime)
	s.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
}

func (s *Server) badRequest(ctx context.Context, w http.ResponseWriter, span trace.Span, otelAttrs []attribute.KeyValue, err error) {
	span.RecordError(err)
	span.SetStatus(codes.Error, "BadRequest")
	s.errors.Add(ctx, 1, otelAttrs...)
	respondError(w, http.StatusBadRequest, err)
}

func respondError(w http.ResponseWriter, code int, err error) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	data, writeErr := json.Marshal(struct {
		ErrorMessage string `json:"error_message"`
	}{
		ErrorMessage: err.Error(),
	})
	if writeErr == nil {
		w.Write(data)
	}
}
