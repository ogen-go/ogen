// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"
	"time"

	"github.com/go-faster/errors"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.34.0"
	"go.opentelemetry.io/otel/trace"
)

type codeRecorder struct {
	http.ResponseWriter
	status int
}

func (c *codeRecorder) WriteHeader(status int) {
	c.status = status
	c.ResponseWriter.WriteHeader(status)
}

// handleActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/add-repo-access-to-self-hosted-runner-group-in-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Adds a repository to the list of selected repositories that can access a self-hosted runner group.
// The runner group must have `visibility` set to `selected`. For more information, see "[Create a
// self-hosted runner group for an
// organization](#create-a-self-hosted-runner-group-for-an-organization)."
// You must authenticate using an access token with the `admin:org`
// scope to use this endpoint.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
func (s *Server) handleActionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-repo-access-to-self-hosted-runner-group-in-org"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgOperation,
			ID:   "actions/add-repo-access-to-self-hosted-runner-group-in-org",
		}
	)
	params, err := decodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgOperation,
			OperationSummary: "Add repository access to a self-hosted runner group in an organization",
			OperationID:      "actions/add-repo-access-to-self-hosted-runner-group-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams
			Response = *ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsAddRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsAddSelectedRepoToOrgSecretRequest handles actions/add-selected-repo-to-org-secret operation.
//
// Adds a repository to an organization secret when the `visibility` for repository access is set to
// `selected`. The visibility is set when you [Create or update an organization secret](https://docs.
// github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate
// using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the
// `secrets` organization permission to use this endpoint.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
func (s *Server) handleActionsAddSelectedRepoToOrgSecretRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-selected-repo-to-org-secret"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsAddSelectedRepoToOrgSecretOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsAddSelectedRepoToOrgSecretOperation,
			ID:   "actions/add-selected-repo-to-org-secret",
		}
	)
	params, err := decodeActionsAddSelectedRepoToOrgSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActionsAddSelectedRepoToOrgSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsAddSelectedRepoToOrgSecretOperation,
			OperationSummary: "Add selected repository to an organization secret",
			OperationID:      "actions/add-selected-repo-to-org-secret",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsAddSelectedRepoToOrgSecretParams
			Response = ActionsAddSelectedRepoToOrgSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsAddSelectedRepoToOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsAddSelectedRepoToOrgSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsAddSelectedRepoToOrgSecret(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsAddSelectedRepoToOrgSecretResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsAddSelfHostedRunnerToGroupForOrgRequest handles actions/add-self-hosted-runner-to-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Adds a self-hosted runner to a runner group configured in an organization.
// You must authenticate using an access token with the `admin:org`
// scope to use this endpoint.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) handleActionsAddSelfHostedRunnerToGroupForOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/add-self-hosted-runner-to-group-for-org"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsAddSelfHostedRunnerToGroupForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsAddSelfHostedRunnerToGroupForOrgOperation,
			ID:   "actions/add-self-hosted-runner-to-group-for-org",
		}
	)
	params, err := decodeActionsAddSelfHostedRunnerToGroupForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsAddSelfHostedRunnerToGroupForOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsAddSelfHostedRunnerToGroupForOrgOperation,
			OperationSummary: "Add a self-hosted runner to a group for an organization",
			OperationID:      "actions/add-self-hosted-runner-to-group-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsAddSelfHostedRunnerToGroupForOrgParams
			Response = *ActionsAddSelfHostedRunnerToGroupForOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsAddSelfHostedRunnerToGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsAddSelfHostedRunnerToGroupForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsAddSelfHostedRunnerToGroupForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsAddSelfHostedRunnerToGroupForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsApproveWorkflowRunRequest handles actions/approve-workflow-run operation.
//
// Approves a workflow run for a pull request from a public fork of a first time contributor. For
// more information, see ["Approving workflow runs from public forks](https://docs.github.
// com/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks)."
// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
// Apps must have the `actions:write` permission to use this endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve
func (s *Server) handleActionsApproveWorkflowRunRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/approve-workflow-run"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/approve"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsApproveWorkflowRunOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsApproveWorkflowRunOperation,
			ID:   "actions/approve-workflow-run",
		}
	)
	params, err := decodeActionsApproveWorkflowRunParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActionsApproveWorkflowRunRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsApproveWorkflowRunOperation,
			OperationSummary: "Approve a workflow run for a fork pull request",
			OperationID:      "actions/approve-workflow-run",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsApproveWorkflowRunParams
			Response = ActionsApproveWorkflowRunRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsApproveWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsApproveWorkflowRun(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsApproveWorkflowRun(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsApproveWorkflowRunResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsCancelWorkflowRunRequest handles actions/cancel-workflow-run operation.
//
// Cancels a workflow run using its `id`. You must authenticate using an access token with the `repo`
// scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this
// endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel
func (s *Server) handleActionsCancelWorkflowRunRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/cancel-workflow-run"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/cancel"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsCancelWorkflowRunOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsCancelWorkflowRunOperation,
			ID:   "actions/cancel-workflow-run",
		}
	)
	params, err := decodeActionsCancelWorkflowRunParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsCancelWorkflowRunAccepted
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsCancelWorkflowRunOperation,
			OperationSummary: "Cancel a workflow run",
			OperationID:      "actions/cancel-workflow-run",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsCancelWorkflowRunParams
			Response = *ActionsCancelWorkflowRunAccepted
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCancelWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsCancelWorkflowRun(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsCancelWorkflowRun(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCancelWorkflowRunResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsCreateOrUpdateEnvironmentSecretRequest handles actions/create-or-update-environment-secret operation.
//
// Creates or updates an environment secret with an encrypted value. Encrypt your secret using
// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate
// using an access
// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
// permission to use
// this endpoint.
// #### Example encrypting a secret using Node.js
// Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
// ```
// const sodium = require('tweetsodium');
// const key = "base64-encoded-public-key";
// const value = "plain-text-secret";
// // Convert the message and key to Uint8Array's (Buffer implements that interface)
// const messageBytes = Buffer.from(value);
// const keyBytes = Buffer.from(key, 'base64');
// // Encrypt using LibSodium.
// const encryptedBytes = sodium.seal(messageBytes, keyBytes);
// // Base64 the encrypted secret
// const encrypted = Buffer.from(encryptedBytes).toString('base64');
// console.log(encrypted);
// ```
// #### Example encrypting a secret using Python
// Encrypt your secret using [pynacl](https://pynacl.readthedocs.
// io/en/stable/public/#nacl-public-sealedbox) with Python 3.
// ```
// from base64 import b64encode
// from nacl import encoding, public
// def encrypt(public_key: str, secret_value: str) -> str:
// """Encrypt a Unicode string using the public key."""
// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
// sealed_box = public.SealedBox(public_key)
// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
// return b64encode(encrypted).decode("utf-8")
// ```
// #### Example encrypting a secret using C#
// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
// ```
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// ```
// #### Example encrypting a secret using Ruby
// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
// ```ruby
// require "rbnacl"
// require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
// public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
// encrypted_secret = box.encrypt("my_secret")
// # Print the base64 encoded secret
// puts Base64.strict_encode64(encrypted_secret)
// ```.
//
// PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (s *Server) handleActionsCreateOrUpdateEnvironmentSecretRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-environment-secret"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsCreateOrUpdateEnvironmentSecretOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsCreateOrUpdateEnvironmentSecretOperation,
			ID:   "actions/create-or-update-environment-secret",
		}
	)
	params, err := decodeActionsCreateOrUpdateEnvironmentSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActionsCreateOrUpdateEnvironmentSecretRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsCreateOrUpdateEnvironmentSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsCreateOrUpdateEnvironmentSecretOperation,
			OperationSummary: "Create or update an environment secret",
			OperationID:      "actions/create-or-update-environment-secret",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
				{
					Name: "environment_name",
					In:   "path",
				}: params.EnvironmentName,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsCreateOrUpdateEnvironmentSecretReq
			Params   = ActionsCreateOrUpdateEnvironmentSecretParams
			Response = ActionsCreateOrUpdateEnvironmentSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateOrUpdateEnvironmentSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsCreateOrUpdateEnvironmentSecret(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsCreateOrUpdateEnvironmentSecret(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateOrUpdateEnvironmentSecretResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsCreateOrUpdateOrgSecretRequest handles actions/create-or-update-org-secret operation.
//
// Creates or updates an organization secret with an encrypted value. Encrypt your secret using
// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate
// using an access
// token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets`
// organization permission to
// use this endpoint.
// #### Example encrypting a secret using Node.js
// Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
// ```
// const sodium = require('tweetsodium');
// const key = "base64-encoded-public-key";
// const value = "plain-text-secret";
// // Convert the message and key to Uint8Array's (Buffer implements that interface)
// const messageBytes = Buffer.from(value);
// const keyBytes = Buffer.from(key, 'base64');
// // Encrypt using LibSodium.
// const encryptedBytes = sodium.seal(messageBytes, keyBytes);
// // Base64 the encrypted secret
// const encrypted = Buffer.from(encryptedBytes).toString('base64');
// console.log(encrypted);
// ```
// #### Example encrypting a secret using Python
// Encrypt your secret using [pynacl](https://pynacl.readthedocs.
// io/en/stable/public/#nacl-public-sealedbox) with Python 3.
// ```
// from base64 import b64encode
// from nacl import encoding, public
// def encrypt(public_key: str, secret_value: str) -> str:
// """Encrypt a Unicode string using the public key."""
// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
// sealed_box = public.SealedBox(public_key)
// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
// return b64encode(encrypted).decode("utf-8")
// ```
// #### Example encrypting a secret using C#
// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
// ```
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// ```
// #### Example encrypting a secret using Ruby
// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
// ```ruby
// require "rbnacl"
// require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
// public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
// encrypted_secret = box.encrypt("my_secret")
// # Print the base64 encoded secret
// puts Base64.strict_encode64(encrypted_secret)
// ```.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}
func (s *Server) handleActionsCreateOrUpdateOrgSecretRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-org-secret"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets/{secret_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsCreateOrUpdateOrgSecretOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsCreateOrUpdateOrgSecretOperation,
			ID:   "actions/create-or-update-org-secret",
		}
	)
	params, err := decodeActionsCreateOrUpdateOrgSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActionsCreateOrUpdateOrgSecretRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsCreateOrUpdateOrgSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsCreateOrUpdateOrgSecretOperation,
			OperationSummary: "Create or update an organization secret",
			OperationID:      "actions/create-or-update-org-secret",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsCreateOrUpdateOrgSecretReq
			Params   = ActionsCreateOrUpdateOrgSecretParams
			Response = ActionsCreateOrUpdateOrgSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateOrUpdateOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsCreateOrUpdateOrgSecret(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsCreateOrUpdateOrgSecret(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateOrUpdateOrgSecretResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsCreateOrUpdateRepoSecretRequest handles actions/create-or-update-repo-secret operation.
//
// Creates or updates a repository secret with an encrypted value. Encrypt your secret using
// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate
// using an access
// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
// permission to use
// this endpoint.
// #### Example encrypting a secret using Node.js
// Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
// ```
// const sodium = require('tweetsodium');
// const key = "base64-encoded-public-key";
// const value = "plain-text-secret";
// // Convert the message and key to Uint8Array's (Buffer implements that interface)
// const messageBytes = Buffer.from(value);
// const keyBytes = Buffer.from(key, 'base64');
// // Encrypt using LibSodium.
// const encryptedBytes = sodium.seal(messageBytes, keyBytes);
// // Base64 the encrypted secret
// const encrypted = Buffer.from(encryptedBytes).toString('base64');
// console.log(encrypted);
// ```
// #### Example encrypting a secret using Python
// Encrypt your secret using [pynacl](https://pynacl.readthedocs.
// io/en/stable/public/#nacl-public-sealedbox) with Python 3.
// ```
// from base64 import b64encode
// from nacl import encoding, public
// def encrypt(public_key: str, secret_value: str) -> str:
// """Encrypt a Unicode string using the public key."""
// public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
// sealed_box = public.SealedBox(public_key)
// encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
// return b64encode(encrypted).decode("utf-8")
// ```
// #### Example encrypting a secret using C#
// Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
// ```
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
// var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// ```
// #### Example encrypting a secret using Ruby
// Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
// ```ruby
// require "rbnacl"
// require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
// public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
// encrypted_secret = box.encrypt("my_secret")
// # Print the base64 encoded secret
// puts Base64.strict_encode64(encrypted_secret)
// ```.
//
// PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (s *Server) handleActionsCreateOrUpdateRepoSecretRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-or-update-repo-secret"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/secrets/{secret_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsCreateOrUpdateRepoSecretOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsCreateOrUpdateRepoSecretOperation,
			ID:   "actions/create-or-update-repo-secret",
		}
	)
	params, err := decodeActionsCreateOrUpdateRepoSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActionsCreateOrUpdateRepoSecretRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActionsCreateOrUpdateRepoSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsCreateOrUpdateRepoSecretOperation,
			OperationSummary: "Create or update a repository secret",
			OperationID:      "actions/create-or-update-repo-secret",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsCreateOrUpdateRepoSecretReq
			Params   = ActionsCreateOrUpdateRepoSecretParams
			Response = ActionsCreateOrUpdateRepoSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateOrUpdateRepoSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsCreateOrUpdateRepoSecret(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsCreateOrUpdateRepoSecret(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateOrUpdateRepoSecretResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsCreateRegistrationTokenForOrgRequest handles actions/create-registration-token-for-org operation.
//
// Returns a token that you can pass to the `config` script. The token expires after one hour.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// #### Example using registration token
// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this
// endpoint.
// ```
// ./config.sh --url https://github.com/octo-org --token TOKEN
// ```.
//
// POST /orgs/{org}/actions/runners/registration-token
func (s *Server) handleActionsCreateRegistrationTokenForOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-registration-token-for-org"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runners/registration-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsCreateRegistrationTokenForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsCreateRegistrationTokenForOrgOperation,
			ID:   "actions/create-registration-token-for-org",
		}
	)
	params, err := decodeActionsCreateRegistrationTokenForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsCreateRegistrationTokenForOrgOperation,
			OperationSummary: "Create a registration token for an organization",
			OperationID:      "actions/create-registration-token-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsCreateRegistrationTokenForOrgParams
			Response = *AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateRegistrationTokenForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsCreateRegistrationTokenForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsCreateRegistrationTokenForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateRegistrationTokenForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsCreateRegistrationTokenForRepoRequest handles actions/create-registration-token-for-repo operation.
//
// Returns a token that you can pass to the `config` script. The token expires after one hour. You
// must authenticate
// using an access token with the `repo` scope to use this endpoint.
// #### Example using registration token
// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this
// endpoint.
// ```
// ./config.sh --url https://github.com/octo-org/octo-repo-artifacts --token TOKEN
// ```.
//
// POST /repos/{owner}/{repo}/actions/runners/registration-token
func (s *Server) handleActionsCreateRegistrationTokenForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-registration-token-for-repo"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runners/registration-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsCreateRegistrationTokenForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsCreateRegistrationTokenForRepoOperation,
			ID:   "actions/create-registration-token-for-repo",
		}
	)
	params, err := decodeActionsCreateRegistrationTokenForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsCreateRegistrationTokenForRepoOperation,
			OperationSummary: "Create a registration token for a repository",
			OperationID:      "actions/create-registration-token-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsCreateRegistrationTokenForRepoParams
			Response = *AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateRegistrationTokenForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsCreateRegistrationTokenForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsCreateRegistrationTokenForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateRegistrationTokenForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsCreateRemoveTokenForOrgRequest handles actions/create-remove-token-for-org operation.
//
// Returns a token that you can pass to the `config` script to remove a self-hosted runner from an
// organization. The token expires after one hour.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// #### Example using remove token
// To remove your self-hosted runner from an organization, replace `TOKEN` with the remove token
// provided by this
// endpoint.
// ```
// ./config.sh remove --token TOKEN
// ```.
//
// POST /orgs/{org}/actions/runners/remove-token
func (s *Server) handleActionsCreateRemoveTokenForOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-remove-token-for-org"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runners/remove-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsCreateRemoveTokenForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsCreateRemoveTokenForOrgOperation,
			ID:   "actions/create-remove-token-for-org",
		}
	)
	params, err := decodeActionsCreateRemoveTokenForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsCreateRemoveTokenForOrgOperation,
			OperationSummary: "Create a remove token for an organization",
			OperationID:      "actions/create-remove-token-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsCreateRemoveTokenForOrgParams
			Response = *AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateRemoveTokenForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsCreateRemoveTokenForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsCreateRemoveTokenForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateRemoveTokenForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsCreateRemoveTokenForRepoRequest handles actions/create-remove-token-for-repo operation.
//
// Returns a token that you can pass to remove a self-hosted runner from a repository. The token
// expires after one hour.
// You must authenticate using an access token with the `repo` scope to use this endpoint.
// #### Example using remove token
// To remove your self-hosted runner from a repository, replace TOKEN with the remove token provided
// by this endpoint.
// ```
// ./config.sh remove --token TOKEN
// ```.
//
// POST /repos/{owner}/{repo}/actions/runners/remove-token
func (s *Server) handleActionsCreateRemoveTokenForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-remove-token-for-repo"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runners/remove-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsCreateRemoveTokenForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsCreateRemoveTokenForRepoOperation,
			ID:   "actions/create-remove-token-for-repo",
		}
	)
	params, err := decodeActionsCreateRemoveTokenForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsCreateRemoveTokenForRepoOperation,
			OperationSummary: "Create a remove token for a repository",
			OperationID:      "actions/create-remove-token-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsCreateRemoveTokenForRepoParams
			Response = *AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateRemoveTokenForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsCreateRemoveTokenForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsCreateRemoveTokenForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateRemoveTokenForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsCreateSelfHostedRunnerGroupForOrgRequest handles actions/create-self-hosted-runner-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub
// Enterprise Server. For more information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Creates a new self-hosted runner group for an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// POST /orgs/{org}/actions/runner-groups
func (s *Server) handleActionsCreateSelfHostedRunnerGroupForOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/create-self-hosted-runner-group-for-org"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsCreateSelfHostedRunnerGroupForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsCreateSelfHostedRunnerGroupForOrgOperation,
			ID:   "actions/create-self-hosted-runner-group-for-org",
		}
	)
	params, err := decodeActionsCreateSelfHostedRunnerGroupForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActionsCreateSelfHostedRunnerGroupForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *RunnerGroupsOrg
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsCreateSelfHostedRunnerGroupForOrgOperation,
			OperationSummary: "Create a self-hosted runner group for an organization",
			OperationID:      "actions/create-self-hosted-runner-group-for-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsCreateSelfHostedRunnerGroupForOrgReq
			Params   = ActionsCreateSelfHostedRunnerGroupForOrgParams
			Response = *RunnerGroupsOrg
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsCreateSelfHostedRunnerGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsCreateSelfHostedRunnerGroupForOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsCreateSelfHostedRunnerGroupForOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsCreateSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsDeleteArtifactRequest handles actions/delete-artifact operation.
//
// Deletes an artifact for a workflow run. You must authenticate using an access token with the
// `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use
// this endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
func (s *Server) handleActionsDeleteArtifactRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-artifact"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/artifacts/{artifact_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsDeleteArtifactOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsDeleteArtifactOperation,
			ID:   "actions/delete-artifact",
		}
	)
	params, err := decodeActionsDeleteArtifactParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsDeleteArtifactNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsDeleteArtifactOperation,
			OperationSummary: "Delete an artifact",
			OperationID:      "actions/delete-artifact",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "artifact_id",
					In:   "path",
				}: params.ArtifactID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteArtifactParams
			Response = *ActionsDeleteArtifactNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteArtifactParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteArtifact(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteArtifact(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteArtifactResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsDeleteEnvironmentSecretRequest handles actions/delete-environment-secret operation.
//
// Deletes a secret in an environment using the secret name. You must authenticate using an access
// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
// permission to use this endpoint.
//
// DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (s *Server) handleActionsDeleteEnvironmentSecretRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-environment-secret"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsDeleteEnvironmentSecretOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsDeleteEnvironmentSecretOperation,
			ID:   "actions/delete-environment-secret",
		}
	)
	params, err := decodeActionsDeleteEnvironmentSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsDeleteEnvironmentSecretNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsDeleteEnvironmentSecretOperation,
			OperationSummary: "Delete an environment secret",
			OperationID:      "actions/delete-environment-secret",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
				{
					Name: "environment_name",
					In:   "path",
				}: params.EnvironmentName,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteEnvironmentSecretParams
			Response = *ActionsDeleteEnvironmentSecretNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteEnvironmentSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteEnvironmentSecret(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteEnvironmentSecret(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteEnvironmentSecretResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsDeleteOrgSecretRequest handles actions/delete-org-secret operation.
//
// Deletes a secret in an organization using the secret name. You must authenticate using an access
// token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets`
// organization permission to use this endpoint.
//
// DELETE /orgs/{org}/actions/secrets/{secret_name}
func (s *Server) handleActionsDeleteOrgSecretRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-org-secret"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets/{secret_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsDeleteOrgSecretOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsDeleteOrgSecretOperation,
			ID:   "actions/delete-org-secret",
		}
	)
	params, err := decodeActionsDeleteOrgSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsDeleteOrgSecretNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsDeleteOrgSecretOperation,
			OperationSummary: "Delete an organization secret",
			OperationID:      "actions/delete-org-secret",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteOrgSecretParams
			Response = *ActionsDeleteOrgSecretNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteOrgSecret(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteOrgSecret(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteOrgSecretResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsDeleteRepoSecretRequest handles actions/delete-repo-secret operation.
//
// Deletes a secret in a repository using the secret name. You must authenticate using an access
// token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository
// permission to use this endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (s *Server) handleActionsDeleteRepoSecretRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-repo-secret"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/secrets/{secret_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsDeleteRepoSecretOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsDeleteRepoSecretOperation,
			ID:   "actions/delete-repo-secret",
		}
	)
	params, err := decodeActionsDeleteRepoSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsDeleteRepoSecretNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsDeleteRepoSecretOperation,
			OperationSummary: "Delete a repository secret",
			OperationID:      "actions/delete-repo-secret",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteRepoSecretParams
			Response = *ActionsDeleteRepoSecretNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteRepoSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteRepoSecret(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteRepoSecret(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteRepoSecretResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsDeleteSelfHostedRunnerFromOrgRequest handles actions/delete-self-hosted-runner-from-org operation.
//
// Forces the removal of a self-hosted runner from an organization. You can use this endpoint to
// completely remove the runner when the machine you were using no longer exists.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// DELETE /orgs/{org}/actions/runners/{runner_id}
func (s *Server) handleActionsDeleteSelfHostedRunnerFromOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-from-org"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runners/{runner_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsDeleteSelfHostedRunnerFromOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsDeleteSelfHostedRunnerFromOrgOperation,
			ID:   "actions/delete-self-hosted-runner-from-org",
		}
	)
	params, err := decodeActionsDeleteSelfHostedRunnerFromOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsDeleteSelfHostedRunnerFromOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsDeleteSelfHostedRunnerFromOrgOperation,
			OperationSummary: "Delete a self-hosted runner from an organization",
			OperationID:      "actions/delete-self-hosted-runner-from-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteSelfHostedRunnerFromOrgParams
			Response = *ActionsDeleteSelfHostedRunnerFromOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteSelfHostedRunnerFromOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteSelfHostedRunnerFromOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteSelfHostedRunnerFromOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteSelfHostedRunnerFromOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsDeleteSelfHostedRunnerFromRepoRequest handles actions/delete-self-hosted-runner-from-repo operation.
//
// Forces the removal of a self-hosted runner from a repository. You can use this endpoint to
// completely remove the runner when the machine you were using no longer exists.
// You must authenticate using an access token with the `repo`
// scope to use this endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}
func (s *Server) handleActionsDeleteSelfHostedRunnerFromRepoRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-from-repo"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runners/{runner_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsDeleteSelfHostedRunnerFromRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsDeleteSelfHostedRunnerFromRepoOperation,
			ID:   "actions/delete-self-hosted-runner-from-repo",
		}
	)
	params, err := decodeActionsDeleteSelfHostedRunnerFromRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsDeleteSelfHostedRunnerFromRepoNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsDeleteSelfHostedRunnerFromRepoOperation,
			OperationSummary: "Delete a self-hosted runner from a repository",
			OperationID:      "actions/delete-self-hosted-runner-from-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteSelfHostedRunnerFromRepoParams
			Response = *ActionsDeleteSelfHostedRunnerFromRepoNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteSelfHostedRunnerFromRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteSelfHostedRunnerFromRepo(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteSelfHostedRunnerFromRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteSelfHostedRunnerFromRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsDeleteSelfHostedRunnerGroupFromOrgRequest handles actions/delete-self-hosted-runner-group-from-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Deletes a self-hosted runner group for an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}
func (s *Server) handleActionsDeleteSelfHostedRunnerGroupFromOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-self-hosted-runner-group-from-org"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsDeleteSelfHostedRunnerGroupFromOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsDeleteSelfHostedRunnerGroupFromOrgOperation,
			ID:   "actions/delete-self-hosted-runner-group-from-org",
		}
	)
	params, err := decodeActionsDeleteSelfHostedRunnerGroupFromOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsDeleteSelfHostedRunnerGroupFromOrgOperation,
			OperationSummary: "Delete a self-hosted runner group from an organization",
			OperationID:      "actions/delete-self-hosted-runner-group-from-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteSelfHostedRunnerGroupFromOrgParams
			Response = *ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteSelfHostedRunnerGroupFromOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteSelfHostedRunnerGroupFromOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteSelfHostedRunnerGroupFromOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteSelfHostedRunnerGroupFromOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsDeleteWorkflowRunRequest handles actions/delete-workflow-run operation.
//
// Delete a specific workflow run. Anyone with write access to the repository can use this endpoint.
// If the repository is
// private you must use an access token with the `repo` scope. GitHub Apps must have the
// `actions:write` permission to use
// this endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/runs/{run_id}
func (s *Server) handleActionsDeleteWorkflowRunRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-workflow-run"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsDeleteWorkflowRunOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsDeleteWorkflowRunOperation,
			ID:   "actions/delete-workflow-run",
		}
	)
	params, err := decodeActionsDeleteWorkflowRunParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsDeleteWorkflowRunNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsDeleteWorkflowRunOperation,
			OperationSummary: "Delete a workflow run",
			OperationID:      "actions/delete-workflow-run",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteWorkflowRunParams
			Response = *ActionsDeleteWorkflowRunNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteWorkflowRun(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteWorkflowRun(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteWorkflowRunResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsDeleteWorkflowRunLogsRequest handles actions/delete-workflow-run-logs operation.
//
// Deletes all logs for a workflow run. You must authenticate using an access token with the `repo`
// scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this
// endpoint.
//
// DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs
func (s *Server) handleActionsDeleteWorkflowRunLogsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/delete-workflow-run-logs"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/logs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsDeleteWorkflowRunLogsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsDeleteWorkflowRunLogsOperation,
			ID:   "actions/delete-workflow-run-logs",
		}
	)
	params, err := decodeActionsDeleteWorkflowRunLogsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsDeleteWorkflowRunLogsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsDeleteWorkflowRunLogsOperation,
			OperationSummary: "Delete workflow run logs",
			OperationID:      "actions/delete-workflow-run-logs",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDeleteWorkflowRunLogsParams
			Response = *ActionsDeleteWorkflowRunLogsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDeleteWorkflowRunLogsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDeleteWorkflowRunLogs(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDeleteWorkflowRunLogs(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDeleteWorkflowRunLogsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsDisableSelectedRepositoryGithubActionsOrganizationRequest handles actions/disable-selected-repository-github-actions-organization operation.
//
// Removes a repository from the list of selected repositories that are enabled for GitHub Actions in
// an organization. To use this endpoint, the organization permission policy for
// `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub
// Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}
func (s *Server) handleActionsDisableSelectedRepositoryGithubActionsOrganizationRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/disable-selected-repository-github-actions-organization"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/permissions/repositories/{repository_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsDisableSelectedRepositoryGithubActionsOrganizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsDisableSelectedRepositoryGithubActionsOrganizationOperation,
			ID:   "actions/disable-selected-repository-github-actions-organization",
		}
	)
	params, err := decodeActionsDisableSelectedRepositoryGithubActionsOrganizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsDisableSelectedRepositoryGithubActionsOrganizationOperation,
			OperationSummary: "Disable a selected repository for GitHub Actions in an organization",
			OperationID:      "actions/disable-selected-repository-github-actions-organization",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDisableSelectedRepositoryGithubActionsOrganizationParams
			Response = *ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDisableSelectedRepositoryGithubActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsDisableSelectedRepositoryGithubActionsOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsDisableSelectedRepositoryGithubActionsOrganization(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDisableSelectedRepositoryGithubActionsOrganizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsDownloadArtifactRequest handles actions/download-artifact operation.
//
// Gets a redirect URL to download an archive for a repository. This URL expires after 1 minute. Look
// for `Location:` in
// the response header to find the URL for the download. The `:archive_format` must be `zip`. Anyone
// with read access to
// the repository can use this endpoint. If the repository is private you must use an access token
// with the `repo` scope.
// GitHub Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}
func (s *Server) handleActionsDownloadArtifactRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-artifact"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsDownloadArtifactOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsDownloadArtifactOperation,
			ID:   "actions/download-artifact",
		}
	)
	params, err := decodeActionsDownloadArtifactParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsDownloadArtifactFound
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsDownloadArtifactOperation,
			OperationSummary: "Download an artifact",
			OperationID:      "actions/download-artifact",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "artifact_id",
					In:   "path",
				}: params.ArtifactID,
				{
					Name: "archive_format",
					In:   "path",
				}: params.ArchiveFormat,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDownloadArtifactParams
			Response = *ActionsDownloadArtifactFound
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDownloadArtifactParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsDownloadArtifact(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsDownloadArtifact(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDownloadArtifactResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsDownloadJobLogsForWorkflowRunRequest handles actions/download-job-logs-for-workflow-run operation.
//
// Gets a redirect URL to download a plain text file of logs for a workflow job. This link expires
// after 1 minute. Look
// for `Location:` in the response header to find the URL for the download. Anyone with read access
// to the repository can
// use this endpoint. If the repository is private you must use an access token with the `repo` scope.
//
//	GitHub Apps must
//
// have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs
func (s *Server) handleActionsDownloadJobLogsForWorkflowRunRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-job-logs-for-workflow-run"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/jobs/{job_id}/logs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsDownloadJobLogsForWorkflowRunOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsDownloadJobLogsForWorkflowRunOperation,
			ID:   "actions/download-job-logs-for-workflow-run",
		}
	)
	params, err := decodeActionsDownloadJobLogsForWorkflowRunParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsDownloadJobLogsForWorkflowRunFound
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsDownloadJobLogsForWorkflowRunOperation,
			OperationSummary: "Download job logs for a workflow run",
			OperationID:      "actions/download-job-logs-for-workflow-run",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "job_id",
					In:   "path",
				}: params.JobID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDownloadJobLogsForWorkflowRunParams
			Response = *ActionsDownloadJobLogsForWorkflowRunFound
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDownloadJobLogsForWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsDownloadJobLogsForWorkflowRun(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsDownloadJobLogsForWorkflowRun(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDownloadJobLogsForWorkflowRunResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsDownloadWorkflowRunLogsRequest handles actions/download-workflow-run-logs operation.
//
// Gets a redirect URL to download an archive of log files for a workflow run. This link expires
// after 1 minute. Look for
// `Location:` in the response header to find the URL for the download. Anyone with read access to
// the repository can use
// this endpoint. If the repository is private you must use an access token with the `repo` scope.
// GitHub Apps must have
// the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs
func (s *Server) handleActionsDownloadWorkflowRunLogsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/download-workflow-run-logs"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/logs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsDownloadWorkflowRunLogsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsDownloadWorkflowRunLogsOperation,
			ID:   "actions/download-workflow-run-logs",
		}
	)
	params, err := decodeActionsDownloadWorkflowRunLogsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsDownloadWorkflowRunLogsFound
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsDownloadWorkflowRunLogsOperation,
			OperationSummary: "Download workflow run logs",
			OperationID:      "actions/download-workflow-run-logs",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsDownloadWorkflowRunLogsParams
			Response = *ActionsDownloadWorkflowRunLogsFound
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsDownloadWorkflowRunLogsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsDownloadWorkflowRunLogs(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsDownloadWorkflowRunLogs(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsDownloadWorkflowRunLogsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsEnableSelectedRepositoryGithubActionsOrganizationRequest handles actions/enable-selected-repository-github-actions-organization operation.
//
// Adds a repository to the list of selected repositories that are enabled for GitHub Actions in an
// organization. To use this endpoint, the organization permission policy for `enabled_repositories`
// must be must be configured to `selected`. For more information, see "[Set GitHub Actions
// permissions for an organization](#set-github-actions-permissions-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// PUT /orgs/{org}/actions/permissions/repositories/{repository_id}
func (s *Server) handleActionsEnableSelectedRepositoryGithubActionsOrganizationRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/enable-selected-repository-github-actions-organization"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/permissions/repositories/{repository_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsEnableSelectedRepositoryGithubActionsOrganizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsEnableSelectedRepositoryGithubActionsOrganizationOperation,
			ID:   "actions/enable-selected-repository-github-actions-organization",
		}
	)
	params, err := decodeActionsEnableSelectedRepositoryGithubActionsOrganizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsEnableSelectedRepositoryGithubActionsOrganizationOperation,
			OperationSummary: "Enable a selected repository for GitHub Actions in an organization",
			OperationID:      "actions/enable-selected-repository-github-actions-organization",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsEnableSelectedRepositoryGithubActionsOrganizationParams
			Response = *ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsEnableSelectedRepositoryGithubActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsEnableSelectedRepositoryGithubActionsOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsEnableSelectedRepositoryGithubActionsOrganization(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsEnableSelectedRepositoryGithubActionsOrganizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetAllowedActionsOrganizationRequest handles actions/get-allowed-actions-organization operation.
//
// Gets the selected actions that are allowed in an organization. To use this endpoint, the
// organization permission policy for `allowed_actions` must be configured to `selected`. For more
// information, see "[Set GitHub Actions permissions for an
// organization](#set-github-actions-permissions-for-an-organization).""
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// GET /orgs/{org}/actions/permissions/selected-actions
func (s *Server) handleActionsGetAllowedActionsOrganizationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-allowed-actions-organization"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/permissions/selected-actions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetAllowedActionsOrganizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetAllowedActionsOrganizationOperation,
			ID:   "actions/get-allowed-actions-organization",
		}
	)
	params, err := decodeActionsGetAllowedActionsOrganizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *SelectedActions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetAllowedActionsOrganizationOperation,
			OperationSummary: "Get allowed actions for an organization",
			OperationID:      "actions/get-allowed-actions-organization",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetAllowedActionsOrganizationParams
			Response = *SelectedActions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetAllowedActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetAllowedActionsOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetAllowedActionsOrganization(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetAllowedActionsOrganizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetAllowedActionsRepositoryRequest handles actions/get-allowed-actions-repository operation.
//
// Gets the settings for selected actions that are allowed in a repository. To use this endpoint, the
// repository policy for `allowed_actions` must be configured to `selected`. For more information,
// see "[Set GitHub Actions permissions for a
// repository](#set-github-actions-permissions-for-a-repository)."
// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
// Apps must have the `administration` repository permission to use this API.
//
// GET /repos/{owner}/{repo}/actions/permissions/selected-actions
func (s *Server) handleActionsGetAllowedActionsRepositoryRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-allowed-actions-repository"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/permissions/selected-actions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetAllowedActionsRepositoryOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetAllowedActionsRepositoryOperation,
			ID:   "actions/get-allowed-actions-repository",
		}
	)
	params, err := decodeActionsGetAllowedActionsRepositoryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *SelectedActions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetAllowedActionsRepositoryOperation,
			OperationSummary: "Get allowed actions for a repository",
			OperationID:      "actions/get-allowed-actions-repository",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetAllowedActionsRepositoryParams
			Response = *SelectedActions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetAllowedActionsRepositoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetAllowedActionsRepository(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetAllowedActionsRepository(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetAllowedActionsRepositoryResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetArtifactRequest handles actions/get-artifact operation.
//
// Gets a specific artifact for a workflow run. Anyone with read access to the repository can use
// this endpoint. If the repository is private you must use an access token with the `repo` scope.
// GitHub Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}
func (s *Server) handleActionsGetArtifactRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-artifact"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/artifacts/{artifact_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetArtifactOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetArtifactOperation,
			ID:   "actions/get-artifact",
		}
	)
	params, err := decodeActionsGetArtifactParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *Artifact
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetArtifactOperation,
			OperationSummary: "Get an artifact",
			OperationID:      "actions/get-artifact",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "artifact_id",
					In:   "path",
				}: params.ArtifactID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetArtifactParams
			Response = *Artifact
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetArtifactParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetArtifact(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetArtifact(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetArtifactResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetEnvironmentPublicKeyRequest handles actions/get-environment-public-key operation.
//
// Get the public key for an environment, which you need to encrypt environment secrets. You need to
// encrypt a secret before you can create or update secrets. Anyone with read access to the
// repository can use this endpoint. If the repository is private you must use an access token with
// the `repo` scope. GitHub Apps must have the `secrets` repository permission to use this endpoint.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key
func (s *Server) handleActionsGetEnvironmentPublicKeyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-environment-public-key"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repositories/{repository_id}/environments/{environment_name}/secrets/public-key"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetEnvironmentPublicKeyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetEnvironmentPublicKeyOperation,
			ID:   "actions/get-environment-public-key",
		}
	)
	params, err := decodeActionsGetEnvironmentPublicKeyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsPublicKey
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetEnvironmentPublicKeyOperation,
			OperationSummary: "Get an environment public key",
			OperationID:      "actions/get-environment-public-key",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
				{
					Name: "environment_name",
					In:   "path",
				}: params.EnvironmentName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetEnvironmentPublicKeyParams
			Response = *ActionsPublicKey
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetEnvironmentPublicKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetEnvironmentPublicKey(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetEnvironmentPublicKey(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetEnvironmentPublicKeyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetEnvironmentSecretRequest handles actions/get-environment-secret operation.
//
// Gets a single environment secret without revealing its encrypted value. You must authenticate
// using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
// `secrets` repository permission to use this endpoint.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}
func (s *Server) handleActionsGetEnvironmentSecretRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-environment-secret"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetEnvironmentSecretOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetEnvironmentSecretOperation,
			ID:   "actions/get-environment-secret",
		}
	)
	params, err := decodeActionsGetEnvironmentSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsSecret
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetEnvironmentSecretOperation,
			OperationSummary: "Get an environment secret",
			OperationID:      "actions/get-environment-secret",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
				{
					Name: "environment_name",
					In:   "path",
				}: params.EnvironmentName,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetEnvironmentSecretParams
			Response = *ActionsSecret
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetEnvironmentSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetEnvironmentSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetEnvironmentSecret(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetEnvironmentSecretResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetGithubActionsPermissionsOrganizationRequest handles actions/get-github-actions-permissions-organization operation.
//
// Gets the GitHub Actions permissions policy for repositories and allowed actions in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// GET /orgs/{org}/actions/permissions
func (s *Server) handleActionsGetGithubActionsPermissionsOrganizationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-github-actions-permissions-organization"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/permissions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetGithubActionsPermissionsOrganizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetGithubActionsPermissionsOrganizationOperation,
			ID:   "actions/get-github-actions-permissions-organization",
		}
	)
	params, err := decodeActionsGetGithubActionsPermissionsOrganizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsOrganizationPermissions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetGithubActionsPermissionsOrganizationOperation,
			OperationSummary: "Get GitHub Actions permissions for an organization",
			OperationID:      "actions/get-github-actions-permissions-organization",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetGithubActionsPermissionsOrganizationParams
			Response = *ActionsOrganizationPermissions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetGithubActionsPermissionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetGithubActionsPermissionsOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetGithubActionsPermissionsOrganization(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetGithubActionsPermissionsOrganizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetGithubActionsPermissionsRepositoryRequest handles actions/get-github-actions-permissions-repository operation.
//
// Gets the GitHub Actions permissions policy for a repository, including whether GitHub Actions is
// enabled and the actions allowed to run in the repository.
// You must authenticate using an access token with the `repo` scope to use this
// endpoint. GitHub Apps must have the `administration` repository permission to use this API.
//
// GET /repos/{owner}/{repo}/actions/permissions
func (s *Server) handleActionsGetGithubActionsPermissionsRepositoryRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-github-actions-permissions-repository"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/permissions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetGithubActionsPermissionsRepositoryOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetGithubActionsPermissionsRepositoryOperation,
			ID:   "actions/get-github-actions-permissions-repository",
		}
	)
	params, err := decodeActionsGetGithubActionsPermissionsRepositoryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsRepositoryPermissions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetGithubActionsPermissionsRepositoryOperation,
			OperationSummary: "Get GitHub Actions permissions for a repository",
			OperationID:      "actions/get-github-actions-permissions-repository",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetGithubActionsPermissionsRepositoryParams
			Response = *ActionsRepositoryPermissions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetGithubActionsPermissionsRepositoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetGithubActionsPermissionsRepository(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetGithubActionsPermissionsRepository(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetGithubActionsPermissionsRepositoryResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetJobForWorkflowRunRequest handles actions/get-job-for-workflow-run operation.
//
// Gets a specific job in a workflow run. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
// Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/jobs/{job_id}
func (s *Server) handleActionsGetJobForWorkflowRunRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-job-for-workflow-run"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/jobs/{job_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetJobForWorkflowRunOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetJobForWorkflowRunOperation,
			ID:   "actions/get-job-for-workflow-run",
		}
	)
	params, err := decodeActionsGetJobForWorkflowRunParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *Job
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetJobForWorkflowRunOperation,
			OperationSummary: "Get a job for a workflow run",
			OperationID:      "actions/get-job-for-workflow-run",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "job_id",
					In:   "path",
				}: params.JobID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetJobForWorkflowRunParams
			Response = *Job
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetJobForWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetJobForWorkflowRun(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetJobForWorkflowRun(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetJobForWorkflowRunResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetOrgPublicKeyRequest handles actions/get-org-public-key operation.
//
// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you
// can create or update secrets. You must authenticate using an access token with the `admin:org`
// scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use
// this endpoint.
//
// GET /orgs/{org}/actions/secrets/public-key
func (s *Server) handleActionsGetOrgPublicKeyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-org-public-key"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets/public-key"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetOrgPublicKeyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetOrgPublicKeyOperation,
			ID:   "actions/get-org-public-key",
		}
	)
	params, err := decodeActionsGetOrgPublicKeyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsPublicKey
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetOrgPublicKeyOperation,
			OperationSummary: "Get an organization public key",
			OperationID:      "actions/get-org-public-key",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetOrgPublicKeyParams
			Response = *ActionsPublicKey
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetOrgPublicKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetOrgPublicKey(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetOrgPublicKey(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetOrgPublicKeyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetOrgSecretRequest handles actions/get-org-secret operation.
//
// Gets a single organization secret without revealing its encrypted value. You must authenticate
// using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the
// `secrets` organization permission to use this endpoint.
//
// GET /orgs/{org}/actions/secrets/{secret_name}
func (s *Server) handleActionsGetOrgSecretRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-org-secret"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets/{secret_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetOrgSecretOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetOrgSecretOperation,
			ID:   "actions/get-org-secret",
		}
	)
	params, err := decodeActionsGetOrgSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *OrganizationActionsSecret
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetOrgSecretOperation,
			OperationSummary: "Get an organization secret",
			OperationID:      "actions/get-org-secret",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetOrgSecretParams
			Response = *OrganizationActionsSecret
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetOrgSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetOrgSecret(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetOrgSecretResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetRepoPublicKeyRequest handles actions/get-repo-public-key operation.
//
// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you
// can create or update secrets. Anyone with read access to the repository can use this endpoint. If
// the repository is private you must use an access token with the `repo` scope. GitHub Apps must
// have the `secrets` repository permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/secrets/public-key
func (s *Server) handleActionsGetRepoPublicKeyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-repo-public-key"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/secrets/public-key"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetRepoPublicKeyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetRepoPublicKeyOperation,
			ID:   "actions/get-repo-public-key",
		}
	)
	params, err := decodeActionsGetRepoPublicKeyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsPublicKey
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetRepoPublicKeyOperation,
			OperationSummary: "Get a repository public key",
			OperationID:      "actions/get-repo-public-key",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetRepoPublicKeyParams
			Response = *ActionsPublicKey
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetRepoPublicKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetRepoPublicKey(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetRepoPublicKey(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetRepoPublicKeyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetRepoSecretRequest handles actions/get-repo-secret operation.
//
// Gets a single repository secret without revealing its encrypted value. You must authenticate using
// an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets`
// repository permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/secrets/{secret_name}
func (s *Server) handleActionsGetRepoSecretRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-repo-secret"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/secrets/{secret_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetRepoSecretOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetRepoSecretOperation,
			ID:   "actions/get-repo-secret",
		}
	)
	params, err := decodeActionsGetRepoSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsSecret
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetRepoSecretOperation,
			OperationSummary: "Get a repository secret",
			OperationID:      "actions/get-repo-secret",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetRepoSecretParams
			Response = *ActionsSecret
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetRepoSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetRepoSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetRepoSecret(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetRepoSecretResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetReviewsForRunRequest handles actions/get-reviews-for-run operation.
//
// Anyone with read access to the repository can use this endpoint. If the repository is private, you
// must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
// permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals
func (s *Server) handleActionsGetReviewsForRunRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-reviews-for-run"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/approvals"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetReviewsForRunOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetReviewsForRunOperation,
			ID:   "actions/get-reviews-for-run",
		}
	)
	params, err := decodeActionsGetReviewsForRunParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []EnvironmentApprovals
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetReviewsForRunOperation,
			OperationSummary: "Get the review history for a workflow run",
			OperationID:      "actions/get-reviews-for-run",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetReviewsForRunParams
			Response = []EnvironmentApprovals
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetReviewsForRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetReviewsForRun(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetReviewsForRun(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetReviewsForRunResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetSelfHostedRunnerForOrgRequest handles actions/get-self-hosted-runner-for-org operation.
//
// Gets a specific self-hosted runner configured in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runners/{runner_id}
func (s *Server) handleActionsGetSelfHostedRunnerForOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-for-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runners/{runner_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetSelfHostedRunnerForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetSelfHostedRunnerForOrgOperation,
			ID:   "actions/get-self-hosted-runner-for-org",
		}
	)
	params, err := decodeActionsGetSelfHostedRunnerForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *Runner
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetSelfHostedRunnerForOrgOperation,
			OperationSummary: "Get a self-hosted runner for an organization",
			OperationID:      "actions/get-self-hosted-runner-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetSelfHostedRunnerForOrgParams
			Response = *Runner
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetSelfHostedRunnerForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetSelfHostedRunnerForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetSelfHostedRunnerForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetSelfHostedRunnerForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetSelfHostedRunnerForRepoRequest handles actions/get-self-hosted-runner-for-repo operation.
//
// Gets a specific self-hosted runner configured in a repository.
// You must authenticate using an access token with the `repo` scope to use this
// endpoint.
//
// GET /repos/{owner}/{repo}/actions/runners/{runner_id}
func (s *Server) handleActionsGetSelfHostedRunnerForRepoRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runners/{runner_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetSelfHostedRunnerForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetSelfHostedRunnerForRepoOperation,
			ID:   "actions/get-self-hosted-runner-for-repo",
		}
	)
	params, err := decodeActionsGetSelfHostedRunnerForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *Runner
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetSelfHostedRunnerForRepoOperation,
			OperationSummary: "Get a self-hosted runner for a repository",
			OperationID:      "actions/get-self-hosted-runner-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetSelfHostedRunnerForRepoParams
			Response = *Runner
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetSelfHostedRunnerForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetSelfHostedRunnerForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetSelfHostedRunnerForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetSelfHostedRunnerForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetSelfHostedRunnerGroupForOrgRequest handles actions/get-self-hosted-runner-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Gets a specific self-hosted runner group for an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}
func (s *Server) handleActionsGetSelfHostedRunnerGroupForOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-self-hosted-runner-group-for-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetSelfHostedRunnerGroupForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetSelfHostedRunnerGroupForOrgOperation,
			ID:   "actions/get-self-hosted-runner-group-for-org",
		}
	)
	params, err := decodeActionsGetSelfHostedRunnerGroupForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *RunnerGroupsOrg
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetSelfHostedRunnerGroupForOrgOperation,
			OperationSummary: "Get a self-hosted runner group for an organization",
			OperationID:      "actions/get-self-hosted-runner-group-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetSelfHostedRunnerGroupForOrgParams
			Response = *RunnerGroupsOrg
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetSelfHostedRunnerGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetSelfHostedRunnerGroupForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetSelfHostedRunnerGroupForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetWorkflowRunRequest handles actions/get-workflow-run operation.
//
// Gets a specific workflow run. Anyone with read access to the repository can use this endpoint. If
// the repository is private you must use an access token with the `repo` scope. GitHub Apps must
// have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}
func (s *Server) handleActionsGetWorkflowRunRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-workflow-run"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetWorkflowRunOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetWorkflowRunOperation,
			ID:   "actions/get-workflow-run",
		}
	)
	params, err := decodeActionsGetWorkflowRunParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WorkflowRun
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetWorkflowRunOperation,
			OperationSummary: "Get a workflow run",
			OperationID:      "actions/get-workflow-run",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetWorkflowRunParams
			Response = *WorkflowRun
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetWorkflowRun(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetWorkflowRun(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetWorkflowRunResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsGetWorkflowRunUsageRequest handles actions/get-workflow-run-usage operation.
//
// Gets the number of billable minutes and total run time for a specific workflow run. Billable
// minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is
// listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also
// included in the usage. The usage does not include the multiplier for macOS and Windows runners and
// is not rounded up to the nearest whole minute. For more information, see "[Managing billing for
// GitHub Actions](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
// Anyone with read access to the repository can use this endpoint. If the repository is private you
// must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
// permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing
func (s *Server) handleActionsGetWorkflowRunUsageRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/get-workflow-run-usage"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/timing"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsGetWorkflowRunUsageOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsGetWorkflowRunUsageOperation,
			ID:   "actions/get-workflow-run-usage",
		}
	)
	params, err := decodeActionsGetWorkflowRunUsageParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WorkflowRunUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsGetWorkflowRunUsageOperation,
			OperationSummary: "Get workflow run usage",
			OperationID:      "actions/get-workflow-run-usage",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsGetWorkflowRunUsageParams
			Response = *WorkflowRunUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsGetWorkflowRunUsageParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsGetWorkflowRunUsage(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsGetWorkflowRunUsage(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsGetWorkflowRunUsageResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListArtifactsForRepoRequest handles actions/list-artifacts-for-repo operation.
//
// Lists all artifacts for a repository. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
// Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/artifacts
func (s *Server) handleActionsListArtifactsForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-artifacts-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/artifacts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListArtifactsForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListArtifactsForRepoOperation,
			ID:   "actions/list-artifacts-for-repo",
		}
	)
	params, err := decodeActionsListArtifactsForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsListArtifactsForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListArtifactsForRepoOperation,
			OperationSummary: "List artifacts for a repository",
			OperationID:      "actions/list-artifacts-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListArtifactsForRepoParams
			Response = *ActionsListArtifactsForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListArtifactsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListArtifactsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListArtifactsForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListArtifactsForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListEnvironmentSecretsRequest handles actions/list-environment-secrets operation.
//
// Lists all secrets available in an environment without revealing their encrypted values. You must
// authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must
// have the `secrets` repository permission to use this endpoint.
//
// GET /repositories/{repository_id}/environments/{environment_name}/secrets
func (s *Server) handleActionsListEnvironmentSecretsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-environment-secrets"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repositories/{repository_id}/environments/{environment_name}/secrets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListEnvironmentSecretsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListEnvironmentSecretsOperation,
			ID:   "actions/list-environment-secrets",
		}
	)
	params, err := decodeActionsListEnvironmentSecretsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsListEnvironmentSecretsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListEnvironmentSecretsOperation,
			OperationSummary: "List environment secrets",
			OperationID:      "actions/list-environment-secrets",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
				{
					Name: "environment_name",
					In:   "path",
				}: params.EnvironmentName,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListEnvironmentSecretsParams
			Response = *ActionsListEnvironmentSecretsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListEnvironmentSecretsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListEnvironmentSecrets(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListEnvironmentSecrets(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListEnvironmentSecretsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListJobsForWorkflowRunRequest handles actions/list-jobs-for-workflow-run operation.
//
// Lists jobs for a workflow run. Anyone with read access to the repository can use this endpoint. If
// the repository is private you must use an access token with the `repo` scope. GitHub Apps must
// have the `actions:read` permission to use this endpoint. You can use parameters to narrow the list
// of results. For more information about using parameters, see [Parameters](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#parameters).
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs
func (s *Server) handleActionsListJobsForWorkflowRunRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-jobs-for-workflow-run"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/jobs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListJobsForWorkflowRunOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListJobsForWorkflowRunOperation,
			ID:   "actions/list-jobs-for-workflow-run",
		}
	)
	params, err := decodeActionsListJobsForWorkflowRunParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsListJobsForWorkflowRunOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListJobsForWorkflowRunOperation,
			OperationSummary: "List jobs for a workflow run",
			OperationID:      "actions/list-jobs-for-workflow-run",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListJobsForWorkflowRunParams
			Response = *ActionsListJobsForWorkflowRunOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListJobsForWorkflowRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListJobsForWorkflowRun(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListJobsForWorkflowRun(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListJobsForWorkflowRunResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListOrgSecretsRequest handles actions/list-org-secrets operation.
//
// Lists all secrets available in an organization without revealing their encrypted values. You must
// authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps
// must have the `secrets` organization permission to use this endpoint.
//
// GET /orgs/{org}/actions/secrets
func (s *Server) handleActionsListOrgSecretsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-org-secrets"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListOrgSecretsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListOrgSecretsOperation,
			ID:   "actions/list-org-secrets",
		}
	)
	params, err := decodeActionsListOrgSecretsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsListOrgSecretsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListOrgSecretsOperation,
			OperationSummary: "List organization secrets",
			OperationID:      "actions/list-org-secrets",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListOrgSecretsParams
			Response = *ActionsListOrgSecretsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListOrgSecretsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListOrgSecrets(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListOrgSecrets(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListOrgSecretsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/list-repo-access-to-self-hosted-runner-group-in-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub
// Enterprise Server. For more information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Lists the repositories with access to a self-hosted runner group configured in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
func (s *Server) handleActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-access-to-self-hosted-runner-group-in-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOperation,
			ID:   "actions/list-repo-access-to-self-hosted-runner-group-in-org",
		}
	)
	params, err := decodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOperation,
			OperationSummary: "List repository access to a self-hosted runner group in an organization",
			OperationID:      "actions/list-repo-access-to-self-hosted-runner-group-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams
			Response = *ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListRepoSecretsRequest handles actions/list-repo-secrets operation.
//
// Lists all secrets available in a repository without revealing their encrypted values. You must
// authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must
// have the `secrets` repository permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/secrets
func (s *Server) handleActionsListRepoSecretsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-secrets"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/secrets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListRepoSecretsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListRepoSecretsOperation,
			ID:   "actions/list-repo-secrets",
		}
	)
	params, err := decodeActionsListRepoSecretsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsListRepoSecretsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListRepoSecretsOperation,
			OperationSummary: "List repository secrets",
			OperationID:      "actions/list-repo-secrets",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListRepoSecretsParams
			Response = *ActionsListRepoSecretsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListRepoSecretsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListRepoSecrets(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListRepoSecrets(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListRepoSecretsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListRepoWorkflowsRequest handles actions/list-repo-workflows operation.
//
// Lists the workflows in a repository. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
// Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/workflows
func (s *Server) handleActionsListRepoWorkflowsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-repo-workflows"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/workflows"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListRepoWorkflowsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListRepoWorkflowsOperation,
			ID:   "actions/list-repo-workflows",
		}
	)
	params, err := decodeActionsListRepoWorkflowsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsListRepoWorkflowsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListRepoWorkflowsOperation,
			OperationSummary: "List repository workflows",
			OperationID:      "actions/list-repo-workflows",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListRepoWorkflowsParams
			Response = *ActionsListRepoWorkflowsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListRepoWorkflowsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListRepoWorkflows(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListRepoWorkflows(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListRepoWorkflowsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListRunnerApplicationsForOrgRequest handles actions/list-runner-applications-for-org operation.
//
// Lists binaries for the runner application that you can download and run.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runners/downloads
func (s *Server) handleActionsListRunnerApplicationsForOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-runner-applications-for-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runners/downloads"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListRunnerApplicationsForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListRunnerApplicationsForOrgOperation,
			ID:   "actions/list-runner-applications-for-org",
		}
	)
	params, err := decodeActionsListRunnerApplicationsForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []RunnerApplication
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListRunnerApplicationsForOrgOperation,
			OperationSummary: "List runner applications for an organization",
			OperationID:      "actions/list-runner-applications-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListRunnerApplicationsForOrgParams
			Response = []RunnerApplication
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListRunnerApplicationsForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListRunnerApplicationsForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListRunnerApplicationsForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListRunnerApplicationsForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListRunnerApplicationsForRepoRequest handles actions/list-runner-applications-for-repo operation.
//
// Lists binaries for the runner application that you can download and run.
// You must authenticate using an access token with the `repo` scope to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runners/downloads
func (s *Server) handleActionsListRunnerApplicationsForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-runner-applications-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runners/downloads"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListRunnerApplicationsForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListRunnerApplicationsForRepoOperation,
			ID:   "actions/list-runner-applications-for-repo",
		}
	)
	params, err := decodeActionsListRunnerApplicationsForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []RunnerApplication
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListRunnerApplicationsForRepoOperation,
			OperationSummary: "List runner applications for a repository",
			OperationID:      "actions/list-runner-applications-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListRunnerApplicationsForRepoParams
			Response = []RunnerApplication
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListRunnerApplicationsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListRunnerApplicationsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListRunnerApplicationsForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListRunnerApplicationsForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListSelectedReposForOrgSecretRequest handles actions/list-selected-repos-for-org-secret operation.
//
// Lists all repositories that have been selected when the `visibility` for repository access to a
// secret is set to `selected`. You must authenticate using an access token with the `admin:org`
// scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use
// this endpoint.
//
// GET /orgs/{org}/actions/secrets/{secret_name}/repositories
func (s *Server) handleActionsListSelectedReposForOrgSecretRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-selected-repos-for-org-secret"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets/{secret_name}/repositories"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListSelectedReposForOrgSecretOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListSelectedReposForOrgSecretOperation,
			ID:   "actions/list-selected-repos-for-org-secret",
		}
	)
	params, err := decodeActionsListSelectedReposForOrgSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsListSelectedReposForOrgSecretOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListSelectedReposForOrgSecretOperation,
			OperationSummary: "List selected repositories for an organization secret",
			OperationID:      "actions/list-selected-repos-for-org-secret",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelectedReposForOrgSecretParams
			Response = *ActionsListSelectedReposForOrgSecretOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelectedReposForOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListSelectedReposForOrgSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListSelectedReposForOrgSecret(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelectedReposForOrgSecretResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest handles actions/list-selected-repositories-enabled-github-actions-organization operation.
//
// Lists the selected repositories that are enabled for GitHub Actions in an organization. To use
// this endpoint, the organization permission policy for `enabled_repositories` must be configured to
// `selected`. For more information, see "[Set GitHub Actions permissions for an
// organization](#set-github-actions-permissions-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// GET /orgs/{org}/actions/permissions/repositories
func (s *Server) handleActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-selected-repositories-enabled-github-actions-organization"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/permissions/repositories"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOperation,
			ID:   "actions/list-selected-repositories-enabled-github-actions-organization",
		}
	)
	params, err := decodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOperation,
			OperationSummary: "List selected repositories enabled for GitHub Actions in an organization",
			OperationID:      "actions/list-selected-repositories-enabled-github-actions-organization",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams
			Response = *ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListSelfHostedRunnerGroupsForOrgRequest handles actions/list-self-hosted-runner-groups-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Lists all self-hosted runner groups configured in an organization and inherited from an enterprise.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runner-groups
func (s *Server) handleActionsListSelfHostedRunnerGroupsForOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runner-groups-for-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListSelfHostedRunnerGroupsForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListSelfHostedRunnerGroupsForOrgOperation,
			ID:   "actions/list-self-hosted-runner-groups-for-org",
		}
	)
	params, err := decodeActionsListSelfHostedRunnerGroupsForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsListSelfHostedRunnerGroupsForOrgOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListSelfHostedRunnerGroupsForOrgOperation,
			OperationSummary: "List self-hosted runner groups for an organization",
			OperationID:      "actions/list-self-hosted-runner-groups-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelfHostedRunnerGroupsForOrgParams
			Response = *ActionsListSelfHostedRunnerGroupsForOrgOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelfHostedRunnerGroupsForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListSelfHostedRunnerGroupsForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListSelfHostedRunnerGroupsForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnerGroupsForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListSelfHostedRunnersForOrgRequest handles actions/list-self-hosted-runners-for-org operation.
//
// Lists all self-hosted runners configured in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runners
func (s *Server) handleActionsListSelfHostedRunnersForOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-for-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runners"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListSelfHostedRunnersForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListSelfHostedRunnersForOrgOperation,
			ID:   "actions/list-self-hosted-runners-for-org",
		}
	)
	params, err := decodeActionsListSelfHostedRunnersForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsListSelfHostedRunnersForOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListSelfHostedRunnersForOrgOperation,
			OperationSummary: "List self-hosted runners for an organization",
			OperationID:      "actions/list-self-hosted-runners-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelfHostedRunnersForOrgParams
			Response = *ActionsListSelfHostedRunnersForOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelfHostedRunnersForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListSelfHostedRunnersForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListSelfHostedRunnersForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnersForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListSelfHostedRunnersForRepoRequest handles actions/list-self-hosted-runners-for-repo operation.
//
// Lists all self-hosted runners configured in a repository. You must authenticate using an access
// token with the `repo` scope to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runners
func (s *Server) handleActionsListSelfHostedRunnersForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runners"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListSelfHostedRunnersForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListSelfHostedRunnersForRepoOperation,
			ID:   "actions/list-self-hosted-runners-for-repo",
		}
	)
	params, err := decodeActionsListSelfHostedRunnersForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsListSelfHostedRunnersForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListSelfHostedRunnersForRepoOperation,
			OperationSummary: "List self-hosted runners for a repository",
			OperationID:      "actions/list-self-hosted-runners-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelfHostedRunnersForRepoParams
			Response = *ActionsListSelfHostedRunnersForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelfHostedRunnersForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListSelfHostedRunnersForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListSelfHostedRunnersForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnersForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListSelfHostedRunnersInGroupForOrgRequest handles actions/list-self-hosted-runners-in-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Lists self-hosted runners that are in a specific organization group.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) handleActionsListSelfHostedRunnersInGroupForOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-self-hosted-runners-in-group-for-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}/runners"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListSelfHostedRunnersInGroupForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListSelfHostedRunnersInGroupForOrgOperation,
			ID:   "actions/list-self-hosted-runners-in-group-for-org",
		}
	)
	params, err := decodeActionsListSelfHostedRunnersInGroupForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsListSelfHostedRunnersInGroupForOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListSelfHostedRunnersInGroupForOrgOperation,
			OperationSummary: "List self-hosted runners in a group for an organization",
			OperationID:      "actions/list-self-hosted-runners-in-group-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListSelfHostedRunnersInGroupForOrgParams
			Response = *ActionsListSelfHostedRunnersInGroupForOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListSelfHostedRunnersInGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListSelfHostedRunnersInGroupForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListSelfHostedRunnersInGroupForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListSelfHostedRunnersInGroupForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListWorkflowRunArtifactsRequest handles actions/list-workflow-run-artifacts operation.
//
// Lists artifacts for a workflow run. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub
// Apps must have the `actions:read` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts
func (s *Server) handleActionsListWorkflowRunArtifactsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-workflow-run-artifacts"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListWorkflowRunArtifactsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListWorkflowRunArtifactsOperation,
			ID:   "actions/list-workflow-run-artifacts",
		}
	)
	params, err := decodeActionsListWorkflowRunArtifactsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsListWorkflowRunArtifactsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListWorkflowRunArtifactsOperation,
			OperationSummary: "List workflow run artifacts",
			OperationID:      "actions/list-workflow-run-artifacts",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListWorkflowRunArtifactsParams
			Response = *ActionsListWorkflowRunArtifactsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListWorkflowRunArtifactsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListWorkflowRunArtifacts(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListWorkflowRunArtifacts(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListWorkflowRunArtifactsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsListWorkflowRunsForRepoRequest handles actions/list-workflow-runs-for-repo operation.
//
// Lists all workflow runs for a repository. You can use parameters to narrow the list of results.
// For more information about using parameters, see [Parameters](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#parameters).
// Anyone with read access to the repository can use this endpoint. If the repository is private you
// must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
// permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/actions/runs
func (s *Server) handleActionsListWorkflowRunsForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/list-workflow-runs-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsListWorkflowRunsForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsListWorkflowRunsForRepoOperation,
			ID:   "actions/list-workflow-runs-for-repo",
		}
	)
	params, err := decodeActionsListWorkflowRunsForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsListWorkflowRunsForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsListWorkflowRunsForRepoOperation,
			OperationSummary: "List workflow runs for a repository",
			OperationID:      "actions/list-workflow-runs-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "actor",
					In:   "query",
				}: params.Actor,
				{
					Name: "branch",
					In:   "query",
				}: params.Branch,
				{
					Name: "event",
					In:   "query",
				}: params.Event,
				{
					Name: "status",
					In:   "query",
				}: params.Status,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "created",
					In:   "query",
				}: params.Created,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsListWorkflowRunsForRepoParams
			Response = *ActionsListWorkflowRunsForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsListWorkflowRunsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsListWorkflowRunsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsListWorkflowRunsForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsListWorkflowRunsForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsReRunWorkflowRequest handles actions/re-run-workflow operation.
//
// **Deprecation Notice:** This endpoint is deprecated.
// We recommend migrating your existing code to use the new [retry workflow](https://docs.github.
// com/rest/reference/actions#retry-a-workflow) endpoint.
// Re-runs your workflow run using its `id`. You must authenticate using
// an access token with the `repo` scope to use this endpoint. GitHub Apps must have
// the `actions:write` permission to use this endpoint.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun
func (s *Server) handleActionsReRunWorkflowRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/re-run-workflow"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/rerun"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsReRunWorkflowOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsReRunWorkflowOperation,
			ID:   "actions/re-run-workflow",
		}
	)
	params, err := decodeActionsReRunWorkflowParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsReRunWorkflowCreated
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsReRunWorkflowOperation,
			OperationSummary: "Re-run a workflow",
			OperationID:      "actions/re-run-workflow",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsReRunWorkflowParams
			Response = *ActionsReRunWorkflowCreated
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsReRunWorkflowParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsReRunWorkflow(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsReRunWorkflow(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsReRunWorkflowResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/remove-repo-access-to-self-hosted-runner-group-in-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Removes a repository from the list of selected repositories that can access a self-hosted runner
// group. The runner group must have `visibility` set to `selected`. For more information, see
// "[Create a self-hosted runner group for an
// organization](#create-a-self-hosted-runner-group-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}
func (s *Server) handleActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-repo-access-to-self-hosted-runner-group-in-org"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgOperation,
			ID:   "actions/remove-repo-access-to-self-hosted-runner-group-in-org",
		}
	)
	params, err := decodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgOperation,
			OperationSummary: "Remove repository access to a self-hosted runner group in an organization",
			OperationID:      "actions/remove-repo-access-to-self-hosted-runner-group-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams
			Response = *ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsRemoveSelectedRepoFromOrgSecretRequest handles actions/remove-selected-repo-from-org-secret operation.
//
// Removes a repository from an organization secret when the `visibility` for repository access is
// set to `selected`. The visibility is set when you [Create or update an organization
// secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret).
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `secrets` organization permission to use this endpoint.
//
// DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}
func (s *Server) handleActionsRemoveSelectedRepoFromOrgSecretRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-selected-repo-from-org-secret"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsRemoveSelectedRepoFromOrgSecretOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsRemoveSelectedRepoFromOrgSecretOperation,
			ID:   "actions/remove-selected-repo-from-org-secret",
		}
	)
	params, err := decodeActionsRemoveSelectedRepoFromOrgSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActionsRemoveSelectedRepoFromOrgSecretRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsRemoveSelectedRepoFromOrgSecretOperation,
			OperationSummary: "Remove selected repository from an organization secret",
			OperationID:      "actions/remove-selected-repo-from-org-secret",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsRemoveSelectedRepoFromOrgSecretParams
			Response = ActionsRemoveSelectedRepoFromOrgSecretRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsRemoveSelectedRepoFromOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsRemoveSelectedRepoFromOrgSecret(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsRemoveSelectedRepoFromOrgSecret(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsRemoveSelectedRepoFromOrgSecretResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsRemoveSelfHostedRunnerFromGroupForOrgRequest handles actions/remove-self-hosted-runner-from-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Removes a self-hosted runner from a group configured in an organization. The runner is then
// returned to the default group.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) handleActionsRemoveSelfHostedRunnerFromGroupForOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/remove-self-hosted-runner-from-group-for-org"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsRemoveSelfHostedRunnerFromGroupForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsRemoveSelfHostedRunnerFromGroupForOrgOperation,
			ID:   "actions/remove-self-hosted-runner-from-group-for-org",
		}
	)
	params, err := decodeActionsRemoveSelfHostedRunnerFromGroupForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsRemoveSelfHostedRunnerFromGroupForOrgOperation,
			OperationSummary: "Remove a self-hosted runner from a group for an organization",
			OperationID:      "actions/remove-self-hosted-runner-from-group-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsRemoveSelfHostedRunnerFromGroupForOrgParams
			Response = *ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsRemoveSelfHostedRunnerFromGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsRemoveSelfHostedRunnerFromGroupForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsRemoveSelfHostedRunnerFromGroupForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsRetryWorkflowRequest handles actions/retry-workflow operation.
//
// Retry your workflow run using its `id`. You must authenticate using an access token with the
// `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use
// this endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/retry
func (s *Server) handleActionsRetryWorkflowRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/retry-workflow"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/retry"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsRetryWorkflowOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsRetryWorkflowOperation,
			ID:   "actions/retry-workflow",
		}
	)
	params, err := decodeActionsRetryWorkflowParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsRetryWorkflowCreated
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsRetryWorkflowOperation,
			OperationSummary: "Retry a workflow",
			OperationID:      "actions/retry-workflow",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActionsRetryWorkflowParams
			Response = *ActionsRetryWorkflowCreated
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsRetryWorkflowParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsRetryWorkflow(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsRetryWorkflow(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsRetryWorkflowResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsReviewPendingDeploymentsForRunRequest handles actions/review-pending-deployments-for-run operation.
//
// Approve or reject pending deployments that are waiting on approval by a required reviewer.
// Anyone with read access to the repository contents and deployments can use this endpoint.
//
// POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments
func (s *Server) handleActionsReviewPendingDeploymentsForRunRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/review-pending-deployments-for-run"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsReviewPendingDeploymentsForRunOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsReviewPendingDeploymentsForRunOperation,
			ID:   "actions/review-pending-deployments-for-run",
		}
	)
	params, err := decodeActionsReviewPendingDeploymentsForRunParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActionsReviewPendingDeploymentsForRunRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response []Deployment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsReviewPendingDeploymentsForRunOperation,
			OperationSummary: "Review pending deployments for a workflow run",
			OperationID:      "actions/review-pending-deployments-for-run",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "run_id",
					In:   "path",
				}: params.RunID,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsReviewPendingDeploymentsForRunReq
			Params   = ActionsReviewPendingDeploymentsForRunParams
			Response = []Deployment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsReviewPendingDeploymentsForRunParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsReviewPendingDeploymentsForRun(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsReviewPendingDeploymentsForRun(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsReviewPendingDeploymentsForRunResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsSetAllowedActionsOrganizationRequest handles actions/set-allowed-actions-organization operation.
//
// Sets the actions that are allowed in an organization. To use this endpoint, the organization
// permission policy for `allowed_actions` must be configured to `selected`. For more information,
// see "[Set GitHub Actions permissions for an
// organization](#set-github-actions-permissions-for-an-organization)."
// If the organization belongs to an enterprise that has `selected` actions set at the enterprise
// level, then you cannot override any of the enterprise's allowed actions settings.
// To use the `patterns_allowed` setting for private repositories, the organization must belong to an
// enterprise. If the organization does not belong to an enterprise, then the `patterns_allowed`
// setting only applies to public repositories in the organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// PUT /orgs/{org}/actions/permissions/selected-actions
func (s *Server) handleActionsSetAllowedActionsOrganizationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-allowed-actions-organization"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/permissions/selected-actions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsSetAllowedActionsOrganizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsSetAllowedActionsOrganizationOperation,
			ID:   "actions/set-allowed-actions-organization",
		}
	)
	params, err := decodeActionsSetAllowedActionsOrganizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActionsSetAllowedActionsOrganizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ActionsSetAllowedActionsOrganizationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsSetAllowedActionsOrganizationOperation,
			OperationSummary: "Set allowed actions for an organization",
			OperationID:      "actions/set-allowed-actions-organization",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = OptSelectedActions
			Params   = ActionsSetAllowedActionsOrganizationParams
			Response = *ActionsSetAllowedActionsOrganizationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetAllowedActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsSetAllowedActionsOrganization(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsSetAllowedActionsOrganization(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetAllowedActionsOrganizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsSetAllowedActionsRepositoryRequest handles actions/set-allowed-actions-repository operation.
//
// Sets the actions that are allowed in a repository. To use this endpoint, the repository permission
// policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set
// GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."
// If the repository belongs to an organization or enterprise that has `selected` actions set at the
// organization or enterprise levels, then you cannot override any of the allowed actions settings.
// To use the `patterns_allowed` setting for private repositories, the repository must belong to an
// enterprise. If the repository does not belong to an enterprise, then the `patterns_allowed`
// setting only applies to public repositories.
// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
// Apps must have the `administration` repository permission to use this API.
//
// PUT /repos/{owner}/{repo}/actions/permissions/selected-actions
func (s *Server) handleActionsSetAllowedActionsRepositoryRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-allowed-actions-repository"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/permissions/selected-actions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsSetAllowedActionsRepositoryOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsSetAllowedActionsRepositoryOperation,
			ID:   "actions/set-allowed-actions-repository",
		}
	)
	params, err := decodeActionsSetAllowedActionsRepositoryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActionsSetAllowedActionsRepositoryRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ActionsSetAllowedActionsRepositoryNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsSetAllowedActionsRepositoryOperation,
			OperationSummary: "Set allowed actions for a repository",
			OperationID:      "actions/set-allowed-actions-repository",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptSelectedActions
			Params   = ActionsSetAllowedActionsRepositoryParams
			Response = *ActionsSetAllowedActionsRepositoryNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetAllowedActionsRepositoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsSetAllowedActionsRepository(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsSetAllowedActionsRepository(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetAllowedActionsRepositoryResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsSetGithubActionsPermissionsOrganizationRequest handles actions/set-github-actions-permissions-organization operation.
//
// Sets the GitHub Actions permissions policy for repositories and allowed actions in an organization.
// If the organization belongs to an enterprise that has set restrictive permissions at the
// enterprise level, such as `allowed_actions` to `selected` actions, then you cannot override them
// for the organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// PUT /orgs/{org}/actions/permissions
func (s *Server) handleActionsSetGithubActionsPermissionsOrganizationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-github-actions-permissions-organization"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/permissions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsSetGithubActionsPermissionsOrganizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsSetGithubActionsPermissionsOrganizationOperation,
			ID:   "actions/set-github-actions-permissions-organization",
		}
	)
	params, err := decodeActionsSetGithubActionsPermissionsOrganizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActionsSetGithubActionsPermissionsOrganizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ActionsSetGithubActionsPermissionsOrganizationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsSetGithubActionsPermissionsOrganizationOperation,
			OperationSummary: "Set GitHub Actions permissions for an organization",
			OperationID:      "actions/set-github-actions-permissions-organization",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsSetGithubActionsPermissionsOrganizationReq
			Params   = ActionsSetGithubActionsPermissionsOrganizationParams
			Response = *ActionsSetGithubActionsPermissionsOrganizationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetGithubActionsPermissionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsSetGithubActionsPermissionsOrganization(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsSetGithubActionsPermissionsOrganization(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetGithubActionsPermissionsOrganizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsSetGithubActionsPermissionsRepositoryRequest handles actions/set-github-actions-permissions-repository operation.
//
// Sets the GitHub Actions permissions policy for enabling GitHub Actions and allowed actions in the
// repository.
// If the repository belongs to an organization or enterprise that has set restrictive permissions at
// the organization or enterprise levels, such as `allowed_actions` to `selected` actions, then you
// cannot override them for the repository.
// You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
// Apps must have the `administration` repository permission to use this API.
//
// PUT /repos/{owner}/{repo}/actions/permissions
func (s *Server) handleActionsSetGithubActionsPermissionsRepositoryRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-github-actions-permissions-repository"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/actions/permissions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsSetGithubActionsPermissionsRepositoryOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsSetGithubActionsPermissionsRepositoryOperation,
			ID:   "actions/set-github-actions-permissions-repository",
		}
	)
	params, err := decodeActionsSetGithubActionsPermissionsRepositoryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActionsSetGithubActionsPermissionsRepositoryRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ActionsSetGithubActionsPermissionsRepositoryNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsSetGithubActionsPermissionsRepositoryOperation,
			OperationSummary: "Set GitHub Actions permissions for a repository",
			OperationID:      "actions/set-github-actions-permissions-repository",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsSetGithubActionsPermissionsRepositoryReq
			Params   = ActionsSetGithubActionsPermissionsRepositoryParams
			Response = *ActionsSetGithubActionsPermissionsRepositoryNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetGithubActionsPermissionsRepositoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsSetGithubActionsPermissionsRepository(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsSetGithubActionsPermissionsRepository(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetGithubActionsPermissionsRepositoryResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest handles actions/set-repo-access-to-self-hosted-runner-group-in-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Replaces the list of repositories that have access to a self-hosted runner group configured in an
// organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories
func (s *Server) handleActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-repo-access-to-self-hosted-runner-group-in-org"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgOperation,
			ID:   "actions/set-repo-access-to-self-hosted-runner-group-in-org",
		}
	)
	params, err := decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgOperation,
			OperationSummary: "Set repository access for a self-hosted runner group in an organization",
			OperationID:      "actions/set-repo-access-to-self-hosted-runner-group-in-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq
			Params   = ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams
			Response = *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsSetRepoAccessToSelfHostedRunnerGroupInOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsSetSelectedReposForOrgSecretRequest handles actions/set-selected-repos-for-org-secret operation.
//
// Replaces all repositories for an organization secret when the `visibility` for repository access
// is set to `selected`. The visibility is set when you [Create or update an organization
// secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret).
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `secrets` organization permission to use this endpoint.
//
// PUT /orgs/{org}/actions/secrets/{secret_name}/repositories
func (s *Server) handleActionsSetSelectedReposForOrgSecretRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-selected-repos-for-org-secret"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/secrets/{secret_name}/repositories"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsSetSelectedReposForOrgSecretOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsSetSelectedReposForOrgSecretOperation,
			ID:   "actions/set-selected-repos-for-org-secret",
		}
	)
	params, err := decodeActionsSetSelectedReposForOrgSecretParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActionsSetSelectedReposForOrgSecretRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ActionsSetSelectedReposForOrgSecretNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsSetSelectedReposForOrgSecretOperation,
			OperationSummary: "Set selected repositories for an organization secret",
			OperationID:      "actions/set-selected-repos-for-org-secret",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "secret_name",
					In:   "path",
				}: params.SecretName,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsSetSelectedReposForOrgSecretReq
			Params   = ActionsSetSelectedReposForOrgSecretParams
			Response = *ActionsSetSelectedReposForOrgSecretNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetSelectedReposForOrgSecretParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsSetSelectedReposForOrgSecret(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsSetSelectedReposForOrgSecret(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetSelectedReposForOrgSecretResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest handles actions/set-selected-repositories-enabled-github-actions-organization operation.
//
// Replaces the list of selected repositories that are enabled for GitHub Actions in an organization.
// To use this endpoint, the organization permission policy for `enabled_repositories` must be
// configured to `selected`. For more information, see "[Set GitHub Actions permissions for an
// organization](#set-github-actions-permissions-for-an-organization)."
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
// GitHub Apps must have the `administration` organization permission to use this API.
//
// PUT /orgs/{org}/actions/permissions/repositories
func (s *Server) handleActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-selected-repositories-enabled-github-actions-organization"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/permissions/repositories"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationOperation,
			ID:   "actions/set-selected-repositories-enabled-github-actions-organization",
		}
	)
	params, err := decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationOperation,
			OperationSummary: "Set selected repositories enabled for GitHub Actions in an organization",
			OperationID:      "actions/set-selected-repositories-enabled-github-actions-organization",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq
			Params   = ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams
			Response = *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsSetSelfHostedRunnersInGroupForOrgRequest handles actions/set-self-hosted-runners-in-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Replaces the list of self-hosted runners that are part of an organization runner group.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) handleActionsSetSelfHostedRunnersInGroupForOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/set-self-hosted-runners-in-group-for-org"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}/runners"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsSetSelfHostedRunnersInGroupForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsSetSelfHostedRunnersInGroupForOrgOperation,
			ID:   "actions/set-self-hosted-runners-in-group-for-org",
		}
	)
	params, err := decodeActionsSetSelfHostedRunnersInGroupForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActionsSetSelfHostedRunnersInGroupForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ActionsSetSelfHostedRunnersInGroupForOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsSetSelfHostedRunnersInGroupForOrgOperation,
			OperationSummary: "Set self-hosted runners in a group for an organization",
			OperationID:      "actions/set-self-hosted-runners-in-group-for-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsSetSelfHostedRunnersInGroupForOrgReq
			Params   = ActionsSetSelfHostedRunnersInGroupForOrgParams
			Response = *ActionsSetSelfHostedRunnersInGroupForOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsSetSelfHostedRunnersInGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActionsSetSelfHostedRunnersInGroupForOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActionsSetSelfHostedRunnersInGroupForOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsSetSelfHostedRunnersInGroupForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActionsUpdateSelfHostedRunnerGroupForOrgRequest handles actions/update-self-hosted-runner-group-for-org operation.
//
// The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more
// information, see "[GitHub's products](https://docs.github.
// com/github/getting-started-with-github/githubs-products)."
// Updates the `name` and `visibility` of a self-hosted runner group in an organization.
// You must authenticate using an access token with the `admin:org` scope to use this endpoint.
//
// PATCH /orgs/{org}/actions/runner-groups/{runner_group_id}
func (s *Server) handleActionsUpdateSelfHostedRunnerGroupForOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("actions/update-self-hosted-runner-group-for-org"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/orgs/{org}/actions/runner-groups/{runner_group_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActionsUpdateSelfHostedRunnerGroupForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActionsUpdateSelfHostedRunnerGroupForOrgOperation,
			ID:   "actions/update-self-hosted-runner-group-for-org",
		}
	)
	params, err := decodeActionsUpdateSelfHostedRunnerGroupForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActionsUpdateSelfHostedRunnerGroupForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *RunnerGroupsOrg
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActionsUpdateSelfHostedRunnerGroupForOrgOperation,
			OperationSummary: "Update a self-hosted runner group for an organization",
			OperationID:      "actions/update-self-hosted-runner-group-for-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = *ActionsUpdateSelfHostedRunnerGroupForOrgReq
			Params   = ActionsUpdateSelfHostedRunnerGroupForOrgParams
			Response = *RunnerGroupsOrg
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActionsUpdateSelfHostedRunnerGroupForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActionsUpdateSelfHostedRunnerGroupForOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActionsUpdateSelfHostedRunnerGroupForOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActionsUpdateSelfHostedRunnerGroupForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityCheckRepoIsStarredByAuthenticatedUserRequest handles activity/check-repo-is-starred-by-authenticated-user operation.
//
// Check if a repository is starred by the authenticated user.
//
// GET /user/starred/{owner}/{repo}
func (s *Server) handleActivityCheckRepoIsStarredByAuthenticatedUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/check-repo-is-starred-by-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/starred/{owner}/{repo}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityCheckRepoIsStarredByAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityCheckRepoIsStarredByAuthenticatedUserOperation,
			ID:   "activity/check-repo-is-starred-by-authenticated-user",
		}
	)
	params, err := decodeActivityCheckRepoIsStarredByAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActivityCheckRepoIsStarredByAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityCheckRepoIsStarredByAuthenticatedUserOperation,
			OperationSummary: "Check if a repository is starred by the authenticated user",
			OperationID:      "activity/check-repo-is-starred-by-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityCheckRepoIsStarredByAuthenticatedUserParams
			Response = ActivityCheckRepoIsStarredByAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityCheckRepoIsStarredByAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityCheckRepoIsStarredByAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityCheckRepoIsStarredByAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityCheckRepoIsStarredByAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityDeleteRepoSubscriptionRequest handles activity/delete-repo-subscription operation.
//
// This endpoint should only be used to stop watching a repository. To control whether or not you
// wish to receive notifications from a repository, [set the repository's subscription
// manually](https://docs.github.com/rest/reference/activity#set-a-repository-subscription).
//
// DELETE /repos/{owner}/{repo}/subscription
func (s *Server) handleActivityDeleteRepoSubscriptionRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/delete-repo-subscription"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/subscription"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityDeleteRepoSubscriptionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityDeleteRepoSubscriptionOperation,
			ID:   "activity/delete-repo-subscription",
		}
	)
	params, err := decodeActivityDeleteRepoSubscriptionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActivityDeleteRepoSubscriptionNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityDeleteRepoSubscriptionOperation,
			OperationSummary: "Delete a repository subscription",
			OperationID:      "activity/delete-repo-subscription",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityDeleteRepoSubscriptionParams
			Response = *ActivityDeleteRepoSubscriptionNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityDeleteRepoSubscriptionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ActivityDeleteRepoSubscription(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ActivityDeleteRepoSubscription(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityDeleteRepoSubscriptionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityDeleteThreadSubscriptionRequest handles activity/delete-thread-subscription operation.
//
// Mutes all future notifications for a conversation until you comment on the thread or get an
// **@mention**. If you are watching the repository of the thread, you will still receive
// notifications. To ignore future notifications for a repository you are watching, use the [Set a
// thread subscription](https://docs.github.com/rest/reference/activity#set-a-thread-subscription)
// endpoint and set `ignore` to `true`.
//
// DELETE /notifications/threads/{thread_id}/subscription
func (s *Server) handleActivityDeleteThreadSubscriptionRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/delete-thread-subscription"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/notifications/threads/{thread_id}/subscription"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityDeleteThreadSubscriptionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityDeleteThreadSubscriptionOperation,
			ID:   "activity/delete-thread-subscription",
		}
	)
	params, err := decodeActivityDeleteThreadSubscriptionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActivityDeleteThreadSubscriptionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityDeleteThreadSubscriptionOperation,
			OperationSummary: "Delete a thread subscription",
			OperationID:      "activity/delete-thread-subscription",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "thread_id",
					In:   "path",
				}: params.ThreadID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityDeleteThreadSubscriptionParams
			Response = ActivityDeleteThreadSubscriptionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityDeleteThreadSubscriptionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityDeleteThreadSubscription(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityDeleteThreadSubscription(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityDeleteThreadSubscriptionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityGetFeedsRequest handles activity/get-feeds operation.
//
// GitHub provides several timeline resources in [Atom](http://en.wikipedia.org/wiki/Atom_(standard))
// format. The Feeds API lists all the feeds available to the authenticated user:
// *   **Timeline**: The GitHub global public timeline
// *   **User**: The public timeline for any user, using [URI template](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#hypermedia)
// *   **Current user public**: The public timeline for the authenticated user
// *   **Current user**: The private timeline for the authenticated user
// *   **Current user actor**: The private timeline for activity created by the authenticated user
// *   **Current user organizations**: The private timeline for the organizations the authenticated
// user is a member of.
// *   **Security advisories**: A collection of public announcements that provide information about
// security-related vulnerabilities in software on GitHub.
// **Note**: Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) since current feed URIs use
// the older, non revocable auth tokens.
//
// GET /feeds
func (s *Server) handleActivityGetFeedsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-feeds"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/feeds"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityGetFeedsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err error
	)

	var rawBody []byte

	var response *Feed
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityGetFeedsOperation,
			OperationSummary: "Get feeds",
			OperationID:      "activity/get-feeds",
			Body:             nil,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *Feed
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityGetFeeds(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityGetFeeds(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityGetFeedsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityGetRepoSubscriptionRequest handles activity/get-repo-subscription operation.
//
// Get a repository subscription.
//
// GET /repos/{owner}/{repo}/subscription
func (s *Server) handleActivityGetRepoSubscriptionRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-repo-subscription"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/subscription"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityGetRepoSubscriptionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityGetRepoSubscriptionOperation,
			ID:   "activity/get-repo-subscription",
		}
	)
	params, err := decodeActivityGetRepoSubscriptionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActivityGetRepoSubscriptionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityGetRepoSubscriptionOperation,
			OperationSummary: "Get a repository subscription",
			OperationID:      "activity/get-repo-subscription",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityGetRepoSubscriptionParams
			Response = ActivityGetRepoSubscriptionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityGetRepoSubscriptionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityGetRepoSubscription(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityGetRepoSubscription(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityGetRepoSubscriptionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityGetThreadRequest handles activity/get-thread operation.
//
// Get a thread.
//
// GET /notifications/threads/{thread_id}
func (s *Server) handleActivityGetThreadRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-thread"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/notifications/threads/{thread_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityGetThreadOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityGetThreadOperation,
			ID:   "activity/get-thread",
		}
	)
	params, err := decodeActivityGetThreadParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActivityGetThreadRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityGetThreadOperation,
			OperationSummary: "Get a thread",
			OperationID:      "activity/get-thread",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "thread_id",
					In:   "path",
				}: params.ThreadID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityGetThreadParams
			Response = ActivityGetThreadRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityGetThreadParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityGetThread(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityGetThread(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityGetThreadResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityGetThreadSubscriptionForAuthenticatedUserRequest handles activity/get-thread-subscription-for-authenticated-user operation.
//
// This checks to see if the current user is subscribed to a thread. You can also [get a repository
// subscription](https://docs.github.com/rest/reference/activity#get-a-repository-subscription).
// Note that subscriptions are only generated if a user is participating in a conversation--for
// example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.
//
// GET /notifications/threads/{thread_id}/subscription
func (s *Server) handleActivityGetThreadSubscriptionForAuthenticatedUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/get-thread-subscription-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/notifications/threads/{thread_id}/subscription"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityGetThreadSubscriptionForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityGetThreadSubscriptionForAuthenticatedUserOperation,
			ID:   "activity/get-thread-subscription-for-authenticated-user",
		}
	)
	params, err := decodeActivityGetThreadSubscriptionForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActivityGetThreadSubscriptionForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityGetThreadSubscriptionForAuthenticatedUserOperation,
			OperationSummary: "Get a thread subscription for the authenticated user",
			OperationID:      "activity/get-thread-subscription-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "thread_id",
					In:   "path",
				}: params.ThreadID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityGetThreadSubscriptionForAuthenticatedUserParams
			Response = ActivityGetThreadSubscriptionForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityGetThreadSubscriptionForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityGetThreadSubscriptionForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityGetThreadSubscriptionForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityGetThreadSubscriptionForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityListEventsForAuthenticatedUserRequest handles activity/list-events-for-authenticated-user operation.
//
// If you are authenticated as the given user, you will see your private events. Otherwise, you'll
// only see public events.
//
// GET /users/{username}/events
func (s *Server) handleActivityListEventsForAuthenticatedUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-events-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityListEventsForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityListEventsForAuthenticatedUserOperation,
			ID:   "activity/list-events-for-authenticated-user",
		}
	)
	params, err := decodeActivityListEventsForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityListEventsForAuthenticatedUserOperation,
			OperationSummary: "List events for the authenticated user",
			OperationID:      "activity/list-events-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListEventsForAuthenticatedUserParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListEventsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListEventsForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListEventsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListEventsForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityListNotificationsForAuthenticatedUserRequest handles activity/list-notifications-for-authenticated-user operation.
//
// List all notifications for the current user, sorted by most recently updated.
//
// GET /notifications
func (s *Server) handleActivityListNotificationsForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-notifications-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/notifications"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityListNotificationsForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityListNotificationsForAuthenticatedUserOperation,
			ID:   "activity/list-notifications-for-authenticated-user",
		}
	)
	params, err := decodeActivityListNotificationsForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActivityListNotificationsForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityListNotificationsForAuthenticatedUserOperation,
			OperationSummary: "List notifications for the authenticated user",
			OperationID:      "activity/list-notifications-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "all",
					In:   "query",
				}: params.All,
				{
					Name: "participating",
					In:   "query",
				}: params.Participating,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "before",
					In:   "query",
				}: params.Before,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListNotificationsForAuthenticatedUserParams
			Response = ActivityListNotificationsForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListNotificationsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListNotificationsForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListNotificationsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListNotificationsForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityListOrgEventsForAuthenticatedUserRequest handles activity/list-org-events-for-authenticated-user operation.
//
// This is the user's organization dashboard. You must be authenticated as the user to view this.
//
// GET /users/{username}/events/orgs/{org}
func (s *Server) handleActivityListOrgEventsForAuthenticatedUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-org-events-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/events/orgs/{org}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityListOrgEventsForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityListOrgEventsForAuthenticatedUserOperation,
			ID:   "activity/list-org-events-for-authenticated-user",
		}
	)
	params, err := decodeActivityListOrgEventsForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityListOrgEventsForAuthenticatedUserOperation,
			OperationSummary: "List organization events for the authenticated user",
			OperationID:      "activity/list-org-events-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListOrgEventsForAuthenticatedUserParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListOrgEventsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListOrgEventsForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListOrgEventsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListOrgEventsForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityListPublicEventsRequest handles activity/list-public-events operation.
//
// We delay the public events feed by five minutes, which means the most recent event returned by the
// public events API actually occurred at least five minutes ago.
//
// GET /events
func (s *Server) handleActivityListPublicEventsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityListPublicEventsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityListPublicEventsOperation,
			ID:   "activity/list-public-events",
		}
	)
	params, err := decodeActivityListPublicEventsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActivityListPublicEventsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityListPublicEventsOperation,
			OperationSummary: "List public events",
			OperationID:      "activity/list-public-events",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListPublicEventsParams
			Response = ActivityListPublicEventsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListPublicEventsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListPublicEvents(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListPublicEvents(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListPublicEventsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityListPublicEventsForRepoNetworkRequest handles activity/list-public-events-for-repo-network operation.
//
// List public events for a network of repositories.
//
// GET /networks/{owner}/{repo}/events
func (s *Server) handleActivityListPublicEventsForRepoNetworkRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events-for-repo-network"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/networks/{owner}/{repo}/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityListPublicEventsForRepoNetworkOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityListPublicEventsForRepoNetworkOperation,
			ID:   "activity/list-public-events-for-repo-network",
		}
	)
	params, err := decodeActivityListPublicEventsForRepoNetworkParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActivityListPublicEventsForRepoNetworkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityListPublicEventsForRepoNetworkOperation,
			OperationSummary: "List public events for a network of repositories",
			OperationID:      "activity/list-public-events-for-repo-network",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListPublicEventsForRepoNetworkParams
			Response = ActivityListPublicEventsForRepoNetworkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListPublicEventsForRepoNetworkParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListPublicEventsForRepoNetwork(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListPublicEventsForRepoNetwork(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListPublicEventsForRepoNetworkResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityListPublicEventsForUserRequest handles activity/list-public-events-for-user operation.
//
// List public events for a user.
//
// GET /users/{username}/events/public
func (s *Server) handleActivityListPublicEventsForUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-events-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/events/public"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityListPublicEventsForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityListPublicEventsForUserOperation,
			ID:   "activity/list-public-events-for-user",
		}
	)
	params, err := decodeActivityListPublicEventsForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityListPublicEventsForUserOperation,
			OperationSummary: "List public events for a user",
			OperationID:      "activity/list-public-events-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListPublicEventsForUserParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListPublicEventsForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListPublicEventsForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListPublicEventsForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListPublicEventsForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityListPublicOrgEventsRequest handles activity/list-public-org-events operation.
//
// List public organization events.
//
// GET /orgs/{org}/events
func (s *Server) handleActivityListPublicOrgEventsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-public-org-events"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityListPublicOrgEventsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityListPublicOrgEventsOperation,
			ID:   "activity/list-public-org-events",
		}
	)
	params, err := decodeActivityListPublicOrgEventsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityListPublicOrgEventsOperation,
			OperationSummary: "List public organization events",
			OperationID:      "activity/list-public-org-events",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListPublicOrgEventsParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListPublicOrgEventsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListPublicOrgEvents(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListPublicOrgEvents(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListPublicOrgEventsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityListReceivedEventsForUserRequest handles activity/list-received-events-for-user operation.
//
// These are events that you've received by watching repos and following users. If you are
// authenticated as the given user, you will see private events. Otherwise, you'll only see public
// events.
//
// GET /users/{username}/received_events
func (s *Server) handleActivityListReceivedEventsForUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-received-events-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/received_events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityListReceivedEventsForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityListReceivedEventsForUserOperation,
			ID:   "activity/list-received-events-for-user",
		}
	)
	params, err := decodeActivityListReceivedEventsForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityListReceivedEventsForUserOperation,
			OperationSummary: "List events received by the authenticated user",
			OperationID:      "activity/list-received-events-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListReceivedEventsForUserParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListReceivedEventsForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListReceivedEventsForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListReceivedEventsForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListReceivedEventsForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityListReceivedPublicEventsForUserRequest handles activity/list-received-public-events-for-user operation.
//
// List public events received by a user.
//
// GET /users/{username}/received_events/public
func (s *Server) handleActivityListReceivedPublicEventsForUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-received-public-events-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/received_events/public"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityListReceivedPublicEventsForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityListReceivedPublicEventsForUserOperation,
			ID:   "activity/list-received-public-events-for-user",
		}
	)
	params, err := decodeActivityListReceivedPublicEventsForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityListReceivedPublicEventsForUserOperation,
			OperationSummary: "List public events received by a user",
			OperationID:      "activity/list-received-public-events-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListReceivedPublicEventsForUserParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListReceivedPublicEventsForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListReceivedPublicEventsForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListReceivedPublicEventsForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListReceivedPublicEventsForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityListRepoEventsRequest handles activity/list-repo-events operation.
//
// List repository events.
//
// GET /repos/{owner}/{repo}/events
func (s *Server) handleActivityListRepoEventsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repo-events"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityListRepoEventsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityListRepoEventsOperation,
			ID:   "activity/list-repo-events",
		}
	)
	params, err := decodeActivityListRepoEventsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []Event
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityListRepoEventsOperation,
			OperationSummary: "List repository events",
			OperationID:      "activity/list-repo-events",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListRepoEventsParams
			Response = []Event
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListRepoEventsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListRepoEvents(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListRepoEvents(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListRepoEventsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityListRepoNotificationsForAuthenticatedUserRequest handles activity/list-repo-notifications-for-authenticated-user operation.
//
// List all notifications for the current user.
//
// GET /repos/{owner}/{repo}/notifications
func (s *Server) handleActivityListRepoNotificationsForAuthenticatedUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repo-notifications-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/notifications"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityListRepoNotificationsForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityListRepoNotificationsForAuthenticatedUserOperation,
			ID:   "activity/list-repo-notifications-for-authenticated-user",
		}
	)
	params, err := decodeActivityListRepoNotificationsForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActivityListRepoNotificationsForAuthenticatedUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityListRepoNotificationsForAuthenticatedUserOperation,
			OperationSummary: "List repository notifications for the authenticated user",
			OperationID:      "activity/list-repo-notifications-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "all",
					In:   "query",
				}: params.All,
				{
					Name: "participating",
					In:   "query",
				}: params.Participating,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "before",
					In:   "query",
				}: params.Before,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListRepoNotificationsForAuthenticatedUserParams
			Response = *ActivityListRepoNotificationsForAuthenticatedUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListRepoNotificationsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListRepoNotificationsForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListRepoNotificationsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListRepoNotificationsForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityListReposStarredByAuthenticatedUserRequest handles activity/list-repos-starred-by-authenticated-user operation.
//
// Lists repositories the authenticated user has starred.
// You can also find out _when_ stars were created by passing the following custom [media
// type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:.
//
// GET /user/starred
func (s *Server) handleActivityListReposStarredByAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repos-starred-by-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/starred"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityListReposStarredByAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityListReposStarredByAuthenticatedUserOperation,
			ID:   "activity/list-repos-starred-by-authenticated-user",
		}
	)
	params, err := decodeActivityListReposStarredByAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActivityListReposStarredByAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityListReposStarredByAuthenticatedUserOperation,
			OperationSummary: "List repositories starred by the authenticated user",
			OperationID:      "activity/list-repos-starred-by-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListReposStarredByAuthenticatedUserParams
			Response = ActivityListReposStarredByAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListReposStarredByAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListReposStarredByAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListReposStarredByAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListReposStarredByAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityListReposWatchedByUserRequest handles activity/list-repos-watched-by-user operation.
//
// Lists repositories a user is watching.
//
// GET /users/{username}/subscriptions
func (s *Server) handleActivityListReposWatchedByUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-repos-watched-by-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/subscriptions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityListReposWatchedByUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityListReposWatchedByUserOperation,
			ID:   "activity/list-repos-watched-by-user",
		}
	)
	params, err := decodeActivityListReposWatchedByUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActivityListReposWatchedByUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityListReposWatchedByUserOperation,
			OperationSummary: "List repositories watched by a user",
			OperationID:      "activity/list-repos-watched-by-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListReposWatchedByUserParams
			Response = *ActivityListReposWatchedByUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListReposWatchedByUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListReposWatchedByUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListReposWatchedByUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListReposWatchedByUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityListWatchedReposForAuthenticatedUserRequest handles activity/list-watched-repos-for-authenticated-user operation.
//
// Lists repositories the authenticated user is watching.
//
// GET /user/subscriptions
func (s *Server) handleActivityListWatchedReposForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-watched-repos-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/subscriptions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityListWatchedReposForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityListWatchedReposForAuthenticatedUserOperation,
			ID:   "activity/list-watched-repos-for-authenticated-user",
		}
	)
	params, err := decodeActivityListWatchedReposForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActivityListWatchedReposForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityListWatchedReposForAuthenticatedUserOperation,
			OperationSummary: "List repositories watched by the authenticated user",
			OperationID:      "activity/list-watched-repos-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListWatchedReposForAuthenticatedUserParams
			Response = ActivityListWatchedReposForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListWatchedReposForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListWatchedReposForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListWatchedReposForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListWatchedReposForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityListWatchersForRepoRequest handles activity/list-watchers-for-repo operation.
//
// Lists the people watching the specified repository.
//
// GET /repos/{owner}/{repo}/subscribers
func (s *Server) handleActivityListWatchersForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/list-watchers-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/subscribers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityListWatchersForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityListWatchersForRepoOperation,
			ID:   "activity/list-watchers-for-repo",
		}
	)
	params, err := decodeActivityListWatchersForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActivityListWatchersForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityListWatchersForRepoOperation,
			OperationSummary: "List watchers",
			OperationID:      "activity/list-watchers-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityListWatchersForRepoParams
			Response = *ActivityListWatchersForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityListWatchersForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityListWatchersForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityListWatchersForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityListWatchersForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityMarkNotificationsAsReadRequest handles activity/mark-notifications-as-read operation.
//
// Marks all notifications as "read" removes it from the [default view on GitHub](https://github.
// com/notifications). If the number of notifications is too large to complete in one request, you
// will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark
// notifications as "read." To check whether any "unread" notifications remain, you can use the [List
// notifications for the authenticated user](https://docs.github.
// com/rest/reference/activity#list-notifications-for-the-authenticated-user) endpoint and pass the
// query parameter `all=false`.
//
// PUT /notifications
func (s *Server) handleActivityMarkNotificationsAsReadRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-notifications-as-read"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/notifications"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityMarkNotificationsAsReadOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityMarkNotificationsAsReadOperation,
			ID:   "activity/mark-notifications-as-read",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeActivityMarkNotificationsAsReadRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActivityMarkNotificationsAsReadRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityMarkNotificationsAsReadOperation,
			OperationSummary: "Mark notifications as read",
			OperationID:      "activity/mark-notifications-as-read",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = OptActivityMarkNotificationsAsReadReq
			Params   = struct{}
			Response = ActivityMarkNotificationsAsReadRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityMarkNotificationsAsRead(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityMarkNotificationsAsRead(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityMarkNotificationsAsReadResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityMarkRepoNotificationsAsReadRequest handles activity/mark-repo-notifications-as-read operation.
//
// Marks all notifications in a repository as "read" removes them from the [default view on
// GitHub](https://github.com/notifications). If the number of notifications is too large to complete
// in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous
// process to mark notifications as "read." To check whether any "unread" notifications remain, you
// can use the [List repository notifications for the authenticated user](https://docs.github.
// com/rest/reference/activity#list-repository-notifications-for-the-authenticated-user) endpoint and
// pass the query parameter `all=false`.
//
// PUT /repos/{owner}/{repo}/notifications
func (s *Server) handleActivityMarkRepoNotificationsAsReadRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-repo-notifications-as-read"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/notifications"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityMarkRepoNotificationsAsReadOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityMarkRepoNotificationsAsReadOperation,
			ID:   "activity/mark-repo-notifications-as-read",
		}
	)
	params, err := decodeActivityMarkRepoNotificationsAsReadParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActivityMarkRepoNotificationsAsReadRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActivityMarkRepoNotificationsAsReadRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityMarkRepoNotificationsAsReadOperation,
			OperationSummary: "Mark repository notifications as read",
			OperationID:      "activity/mark-repo-notifications-as-read",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptActivityMarkRepoNotificationsAsReadReq
			Params   = ActivityMarkRepoNotificationsAsReadParams
			Response = ActivityMarkRepoNotificationsAsReadRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityMarkRepoNotificationsAsReadParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityMarkRepoNotificationsAsRead(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityMarkRepoNotificationsAsRead(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityMarkRepoNotificationsAsReadResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityMarkThreadAsReadRequest handles activity/mark-thread-as-read operation.
//
// Mark a thread as read.
//
// PATCH /notifications/threads/{thread_id}
func (s *Server) handleActivityMarkThreadAsReadRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/mark-thread-as-read"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/notifications/threads/{thread_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityMarkThreadAsReadOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityMarkThreadAsReadOperation,
			ID:   "activity/mark-thread-as-read",
		}
	)
	params, err := decodeActivityMarkThreadAsReadParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActivityMarkThreadAsReadRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityMarkThreadAsReadOperation,
			OperationSummary: "Mark a thread as read",
			OperationID:      "activity/mark-thread-as-read",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "thread_id",
					In:   "path",
				}: params.ThreadID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityMarkThreadAsReadParams
			Response = ActivityMarkThreadAsReadRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityMarkThreadAsReadParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityMarkThreadAsRead(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityMarkThreadAsRead(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityMarkThreadAsReadResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivitySetRepoSubscriptionRequest handles activity/set-repo-subscription operation.
//
// If you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore
// notifications made within a repository, set `ignored` to `true`. If you would like to stop
// watching a repository, [delete the repository's subscription](https://docs.github.
// com/rest/reference/activity#delete-a-repository-subscription) completely.
//
// PUT /repos/{owner}/{repo}/subscription
func (s *Server) handleActivitySetRepoSubscriptionRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/set-repo-subscription"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/subscription"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivitySetRepoSubscriptionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivitySetRepoSubscriptionOperation,
			ID:   "activity/set-repo-subscription",
		}
	)
	params, err := decodeActivitySetRepoSubscriptionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActivitySetRepoSubscriptionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *RepositorySubscription
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivitySetRepoSubscriptionOperation,
			OperationSummary: "Set a repository subscription",
			OperationID:      "activity/set-repo-subscription",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptActivitySetRepoSubscriptionReq
			Params   = ActivitySetRepoSubscriptionParams
			Response = *RepositorySubscription
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivitySetRepoSubscriptionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivitySetRepoSubscription(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivitySetRepoSubscription(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivitySetRepoSubscriptionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivitySetThreadSubscriptionRequest handles activity/set-thread-subscription operation.
//
// If you are watching a repository, you receive notifications for all threads by default. Use this
// endpoint to ignore future notifications for threads until you comment on the thread or get an
// **@mention**.
// You can also use this endpoint to subscribe to threads that you are currently not receiving
// notifications for or to subscribed to threads that you have previously ignored.
// Unsubscribing from a conversation in a repository that you are not watching is functionally
// equivalent to the [Delete a thread subscription](https://docs.github.
// com/rest/reference/activity#delete-a-thread-subscription) endpoint.
//
// PUT /notifications/threads/{thread_id}/subscription
func (s *Server) handleActivitySetThreadSubscriptionRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/set-thread-subscription"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/notifications/threads/{thread_id}/subscription"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivitySetThreadSubscriptionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivitySetThreadSubscriptionOperation,
			ID:   "activity/set-thread-subscription",
		}
	)
	params, err := decodeActivitySetThreadSubscriptionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeActivitySetThreadSubscriptionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ActivitySetThreadSubscriptionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivitySetThreadSubscriptionOperation,
			OperationSummary: "Set a thread subscription",
			OperationID:      "activity/set-thread-subscription",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "thread_id",
					In:   "path",
				}: params.ThreadID,
			},
			Raw: r,
		}

		type (
			Request  = OptActivitySetThreadSubscriptionReq
			Params   = ActivitySetThreadSubscriptionParams
			Response = ActivitySetThreadSubscriptionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivitySetThreadSubscriptionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivitySetThreadSubscription(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivitySetThreadSubscription(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivitySetThreadSubscriptionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityStarRepoForAuthenticatedUserRequest handles activity/star-repo-for-authenticated-user operation.
//
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /user/starred/{owner}/{repo}
func (s *Server) handleActivityStarRepoForAuthenticatedUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/star-repo-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/user/starred/{owner}/{repo}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityStarRepoForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityStarRepoForAuthenticatedUserOperation,
			ID:   "activity/star-repo-for-authenticated-user",
		}
	)
	params, err := decodeActivityStarRepoForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActivityStarRepoForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityStarRepoForAuthenticatedUserOperation,
			OperationSummary: "Star a repository for the authenticated user",
			OperationID:      "activity/star-repo-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityStarRepoForAuthenticatedUserParams
			Response = ActivityStarRepoForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityStarRepoForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityStarRepoForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityStarRepoForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityStarRepoForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleActivityUnstarRepoForAuthenticatedUserRequest handles activity/unstar-repo-for-authenticated-user operation.
//
// Unstar a repository for the authenticated user.
//
// DELETE /user/starred/{owner}/{repo}
func (s *Server) handleActivityUnstarRepoForAuthenticatedUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("activity/unstar-repo-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/starred/{owner}/{repo}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ActivityUnstarRepoForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ActivityUnstarRepoForAuthenticatedUserOperation,
			ID:   "activity/unstar-repo-for-authenticated-user",
		}
	)
	params, err := decodeActivityUnstarRepoForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ActivityUnstarRepoForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ActivityUnstarRepoForAuthenticatedUserOperation,
			OperationSummary: "Unstar a repository for the authenticated user",
			OperationID:      "activity/unstar-repo-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ActivityUnstarRepoForAuthenticatedUserParams
			Response = ActivityUnstarRepoForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackActivityUnstarRepoForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ActivityUnstarRepoForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ActivityUnstarRepoForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeActivityUnstarRepoForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsAddRepoToInstallationRequest handles apps/add-repo-to-installation operation.
//
// Add a single repository to an installation. The authenticated user must have admin access to the
// repository.
// You must use a personal access token (which you can create via the [command line](https://docs.
// github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic
// Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
//
// PUT /user/installations/{installation_id}/repositories/{repository_id}
func (s *Server) handleAppsAddRepoToInstallationRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/add-repo-to-installation"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/user/installations/{installation_id}/repositories/{repository_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsAddRepoToInstallationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsAddRepoToInstallationOperation,
			ID:   "apps/add-repo-to-installation",
		}
	)
	params, err := decodeAppsAddRepoToInstallationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsAddRepoToInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsAddRepoToInstallationOperation,
			OperationSummary: "Add a repository to an app installation",
			OperationID:      "apps/add-repo-to-installation",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "installation_id",
					In:   "path",
				}: params.InstallationID,
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsAddRepoToInstallationParams
			Response = AppsAddRepoToInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsAddRepoToInstallationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsAddRepoToInstallation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsAddRepoToInstallation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsAddRepoToInstallationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsCheckTokenRequest handles apps/check-token operation.
//
// OAuth applications can use a special API method for checking OAuth token validity without
// exceeding the normal rate limits for failed login attempts. Authentication works differently with
// this particular endpoint. You must use [Basic Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) to use this endpoint, where
// the username is the OAuth application `client_id` and the password is its `client_secret`. Invalid
// tokens will return `404 NOT FOUND`.
//
// POST /applications/{client_id}/token
func (s *Server) handleAppsCheckTokenRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/check-token"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/applications/{client_id}/token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsCheckTokenOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsCheckTokenOperation,
			ID:   "apps/check-token",
		}
	)
	params, err := decodeAppsCheckTokenParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeAppsCheckTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsCheckTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsCheckTokenOperation,
			OperationSummary: "Check a token",
			OperationID:      "apps/check-token",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "client_id",
					In:   "path",
				}: params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = *AppsCheckTokenReq
			Params   = AppsCheckTokenParams
			Response = AppsCheckTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsCheckTokenParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsCheckToken(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsCheckToken(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsCheckTokenResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsCreateContentAttachmentRequest handles apps/create-content-attachment operation.
//
// Creates an attachment under a content reference URL in the body or comment of an issue or pull
// request. Use the `id` and `repository` `full_name` of the content reference from the
// [`content_reference` event](https://docs.github.com/webhooks/event-payloads/#content_reference) to
// create an attachment.
// The app must create a content attachment within six hours of the content reference URL being
// posted. See "[Using content attachments](https://docs.github.com/apps/using-content-attachments/)"
// for details about content attachments.
// You must use an [installation access token](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
// to access this endpoint.
//
// POST /repos/{owner}/{repo}/content_references/{content_reference_id}/attachments
func (s *Server) handleAppsCreateContentAttachmentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/create-content-attachment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/content_references/{content_reference_id}/attachments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsCreateContentAttachmentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsCreateContentAttachmentOperation,
			ID:   "apps/create-content-attachment",
		}
	)
	params, err := decodeAppsCreateContentAttachmentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeAppsCreateContentAttachmentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsCreateContentAttachmentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsCreateContentAttachmentOperation,
			OperationSummary: "Create a content attachment",
			OperationID:      "apps/create-content-attachment",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "content_reference_id",
					In:   "path",
				}: params.ContentReferenceID,
			},
			Raw: r,
		}

		type (
			Request  = *AppsCreateContentAttachmentReq
			Params   = AppsCreateContentAttachmentParams
			Response = AppsCreateContentAttachmentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsCreateContentAttachmentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsCreateContentAttachment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsCreateContentAttachment(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsCreateContentAttachmentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsCreateFromManifestRequest handles apps/create-from-manifest operation.
//
// Use this endpoint to complete the handshake necessary when implementing the [GitHub App Manifest
// flow](https://docs.github.com/apps/building-github-apps/creating-github-apps-from-a-manifest/).
// When you create a GitHub App with the manifest flow, you receive a temporary `code` used to
// retrieve the GitHub App's `id`, `pem` (private key), and `webhook_secret`.
//
// POST /app-manifests/{code}/conversions
func (s *Server) handleAppsCreateFromManifestRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/create-from-manifest"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/app-manifests/{code}/conversions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsCreateFromManifestOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsCreateFromManifestOperation,
			ID:   "apps/create-from-manifest",
		}
	)
	params, err := decodeAppsCreateFromManifestParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeAppsCreateFromManifestRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsCreateFromManifestRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsCreateFromManifestOperation,
			OperationSummary: "Create a GitHub App from a manifest",
			OperationID:      "apps/create-from-manifest",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "code",
					In:   "path",
				}: params.Code,
			},
			Raw: r,
		}

		type (
			Request  = *AppsCreateFromManifestReq
			Params   = AppsCreateFromManifestParams
			Response = AppsCreateFromManifestRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsCreateFromManifestParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsCreateFromManifest(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsCreateFromManifest(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsCreateFromManifestResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsCreateInstallationAccessTokenRequest handles apps/create-installation-access-token operation.
//
// Creates an installation access token that enables a GitHub App to make authenticated API requests
// for the app's installation on an organization or individual account. Installation tokens expire
// one hour from the time you create them. Using an expired token produces a status code of `401 -
// Unauthorized`, and requires creating a new installation token. By default the installation token
// has access to all repositories that the installation can access. To restrict the access to
// specific repositories, you can provide the `repository_ids` when creating the token. When you omit
// `repository_ids`, the response does not contain the `repositories` key.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// POST /app/installations/{installation_id}/access_tokens
func (s *Server) handleAppsCreateInstallationAccessTokenRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/create-installation-access-token"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/app/installations/{installation_id}/access_tokens"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsCreateInstallationAccessTokenOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsCreateInstallationAccessTokenOperation,
			ID:   "apps/create-installation-access-token",
		}
	)
	params, err := decodeAppsCreateInstallationAccessTokenParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeAppsCreateInstallationAccessTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsCreateInstallationAccessTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsCreateInstallationAccessTokenOperation,
			OperationSummary: "Create an installation access token for an app",
			OperationID:      "apps/create-installation-access-token",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "installation_id",
					In:   "path",
				}: params.InstallationID,
			},
			Raw: r,
		}

		type (
			Request  = OptAppsCreateInstallationAccessTokenReq
			Params   = AppsCreateInstallationAccessTokenParams
			Response = AppsCreateInstallationAccessTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsCreateInstallationAccessTokenParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsCreateInstallationAccessToken(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsCreateInstallationAccessToken(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsCreateInstallationAccessTokenResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsDeleteAuthorizationRequest handles apps/delete-authorization operation.
//
// OAuth application owners can revoke a grant for their OAuth application and a specific user. You
// must use [Basic Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint,
// using the OAuth application's `client_id` and `client_secret` as the username and password. You
// must also provide a valid OAuth `access_token` as an input parameter and the grant for the token's
// owner will be deleted.
// Deleting an OAuth application's grant will also delete all OAuth tokens associated with the
// application for the user. Once deleted, the application will have no access to the user's account
// and will no longer be listed on [the application authorizations settings screen within
// GitHub](https://github.com/settings/applications#authorized).
//
// DELETE /applications/{client_id}/grant
func (s *Server) handleAppsDeleteAuthorizationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-authorization"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/applications/{client_id}/grant"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsDeleteAuthorizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsDeleteAuthorizationOperation,
			ID:   "apps/delete-authorization",
		}
	)
	params, err := decodeAppsDeleteAuthorizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeAppsDeleteAuthorizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsDeleteAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsDeleteAuthorizationOperation,
			OperationSummary: "Delete an app authorization",
			OperationID:      "apps/delete-authorization",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "client_id",
					In:   "path",
				}: params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = *AppsDeleteAuthorizationReq
			Params   = AppsDeleteAuthorizationParams
			Response = AppsDeleteAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsDeleteAuthorizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsDeleteAuthorization(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsDeleteAuthorization(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsDeleteAuthorizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsDeleteInstallationRequest handles apps/delete-installation operation.
//
// Uninstalls a GitHub App on a user, organization, or business account. If you prefer to temporarily
// suspend an app's access to your account's resources, then we recommend the "[Suspend an app
// installation](https://docs.github.com/rest/reference/apps/#suspend-an-app-installation)" endpoint.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// DELETE /app/installations/{installation_id}
func (s *Server) handleAppsDeleteInstallationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-installation"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/app/installations/{installation_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsDeleteInstallationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsDeleteInstallationOperation,
			ID:   "apps/delete-installation",
		}
	)
	params, err := decodeAppsDeleteInstallationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsDeleteInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsDeleteInstallationOperation,
			OperationSummary: "Delete an installation for the authenticated app",
			OperationID:      "apps/delete-installation",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "installation_id",
					In:   "path",
				}: params.InstallationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsDeleteInstallationParams
			Response = AppsDeleteInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsDeleteInstallationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsDeleteInstallation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsDeleteInstallation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsDeleteInstallationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsDeleteTokenRequest handles apps/delete-token operation.
//
// OAuth application owners can revoke a single token for an OAuth application. You must use [Basic
// Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint,
// using the OAuth application's `client_id` and `client_secret` as the username and password.
//
// DELETE /applications/{client_id}/token
func (s *Server) handleAppsDeleteTokenRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/delete-token"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/applications/{client_id}/token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsDeleteTokenOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsDeleteTokenOperation,
			ID:   "apps/delete-token",
		}
	)
	params, err := decodeAppsDeleteTokenParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeAppsDeleteTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsDeleteTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsDeleteTokenOperation,
			OperationSummary: "Delete an app token",
			OperationID:      "apps/delete-token",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "client_id",
					In:   "path",
				}: params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = *AppsDeleteTokenReq
			Params   = AppsDeleteTokenParams
			Response = AppsDeleteTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsDeleteTokenParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsDeleteToken(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsDeleteToken(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsDeleteTokenResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsGetAuthenticatedRequest handles apps/get-authenticated operation.
//
// Returns the GitHub App associated with the authentication credentials used. To see how many app
// installations are associated with this GitHub App, see the `installations_count` in the response.
// For more details about your app's installations, see the "[List installations for the
// authenticated app](https://docs.github.
// com/rest/reference/apps#list-installations-for-the-authenticated-app)" endpoint.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// GET /app
func (s *Server) handleAppsGetAuthenticatedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-authenticated"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/app"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsGetAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err error
	)

	var rawBody []byte

	var response *Integration
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsGetAuthenticatedOperation,
			OperationSummary: "Get the authenticated app",
			OperationID:      "apps/get-authenticated",
			Body:             nil,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *Integration
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsGetAuthenticated(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsGetAuthenticated(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsGetBySlugRequest handles apps/get-by-slug operation.
//
// **Note**: The `:app_slug` is just the URL-friendly name of your GitHub App. You can find this on
// the settings page for your GitHub App (e.g., `https://github.com/settings/apps/:app_slug`).
// If the GitHub App you specify is public, you can access this endpoint without authenticating. If
// the GitHub App you specify is private, you must authenticate with a [personal access
// token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/) or
// an [installation access token](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
// to access this endpoint.
//
// GET /apps/{app_slug}
func (s *Server) handleAppsGetBySlugRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-by-slug"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/apps/{app_slug}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsGetBySlugOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsGetBySlugOperation,
			ID:   "apps/get-by-slug",
		}
	)
	params, err := decodeAppsGetBySlugParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsGetBySlugRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsGetBySlugOperation,
			OperationSummary: "Get an app",
			OperationID:      "apps/get-by-slug",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "app_slug",
					In:   "path",
				}: params.AppSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsGetBySlugParams
			Response = AppsGetBySlugRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsGetBySlugParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsGetBySlug(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsGetBySlug(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetBySlugResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsGetSubscriptionPlanForAccountRequest handles apps/get-subscription-plan-for-account operation.
//
// Shows whether the user or organization account actively subscribes to a plan listed by the
// authenticated GitHub App. When someone submits a plan change that won't be processed until the end
// of their billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/accounts/{account_id}
func (s *Server) handleAppsGetSubscriptionPlanForAccountRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-subscription-plan-for-account"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/marketplace_listing/accounts/{account_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsGetSubscriptionPlanForAccountOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsGetSubscriptionPlanForAccountOperation,
			ID:   "apps/get-subscription-plan-for-account",
		}
	)
	params, err := decodeAppsGetSubscriptionPlanForAccountParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsGetSubscriptionPlanForAccountRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsGetSubscriptionPlanForAccountOperation,
			OperationSummary: "Get a subscription plan for an account",
			OperationID:      "apps/get-subscription-plan-for-account",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsGetSubscriptionPlanForAccountParams
			Response = AppsGetSubscriptionPlanForAccountRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsGetSubscriptionPlanForAccountParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsGetSubscriptionPlanForAccount(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsGetSubscriptionPlanForAccount(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetSubscriptionPlanForAccountResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsGetSubscriptionPlanForAccountStubbedRequest handles apps/get-subscription-plan-for-account-stubbed operation.
//
// Shows whether the user or organization account actively subscribes to a plan listed by the
// authenticated GitHub App. When someone submits a plan change that won't be processed until the end
// of their billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/stubbed/accounts/{account_id}
func (s *Server) handleAppsGetSubscriptionPlanForAccountStubbedRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-subscription-plan-for-account-stubbed"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/marketplace_listing/stubbed/accounts/{account_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsGetSubscriptionPlanForAccountStubbedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsGetSubscriptionPlanForAccountStubbedOperation,
			ID:   "apps/get-subscription-plan-for-account-stubbed",
		}
	)
	params, err := decodeAppsGetSubscriptionPlanForAccountStubbedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsGetSubscriptionPlanForAccountStubbedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsGetSubscriptionPlanForAccountStubbedOperation,
			OperationSummary: "Get a subscription plan for an account (stubbed)",
			OperationID:      "apps/get-subscription-plan-for-account-stubbed",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "account_id",
					In:   "path",
				}: params.AccountID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsGetSubscriptionPlanForAccountStubbedParams
			Response = AppsGetSubscriptionPlanForAccountStubbedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsGetSubscriptionPlanForAccountStubbedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsGetSubscriptionPlanForAccountStubbed(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsGetSubscriptionPlanForAccountStubbed(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetSubscriptionPlanForAccountStubbedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsGetWebhookConfigForAppRequest handles apps/get-webhook-config-for-app operation.
//
// Returns the webhook configuration for a GitHub App. For more information about configuring a
// webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// GET /app/hook/config
func (s *Server) handleAppsGetWebhookConfigForAppRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-webhook-config-for-app"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/app/hook/config"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsGetWebhookConfigForAppOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err error
	)

	var rawBody []byte

	var response *WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsGetWebhookConfigForAppOperation,
			OperationSummary: "Get a webhook configuration for an app",
			OperationID:      "apps/get-webhook-config-for-app",
			Body:             nil,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsGetWebhookConfigForApp(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsGetWebhookConfigForApp(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetWebhookConfigForAppResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsGetWebhookDeliveryRequest handles apps/get-webhook-delivery operation.
//
// Returns a delivery for the webhook configured for a GitHub App.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// GET /app/hook/deliveries/{delivery_id}
func (s *Server) handleAppsGetWebhookDeliveryRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/get-webhook-delivery"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/app/hook/deliveries/{delivery_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsGetWebhookDeliveryOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsGetWebhookDeliveryOperation,
			ID:   "apps/get-webhook-delivery",
		}
	)
	params, err := decodeAppsGetWebhookDeliveryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsGetWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsGetWebhookDeliveryOperation,
			OperationSummary: "Get a delivery for an app webhook",
			OperationID:      "apps/get-webhook-delivery",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "delivery_id",
					In:   "path",
				}: params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsGetWebhookDeliveryParams
			Response = AppsGetWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsGetWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsGetWebhookDelivery(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsGetWebhookDelivery(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsGetWebhookDeliveryResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsListAccountsForPlanRequest handles apps/list-accounts-for-plan operation.
//
// Returns user and organization accounts associated with the specified plan, including free plans.
// For per-seat pricing, you see the list of accounts that have purchased the plan, including the
// number of seats purchased. When someone submits a plan change that won't be processed until the
// end of their billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/plans/{plan_id}/accounts
func (s *Server) handleAppsListAccountsForPlanRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-accounts-for-plan"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/marketplace_listing/plans/{plan_id}/accounts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsListAccountsForPlanOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsListAccountsForPlanOperation,
			ID:   "apps/list-accounts-for-plan",
		}
	)
	params, err := decodeAppsListAccountsForPlanParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsListAccountsForPlanRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsListAccountsForPlanOperation,
			OperationSummary: "List accounts for a plan",
			OperationID:      "apps/list-accounts-for-plan",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "plan_id",
					In:   "path",
				}: params.PlanID,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListAccountsForPlanParams
			Response = AppsListAccountsForPlanRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListAccountsForPlanParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListAccountsForPlan(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListAccountsForPlan(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListAccountsForPlanResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsListAccountsForPlanStubbedRequest handles apps/list-accounts-for-plan-stubbed operation.
//
// Returns repository and organization accounts associated with the specified plan, including free
// plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including
// the number of seats purchased. When someone submits a plan change that won't be processed until
// the end of their billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/stubbed/plans/{plan_id}/accounts
func (s *Server) handleAppsListAccountsForPlanStubbedRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-accounts-for-plan-stubbed"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/marketplace_listing/stubbed/plans/{plan_id}/accounts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsListAccountsForPlanStubbedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsListAccountsForPlanStubbedOperation,
			ID:   "apps/list-accounts-for-plan-stubbed",
		}
	)
	params, err := decodeAppsListAccountsForPlanStubbedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsListAccountsForPlanStubbedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsListAccountsForPlanStubbedOperation,
			OperationSummary: "List accounts for a plan (stubbed)",
			OperationID:      "apps/list-accounts-for-plan-stubbed",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "plan_id",
					In:   "path",
				}: params.PlanID,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListAccountsForPlanStubbedParams
			Response = AppsListAccountsForPlanStubbedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListAccountsForPlanStubbedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListAccountsForPlanStubbed(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListAccountsForPlanStubbed(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListAccountsForPlanStubbedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsListInstallationReposForAuthenticatedUserRequest handles apps/list-installation-repos-for-authenticated-user operation.
//
// List repositories that the authenticated user has explicit permission (`:read`, `:write`, or
// `:admin`) to access for an installation.
// The authenticated user has explicit permission to access repositories they own, repositories where
// they are a collaborator, and repositories that they can access through an organization membership.
// You must use a [user-to-server OAuth access token](https://docs.github.
// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.
// The access the user has to each repository is included in the hash under the `permissions` key.
//
// GET /user/installations/{installation_id}/repositories
func (s *Server) handleAppsListInstallationReposForAuthenticatedUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-installation-repos-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/installations/{installation_id}/repositories"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsListInstallationReposForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsListInstallationReposForAuthenticatedUserOperation,
			ID:   "apps/list-installation-repos-for-authenticated-user",
		}
	)
	params, err := decodeAppsListInstallationReposForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsListInstallationReposForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsListInstallationReposForAuthenticatedUserOperation,
			OperationSummary: "List repositories accessible to the user access token",
			OperationID:      "apps/list-installation-repos-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "installation_id",
					In:   "path",
				}: params.InstallationID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListInstallationReposForAuthenticatedUserParams
			Response = AppsListInstallationReposForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListInstallationReposForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListInstallationReposForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListInstallationReposForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListInstallationReposForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsListPlansRequest handles apps/list-plans operation.
//
// Lists all plans that are part of your GitHub Marketplace listing.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/plans
func (s *Server) handleAppsListPlansRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-plans"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/marketplace_listing/plans"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsListPlansOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsListPlansOperation,
			ID:   "apps/list-plans",
		}
	)
	params, err := decodeAppsListPlansParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsListPlansRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsListPlansOperation,
			OperationSummary: "List plans",
			OperationID:      "apps/list-plans",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListPlansParams
			Response = AppsListPlansRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListPlansParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListPlans(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListPlans(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListPlansResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsListPlansStubbedRequest handles apps/list-plans-stubbed operation.
//
// Lists all plans that are part of your GitHub Marketplace listing.
// GitHub Apps must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and
// client secret to access this endpoint.
//
// GET /marketplace_listing/stubbed/plans
func (s *Server) handleAppsListPlansStubbedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-plans-stubbed"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/marketplace_listing/stubbed/plans"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsListPlansStubbedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsListPlansStubbedOperation,
			ID:   "apps/list-plans-stubbed",
		}
	)
	params, err := decodeAppsListPlansStubbedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsListPlansStubbedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsListPlansStubbedOperation,
			OperationSummary: "List plans (stubbed)",
			OperationID:      "apps/list-plans-stubbed",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListPlansStubbedParams
			Response = AppsListPlansStubbedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListPlansStubbedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListPlansStubbed(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListPlansStubbed(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListPlansStubbedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsListReposAccessibleToInstallationRequest handles apps/list-repos-accessible-to-installation operation.
//
// List repositories that an app installation can access.
// You must use an [installation access token](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
// to access this endpoint.
//
// GET /installation/repositories
func (s *Server) handleAppsListReposAccessibleToInstallationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-repos-accessible-to-installation"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/installation/repositories"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsListReposAccessibleToInstallationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsListReposAccessibleToInstallationOperation,
			ID:   "apps/list-repos-accessible-to-installation",
		}
	)
	params, err := decodeAppsListReposAccessibleToInstallationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsListReposAccessibleToInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsListReposAccessibleToInstallationOperation,
			OperationSummary: "List repositories accessible to the app installation",
			OperationID:      "apps/list-repos-accessible-to-installation",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListReposAccessibleToInstallationParams
			Response = AppsListReposAccessibleToInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListReposAccessibleToInstallationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListReposAccessibleToInstallation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListReposAccessibleToInstallation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListReposAccessibleToInstallationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsListSubscriptionsForAuthenticatedUserRequest handles apps/list-subscriptions-for-authenticated-user operation.
//
// Lists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth
// access token](https://docs.github.
// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
//
// GET /user/marketplace_purchases
func (s *Server) handleAppsListSubscriptionsForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-subscriptions-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/marketplace_purchases"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsListSubscriptionsForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsListSubscriptionsForAuthenticatedUserOperation,
			ID:   "apps/list-subscriptions-for-authenticated-user",
		}
	)
	params, err := decodeAppsListSubscriptionsForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsListSubscriptionsForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsListSubscriptionsForAuthenticatedUserOperation,
			OperationSummary: "List subscriptions for the authenticated user",
			OperationID:      "apps/list-subscriptions-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListSubscriptionsForAuthenticatedUserParams
			Response = AppsListSubscriptionsForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListSubscriptionsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListSubscriptionsForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListSubscriptionsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListSubscriptionsForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsListSubscriptionsForAuthenticatedUserStubbedRequest handles apps/list-subscriptions-for-authenticated-user-stubbed operation.
//
// Lists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth
// access token](https://docs.github.
// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
//
// GET /user/marketplace_purchases/stubbed
func (s *Server) handleAppsListSubscriptionsForAuthenticatedUserStubbedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-subscriptions-for-authenticated-user-stubbed"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/marketplace_purchases/stubbed"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsListSubscriptionsForAuthenticatedUserStubbedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsListSubscriptionsForAuthenticatedUserStubbedOperation,
			ID:   "apps/list-subscriptions-for-authenticated-user-stubbed",
		}
	)
	params, err := decodeAppsListSubscriptionsForAuthenticatedUserStubbedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsListSubscriptionsForAuthenticatedUserStubbedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsListSubscriptionsForAuthenticatedUserStubbedOperation,
			OperationSummary: "List subscriptions for the authenticated user (stubbed)",
			OperationID:      "apps/list-subscriptions-for-authenticated-user-stubbed",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListSubscriptionsForAuthenticatedUserStubbedParams
			Response = AppsListSubscriptionsForAuthenticatedUserStubbedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListSubscriptionsForAuthenticatedUserStubbedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListSubscriptionsForAuthenticatedUserStubbed(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListSubscriptionsForAuthenticatedUserStubbed(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListSubscriptionsForAuthenticatedUserStubbedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsListWebhookDeliveriesRequest handles apps/list-webhook-deliveries operation.
//
// Returns a list of webhook deliveries for the webhook configured for a GitHub App.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// GET /app/hook/deliveries
func (s *Server) handleAppsListWebhookDeliveriesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/list-webhook-deliveries"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/app/hook/deliveries"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsListWebhookDeliveriesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsListWebhookDeliveriesOperation,
			ID:   "apps/list-webhook-deliveries",
		}
	)
	params, err := decodeAppsListWebhookDeliveriesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsListWebhookDeliveriesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsListWebhookDeliveriesOperation,
			OperationSummary: "List deliveries for an app webhook",
			OperationID:      "apps/list-webhook-deliveries",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "cursor",
					In:   "query",
				}: params.Cursor,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsListWebhookDeliveriesParams
			Response = AppsListWebhookDeliveriesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsListWebhookDeliveriesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsListWebhookDeliveries(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsListWebhookDeliveries(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsListWebhookDeliveriesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsRedeliverWebhookDeliveryRequest handles apps/redeliver-webhook-delivery operation.
//
// Redeliver a delivery for the webhook configured for a GitHub App.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// POST /app/hook/deliveries/{delivery_id}/attempts
func (s *Server) handleAppsRedeliverWebhookDeliveryRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/redeliver-webhook-delivery"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/app/hook/deliveries/{delivery_id}/attempts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsRedeliverWebhookDeliveryOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsRedeliverWebhookDeliveryOperation,
			ID:   "apps/redeliver-webhook-delivery",
		}
	)
	params, err := decodeAppsRedeliverWebhookDeliveryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsRedeliverWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsRedeliverWebhookDeliveryOperation,
			OperationSummary: "Redeliver a delivery for an app webhook",
			OperationID:      "apps/redeliver-webhook-delivery",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "delivery_id",
					In:   "path",
				}: params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsRedeliverWebhookDeliveryParams
			Response = AppsRedeliverWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsRedeliverWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsRedeliverWebhookDelivery(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsRedeliverWebhookDelivery(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsRedeliverWebhookDeliveryResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsRemoveRepoFromInstallationRequest handles apps/remove-repo-from-installation operation.
//
// Remove a single repository from an installation. The authenticated user must have admin access to
// the repository.
// You must use a personal access token (which you can create via the [command line](https://docs.
// github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic
// Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
//
// DELETE /user/installations/{installation_id}/repositories/{repository_id}
func (s *Server) handleAppsRemoveRepoFromInstallationRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/remove-repo-from-installation"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/installations/{installation_id}/repositories/{repository_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsRemoveRepoFromInstallationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsRemoveRepoFromInstallationOperation,
			ID:   "apps/remove-repo-from-installation",
		}
	)
	params, err := decodeAppsRemoveRepoFromInstallationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsRemoveRepoFromInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsRemoveRepoFromInstallationOperation,
			OperationSummary: "Remove a repository from an app installation",
			OperationID:      "apps/remove-repo-from-installation",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "installation_id",
					In:   "path",
				}: params.InstallationID,
				{
					Name: "repository_id",
					In:   "path",
				}: params.RepositoryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsRemoveRepoFromInstallationParams
			Response = AppsRemoveRepoFromInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsRemoveRepoFromInstallationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsRemoveRepoFromInstallation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsRemoveRepoFromInstallation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsRemoveRepoFromInstallationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsResetTokenRequest handles apps/reset-token operation.
//
// OAuth applications can use this API method to reset a valid OAuth token without end-user
// involvement. Applications must save the "token" property in the response because changes take
// effect immediately. You must use [Basic Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint,
// using the OAuth application's `client_id` and `client_secret` as the username and password.
// Invalid tokens will return `404 NOT FOUND`.
//
// PATCH /applications/{client_id}/token
func (s *Server) handleAppsResetTokenRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/reset-token"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/applications/{client_id}/token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsResetTokenOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsResetTokenOperation,
			ID:   "apps/reset-token",
		}
	)
	params, err := decodeAppsResetTokenParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeAppsResetTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsResetTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsResetTokenOperation,
			OperationSummary: "Reset a token",
			OperationID:      "apps/reset-token",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "client_id",
					In:   "path",
				}: params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = *AppsResetTokenReq
			Params   = AppsResetTokenParams
			Response = AppsResetTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsResetTokenParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsResetToken(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsResetToken(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsResetTokenResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsRevokeInstallationAccessTokenRequest handles apps/revoke-installation-access-token operation.
//
// Revokes the installation token you're using to authenticate as an installation and access this
// endpoint.
// Once an installation token is revoked, the token is invalidated and cannot be used. Other
// endpoints that require the revoked installation token must have a new installation token to work.
// You can create a new token using the "[Create an installation access token for an
// app](https://docs.github.com/rest/reference/apps#create-an-installation-access-token-for-an-app)"
// endpoint.
// You must use an [installation access token](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
// to access this endpoint.
//
// DELETE /installation/token
func (s *Server) handleAppsRevokeInstallationAccessTokenRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/revoke-installation-access-token"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/installation/token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsRevokeInstallationAccessTokenOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err error
	)

	var rawBody []byte

	var response *AppsRevokeInstallationAccessTokenNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsRevokeInstallationAccessTokenOperation,
			OperationSummary: "Revoke an installation access token",
			OperationID:      "apps/revoke-installation-access-token",
			Body:             nil,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *AppsRevokeInstallationAccessTokenNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.AppsRevokeInstallationAccessToken(ctx)
				return response, err
			},
		)
	} else {
		err = s.h.AppsRevokeInstallationAccessToken(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsRevokeInstallationAccessTokenResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsScopeTokenRequest handles apps/scope-token operation.
//
// Use a non-scoped user-to-server OAuth access token to create a repository scoped and/or permission
// scoped user-to-server OAuth access token. You can specify which repositories the token can access
// and which permissions are granted to the token. You must use [Basic Authentication](https://docs.
// github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this
// endpoint, using the OAuth application's `client_id` and `client_secret` as the username and
// password. Invalid tokens will return `404 NOT FOUND`.
//
// POST /applications/{client_id}/token/scoped
func (s *Server) handleAppsScopeTokenRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/scope-token"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/applications/{client_id}/token/scoped"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsScopeTokenOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsScopeTokenOperation,
			ID:   "apps/scope-token",
		}
	)
	params, err := decodeAppsScopeTokenParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeAppsScopeTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response AppsScopeTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsScopeTokenOperation,
			OperationSummary: "Create a scoped access token",
			OperationID:      "apps/scope-token",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "client_id",
					In:   "path",
				}: params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = *AppsScopeTokenReq
			Params   = AppsScopeTokenParams
			Response = AppsScopeTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsScopeTokenParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsScopeToken(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsScopeToken(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsScopeTokenResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsSuspendInstallationRequest handles apps/suspend-installation operation.
//
// Suspends a GitHub App on a user, organization, or business account, which blocks the app from
// accessing the account's resources. When a GitHub App is suspended, the app's access to the GitHub
// API or webhook events is blocked for that account.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// PUT /app/installations/{installation_id}/suspended
func (s *Server) handleAppsSuspendInstallationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/suspend-installation"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/app/installations/{installation_id}/suspended"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsSuspendInstallationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsSuspendInstallationOperation,
			ID:   "apps/suspend-installation",
		}
	)
	params, err := decodeAppsSuspendInstallationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsSuspendInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsSuspendInstallationOperation,
			OperationSummary: "Suspend an app installation",
			OperationID:      "apps/suspend-installation",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "installation_id",
					In:   "path",
				}: params.InstallationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsSuspendInstallationParams
			Response = AppsSuspendInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsSuspendInstallationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsSuspendInstallation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsSuspendInstallation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsSuspendInstallationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsUnsuspendInstallationRequest handles apps/unsuspend-installation operation.
//
// Removes a GitHub App installation suspension.
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// DELETE /app/installations/{installation_id}/suspended
func (s *Server) handleAppsUnsuspendInstallationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/unsuspend-installation"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/app/installations/{installation_id}/suspended"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsUnsuspendInstallationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsUnsuspendInstallationOperation,
			ID:   "apps/unsuspend-installation",
		}
	)
	params, err := decodeAppsUnsuspendInstallationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response AppsUnsuspendInstallationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsUnsuspendInstallationOperation,
			OperationSummary: "Unsuspend an app installation",
			OperationID:      "apps/unsuspend-installation",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "installation_id",
					In:   "path",
				}: params.InstallationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = AppsUnsuspendInstallationParams
			Response = AppsUnsuspendInstallationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAppsUnsuspendInstallationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsUnsuspendInstallation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsUnsuspendInstallation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsUnsuspendInstallationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAppsUpdateWebhookConfigForAppRequest handles apps/update-webhook-config-for-app operation.
//
// Updates the webhook configuration for a GitHub App. For more information about configuring a
// webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
// You must use a [JWT](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to
// access this endpoint.
//
// PATCH /app/hook/config
func (s *Server) handleAppsUpdateWebhookConfigForAppRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("apps/update-webhook-config-for-app"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/app/hook/config"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), AppsUpdateWebhookConfigForAppOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: AppsUpdateWebhookConfigForAppOperation,
			ID:   "apps/update-webhook-config-for-app",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeAppsUpdateWebhookConfigForAppRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    AppsUpdateWebhookConfigForAppOperation,
			OperationSummary: "Update a webhook configuration for an app",
			OperationID:      "apps/update-webhook-config-for-app",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = OptAppsUpdateWebhookConfigForAppReq
			Params   = struct{}
			Response = *WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AppsUpdateWebhookConfigForApp(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.AppsUpdateWebhookConfigForApp(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAppsUpdateWebhookConfigForAppResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleBillingGetGithubActionsBillingGheRequest handles billing/get-github-actions-billing-ghe operation.
//
// Gets the summary of the free and paid GitHub Actions minutes used.
// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners.
// Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also
// included in the usage. The usage does not include the multiplier for macOS and Windows runners and
// is not rounded up to the nearest whole minute. For more information, see "[Managing billing for
// GitHub Actions](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
// The authenticated user must be an enterprise admin.
//
// GET /enterprises/{enterprise}/settings/billing/actions
func (s *Server) handleBillingGetGithubActionsBillingGheRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-ghe"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/settings/billing/actions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), BillingGetGithubActionsBillingGheOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: BillingGetGithubActionsBillingGheOperation,
			ID:   "billing/get-github-actions-billing-ghe",
		}
	)
	params, err := decodeBillingGetGithubActionsBillingGheParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    BillingGetGithubActionsBillingGheOperation,
			OperationSummary: "Get GitHub Actions billing for an enterprise",
			OperationID:      "billing/get-github-actions-billing-ghe",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubActionsBillingGheParams
			Response = *ActionsBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubActionsBillingGheParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetGithubActionsBillingGhe(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetGithubActionsBillingGhe(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubActionsBillingGheResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleBillingGetGithubActionsBillingOrgRequest handles billing/get-github-actions-billing-org operation.
//
// Gets the summary of the free and paid GitHub Actions minutes used.
// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners.
// Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also
// included in the usage. The usage returned includes any minute multipliers for macOS and Windows
// runners, and is rounded up to the nearest whole minute. For more information, see "[Managing
// billing for GitHub Actions](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
// Access tokens must have the `repo` or `admin:org` scope.
//
// GET /orgs/{org}/settings/billing/actions
func (s *Server) handleBillingGetGithubActionsBillingOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/settings/billing/actions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), BillingGetGithubActionsBillingOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: BillingGetGithubActionsBillingOrgOperation,
			ID:   "billing/get-github-actions-billing-org",
		}
	)
	params, err := decodeBillingGetGithubActionsBillingOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    BillingGetGithubActionsBillingOrgOperation,
			OperationSummary: "Get GitHub Actions billing for an organization",
			OperationID:      "billing/get-github-actions-billing-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubActionsBillingOrgParams
			Response = *ActionsBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubActionsBillingOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetGithubActionsBillingOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetGithubActionsBillingOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubActionsBillingOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleBillingGetGithubActionsBillingUserRequest handles billing/get-github-actions-billing-user operation.
//
// Gets the summary of the free and paid GitHub Actions minutes used.
// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners.
// Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also
// included in the usage. The usage returned includes any minute multipliers for macOS and Windows
// runners, and is rounded up to the nearest whole minute. For more information, see "[Managing
// billing for GitHub Actions](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
// Access tokens must have the `user` scope.
//
// GET /users/{username}/settings/billing/actions
func (s *Server) handleBillingGetGithubActionsBillingUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-actions-billing-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/settings/billing/actions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), BillingGetGithubActionsBillingUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: BillingGetGithubActionsBillingUserOperation,
			ID:   "billing/get-github-actions-billing-user",
		}
	)
	params, err := decodeBillingGetGithubActionsBillingUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    BillingGetGithubActionsBillingUserOperation,
			OperationSummary: "Get GitHub Actions billing for a user",
			OperationID:      "billing/get-github-actions-billing-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubActionsBillingUserParams
			Response = *ActionsBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubActionsBillingUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetGithubActionsBillingUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetGithubActionsBillingUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubActionsBillingUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleBillingGetGithubPackagesBillingGheRequest handles billing/get-github-packages-billing-ghe operation.
//
// Gets the free and paid storage used for GitHub Packages in gigabytes.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// The authenticated user must be an enterprise admin.
//
// GET /enterprises/{enterprise}/settings/billing/packages
func (s *Server) handleBillingGetGithubPackagesBillingGheRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-ghe"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/settings/billing/packages"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), BillingGetGithubPackagesBillingGheOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: BillingGetGithubPackagesBillingGheOperation,
			ID:   "billing/get-github-packages-billing-ghe",
		}
	)
	params, err := decodeBillingGetGithubPackagesBillingGheParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *PackagesBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    BillingGetGithubPackagesBillingGheOperation,
			OperationSummary: "Get GitHub Packages billing for an enterprise",
			OperationID:      "billing/get-github-packages-billing-ghe",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubPackagesBillingGheParams
			Response = *PackagesBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubPackagesBillingGheParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetGithubPackagesBillingGhe(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetGithubPackagesBillingGhe(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubPackagesBillingGheResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleBillingGetGithubPackagesBillingOrgRequest handles billing/get-github-packages-billing-org operation.
//
// Gets the free and paid storage used for GitHub Packages in gigabytes.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// Access tokens must have the `repo` or `admin:org` scope.
//
// GET /orgs/{org}/settings/billing/packages
func (s *Server) handleBillingGetGithubPackagesBillingOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/settings/billing/packages"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), BillingGetGithubPackagesBillingOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: BillingGetGithubPackagesBillingOrgOperation,
			ID:   "billing/get-github-packages-billing-org",
		}
	)
	params, err := decodeBillingGetGithubPackagesBillingOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *PackagesBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    BillingGetGithubPackagesBillingOrgOperation,
			OperationSummary: "Get GitHub Packages billing for an organization",
			OperationID:      "billing/get-github-packages-billing-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubPackagesBillingOrgParams
			Response = *PackagesBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubPackagesBillingOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetGithubPackagesBillingOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetGithubPackagesBillingOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubPackagesBillingOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleBillingGetGithubPackagesBillingUserRequest handles billing/get-github-packages-billing-user operation.
//
// Gets the free and paid storage used for GitHub Packages in gigabytes.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// Access tokens must have the `user` scope.
//
// GET /users/{username}/settings/billing/packages
func (s *Server) handleBillingGetGithubPackagesBillingUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-github-packages-billing-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/settings/billing/packages"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), BillingGetGithubPackagesBillingUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: BillingGetGithubPackagesBillingUserOperation,
			ID:   "billing/get-github-packages-billing-user",
		}
	)
	params, err := decodeBillingGetGithubPackagesBillingUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *PackagesBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    BillingGetGithubPackagesBillingUserOperation,
			OperationSummary: "Get GitHub Packages billing for a user",
			OperationID:      "billing/get-github-packages-billing-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetGithubPackagesBillingUserParams
			Response = *PackagesBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetGithubPackagesBillingUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetGithubPackagesBillingUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetGithubPackagesBillingUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetGithubPackagesBillingUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleBillingGetSharedStorageBillingGheRequest handles billing/get-shared-storage-billing-ghe operation.
//
// Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// The authenticated user must be an enterprise admin.
//
// GET /enterprises/{enterprise}/settings/billing/shared-storage
func (s *Server) handleBillingGetSharedStorageBillingGheRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-ghe"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/settings/billing/shared-storage"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), BillingGetSharedStorageBillingGheOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: BillingGetSharedStorageBillingGheOperation,
			ID:   "billing/get-shared-storage-billing-ghe",
		}
	)
	params, err := decodeBillingGetSharedStorageBillingGheParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *CombinedBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    BillingGetSharedStorageBillingGheOperation,
			OperationSummary: "Get shared storage billing for an enterprise",
			OperationID:      "billing/get-shared-storage-billing-ghe",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetSharedStorageBillingGheParams
			Response = *CombinedBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetSharedStorageBillingGheParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetSharedStorageBillingGhe(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetSharedStorageBillingGhe(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetSharedStorageBillingGheResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleBillingGetSharedStorageBillingOrgRequest handles billing/get-shared-storage-billing-org operation.
//
// Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// Access tokens must have the `repo` or `admin:org` scope.
//
// GET /orgs/{org}/settings/billing/shared-storage
func (s *Server) handleBillingGetSharedStorageBillingOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/settings/billing/shared-storage"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), BillingGetSharedStorageBillingOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: BillingGetSharedStorageBillingOrgOperation,
			ID:   "billing/get-shared-storage-billing-org",
		}
	)
	params, err := decodeBillingGetSharedStorageBillingOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *CombinedBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    BillingGetSharedStorageBillingOrgOperation,
			OperationSummary: "Get shared storage billing for an organization",
			OperationID:      "billing/get-shared-storage-billing-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetSharedStorageBillingOrgParams
			Response = *CombinedBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetSharedStorageBillingOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetSharedStorageBillingOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetSharedStorageBillingOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetSharedStorageBillingOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleBillingGetSharedStorageBillingUserRequest handles billing/get-shared-storage-billing-user operation.
//
// Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
// Paid minutes only apply to packages stored for private repositories. For more information, see
// "[Managing billing for GitHub Packages](https://help.github.
// com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
// Access tokens must have the `user` scope.
//
// GET /users/{username}/settings/billing/shared-storage
func (s *Server) handleBillingGetSharedStorageBillingUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("billing/get-shared-storage-billing-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/settings/billing/shared-storage"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), BillingGetSharedStorageBillingUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: BillingGetSharedStorageBillingUserOperation,
			ID:   "billing/get-shared-storage-billing-user",
		}
	)
	params, err := decodeBillingGetSharedStorageBillingUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *CombinedBillingUsage
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    BillingGetSharedStorageBillingUserOperation,
			OperationSummary: "Get shared storage billing for a user",
			OperationID:      "billing/get-shared-storage-billing-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = BillingGetSharedStorageBillingUserParams
			Response = *CombinedBillingUsage
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackBillingGetSharedStorageBillingUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.BillingGetSharedStorageBillingUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.BillingGetSharedStorageBillingUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeBillingGetSharedStorageBillingUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleChecksCreateSuiteRequest handles checks/create-suite operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array and a `null` value for `head_branch`.
// By default, check suites are automatically created when you create a [check run](https://docs.
// github.com/rest/reference/checks#check-runs). You only need to use this endpoint for manually
// creating check suites when you've disabled automatic creation using "[Update repository
// preferences for check suites](https://docs.github.
// com/rest/reference/checks#update-repository-preferences-for-check-suites)". Your GitHub App must
// have the `checks:write` permission to create check suites.
//
// POST /repos/{owner}/{repo}/check-suites
func (s *Server) handleChecksCreateSuiteRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/create-suite"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/check-suites"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ChecksCreateSuiteOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ChecksCreateSuiteOperation,
			ID:   "checks/create-suite",
		}
	)
	params, err := decodeChecksCreateSuiteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeChecksCreateSuiteRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ChecksCreateSuiteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ChecksCreateSuiteOperation,
			OperationSummary: "Create a check suite",
			OperationID:      "checks/create-suite",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ChecksCreateSuiteReq
			Params   = ChecksCreateSuiteParams
			Response = ChecksCreateSuiteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksCreateSuiteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ChecksCreateSuite(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ChecksCreateSuite(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksCreateSuiteResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleChecksGetRequest handles checks/get operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array.
// Gets a single check run using its `id`. GitHub Apps must have the `checks:read` permission on a
// private repository or pull access to a public repository to get check runs. OAuth Apps and
// authenticated users must have the `repo` scope to get check runs in a private repository.
//
// GET /repos/{owner}/{repo}/check-runs/{check_run_id}
func (s *Server) handleChecksGetRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/check-runs/{check_run_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ChecksGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ChecksGetOperation,
			ID:   "checks/get",
		}
	)
	params, err := decodeChecksGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *CheckRun
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ChecksGetOperation,
			OperationSummary: "Get a check run",
			OperationID:      "checks/get",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "check_run_id",
					In:   "path",
				}: params.CheckRunID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksGetParams
			Response = *CheckRun
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ChecksGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ChecksGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleChecksGetSuiteRequest handles checks/get-suite operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array and a `null` value for `head_branch`.
// Gets a single check suite using its `id`. GitHub Apps must have the `checks:read` permission on a
// private repository or pull access to a public repository to get check suites. OAuth Apps and
// authenticated users must have the `repo` scope to get check suites in a private repository.
//
// GET /repos/{owner}/{repo}/check-suites/{check_suite_id}
func (s *Server) handleChecksGetSuiteRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/get-suite"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/check-suites/{check_suite_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ChecksGetSuiteOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ChecksGetSuiteOperation,
			ID:   "checks/get-suite",
		}
	)
	params, err := decodeChecksGetSuiteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *CheckSuite
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ChecksGetSuiteOperation,
			OperationSummary: "Get a check suite",
			OperationID:      "checks/get-suite",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "check_suite_id",
					In:   "path",
				}: params.CheckSuiteID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksGetSuiteParams
			Response = *CheckSuite
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksGetSuiteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ChecksGetSuite(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ChecksGetSuite(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksGetSuiteResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleChecksListAnnotationsRequest handles checks/list-annotations operation.
//
// Lists annotations for a check run using the annotation `id`. GitHub Apps must have the
// `checks:read` permission on a private repository or pull access to a public repository to get
// annotations for a check run. OAuth Apps and authenticated users must have the `repo` scope to get
// annotations for a check run in a private repository.
//
// GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations
func (s *Server) handleChecksListAnnotationsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-annotations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ChecksListAnnotationsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ChecksListAnnotationsOperation,
			ID:   "checks/list-annotations",
		}
	)
	params, err := decodeChecksListAnnotationsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ChecksListAnnotationsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ChecksListAnnotationsOperation,
			OperationSummary: "List check run annotations",
			OperationID:      "checks/list-annotations",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "check_run_id",
					In:   "path",
				}: params.CheckRunID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksListAnnotationsParams
			Response = *ChecksListAnnotationsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksListAnnotationsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ChecksListAnnotations(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ChecksListAnnotations(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksListAnnotationsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleChecksListForRefRequest handles checks/list-for-ref operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array.
// Lists check runs for a commit ref. The `ref` can be a SHA, branch name, or a tag name. GitHub Apps
// must have the `checks:read` permission on a private repository or pull access to a public
// repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get
// check runs in a private repository.
//
// GET /repos/{owner}/{repo}/commits/{ref}/check-runs
func (s *Server) handleChecksListForRefRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-for-ref"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{ref}/check-runs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ChecksListForRefOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ChecksListForRefOperation,
			ID:   "checks/list-for-ref",
		}
	)
	params, err := decodeChecksListForRefParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ChecksListForRefOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ChecksListForRefOperation,
			OperationSummary: "List check runs for a Git reference",
			OperationID:      "checks/list-for-ref",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
				{
					Name: "check_name",
					In:   "query",
				}: params.CheckName,
				{
					Name: "status",
					In:   "query",
				}: params.Status,
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "app_id",
					In:   "query",
				}: params.AppID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksListForRefParams
			Response = *ChecksListForRefOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksListForRefParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ChecksListForRef(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ChecksListForRef(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksListForRefResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleChecksListForSuiteRequest handles checks/list-for-suite operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array.
// Lists check runs for a check suite using its `id`. GitHub Apps must have the `checks:read`
// permission on a private repository or pull access to a public repository to get check runs. OAuth
// Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
//
// GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs
func (s *Server) handleChecksListForSuiteRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-for-suite"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ChecksListForSuiteOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ChecksListForSuiteOperation,
			ID:   "checks/list-for-suite",
		}
	)
	params, err := decodeChecksListForSuiteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ChecksListForSuiteOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ChecksListForSuiteOperation,
			OperationSummary: "List check runs in a check suite",
			OperationID:      "checks/list-for-suite",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "check_suite_id",
					In:   "path",
				}: params.CheckSuiteID,
				{
					Name: "check_name",
					In:   "query",
				}: params.CheckName,
				{
					Name: "status",
					In:   "query",
				}: params.Status,
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksListForSuiteParams
			Response = *ChecksListForSuiteOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksListForSuiteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ChecksListForSuite(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ChecksListForSuite(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksListForSuiteResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleChecksListSuitesForRefRequest handles checks/list-suites-for-ref operation.
//
// **Note:** The Checks API only looks for pushes in the repository where the check suite or check
// run were created. Pushes to a branch in a forked repository are not detected and return an empty
// `pull_requests` array and a `null` value for `head_branch`.
// Lists check suites for a commit `ref`. The `ref` can be a SHA, branch name, or a tag name. GitHub
// Apps must have the `checks:read` permission on a private repository or pull access to a public
// repository to list check suites. OAuth Apps and authenticated users must have the `repo` scope to
// get check suites in a private repository.
//
// GET /repos/{owner}/{repo}/commits/{ref}/check-suites
func (s *Server) handleChecksListSuitesForRefRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/list-suites-for-ref"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{ref}/check-suites"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ChecksListSuitesForRefOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ChecksListSuitesForRefOperation,
			ID:   "checks/list-suites-for-ref",
		}
	)
	params, err := decodeChecksListSuitesForRefParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ChecksListSuitesForRefOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ChecksListSuitesForRefOperation,
			OperationSummary: "List check suites for a Git reference",
			OperationID:      "checks/list-suites-for-ref",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
				{
					Name: "app_id",
					In:   "query",
				}: params.AppID,
				{
					Name: "check_name",
					In:   "query",
				}: params.CheckName,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksListSuitesForRefParams
			Response = *ChecksListSuitesForRefOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksListSuitesForRefParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ChecksListSuitesForRef(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ChecksListSuitesForRef(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksListSuitesForRefResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleChecksRerequestSuiteRequest handles checks/rerequest-suite operation.
//
// Triggers GitHub to rerequest an existing check suite, without pushing new code to a repository.
// This endpoint will trigger the [`check_suite` webhook](https://docs.github.
// com/webhooks/event-payloads/#check_suite) event with the action `rerequested`. When a check suite
// is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.
// To rerequest a check suite, your GitHub App must have the `checks:read` permission on a private
// repository or pull access to a public repository.
//
// POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest
func (s *Server) handleChecksRerequestSuiteRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/rerequest-suite"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ChecksRerequestSuiteOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ChecksRerequestSuiteOperation,
			ID:   "checks/rerequest-suite",
		}
	)
	params, err := decodeChecksRerequestSuiteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ChecksRerequestSuiteCreated
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ChecksRerequestSuiteOperation,
			OperationSummary: "Rerequest a check suite",
			OperationID:      "checks/rerequest-suite",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "check_suite_id",
					In:   "path",
				}: params.CheckSuiteID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ChecksRerequestSuiteParams
			Response = *ChecksRerequestSuiteCreated
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksRerequestSuiteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ChecksRerequestSuite(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ChecksRerequestSuite(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksRerequestSuiteResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleChecksSetSuitesPreferencesRequest handles checks/set-suites-preferences operation.
//
// Changes the default automatic flow when creating check suites. By default, a check suite is
// automatically created each time code is pushed to a repository. When you disable the automatic
// creation of check suites, you can manually [Create a check suite](https://docs.github.
// com/rest/reference/checks#create-a-check-suite). You must have admin permissions in the repository
// to set preferences for check suites.
//
// PATCH /repos/{owner}/{repo}/check-suites/preferences
func (s *Server) handleChecksSetSuitesPreferencesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checks/set-suites-preferences"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/check-suites/preferences"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ChecksSetSuitesPreferencesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ChecksSetSuitesPreferencesOperation,
			ID:   "checks/set-suites-preferences",
		}
	)
	params, err := decodeChecksSetSuitesPreferencesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeChecksSetSuitesPreferencesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *CheckSuitePreference
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ChecksSetSuitesPreferencesOperation,
			OperationSummary: "Update repository preferences for check suites",
			OperationID:      "checks/set-suites-preferences",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ChecksSetSuitesPreferencesReq
			Params   = ChecksSetSuitesPreferencesParams
			Response = *CheckSuitePreference
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackChecksSetSuitesPreferencesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ChecksSetSuitesPreferences(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ChecksSetSuitesPreferences(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeChecksSetSuitesPreferencesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCodeScanningDeleteAnalysisRequest handles code-scanning/delete-analysis operation.
//
// Deletes a specified code scanning analysis from a repository. For
// private repositories, you must use an access token with the `repo` scope. For public repositories,
// you must use an access token with `public_repo` and `repo:security_events` scopes.
// GitHub Apps must have the `security_events` write permission to use this endpoint.
// You can delete one analysis at a time.
// To delete a series of analyses, start with the most recent analysis and work backwards.
// Conceptually, the process is similar to the undo function in a text editor.
// When you list the analyses for a repository,
// one or more will be identified as deletable in the response:
// ```
// "deletable": true
// ```
// An analysis is deletable when it's the most recent in a set of analyses.
// Typically, a repository will have multiple sets of analyses
// for each enabled code scanning tool,
// where a set is determined by a unique combination of analysis values:
// * `ref`
// * `tool`
// * `analysis_key`
// * `environment`
// If you attempt to delete an analysis that is not the most recent in a set,
// you'll get a 400 response with the message:
// ```
// Analysis specified is not deletable.
// ```
// The response from a successful `DELETE` operation provides you with
// two alternative URLs for deleting the next analysis in the set
// (see the example default response below).
// Use the `next_analysis_url` URL if you want to avoid accidentally deleting the final analysis
// in the set. This is a useful option if you want to preserve at least one analysis
// for the specified tool in your repository.
// Use the `confirm_delete_url` URL if you are content to remove all analyses for a tool.
// When you delete the last analysis in a set the value of `next_analysis_url` and
// `confirm_delete_url`
// in the 200 response is `null`.
// As an example of the deletion process,
// let's imagine that you added a workflow that configured a particular code scanning tool
// to analyze the code in a repository. This tool has added 15 analyses:
// 10 on the default branch, and another 5 on a topic branch.
// You therefore have two separate sets of analyses for this tool.
// You've now decided that you want to remove all of the analyses for the tool.
// To do this you must make 15 separate deletion requests.
// To start, you must find the deletable analysis for one of the sets,
// step through deleting the analyses in that set,
// and then repeat the process for the second set.
// The procedure therefore consists of a nested loop:
// **Outer loop**:
// * List the analyses for the repository, filtered by tool.
// * Parse this list to find a deletable analysis. If found:
// **Inner loop**:
// * Delete the identified analysis.
// * Parse the response for the value of `confirm_delete_url` and, if found, use this in the next
// iteration.
// The above process assumes that you want to remove all trace of the tool's analyses from the GitHub
// user interface, for the specified repository, and it therefore uses the `confirm_delete_url` value.
//
//	Alternatively, you could use the `next_analysis_url` value, which would leave the last analysis
//
// in each set undeleted to avoid removing a tool's analysis entirely.
//
// DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
func (s *Server) handleCodeScanningDeleteAnalysisRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/delete-analysis"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), CodeScanningDeleteAnalysisOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CodeScanningDeleteAnalysisOperation,
			ID:   "code-scanning/delete-analysis",
		}
	)
	params, err := decodeCodeScanningDeleteAnalysisParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response CodeScanningDeleteAnalysisRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CodeScanningDeleteAnalysisOperation,
			OperationSummary: "Delete a code scanning analysis from a repository",
			OperationID:      "code-scanning/delete-analysis",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "analysis_id",
					In:   "path",
				}: params.AnalysisID,
				{
					Name: "confirm_delete",
					In:   "query",
				}: params.ConfirmDelete,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningDeleteAnalysisParams
			Response = CodeScanningDeleteAnalysisRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningDeleteAnalysisParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningDeleteAnalysis(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningDeleteAnalysis(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningDeleteAnalysisResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCodeScanningGetAlertRequest handles code-scanning/get-alert operation.
//
// Gets a single code scanning alert. You must use an access token with the `security_events` scope
// to use this endpoint. GitHub Apps must have the `security_events` read permission to use this
// endpoint.
// **Deprecation notice**:
// The instances field is deprecated and will, in future, not be included in the response for this
// endpoint. The example response reflects this change. The same information can now be retrieved via
// a GET request to the URL specified by `instances_url`.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
func (s *Server) handleCodeScanningGetAlertRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-alert"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), CodeScanningGetAlertOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CodeScanningGetAlertOperation,
			ID:   "code-scanning/get-alert",
		}
	)
	params, err := decodeCodeScanningGetAlertParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response CodeScanningGetAlertRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CodeScanningGetAlertOperation,
			OperationSummary: "Get a code scanning alert",
			OperationID:      "code-scanning/get-alert",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "alert_number",
					In:   "path",
				}: params.AlertNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningGetAlertParams
			Response = CodeScanningGetAlertRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningGetAlertParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningGetAlert(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningGetAlert(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningGetAlertResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCodeScanningGetAnalysisRequest handles code-scanning/get-analysis operation.
//
// Gets a specified code scanning analysis for a repository.
// You must use an access token with the `security_events` scope to use this endpoint.
// GitHub Apps must have the `security_events` read permission to use this endpoint.
// The default JSON response contains fields that describe the analysis.
// This includes the Git reference and commit SHA to which the analysis relates,
// the datetime of the analysis, the name of the code scanning tool,
// and the number of alerts.
// The `rules_count` field in the default response give the number of rules
// that were run in the analysis.
// For very old analyses this data is not available,
// and `0` is returned in this field.
// If you use the Accept header `application/sarif+json`,
// the response contains the analysis data that was uploaded.
// This is formatted as
// [SARIF version 2.1.0](https://docs.oasis-open.org/sarif/sarif/v2.1.0/cs01/sarif-v2.1.0-cs01.html).
// **Deprecation notice**:
// The `tool_name` field is deprecated and will, in future, not be included in the response for this
// endpoint. The example response reflects this change. The tool name can now be found inside the
// `tool` field.
//
// GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}
func (s *Server) handleCodeScanningGetAnalysisRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-analysis"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), CodeScanningGetAnalysisOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CodeScanningGetAnalysisOperation,
			ID:   "code-scanning/get-analysis",
		}
	)
	params, err := decodeCodeScanningGetAnalysisParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response CodeScanningGetAnalysisRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CodeScanningGetAnalysisOperation,
			OperationSummary: "Get a code scanning analysis for a repository",
			OperationID:      "code-scanning/get-analysis",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "analysis_id",
					In:   "path",
				}: params.AnalysisID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningGetAnalysisParams
			Response = CodeScanningGetAnalysisRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningGetAnalysisParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningGetAnalysis(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningGetAnalysis(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningGetAnalysisResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCodeScanningGetSarifRequest handles code-scanning/get-sarif operation.
//
// Gets information about a SARIF upload, including the status and the URL of the analysis that was
// uploaded so that you can retrieve details of the analysis. For more information, see "[Get a code
// scanning analysis for a
// repository](/rest/reference/code-scanning#get-a-code-scanning-analysis-for-a-repository)." You
// must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must
// have the `security_events` read permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}
func (s *Server) handleCodeScanningGetSarifRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/get-sarif"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), CodeScanningGetSarifOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CodeScanningGetSarifOperation,
			ID:   "code-scanning/get-sarif",
		}
	)
	params, err := decodeCodeScanningGetSarifParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response CodeScanningGetSarifRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CodeScanningGetSarifOperation,
			OperationSummary: "Get information about a SARIF upload",
			OperationID:      "code-scanning/get-sarif",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "sarif_id",
					In:   "path",
				}: params.SarifID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningGetSarifParams
			Response = CodeScanningGetSarifRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningGetSarifParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningGetSarif(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningGetSarif(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningGetSarifResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCodeScanningListAlertInstancesRequest handles code-scanning/list-alert-instances operation.
//
// Lists all instances of the specified code scanning alert. You must use an access token with the
// `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` read
// permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances
func (s *Server) handleCodeScanningListAlertInstancesRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-alert-instances"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), CodeScanningListAlertInstancesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CodeScanningListAlertInstancesOperation,
			ID:   "code-scanning/list-alert-instances",
		}
	)
	params, err := decodeCodeScanningListAlertInstancesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response CodeScanningListAlertInstancesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CodeScanningListAlertInstancesOperation,
			OperationSummary: "List instances of a code scanning alert",
			OperationID:      "code-scanning/list-alert-instances",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "alert_number",
					In:   "path",
				}: params.AlertNumber,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "ref",
					In:   "query",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningListAlertInstancesParams
			Response = CodeScanningListAlertInstancesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningListAlertInstancesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningListAlertInstances(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningListAlertInstances(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningListAlertInstancesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCodeScanningListAlertsForRepoRequest handles code-scanning/list-alerts-for-repo operation.
//
// Lists all open code scanning alerts for the default branch (usually `main`
// or `master`). You must use an access token with the `security_events` scope to use
// this endpoint. GitHub Apps must have the `security_events` read permission to use
// this endpoint.
// The response includes a `most_recent_instance` object.
// This provides details of the most recent instance of this alert
// for the default branch or for the specified Git reference
// (if you used `ref` in the request).
//
// GET /repos/{owner}/{repo}/code-scanning/alerts
func (s *Server) handleCodeScanningListAlertsForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-alerts-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/alerts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), CodeScanningListAlertsForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CodeScanningListAlertsForRepoOperation,
			ID:   "code-scanning/list-alerts-for-repo",
		}
	)
	params, err := decodeCodeScanningListAlertsForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response CodeScanningListAlertsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CodeScanningListAlertsForRepoOperation,
			OperationSummary: "List code scanning alerts for a repository",
			OperationID:      "code-scanning/list-alerts-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "tool_name",
					In:   "query",
				}: params.ToolName,
				{
					Name: "tool_guid",
					In:   "query",
				}: params.ToolGUID,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "ref",
					In:   "query",
				}: params.Ref,
				{
					Name: "state",
					In:   "query",
				}: params.State,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningListAlertsForRepoParams
			Response = CodeScanningListAlertsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningListAlertsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningListAlertsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningListAlertsForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningListAlertsForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCodeScanningListRecentAnalysesRequest handles code-scanning/list-recent-analyses operation.
//
// Lists the details of all code scanning analyses for a repository,
// starting with the most recent.
// The response is paginated and you can use the `page` and `per_page` parameters
// to list the analyses you're interested in.
// By default 30 analyses are listed per page.
// The `rules_count` field in the response give the number of rules
// that were run in the analysis.
// For very old analyses this data is not available,
// and `0` is returned in this field.
// You must use an access token with the `security_events` scope to use this endpoint.
// GitHub Apps must have the `security_events` read permission to use this endpoint.
// **Deprecation notice**:
// The `tool_name` field is deprecated and will, in future, not be included in the response for this
// endpoint. The example response reflects this change. The tool name can now be found inside the
// `tool` field.
//
// GET /repos/{owner}/{repo}/code-scanning/analyses
func (s *Server) handleCodeScanningListRecentAnalysesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/list-recent-analyses"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/analyses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), CodeScanningListRecentAnalysesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CodeScanningListRecentAnalysesOperation,
			ID:   "code-scanning/list-recent-analyses",
		}
	)
	params, err := decodeCodeScanningListRecentAnalysesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response CodeScanningListRecentAnalysesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CodeScanningListRecentAnalysesOperation,
			OperationSummary: "List code scanning analyses for a repository",
			OperationID:      "code-scanning/list-recent-analyses",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "tool_name",
					In:   "query",
				}: params.ToolName,
				{
					Name: "tool_guid",
					In:   "query",
				}: params.ToolGUID,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "ref",
					In:   "query",
				}: params.Ref,
				{
					Name: "sarif_id",
					In:   "query",
				}: params.SarifID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodeScanningListRecentAnalysesParams
			Response = CodeScanningListRecentAnalysesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningListRecentAnalysesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningListRecentAnalyses(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningListRecentAnalyses(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningListRecentAnalysesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCodeScanningUpdateAlertRequest handles code-scanning/update-alert operation.
//
// Updates the status of a single code scanning alert. You must use an access token with the
// `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` write
// permission to use this endpoint.
//
// PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}
func (s *Server) handleCodeScanningUpdateAlertRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/update-alert"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), CodeScanningUpdateAlertOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CodeScanningUpdateAlertOperation,
			ID:   "code-scanning/update-alert",
		}
	)
	params, err := decodeCodeScanningUpdateAlertParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeCodeScanningUpdateAlertRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CodeScanningUpdateAlertRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CodeScanningUpdateAlertOperation,
			OperationSummary: "Update a code scanning alert",
			OperationID:      "code-scanning/update-alert",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "alert_number",
					In:   "path",
				}: params.AlertNumber,
			},
			Raw: r,
		}

		type (
			Request  = *CodeScanningUpdateAlertReq
			Params   = CodeScanningUpdateAlertParams
			Response = CodeScanningUpdateAlertRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningUpdateAlertParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningUpdateAlert(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningUpdateAlert(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningUpdateAlertResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCodeScanningUploadSarifRequest handles code-scanning/upload-sarif operation.
//
// Uploads SARIF data containing the results of a code scanning analysis to make the results
// available in a repository. You must use an access token with the `security_events` scope to use
// this endpoint. GitHub Apps must have the `security_events` write permission to use this endpoint.
// There are two places where you can upload code scanning results.
// - If you upload to a pull request, for example `--ref refs/pull/42/merge` or `--ref
// refs/pull/42/head`, then the results appear as alerts in a pull request check. For more
// information, see "[Triaging code scanning alerts in pull
// requests](/code-security/secure-coding/triaging-code-scanning-alerts-in-pull-requests)."
// - If you upload to a branch, for example `--ref refs/heads/my-branch`, then the results appear in
// the **Security** tab for your repository. For more information, see "[Managing code scanning
// alerts for your
// repository](/code-security/secure-coding/managing-code-scanning-alerts-for-your-repository#viewing-the-alerts-for-a-repository)."
// You must compress the SARIF-formatted analysis data that you want to upload, using `gzip`, and
// then encode it as a Base64 format string. For example:
// ```
// gzip -c analysis-data.sarif | base64 -w0
// ```
// SARIF upload supports a maximum of 5000 results per analysis run. Any results over this limit are
// ignored and any SARIF uploads with more than 25,000 results are rejected. Typically, but not
// necessarily, a SARIF file contains a single run of a single tool. If a code scanning tool
// generates too many results, you should update the analysis configuration to run only the most
// important rules or queries.
// The `202 Accepted`, response includes an `id` value.
// You can use this ID to check the status of the upload by using this for the `/sarifs/{sarif_id}`
// endpoint.
// For more information, see "[Get information about a SARIF
// upload](/rest/reference/code-scanning#get-information-about-a-sarif-upload).".
//
// POST /repos/{owner}/{repo}/code-scanning/sarifs
func (s *Server) handleCodeScanningUploadSarifRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("code-scanning/upload-sarif"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/code-scanning/sarifs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), CodeScanningUploadSarifOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CodeScanningUploadSarifOperation,
			ID:   "code-scanning/upload-sarif",
		}
	)
	params, err := decodeCodeScanningUploadSarifParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeCodeScanningUploadSarifRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CodeScanningUploadSarifRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CodeScanningUploadSarifOperation,
			OperationSummary: "Upload an analysis as SARIF data",
			OperationID:      "code-scanning/upload-sarif",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *CodeScanningUploadSarifReq
			Params   = CodeScanningUploadSarifParams
			Response = CodeScanningUploadSarifRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodeScanningUploadSarifParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodeScanningUploadSarif(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodeScanningUploadSarif(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodeScanningUploadSarifResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCodesOfConductGetAllCodesOfConductRequest handles codes-of-conduct/get-all-codes-of-conduct operation.
//
// Get all codes of conduct.
//
// GET /codes_of_conduct
func (s *Server) handleCodesOfConductGetAllCodesOfConductRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("codes-of-conduct/get-all-codes-of-conduct"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/codes_of_conduct"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), CodesOfConductGetAllCodesOfConductOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err error
	)

	var rawBody []byte

	var response CodesOfConductGetAllCodesOfConductRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CodesOfConductGetAllCodesOfConductOperation,
			OperationSummary: "Get all codes of conduct",
			OperationID:      "codes-of-conduct/get-all-codes-of-conduct",
			Body:             nil,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = CodesOfConductGetAllCodesOfConductRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodesOfConductGetAllCodesOfConduct(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodesOfConductGetAllCodesOfConduct(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodesOfConductGetAllCodesOfConductResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCodesOfConductGetConductCodeRequest handles codes-of-conduct/get-conduct-code operation.
//
// Get a code of conduct.
//
// GET /codes_of_conduct/{key}
func (s *Server) handleCodesOfConductGetConductCodeRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("codes-of-conduct/get-conduct-code"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/codes_of_conduct/{key}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), CodesOfConductGetConductCodeOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CodesOfConductGetConductCodeOperation,
			ID:   "codes-of-conduct/get-conduct-code",
		}
	)
	params, err := decodeCodesOfConductGetConductCodeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response CodesOfConductGetConductCodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CodesOfConductGetConductCodeOperation,
			OperationSummary: "Get a code of conduct",
			OperationID:      "codes-of-conduct/get-conduct-code",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "key",
					In:   "path",
				}: params.Key,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CodesOfConductGetConductCodeParams
			Response = CodesOfConductGetConductCodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCodesOfConductGetConductCodeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CodesOfConductGetConductCode(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CodesOfConductGetConductCode(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCodesOfConductGetConductCodeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEmojisGetRequest handles emojis/get operation.
//
// Lists all the emojis available to use on GitHub.
//
// GET /emojis
func (s *Server) handleEmojisGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("emojis/get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/emojis"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EmojisGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err error
	)

	var rawBody []byte

	var response EmojisGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EmojisGetOperation,
			OperationSummary: "Get emojis",
			OperationID:      "emojis/get",
			Body:             nil,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = EmojisGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EmojisGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.EmojisGet(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEmojisGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// Adds an organization to the list of selected organizations that can access a self-hosted runner
// group. The runner group must have `visibility` set to `selected`. For more information, see
// "[Create a self-hosted runner group for an
// enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
func (s *Server) handleEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseOperation,
			ID:   "enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseOperation,
			OperationSummary: "Add organization access to a self-hosted runner group in an enterprise",
			OperationID:      "enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "org_id",
					In:   "path",
				}: params.OrgID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
			Response = *EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest handles enterprise-admin/add-self-hosted-runner-to-group-for-enterprise operation.
//
// Adds a self-hosted runner to a runner group configured in an enterprise.
// You must authenticate using an access token with the `admin:enterprise`
// scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) handleEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/add-self-hosted-runner-to-group-for-enterprise"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseOperation,
			ID:   "enterprise-admin/add-self-hosted-runner-to-group-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseOperation,
			OperationSummary: "Add a self-hosted runner to a group for an enterprise",
			OperationID:      "enterprise-admin/add-self-hosted-runner-to-group-for-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams
			Response = *EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminCreateRegistrationTokenForEnterpriseRequest handles enterprise-admin/create-registration-token-for-enterprise operation.
//
// Returns a token that you can pass to the `config` script. The token expires after one hour.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
// #### Example using registration token
// Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this
// endpoint.
// ```
// ./config.sh --url https://github.com/enterprises/octo-enterprise --token TOKEN
// ```.
//
// POST /enterprises/{enterprise}/actions/runners/registration-token
func (s *Server) handleEnterpriseAdminCreateRegistrationTokenForEnterpriseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-registration-token-for-enterprise"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runners/registration-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminCreateRegistrationTokenForEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminCreateRegistrationTokenForEnterpriseOperation,
			ID:   "enterprise-admin/create-registration-token-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminCreateRegistrationTokenForEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminCreateRegistrationTokenForEnterpriseOperation,
			OperationSummary: "Create a registration token for an enterprise",
			OperationID:      "enterprise-admin/create-registration-token-for-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminCreateRegistrationTokenForEnterpriseParams
			Response = *AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminCreateRegistrationTokenForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminCreateRegistrationTokenForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminCreateRegistrationTokenForEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminCreateRegistrationTokenForEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminCreateRemoveTokenForEnterpriseRequest handles enterprise-admin/create-remove-token-for-enterprise operation.
//
// Returns a token that you can pass to the `config` script to remove a self-hosted runner from an
// enterprise. The token expires after one hour.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
// #### Example using remove token
// To remove your self-hosted runner from an enterprise, replace `TOKEN` with the remove token
// provided by this
// endpoint.
// ```
// ./config.sh remove --token TOKEN
// ```.
//
// POST /enterprises/{enterprise}/actions/runners/remove-token
func (s *Server) handleEnterpriseAdminCreateRemoveTokenForEnterpriseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-remove-token-for-enterprise"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runners/remove-token"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminCreateRemoveTokenForEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminCreateRemoveTokenForEnterpriseOperation,
			ID:   "enterprise-admin/create-remove-token-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminCreateRemoveTokenForEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *AuthenticationToken
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminCreateRemoveTokenForEnterpriseOperation,
			OperationSummary: "Create a remove token for an enterprise",
			OperationID:      "enterprise-admin/create-remove-token-for-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminCreateRemoveTokenForEnterpriseParams
			Response = *AuthenticationToken
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminCreateRemoveTokenForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminCreateRemoveTokenForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminCreateRemoveTokenForEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminCreateRemoveTokenForEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest handles enterprise-admin/create-self-hosted-runner-group-for-enterprise operation.
//
// Creates a new self-hosted runner group for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// POST /enterprises/{enterprise}/actions/runner-groups
func (s *Server) handleEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/create-self-hosted-runner-group-for-enterprise"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseOperation,
			ID:   "enterprise-admin/create-self-hosted-runner-group-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *RunnerGroupsEnterprise
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseOperation,
			OperationSummary: "Create a self-hosted runner group for an enterprise",
			OperationID:      "enterprise-admin/create-self-hosted-runner-group-for-enterprise",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq
			Params   = EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams
			Response = *RunnerGroupsEnterprise
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminDeleteScimGroupFromEnterpriseRequest handles enterprise-admin/delete-scim-group-from-enterprise operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// DELETE /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) handleEnterpriseAdminDeleteScimGroupFromEnterpriseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-scim-group-from-enterprise"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminDeleteScimGroupFromEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminDeleteScimGroupFromEnterpriseOperation,
			ID:   "enterprise-admin/delete-scim-group-from-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminDeleteScimGroupFromEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminDeleteScimGroupFromEnterpriseOperation,
			OperationSummary: "Delete a SCIM group from an enterprise",
			OperationID:      "enterprise-admin/delete-scim-group-from-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "scim_group_id",
					In:   "path",
				}: params.ScimGroupID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminDeleteScimGroupFromEnterpriseParams
			Response = *EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminDeleteScimGroupFromEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminDeleteScimGroupFromEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminDeleteScimGroupFromEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteScimGroupFromEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest handles enterprise-admin/delete-self-hosted-runner-from-enterprise operation.
//
// Forces the removal of a self-hosted runner from an enterprise. You can use this endpoint to
// completely remove the runner when the machine you were using no longer exists.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/runners/{runner_id}
func (s *Server) handleEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-self-hosted-runner-from-enterprise"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runners/{runner_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseOperation,
			ID:   "enterprise-admin/delete-self-hosted-runner-from-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseOperation,
			OperationSummary: "Delete a self-hosted runner from an enterprise",
			OperationID:      "enterprise-admin/delete-self-hosted-runner-from-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams
			Response = *EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminDeleteSelfHostedRunnerFromEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest handles enterprise-admin/delete-self-hosted-runner-group-from-enterprise operation.
//
// Deletes a self-hosted runner group for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (s *Server) handleEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-self-hosted-runner-group-from-enterprise"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseOperation,
			ID:   "enterprise-admin/delete-self-hosted-runner-group-from-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseOperation,
			OperationSummary: "Delete a self-hosted runner group from an enterprise",
			OperationID:      "enterprise-admin/delete-self-hosted-runner-group-from-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams
			Response = *EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminDeleteUserFromEnterpriseRequest handles enterprise-admin/delete-user-from-enterprise operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// DELETE /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) handleEnterpriseAdminDeleteUserFromEnterpriseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/delete-user-from-enterprise"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminDeleteUserFromEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminDeleteUserFromEnterpriseOperation,
			ID:   "enterprise-admin/delete-user-from-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminDeleteUserFromEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *EnterpriseAdminDeleteUserFromEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminDeleteUserFromEnterpriseOperation,
			OperationSummary: "Delete a SCIM user from an enterprise",
			OperationID:      "enterprise-admin/delete-user-from-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "scim_user_id",
					In:   "path",
				}: params.ScimUserID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminDeleteUserFromEnterpriseParams
			Response = *EnterpriseAdminDeleteUserFromEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminDeleteUserFromEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminDeleteUserFromEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminDeleteUserFromEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminDeleteUserFromEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest handles enterprise-admin/disable-selected-organization-github-actions-enterprise operation.
//
// Removes an organization from the list of selected organizations that are enabled for GitHub
// Actions in an enterprise. To use this endpoint, the enterprise permission policy for
// `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub
// Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}
func (s *Server) handleEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/disable-selected-organization-github-actions-enterprise"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/permissions/organizations/{org_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseOperation,
			ID:   "enterprise-admin/disable-selected-organization-github-actions-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseOperation,
			OperationSummary: "Disable a selected organization for GitHub Actions in an enterprise",
			OperationID:      "enterprise-admin/disable-selected-organization-github-actions-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "org_id",
					In:   "path",
				}: params.OrgID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams
			Response = *EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest handles enterprise-admin/enable-selected-organization-github-actions-enterprise operation.
//
// Adds an organization to the list of selected organizations that are enabled for GitHub Actions in
// an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations`
// must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for
// an enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}
func (s *Server) handleEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/enable-selected-organization-github-actions-enterprise"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/permissions/organizations/{org_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseOperation,
			ID:   "enterprise-admin/enable-selected-organization-github-actions-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseOperation,
			OperationSummary: "Enable a selected organization for GitHub Actions in an enterprise",
			OperationID:      "enterprise-admin/enable-selected-organization-github-actions-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "org_id",
					In:   "path",
				}: params.OrgID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams
			Response = *EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminGetAllowedActionsEnterpriseRequest handles enterprise-admin/get-allowed-actions-enterprise operation.
//
// Gets the selected actions that are allowed in an enterprise. To use this endpoint, the enterprise
// permission policy for `allowed_actions` must be configured to `selected`. For more information,
// see "[Set GitHub Actions permissions for an
// enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/permissions/selected-actions
func (s *Server) handleEnterpriseAdminGetAllowedActionsEnterpriseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-allowed-actions-enterprise"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/permissions/selected-actions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminGetAllowedActionsEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminGetAllowedActionsEnterpriseOperation,
			ID:   "enterprise-admin/get-allowed-actions-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminGetAllowedActionsEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *SelectedActions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminGetAllowedActionsEnterpriseOperation,
			OperationSummary: "Get allowed actions for an enterprise",
			OperationID:      "enterprise-admin/get-allowed-actions-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetAllowedActionsEnterpriseParams
			Response = *SelectedActions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetAllowedActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminGetAllowedActionsEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetAllowedActionsEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetAllowedActionsEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminGetAuditLogRequest handles enterprise-admin/get-audit-log operation.
//
// Gets the audit log for an enterprise. To use this endpoint, you must be an enterprise admin, and
// you must use an access token with the `admin:enterprise` scope.
//
// GET /enterprises/{enterprise}/audit-log
func (s *Server) handleEnterpriseAdminGetAuditLogRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-audit-log"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/audit-log"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminGetAuditLogOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminGetAuditLogOperation,
			ID:   "enterprise-admin/get-audit-log",
		}
	)
	params, err := decodeEnterpriseAdminGetAuditLogParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []AuditLogEvent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminGetAuditLogOperation,
			OperationSummary: "Get the audit log for an enterprise",
			OperationID:      "enterprise-admin/get-audit-log",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "phrase",
					In:   "query",
				}: params.Phrase,
				{
					Name: "include",
					In:   "query",
				}: params.Include,
				{
					Name: "after",
					In:   "query",
				}: params.After,
				{
					Name: "before",
					In:   "query",
				}: params.Before,
				{
					Name: "order",
					In:   "query",
				}: params.Order,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetAuditLogParams
			Response = []AuditLogEvent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetAuditLogParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminGetAuditLog(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetAuditLog(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetAuditLogResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest handles enterprise-admin/get-github-actions-permissions-enterprise operation.
//
// Gets the GitHub Actions permissions policy for organizations and allowed actions in an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/permissions
func (s *Server) handleEnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-github-actions-permissions-enterprise"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/permissions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminGetGithubActionsPermissionsEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminGetGithubActionsPermissionsEnterpriseOperation,
			ID:   "enterprise-admin/get-github-actions-permissions-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ActionsEnterprisePermissions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminGetGithubActionsPermissionsEnterpriseOperation,
			OperationSummary: "Get GitHub Actions permissions for an enterprise",
			OperationID:      "enterprise-admin/get-github-actions-permissions-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams
			Response = *ActionsEnterprisePermissions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetGithubActionsPermissionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminGetGithubActionsPermissionsEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetGithubActionsPermissionsEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest handles enterprise-admin/get-provisioning-information-for-enterprise-group operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// GET /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) handleEnterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-provisioning-information-for-enterprise-group"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminGetProvisioningInformationForEnterpriseGroupOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminGetProvisioningInformationForEnterpriseGroupOperation,
			ID:   "enterprise-admin/get-provisioning-information-for-enterprise-group",
		}
	)
	params, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ScimEnterpriseGroup
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminGetProvisioningInformationForEnterpriseGroupOperation,
			OperationSummary: "Get SCIM provisioning information for an enterprise group",
			OperationID:      "enterprise-admin/get-provisioning-information-for-enterprise-group",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "scim_group_id",
					In:   "path",
				}: params.ScimGroupID,
				{
					Name: "excludedAttributes",
					In:   "query",
				}: params.ExcludedAttributes,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams
			Response = *ScimEnterpriseGroup
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminGetProvisioningInformationForEnterpriseGroup(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetProvisioningInformationForEnterpriseGroup(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminGetProvisioningInformationForEnterpriseUserRequest handles enterprise-admin/get-provisioning-information-for-enterprise-user operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// GET /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) handleEnterpriseAdminGetProvisioningInformationForEnterpriseUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-provisioning-information-for-enterprise-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminGetProvisioningInformationForEnterpriseUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminGetProvisioningInformationForEnterpriseUserOperation,
			ID:   "enterprise-admin/get-provisioning-information-for-enterprise-user",
		}
	)
	params, err := decodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ScimEnterpriseUser
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminGetProvisioningInformationForEnterpriseUserOperation,
			OperationSummary: "Get SCIM provisioning information for an enterprise user",
			OperationID:      "enterprise-admin/get-provisioning-information-for-enterprise-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "scim_user_id",
					In:   "path",
				}: params.ScimUserID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams
			Response = *ScimEnterpriseUser
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetProvisioningInformationForEnterpriseUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminGetProvisioningInformationForEnterpriseUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetProvisioningInformationForEnterpriseUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest handles enterprise-admin/get-self-hosted-runner-for-enterprise operation.
//
// Gets a specific self-hosted runner configured in an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runners/{runner_id}
func (s *Server) handleEnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-self-hosted-runner-for-enterprise"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runners/{runner_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminGetSelfHostedRunnerForEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminGetSelfHostedRunnerForEnterpriseOperation,
			ID:   "enterprise-admin/get-self-hosted-runner-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *Runner
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminGetSelfHostedRunnerForEnterpriseOperation,
			OperationSummary: "Get a self-hosted runner for an enterprise",
			OperationID:      "enterprise-admin/get-self-hosted-runner-for-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams
			Response = *Runner
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetSelfHostedRunnerForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminGetSelfHostedRunnerForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetSelfHostedRunnerForEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest handles enterprise-admin/get-self-hosted-runner-group-for-enterprise operation.
//
// Gets a specific self-hosted runner group for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (s *Server) handleEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/get-self-hosted-runner-group-for-enterprise"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseOperation,
			ID:   "enterprise-admin/get-self-hosted-runner-group-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *RunnerGroupsEnterprise
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseOperation,
			OperationSummary: "Get a self-hosted runner group for an enterprise",
			OperationID:      "enterprise-admin/get-self-hosted-runner-group-for-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams
			Response = *RunnerGroupsEnterprise
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// Lists the organizations with access to a self-hosted runner group.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
func (s *Server) handleEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOperation,
			ID:   "enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOperation,
			OperationSummary: "List organization access to a self-hosted runner group in an enterprise",
			OperationID:      "enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
			Response = *EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminListProvisionedGroupsEnterpriseRequest handles enterprise-admin/list-provisioned-groups-enterprise operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
//
// GET /scim/v2/enterprises/{enterprise}/Groups
func (s *Server) handleEnterpriseAdminListProvisionedGroupsEnterpriseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-provisioned-groups-enterprise"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Groups"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminListProvisionedGroupsEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminListProvisionedGroupsEnterpriseOperation,
			ID:   "enterprise-admin/list-provisioned-groups-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminListProvisionedGroupsEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ScimGroupListEnterprise
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminListProvisionedGroupsEnterpriseOperation,
			OperationSummary: "List provisioned SCIM groups for an enterprise",
			OperationID:      "enterprise-admin/list-provisioned-groups-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "startIndex",
					In:   "query",
				}: params.StartIndex,
				{
					Name: "count",
					In:   "query",
				}: params.Count,
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "excludedAttributes",
					In:   "query",
				}: params.ExcludedAttributes,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListProvisionedGroupsEnterpriseParams
			Response = *ScimGroupListEnterprise
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListProvisionedGroupsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminListProvisionedGroupsEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListProvisionedGroupsEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListProvisionedGroupsEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminListProvisionedIdentitiesEnterpriseRequest handles enterprise-admin/list-provisioned-identities-enterprise operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Retrieves a paginated list of all provisioned enterprise members, including pending invitations.
// When a user with a SAML-provisioned external identity leaves (or is removed from) an enterprise,
// the account's metadata is immediately removed. However, the returned list of user accounts might
// not always match the organization or enterprise member list you see on GitHub. This can happen in
// certain cases where an external identity associated with an organization will not match an
// organization member:
// - When a user with a SCIM-provisioned external identity is removed from an enterprise, the
// account's metadata is preserved to allow the user to re-join the organization in the future.
// - When inviting a user to join an organization, you can expect to see their external identity in
// the results before they accept the invitation, or if the invitation is cancelled (or never
// accepted).
// - When a user is invited over SCIM, an external identity is created that matches with the
// invitee's email address. However, this identity is only linked to a user account when the user
// accepts the invitation by going through SAML SSO.
// The returned list of external identities can include an entry for a `null` user. These are
// unlinked SAML identities that are created when a user goes through the following Single Sign-On
// (SSO) process but does not sign in to their GitHub account after completing SSO:
// 1. The user is granted access by the IdP and is not a member of the GitHub enterprise.
// 1. The user attempts to access the GitHub enterprise and initiates the SAML SSO process, and is
// not currently signed in to their GitHub account.
// 1. After successfully authenticating with the SAML SSO IdP, the `null` external identity entry is
// created and the user is prompted to sign in to their GitHub account:
// - If the user signs in, their GitHub account is linked to this entry.
// - If the user does not sign in (or does not create a new account when prompted), they are not
// added to the GitHub enterprise, and the external identity `null` entry remains in place.
//
// GET /scim/v2/enterprises/{enterprise}/Users
func (s *Server) handleEnterpriseAdminListProvisionedIdentitiesEnterpriseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-provisioned-identities-enterprise"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Users"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminListProvisionedIdentitiesEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminListProvisionedIdentitiesEnterpriseOperation,
			ID:   "enterprise-admin/list-provisioned-identities-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminListProvisionedIdentitiesEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ScimUserListEnterprise
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminListProvisionedIdentitiesEnterpriseOperation,
			OperationSummary: "List SCIM provisioned identities for an enterprise",
			OperationID:      "enterprise-admin/list-provisioned-identities-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "startIndex",
					In:   "query",
				}: params.StartIndex,
				{
					Name: "count",
					In:   "query",
				}: params.Count,
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListProvisionedIdentitiesEnterpriseParams
			Response = *ScimUserListEnterprise
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListProvisionedIdentitiesEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminListProvisionedIdentitiesEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListProvisionedIdentitiesEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListProvisionedIdentitiesEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminListRunnerApplicationsForEnterpriseRequest handles enterprise-admin/list-runner-applications-for-enterprise operation.
//
// Lists binaries for the runner application that you can download and run.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runners/downloads
func (s *Server) handleEnterpriseAdminListRunnerApplicationsForEnterpriseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-runner-applications-for-enterprise"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runners/downloads"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminListRunnerApplicationsForEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminListRunnerApplicationsForEnterpriseOperation,
			ID:   "enterprise-admin/list-runner-applications-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminListRunnerApplicationsForEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []RunnerApplication
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminListRunnerApplicationsForEnterpriseOperation,
			OperationSummary: "List runner applications for an enterprise",
			OperationID:      "enterprise-admin/list-runner-applications-for-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListRunnerApplicationsForEnterpriseParams
			Response = []RunnerApplication
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListRunnerApplicationsForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminListRunnerApplicationsForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListRunnerApplicationsForEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListRunnerApplicationsForEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest handles enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise operation.
//
// Lists the organizations that are selected to have GitHub Actions enabled in an enterprise. To use
// this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to
// `selected`. For more information, see "[Set GitHub Actions permissions for an
// enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/permissions/organizations
func (s *Server) handleEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/permissions/organizations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOperation,
			ID:   "enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOperation,
			OperationSummary: "List selected organizations enabled for GitHub Actions in an enterprise",
			OperationID:      "enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams
			Response = *EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest handles enterprise-admin/list-self-hosted-runner-groups-for-enterprise operation.
//
// Lists all self-hosted runner groups for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runner-groups
func (s *Server) handleEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runner-groups-for-enterprise"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOperation,
			ID:   "enterprise-admin/list-self-hosted-runner-groups-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOperation,
			OperationSummary: "List self-hosted runner groups for an enterprise",
			OperationID:      "enterprise-admin/list-self-hosted-runner-groups-for-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams
			Response = *EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminListSelfHostedRunnersForEnterpriseRequest handles enterprise-admin/list-self-hosted-runners-for-enterprise operation.
//
// Lists all self-hosted runners configured for an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runners
func (s *Server) handleEnterpriseAdminListSelfHostedRunnersForEnterpriseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runners-for-enterprise"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runners"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminListSelfHostedRunnersForEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminListSelfHostedRunnersForEnterpriseOperation,
			ID:   "enterprise-admin/list-self-hosted-runners-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminListSelfHostedRunnersForEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *EnterpriseAdminListSelfHostedRunnersForEnterpriseOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminListSelfHostedRunnersForEnterpriseOperation,
			OperationSummary: "List self-hosted runners for an enterprise",
			OperationID:      "enterprise-admin/list-self-hosted-runners-for-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListSelfHostedRunnersForEnterpriseParams
			Response = *EnterpriseAdminListSelfHostedRunnersForEnterpriseOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListSelfHostedRunnersForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminListSelfHostedRunnersForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListSelfHostedRunnersForEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListSelfHostedRunnersForEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest handles enterprise-admin/list-self-hosted-runners-in-group-for-enterprise operation.
//
// Lists the self-hosted runners that are in a specific enterprise group.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) handleEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/list-self-hosted-runners-in-group-for-enterprise"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOperation,
			ID:   "enterprise-admin/list-self-hosted-runners-in-group-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOperation,
			OperationSummary: "List self-hosted runners in a group for an enterprise",
			OperationID:      "enterprise-admin/list-self-hosted-runners-in-group-for-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams
			Response = *EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest handles enterprise-admin/provision-and-invite-enterprise-group operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Provision an enterprise group, and invite users to the group. This sends invitation emails to the
// email address of the invited users to join the GitHub organization that the SCIM group corresponds
// to.
//
// POST /scim/v2/enterprises/{enterprise}/Groups
func (s *Server) handleEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/provision-and-invite-enterprise-group"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Groups"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminProvisionAndInviteEnterpriseGroupOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminProvisionAndInviteEnterpriseGroupOperation,
			ID:   "enterprise-admin/provision-and-invite-enterprise-group",
		}
	)
	params, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ScimEnterpriseGroup
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminProvisionAndInviteEnterpriseGroupOperation,
			OperationSummary: "Provision a SCIM enterprise group and invite users",
			OperationID:      "enterprise-admin/provision-and-invite-enterprise-group",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminProvisionAndInviteEnterpriseGroupReq
			Params   = EnterpriseAdminProvisionAndInviteEnterpriseGroupParams
			Response = *ScimEnterpriseGroup
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminProvisionAndInviteEnterpriseGroupParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminProvisionAndInviteEnterpriseGroup(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminProvisionAndInviteEnterpriseGroup(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminProvisionAndInviteEnterpriseGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminProvisionAndInviteEnterpriseUserRequest handles enterprise-admin/provision-and-invite-enterprise-user operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Provision enterprise membership for a user, and send organization invitation emails to the email
// address.
// You can optionally include the groups a user will be invited to join. If you do not provide a list
// of `groups`, the user is provisioned for the enterprise, but no organization invitation emails
// will be sent.
//
// POST /scim/v2/enterprises/{enterprise}/Users
func (s *Server) handleEnterpriseAdminProvisionAndInviteEnterpriseUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/provision-and-invite-enterprise-user"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Users"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminProvisionAndInviteEnterpriseUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminProvisionAndInviteEnterpriseUserOperation,
			ID:   "enterprise-admin/provision-and-invite-enterprise-user",
		}
	)
	params, err := decodeEnterpriseAdminProvisionAndInviteEnterpriseUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeEnterpriseAdminProvisionAndInviteEnterpriseUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ScimEnterpriseUser
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminProvisionAndInviteEnterpriseUserOperation,
			OperationSummary: "Provision and invite a SCIM enterprise user",
			OperationID:      "enterprise-admin/provision-and-invite-enterprise-user",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminProvisionAndInviteEnterpriseUserReq
			Params   = EnterpriseAdminProvisionAndInviteEnterpriseUserParams
			Response = *ScimEnterpriseUser
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminProvisionAndInviteEnterpriseUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminProvisionAndInviteEnterpriseUser(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminProvisionAndInviteEnterpriseUser(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminProvisionAndInviteEnterpriseUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// Removes an organization from the list of selected organizations that can access a self-hosted
// runner group. The runner group must have `visibility` set to `selected`. For more information, see
// "[Create a self-hosted runner group for an
// enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}
func (s *Server) handleEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseOperation,
			ID:   "enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseOperation,
			OperationSummary: "Remove organization access to a self-hosted runner group in an enterprise",
			OperationID:      "enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "org_id",
					In:   "path",
				}: params.OrgID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
			Response = *EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest handles enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise operation.
//
// Removes a self-hosted runner from a group configured in an enterprise. The runner is then returned
// to the default group.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// DELETE /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}
func (s *Server) handleEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseOperation,
			ID:   "enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseOperation,
			OperationSummary: "Remove a self-hosted runner from a group for an enterprise",
			OperationID:      "enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
				{
					Name: "runner_id",
					In:   "path",
				}: params.RunnerID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams
			Response = *EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminSetAllowedActionsEnterpriseRequest handles enterprise-admin/set-allowed-actions-enterprise operation.
//
// Sets the actions that are allowed in an enterprise. To use this endpoint, the enterprise
// permission policy for `allowed_actions` must be configured to `selected`. For more information,
// see "[Set GitHub Actions permissions for an
// enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/permissions/selected-actions
func (s *Server) handleEnterpriseAdminSetAllowedActionsEnterpriseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-allowed-actions-enterprise"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/permissions/selected-actions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminSetAllowedActionsEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminSetAllowedActionsEnterpriseOperation,
			ID:   "enterprise-admin/set-allowed-actions-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminSetAllowedActionsEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeEnterpriseAdminSetAllowedActionsEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *EnterpriseAdminSetAllowedActionsEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminSetAllowedActionsEnterpriseOperation,
			OperationSummary: "Set allowed actions for an enterprise",
			OperationID:      "enterprise-admin/set-allowed-actions-enterprise",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = *SelectedActions
			Params   = EnterpriseAdminSetAllowedActionsEnterpriseParams
			Response = *EnterpriseAdminSetAllowedActionsEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetAllowedActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminSetAllowedActionsEnterprise(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminSetAllowedActionsEnterprise(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetAllowedActionsEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest handles enterprise-admin/set-github-actions-permissions-enterprise operation.
//
// Sets the GitHub Actions permissions policy for organizations and allowed actions in an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/permissions
func (s *Server) handleEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-github-actions-permissions-enterprise"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/permissions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminSetGithubActionsPermissionsEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminSetGithubActionsPermissionsEnterpriseOperation,
			ID:   "enterprise-admin/set-github-actions-permissions-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminSetGithubActionsPermissionsEnterpriseOperation,
			OperationSummary: "Set GitHub Actions permissions for an enterprise",
			OperationID:      "enterprise-admin/set-github-actions-permissions-enterprise",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq
			Params   = EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams
			Response = *EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetGithubActionsPermissionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminSetGithubActionsPermissionsEnterprise(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminSetGithubActionsPermissionsEnterprise(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest handles enterprise-admin/set-information-for-provisioned-enterprise-group operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Replaces an existing provisioned group’s information. You must provide all the information
// required for the group as if you were provisioning it for the first time. Any existing group
// information that you don't provide will be removed, including group membership. If you want to
// only update a specific attribute, use the [Update an attribute for a SCIM enterprise
// group](#update-an-attribute-for-a-scim-enterprise-group) endpoint instead.
//
// PUT /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) handleEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-information-for-provisioned-enterprise-group"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminSetInformationForProvisionedEnterpriseGroupOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminSetInformationForProvisionedEnterpriseGroupOperation,
			ID:   "enterprise-admin/set-information-for-provisioned-enterprise-group",
		}
	)
	params, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ScimEnterpriseGroup
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminSetInformationForProvisionedEnterpriseGroupOperation,
			OperationSummary: "Set SCIM information for a provisioned enterprise group",
			OperationID:      "enterprise-admin/set-information-for-provisioned-enterprise-group",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "scim_group_id",
					In:   "path",
				}: params.ScimGroupID,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq
			Params   = EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams
			Response = *ScimEnterpriseGroup
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminSetInformationForProvisionedEnterpriseGroup(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminSetInformationForProvisionedEnterpriseGroup(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest handles enterprise-admin/set-information-for-provisioned-enterprise-user operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Replaces an existing provisioned user's information. You must provide all the information required
// for the user as if you were provisioning them for the first time. Any existing user information
// that you don't provide will be removed. If you want to only update a specific attribute, use the
// [Update an attribute for a SCIM user](#update-an-attribute-for-an-enterprise-scim-user) endpoint
// instead.
// You must at least provide the required values for the user: `userName`, `name`, and `emails`.
// **Warning:** Setting `active: false` removes the user from the enterprise, deletes the external
// identity, and deletes the associated `{scim_user_id}`.
//
// PUT /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) handleEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-information-for-provisioned-enterprise-user"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminSetInformationForProvisionedEnterpriseUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminSetInformationForProvisionedEnterpriseUserOperation,
			ID:   "enterprise-admin/set-information-for-provisioned-enterprise-user",
		}
	)
	params, err := decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ScimEnterpriseUser
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminSetInformationForProvisionedEnterpriseUserOperation,
			OperationSummary: "Set SCIM information for a provisioned enterprise user",
			OperationID:      "enterprise-admin/set-information-for-provisioned-enterprise-user",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "scim_user_id",
					In:   "path",
				}: params.ScimUserID,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq
			Params   = EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams
			Response = *ScimEnterpriseUser
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetInformationForProvisionedEnterpriseUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminSetInformationForProvisionedEnterpriseUser(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminSetInformationForProvisionedEnterpriseUser(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest handles enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise operation.
//
// Replaces the list of organizations that have access to a self-hosted runner configured in an
// enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations
func (s *Server) handleEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseOperation,
			ID:   "enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseOperation,
			OperationSummary: "Set organization access for a self-hosted runner group in an enterprise",
			OperationID:      "enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq
			Params   = EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams
			Response = *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest handles enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise operation.
//
// Replaces the list of selected organizations that are enabled for GitHub Actions in an enterprise.
// To use this endpoint, the enterprise permission policy for `enabled_organizations` must be
// configured to `selected`. For more information, see "[Set GitHub Actions permissions for an
// enterprise](#set-github-actions-permissions-for-an-enterprise)."
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/permissions/organizations
func (s *Server) handleEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/permissions/organizations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseOperation,
			ID:   "enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseOperation,
			OperationSummary: "Set selected organizations enabled for GitHub Actions in an enterprise",
			OperationID:      "enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq
			Params   = EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams
			Response = *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest handles enterprise-admin/set-self-hosted-runners-in-group-for-enterprise operation.
//
// Replaces the list of self-hosted runners that are part of an enterprise runner group.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PUT /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners
func (s *Server) handleEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/set-self-hosted-runners-in-group-for-enterprise"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseOperation,
			ID:   "enterprise-admin/set-self-hosted-runners-in-group-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseOperation,
			OperationSummary: "Set self-hosted runners in a group for an enterprise",
			OperationID:      "enterprise-admin/set-self-hosted-runners-in-group-for-enterprise",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq
			Params   = EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams
			Response = *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.EnterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest handles enterprise-admin/update-attribute-for-enterprise-group operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Allows you to change a provisioned group’s individual attributes. To change a group’s values,
// you must provide a specific Operations JSON format that contains at least one of the add, remove,
// or replace operations. For examples and more information on the SCIM operations format, see the
// [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
//
// PATCH /scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}
func (s *Server) handleEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-attribute-for-enterprise-group"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminUpdateAttributeForEnterpriseGroupOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminUpdateAttributeForEnterpriseGroupOperation,
			ID:   "enterprise-admin/update-attribute-for-enterprise-group",
		}
	)
	params, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseGroupParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeEnterpriseAdminUpdateAttributeForEnterpriseGroupRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ScimEnterpriseGroup
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminUpdateAttributeForEnterpriseGroupOperation,
			OperationSummary: "Update an attribute for a SCIM enterprise group",
			OperationID:      "enterprise-admin/update-attribute-for-enterprise-group",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "scim_group_id",
					In:   "path",
				}: params.ScimGroupID,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminUpdateAttributeForEnterpriseGroupReq
			Params   = EnterpriseAdminUpdateAttributeForEnterpriseGroupParams
			Response = *ScimEnterpriseGroup
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminUpdateAttributeForEnterpriseGroupParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminUpdateAttributeForEnterpriseGroup(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminUpdateAttributeForEnterpriseGroup(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminUpdateAttributeForEnterpriseGroupResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminUpdateAttributeForEnterpriseUserRequest handles enterprise-admin/update-attribute-for-enterprise-user operation.
//
// **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to
// change.
// Allows you to change a provisioned user's individual attributes. To change a user's values, you
// must provide a specific `Operations` JSON format that contains at least one of the `add`, `remove`,
//
//	or `replace` operations. For examples and more information on the SCIM operations format, see the
//
// [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
// **Note:** Complicated SCIM `path` selectors that include filters are not supported. For example, a
// `path` selector defined as `"path": "emails[type eq \"work\"]"` will not work.
// **Warning:** If you set `active:false` using the `replace` operation (as shown in the JSON example
// below), it removes the user from the enterprise, deletes the external identity, and deletes the
// associated `:scim_user_id`.
// ```
// {
// "Operations":[{
// "op":"replace",
// "value":{
// "active":false
// }
// }]
// }
// ```.
//
// PATCH /scim/v2/enterprises/{enterprise}/Users/{scim_user_id}
func (s *Server) handleEnterpriseAdminUpdateAttributeForEnterpriseUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-attribute-for-enterprise-user"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminUpdateAttributeForEnterpriseUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminUpdateAttributeForEnterpriseUserOperation,
			ID:   "enterprise-admin/update-attribute-for-enterprise-user",
		}
	)
	params, err := decodeEnterpriseAdminUpdateAttributeForEnterpriseUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeEnterpriseAdminUpdateAttributeForEnterpriseUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ScimEnterpriseUser
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminUpdateAttributeForEnterpriseUserOperation,
			OperationSummary: "Update an attribute for a SCIM enterprise user",
			OperationID:      "enterprise-admin/update-attribute-for-enterprise-user",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "scim_user_id",
					In:   "path",
				}: params.ScimUserID,
			},
			Raw: r,
		}

		type (
			Request  = *EnterpriseAdminUpdateAttributeForEnterpriseUserReq
			Params   = EnterpriseAdminUpdateAttributeForEnterpriseUserParams
			Response = *ScimEnterpriseUser
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminUpdateAttributeForEnterpriseUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminUpdateAttributeForEnterpriseUser(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminUpdateAttributeForEnterpriseUser(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminUpdateAttributeForEnterpriseUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest handles enterprise-admin/update-self-hosted-runner-group-for-enterprise operation.
//
// Updates the `name` and `visibility` of a self-hosted runner group in an enterprise.
// You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
//
// PATCH /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}
func (s *Server) handleEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("enterprise-admin/update-self-hosted-runner-group-for-enterprise"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseOperation,
			ID:   "enterprise-admin/update-self-hosted-runner-group-for-enterprise",
		}
	)
	params, err := decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *RunnerGroupsEnterprise
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseOperation,
			OperationSummary: "Update a self-hosted runner group for an enterprise",
			OperationID:      "enterprise-admin/update-self-hosted-runner-group-for-enterprise",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "enterprise",
					In:   "path",
				}: params.Enterprise,
				{
					Name: "runner_group_id",
					In:   "path",
				}: params.RunnerGroupID,
			},
			Raw: r,
		}

		type (
			Request  = OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq
			Params   = EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams
			Response = *RunnerGroupsEnterprise
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsCheckIsStarredRequest handles gists/check-is-starred operation.
//
// Check if a gist is starred.
//
// GET /gists/{gist_id}/star
func (s *Server) handleGistsCheckIsStarredRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/check-is-starred"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/star"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsCheckIsStarredOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsCheckIsStarredOperation,
			ID:   "gists/check-is-starred",
		}
	)
	params, err := decodeGistsCheckIsStarredParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GistsCheckIsStarredRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsCheckIsStarredOperation,
			OperationSummary: "Check if a gist is starred",
			OperationID:      "gists/check-is-starred",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsCheckIsStarredParams
			Response = GistsCheckIsStarredRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsCheckIsStarredParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsCheckIsStarred(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsCheckIsStarred(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsCheckIsStarredResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsCreateRequest handles gists/create operation.
//
// Allows you to add a new gist with one or more files.
// **Note:** Don't name your files "gistfile" with a numerical suffix. This is the format of the
// automatic naming scheme that Gist uses internally.
//
// POST /gists
func (s *Server) handleGistsCreateRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/create"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/gists"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsCreateOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsCreateOperation,
			ID:   "gists/create",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeGistsCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GistsCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsCreateOperation,
			OperationSummary: "Create a gist",
			OperationID:      "gists/create",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *GistsCreateReq
			Params   = struct{}
			Response = GistsCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsCreate(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsCreate(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsCreateResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsCreateCommentRequest handles gists/create-comment operation.
//
// Create a gist comment.
//
// POST /gists/{gist_id}/comments
func (s *Server) handleGistsCreateCommentRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/create-comment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsCreateCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsCreateCommentOperation,
			ID:   "gists/create-comment",
		}
	)
	params, err := decodeGistsCreateCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeGistsCreateCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GistsCreateCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsCreateCommentOperation,
			OperationSummary: "Create a gist comment",
			OperationID:      "gists/create-comment",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = *GistsCreateCommentReq
			Params   = GistsCreateCommentParams
			Response = GistsCreateCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsCreateCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsCreateComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsCreateComment(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsCreateCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsDeleteRequest handles gists/delete operation.
//
// Delete a gist.
//
// DELETE /gists/{gist_id}
func (s *Server) handleGistsDeleteRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/delete"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsDeleteOperation,
			ID:   "gists/delete",
		}
	)
	params, err := decodeGistsDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GistsDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsDeleteOperation,
			OperationSummary: "Delete a gist",
			OperationID:      "gists/delete",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsDeleteParams
			Response = GistsDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsDelete(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsDeleteResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsDeleteCommentRequest handles gists/delete-comment operation.
//
// Delete a gist comment.
//
// DELETE /gists/{gist_id}/comments/{comment_id}
func (s *Server) handleGistsDeleteCommentRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/delete-comment"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/comments/{comment_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsDeleteCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsDeleteCommentOperation,
			ID:   "gists/delete-comment",
		}
	)
	params, err := decodeGistsDeleteCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GistsDeleteCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsDeleteCommentOperation,
			OperationSummary: "Delete a gist comment",
			OperationID:      "gists/delete-comment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsDeleteCommentParams
			Response = GistsDeleteCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsDeleteCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsDeleteComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsDeleteComment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsDeleteCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsForkRequest handles gists/fork operation.
//
// **Note**: This was previously `/gists/:gist_id/fork`.
//
// POST /gists/{gist_id}/forks
func (s *Server) handleGistsForkRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/fork"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/forks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsForkOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsForkOperation,
			ID:   "gists/fork",
		}
	)
	params, err := decodeGistsForkParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GistsForkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsForkOperation,
			OperationSummary: "Fork a gist",
			OperationID:      "gists/fork",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsForkParams
			Response = GistsForkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsForkParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsFork(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsFork(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsForkResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsGetRequest handles gists/get operation.
//
// Get a gist.
//
// GET /gists/{gist_id}
func (s *Server) handleGistsGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsGetOperation,
			ID:   "gists/get",
		}
	)
	params, err := decodeGistsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GistsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsGetOperation,
			OperationSummary: "Get a gist",
			OperationID:      "gists/get",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsGetParams
			Response = GistsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsGetCommentRequest handles gists/get-comment operation.
//
// Get a gist comment.
//
// GET /gists/{gist_id}/comments/{comment_id}
func (s *Server) handleGistsGetCommentRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get-comment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/comments/{comment_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsGetCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsGetCommentOperation,
			ID:   "gists/get-comment",
		}
	)
	params, err := decodeGistsGetCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GistsGetCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsGetCommentOperation,
			OperationSummary: "Get a gist comment",
			OperationID:      "gists/get-comment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsGetCommentParams
			Response = GistsGetCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsGetCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsGetComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsGetComment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsGetCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsGetRevisionRequest handles gists/get-revision operation.
//
// Get a gist revision.
//
// GET /gists/{gist_id}/{sha}
func (s *Server) handleGistsGetRevisionRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/get-revision"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/{sha}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsGetRevisionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsGetRevisionOperation,
			ID:   "gists/get-revision",
		}
	)
	params, err := decodeGistsGetRevisionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GistsGetRevisionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsGetRevisionOperation,
			OperationSummary: "Get a gist revision",
			OperationID:      "gists/get-revision",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
				{
					Name: "sha",
					In:   "path",
				}: params.Sha,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsGetRevisionParams
			Response = GistsGetRevisionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsGetRevisionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsGetRevision(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsGetRevision(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsGetRevisionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsListRequest handles gists/list operation.
//
// Lists the authenticated user's gists or if called anonymously, this endpoint returns all public
// gists:.
//
// GET /gists
func (s *Server) handleGistsListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsListOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsListOperation,
			ID:   "gists/list",
		}
	)
	params, err := decodeGistsListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GistsListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsListOperation,
			OperationSummary: "List gists for the authenticated user",
			OperationID:      "gists/list",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListParams
			Response = GistsListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsListCommentsRequest handles gists/list-comments operation.
//
// List gist comments.
//
// GET /gists/{gist_id}/comments
func (s *Server) handleGistsListCommentsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-comments"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsListCommentsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsListCommentsOperation,
			ID:   "gists/list-comments",
		}
	)
	params, err := decodeGistsListCommentsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GistsListCommentsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsListCommentsOperation,
			OperationSummary: "List gist comments",
			OperationID:      "gists/list-comments",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListCommentsParams
			Response = GistsListCommentsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListCommentsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsListComments(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsListComments(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListCommentsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsListCommitsRequest handles gists/list-commits operation.
//
// List gist commits.
//
// GET /gists/{gist_id}/commits
func (s *Server) handleGistsListCommitsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-commits"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/commits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsListCommitsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsListCommitsOperation,
			ID:   "gists/list-commits",
		}
	)
	params, err := decodeGistsListCommitsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GistsListCommitsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsListCommitsOperation,
			OperationSummary: "List gist commits",
			OperationID:      "gists/list-commits",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListCommitsParams
			Response = GistsListCommitsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListCommitsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsListCommits(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsListCommits(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListCommitsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsListForUserRequest handles gists/list-for-user operation.
//
// Lists public gists for the specified user:.
//
// GET /users/{username}/gists
func (s *Server) handleGistsListForUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/gists"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsListForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsListForUserOperation,
			ID:   "gists/list-for-user",
		}
	)
	params, err := decodeGistsListForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GistsListForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsListForUserOperation,
			OperationSummary: "List gists for a user",
			OperationID:      "gists/list-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListForUserParams
			Response = GistsListForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsListForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsListForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsListForksRequest handles gists/list-forks operation.
//
// List gist forks.
//
// GET /gists/{gist_id}/forks
func (s *Server) handleGistsListForksRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-forks"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/forks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsListForksOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsListForksOperation,
			ID:   "gists/list-forks",
		}
	)
	params, err := decodeGistsListForksParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GistsListForksRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsListForksOperation,
			OperationSummary: "List gist forks",
			OperationID:      "gists/list-forks",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListForksParams
			Response = GistsListForksRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListForksParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsListForks(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsListForks(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListForksResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsListPublicRequest handles gists/list-public operation.
//
// List public gists sorted by most recently updated to least recently updated.
// Note: With [pagination](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#pagination), you can fetch up to 3000 gists. For
// example, you can fetch 100 pages with 30 gists per page or 30 pages with 100 gists per page.
//
// GET /gists/public
func (s *Server) handleGistsListPublicRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-public"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/public"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsListPublicOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsListPublicOperation,
			ID:   "gists/list-public",
		}
	)
	params, err := decodeGistsListPublicParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GistsListPublicRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsListPublicOperation,
			OperationSummary: "List public gists",
			OperationID:      "gists/list-public",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListPublicParams
			Response = GistsListPublicRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListPublicParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsListPublic(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsListPublic(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListPublicResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsListStarredRequest handles gists/list-starred operation.
//
// List the authenticated user's starred gists:.
//
// GET /gists/starred
func (s *Server) handleGistsListStarredRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/list-starred"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gists/starred"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsListStarredOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsListStarredOperation,
			ID:   "gists/list-starred",
		}
	)
	params, err := decodeGistsListStarredParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GistsListStarredRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsListStarredOperation,
			OperationSummary: "List starred gists",
			OperationID:      "gists/list-starred",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsListStarredParams
			Response = GistsListStarredRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsListStarredParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsListStarred(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsListStarred(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsListStarredResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsStarRequest handles gists/star operation.
//
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /gists/{gist_id}/star
func (s *Server) handleGistsStarRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/star"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/star"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsStarOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsStarOperation,
			ID:   "gists/star",
		}
	)
	params, err := decodeGistsStarParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GistsStarRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsStarOperation,
			OperationSummary: "Star a gist",
			OperationID:      "gists/star",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsStarParams
			Response = GistsStarRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsStarParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsStar(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsStar(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsStarResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsUnstarRequest handles gists/unstar operation.
//
// Unstar a gist.
//
// DELETE /gists/{gist_id}/star
func (s *Server) handleGistsUnstarRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/unstar"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/star"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsUnstarOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsUnstarOperation,
			ID:   "gists/unstar",
		}
	)
	params, err := decodeGistsUnstarParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GistsUnstarRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsUnstarOperation,
			OperationSummary: "Unstar a gist",
			OperationID:      "gists/unstar",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GistsUnstarParams
			Response = GistsUnstarRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsUnstarParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsUnstar(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsUnstar(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsUnstarResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGistsUpdateCommentRequest handles gists/update-comment operation.
//
// Update a gist comment.
//
// PATCH /gists/{gist_id}/comments/{comment_id}
func (s *Server) handleGistsUpdateCommentRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gists/update-comment"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/gists/{gist_id}/comments/{comment_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GistsUpdateCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GistsUpdateCommentOperation,
			ID:   "gists/update-comment",
		}
	)
	params, err := decodeGistsUpdateCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeGistsUpdateCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GistsUpdateCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GistsUpdateCommentOperation,
			OperationSummary: "Update a gist comment",
			OperationID:      "gists/update-comment",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "gist_id",
					In:   "path",
				}: params.GistID,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = *GistsUpdateCommentReq
			Params   = GistsUpdateCommentParams
			Response = GistsUpdateCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGistsUpdateCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GistsUpdateComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GistsUpdateComment(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGistsUpdateCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGitCreateBlobRequest handles git/create-blob operation.
//
// Create a blob.
//
// POST /repos/{owner}/{repo}/git/blobs
func (s *Server) handleGitCreateBlobRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-blob"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/blobs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GitCreateBlobOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GitCreateBlobOperation,
			ID:   "git/create-blob",
		}
	)
	params, err := decodeGitCreateBlobParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeGitCreateBlobRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitCreateBlobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GitCreateBlobOperation,
			OperationSummary: "Create a blob",
			OperationID:      "git/create-blob",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *GitCreateBlobReq
			Params   = GitCreateBlobParams
			Response = GitCreateBlobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitCreateBlobParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitCreateBlob(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitCreateBlob(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitCreateBlobResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGitCreateCommitRequest handles git/create-commit operation.
//
// Creates a new Git [commit object](https://git-scm.
// com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// POST /repos/{owner}/{repo}/git/commits
func (s *Server) handleGitCreateCommitRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-commit"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/commits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GitCreateCommitOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GitCreateCommitOperation,
			ID:   "git/create-commit",
		}
	)
	params, err := decodeGitCreateCommitParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeGitCreateCommitRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitCreateCommitRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GitCreateCommitOperation,
			OperationSummary: "Create a commit",
			OperationID:      "git/create-commit",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *GitCreateCommitReq
			Params   = GitCreateCommitParams
			Response = GitCreateCommitRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitCreateCommitParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitCreateCommit(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitCreateCommit(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitCreateCommitResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGitCreateRefRequest handles git/create-ref operation.
//
// Creates a reference for your repository. You are unable to create new references for empty
// repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories
// without branches.
//
// POST /repos/{owner}/{repo}/git/refs
func (s *Server) handleGitCreateRefRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-ref"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/refs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GitCreateRefOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GitCreateRefOperation,
			ID:   "git/create-ref",
		}
	)
	params, err := decodeGitCreateRefParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeGitCreateRefRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitCreateRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GitCreateRefOperation,
			OperationSummary: "Create a reference",
			OperationID:      "git/create-ref",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *GitCreateRefReq
			Params   = GitCreateRefParams
			Response = GitCreateRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitCreateRefParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitCreateRef(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitCreateRef(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitCreateRefResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGitCreateTagRequest handles git/create-tag operation.
//
// Note that creating a tag object does not create the reference that makes a tag in Git. If you want
// to create an annotated tag in Git, you have to do this call to create the tag object, and then
// [create](https://docs.github.com/rest/reference/git#create-a-reference) the `refs/tags/[tag]`
// reference. If you want to create a lightweight tag, you only have to [create](https://docs.github.
// com/rest/reference/git#create-a-reference) the tag reference - this call would be unnecessary.
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// POST /repos/{owner}/{repo}/git/tags
func (s *Server) handleGitCreateTagRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-tag"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/tags"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GitCreateTagOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GitCreateTagOperation,
			ID:   "git/create-tag",
		}
	)
	params, err := decodeGitCreateTagParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeGitCreateTagRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitCreateTagRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GitCreateTagOperation,
			OperationSummary: "Create a tag object",
			OperationID:      "git/create-tag",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *GitCreateTagReq
			Params   = GitCreateTagParams
			Response = GitCreateTagRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitCreateTagParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitCreateTag(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitCreateTag(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitCreateTagResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGitCreateTreeRequest handles git/create-tree operation.
//
// The tree creation API accepts nested entries. If you specify both a tree and a nested path
// modifying that tree, this endpoint will overwrite the contents of the tree with the new path
// contents, and create a new tree structure.
// If you use this endpoint to add, delete, or modify the file contents in a tree, you will need to
// commit the tree and then update a branch to point to the commit. For more information see "[Create
// a commit](https://docs.github.com/rest/reference/git#create-a-commit)" and "[Update a
// reference](https://docs.github.com/rest/reference/git#update-a-reference).".
//
// POST /repos/{owner}/{repo}/git/trees
func (s *Server) handleGitCreateTreeRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/create-tree"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/trees"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GitCreateTreeOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GitCreateTreeOperation,
			ID:   "git/create-tree",
		}
	)
	params, err := decodeGitCreateTreeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeGitCreateTreeRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitCreateTreeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GitCreateTreeOperation,
			OperationSummary: "Create a tree",
			OperationID:      "git/create-tree",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *GitCreateTreeReq
			Params   = GitCreateTreeParams
			Response = GitCreateTreeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitCreateTreeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitCreateTree(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitCreateTree(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitCreateTreeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGitDeleteRefRequest handles git/delete-ref operation.
//
// Delete a reference.
//
// DELETE /repos/{owner}/{repo}/git/refs/{ref}
func (s *Server) handleGitDeleteRefRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/delete-ref"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/refs/{ref}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GitDeleteRefOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GitDeleteRefOperation,
			ID:   "git/delete-ref",
		}
	)
	params, err := decodeGitDeleteRefParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GitDeleteRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GitDeleteRefOperation,
			OperationSummary: "Delete a reference",
			OperationID:      "git/delete-ref",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitDeleteRefParams
			Response = GitDeleteRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitDeleteRefParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitDeleteRef(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitDeleteRef(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitDeleteRefResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGitGetBlobRequest handles git/get-blob operation.
//
// The `content` in the response will always be Base64 encoded.
// _Note_: This API supports blobs up to 100 megabytes in size.
//
// GET /repos/{owner}/{repo}/git/blobs/{file_sha}
func (s *Server) handleGitGetBlobRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-blob"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/blobs/{file_sha}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GitGetBlobOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GitGetBlobOperation,
			ID:   "git/get-blob",
		}
	)
	params, err := decodeGitGetBlobParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GitGetBlobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GitGetBlobOperation,
			OperationSummary: "Get a blob",
			OperationID:      "git/get-blob",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "file_sha",
					In:   "path",
				}: params.FileSha,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitGetBlobParams
			Response = GitGetBlobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitGetBlobParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitGetBlob(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitGetBlob(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitGetBlobResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGitGetCommitRequest handles git/get-commit operation.
//
// Gets a Git [commit object](https://git-scm.
// com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/git/commits/{commit_sha}
func (s *Server) handleGitGetCommitRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-commit"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/commits/{commit_sha}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GitGetCommitOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GitGetCommitOperation,
			ID:   "git/get-commit",
		}
	)
	params, err := decodeGitGetCommitParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GitGetCommitRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GitGetCommitOperation,
			OperationSummary: "Get a commit",
			OperationID:      "git/get-commit",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "commit_sha",
					In:   "path",
				}: params.CommitSha,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitGetCommitParams
			Response = GitGetCommitRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitGetCommitParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitGetCommit(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitGetCommit(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitGetCommitResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGitGetRefRequest handles git/get-ref operation.
//
// Returns a single reference from your Git database. The `:ref` in the URL must be formatted as
// `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't match an
// existing ref, a `404` is returned.
// **Note:** You need to explicitly [request a pull request](https://docs.github.
// com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the
// mergeability of pull requests. For more information, see "[Checking mergeability of pull
// requests](https://docs.github.
// com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
//
// GET /repos/{owner}/{repo}/git/ref/{ref}
func (s *Server) handleGitGetRefRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-ref"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/ref/{ref}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GitGetRefOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GitGetRefOperation,
			ID:   "git/get-ref",
		}
	)
	params, err := decodeGitGetRefParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GitGetRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GitGetRefOperation,
			OperationSummary: "Get a reference",
			OperationID:      "git/get-ref",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitGetRefParams
			Response = GitGetRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitGetRefParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitGetRef(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitGetRef(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitGetRefResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGitGetTagRequest handles git/get-tag operation.
//
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/git/tags/{tag_sha}
func (s *Server) handleGitGetTagRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-tag"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/tags/{tag_sha}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GitGetTagOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GitGetTagOperation,
			ID:   "git/get-tag",
		}
	)
	params, err := decodeGitGetTagParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GitGetTagRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GitGetTagOperation,
			OperationSummary: "Get a tag",
			OperationID:      "git/get-tag",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "tag_sha",
					In:   "path",
				}: params.TagSha,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitGetTagParams
			Response = GitGetTagRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitGetTagParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitGetTag(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitGetTag(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitGetTagResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGitGetTreeRequest handles git/get-tree operation.
//
// Returns a single tree using the SHA1 value for that tree.
// If `truncated` is `true` in the response then the number of items in the `tree` array exceeded our
// maximum limit. If you need to fetch more items, use the non-recursive method of fetching trees,
// and fetch one sub-tree at a time.
//
// GET /repos/{owner}/{repo}/git/trees/{tree_sha}
func (s *Server) handleGitGetTreeRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/get-tree"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/trees/{tree_sha}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GitGetTreeOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GitGetTreeOperation,
			ID:   "git/get-tree",
		}
	)
	params, err := decodeGitGetTreeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GitGetTreeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GitGetTreeOperation,
			OperationSummary: "Get a tree",
			OperationID:      "git/get-tree",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "tree_sha",
					In:   "path",
				}: params.TreeSha,
				{
					Name: "recursive",
					In:   "query",
				}: params.Recursive,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitGetTreeParams
			Response = GitGetTreeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitGetTreeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitGetTree(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitGetTree(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitGetTreeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGitListMatchingRefsRequest handles git/list-matching-refs operation.
//
// Returns an array of references from your Git database that match the supplied name. The `:ref` in
// the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If
// the `:ref` doesn't exist in the repository, but existing refs start with `:ref`, they will be
// returned as an array.
// When you use this endpoint without providing a `:ref`, it will return an array of all the
// references from your Git database, including notes and stashes if they exist on the server.
// Anything in the namespace is returned, not just `heads` and `tags`.
// **Note:** You need to explicitly [request a pull request](https://docs.github.
// com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the
// mergeability of pull requests. For more information, see "[Checking mergeability of pull
// requests](https://docs.github.
// com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
// If you request matching references for a branch named `feature` but the branch `feature` doesn't
// exist, the response can still include other matching head refs that start with the word `feature`,
// such as `featureA` and `featureB`.
//
// GET /repos/{owner}/{repo}/git/matching-refs/{ref}
func (s *Server) handleGitListMatchingRefsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/list-matching-refs"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/matching-refs/{ref}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GitListMatchingRefsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GitListMatchingRefsOperation,
			ID:   "git/list-matching-refs",
		}
	)
	params, err := decodeGitListMatchingRefsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *GitListMatchingRefsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GitListMatchingRefsOperation,
			OperationSummary: "List matching references",
			OperationID:      "git/list-matching-refs",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitListMatchingRefsParams
			Response = *GitListMatchingRefsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitListMatchingRefsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitListMatchingRefs(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitListMatchingRefs(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitListMatchingRefsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGitUpdateRefRequest handles git/update-ref operation.
//
// Update a reference.
//
// PATCH /repos/{owner}/{repo}/git/refs/{ref}
func (s *Server) handleGitUpdateRefRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("git/update-ref"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/git/refs/{ref}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GitUpdateRefOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GitUpdateRefOperation,
			ID:   "git/update-ref",
		}
	)
	params, err := decodeGitUpdateRefParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeGitUpdateRefRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response GitUpdateRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GitUpdateRefOperation,
			OperationSummary: "Update a reference",
			OperationID:      "git/update-ref",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = *GitUpdateRefReq
			Params   = GitUpdateRefParams
			Response = GitUpdateRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitUpdateRefParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitUpdateRef(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitUpdateRef(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitUpdateRefResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGitignoreGetAllTemplatesRequest handles gitignore/get-all-templates operation.
//
// List all templates available to pass as an option when [creating a repository](https://docs.github.
// com/rest/reference/repos#create-a-repository-for-the-authenticated-user).
//
// GET /gitignore/templates
func (s *Server) handleGitignoreGetAllTemplatesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gitignore/get-all-templates"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gitignore/templates"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GitignoreGetAllTemplatesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err error
	)

	var rawBody []byte

	var response GitignoreGetAllTemplatesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GitignoreGetAllTemplatesOperation,
			OperationSummary: "Get all gitignore templates",
			OperationID:      "gitignore/get-all-templates",
			Body:             nil,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = GitignoreGetAllTemplatesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitignoreGetAllTemplates(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitignoreGetAllTemplates(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitignoreGetAllTemplatesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGitignoreGetTemplateRequest handles gitignore/get-template operation.
//
// The API also allows fetching the source of a single template.
// Use the raw [media type](https://docs.github.com/rest/overview/media-types/) to get the raw
// contents.
//
// GET /gitignore/templates/{name}
func (s *Server) handleGitignoreGetTemplateRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("gitignore/get-template"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/gitignore/templates/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), GitignoreGetTemplateOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GitignoreGetTemplateOperation,
			ID:   "gitignore/get-template",
		}
	)
	params, err := decodeGitignoreGetTemplateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response GitignoreGetTemplateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GitignoreGetTemplateOperation,
			OperationSummary: "Get a gitignore template",
			OperationID:      "gitignore/get-template",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GitignoreGetTemplateParams
			Response = GitignoreGetTemplateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGitignoreGetTemplateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GitignoreGetTemplate(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GitignoreGetTemplate(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGitignoreGetTemplateResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleInteractionsRemoveRestrictionsForAuthenticatedUserRequest handles interactions/remove-restrictions-for-authenticated-user operation.
//
// Removes any interaction restrictions from your public repositories.
//
// DELETE /user/interaction-limits
func (s *Server) handleInteractionsRemoveRestrictionsForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/interaction-limits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), InteractionsRemoveRestrictionsForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err error
	)

	var rawBody []byte

	var response *InteractionsRemoveRestrictionsForAuthenticatedUserNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    InteractionsRemoveRestrictionsForAuthenticatedUserOperation,
			OperationSummary: "Remove interaction restrictions from your public repositories",
			OperationID:      "interactions/remove-restrictions-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *InteractionsRemoveRestrictionsForAuthenticatedUserNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.InteractionsRemoveRestrictionsForAuthenticatedUser(ctx)
				return response, err
			},
		)
	} else {
		err = s.h.InteractionsRemoveRestrictionsForAuthenticatedUser(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsRemoveRestrictionsForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleInteractionsRemoveRestrictionsForOrgRequest handles interactions/remove-restrictions-for-org operation.
//
// Removes all interaction restrictions from public repositories in the given organization. You must
// be an organization owner to remove restrictions.
//
// DELETE /orgs/{org}/interaction-limits
func (s *Server) handleInteractionsRemoveRestrictionsForOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-org"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/interaction-limits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), InteractionsRemoveRestrictionsForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: InteractionsRemoveRestrictionsForOrgOperation,
			ID:   "interactions/remove-restrictions-for-org",
		}
	)
	params, err := decodeInteractionsRemoveRestrictionsForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *InteractionsRemoveRestrictionsForOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    InteractionsRemoveRestrictionsForOrgOperation,
			OperationSummary: "Remove interaction restrictions for an organization",
			OperationID:      "interactions/remove-restrictions-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = InteractionsRemoveRestrictionsForOrgParams
			Response = *InteractionsRemoveRestrictionsForOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackInteractionsRemoveRestrictionsForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.InteractionsRemoveRestrictionsForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.InteractionsRemoveRestrictionsForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsRemoveRestrictionsForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleInteractionsRemoveRestrictionsForRepoRequest handles interactions/remove-restrictions-for-repo operation.
//
// Removes all interaction restrictions from the given repository. You must have owner or admin
// access to remove restrictions. If the interaction limit is set for the user or organization that
// owns this repository, you will receive a `409 Conflict` response and will not be able to use this
// endpoint to change the interaction limit for a single repository.
//
// DELETE /repos/{owner}/{repo}/interaction-limits
func (s *Server) handleInteractionsRemoveRestrictionsForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/remove-restrictions-for-repo"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/interaction-limits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), InteractionsRemoveRestrictionsForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: InteractionsRemoveRestrictionsForRepoOperation,
			ID:   "interactions/remove-restrictions-for-repo",
		}
	)
	params, err := decodeInteractionsRemoveRestrictionsForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response InteractionsRemoveRestrictionsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    InteractionsRemoveRestrictionsForRepoOperation,
			OperationSummary: "Remove interaction restrictions for a repository",
			OperationID:      "interactions/remove-restrictions-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = InteractionsRemoveRestrictionsForRepoParams
			Response = InteractionsRemoveRestrictionsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackInteractionsRemoveRestrictionsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.InteractionsRemoveRestrictionsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.InteractionsRemoveRestrictionsForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsRemoveRestrictionsForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleInteractionsSetRestrictionsForAuthenticatedUserRequest handles interactions/set-restrictions-for-authenticated-user operation.
//
// Temporarily restricts which type of GitHub user can interact with your public repositories.
// Setting the interaction limit at the user level will overwrite any interaction limits that are set
// for individual repositories owned by the user.
//
// PUT /user/interaction-limits
func (s *Server) handleInteractionsSetRestrictionsForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/user/interaction-limits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), InteractionsSetRestrictionsForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: InteractionsSetRestrictionsForAuthenticatedUserOperation,
			ID:   "interactions/set-restrictions-for-authenticated-user",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeInteractionsSetRestrictionsForAuthenticatedUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response InteractionsSetRestrictionsForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    InteractionsSetRestrictionsForAuthenticatedUserOperation,
			OperationSummary: "Set interaction restrictions for your public repositories",
			OperationID:      "interactions/set-restrictions-for-authenticated-user",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *InteractionLimit
			Params   = struct{}
			Response = InteractionsSetRestrictionsForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.InteractionsSetRestrictionsForAuthenticatedUser(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.InteractionsSetRestrictionsForAuthenticatedUser(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsSetRestrictionsForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleInteractionsSetRestrictionsForOrgRequest handles interactions/set-restrictions-for-org operation.
//
// Temporarily restricts interactions to a certain type of GitHub user in any public repository in
// the given organization. You must be an organization owner to set these restrictions. Setting the
// interaction limit at the organization level will overwrite any interaction limits that are set for
// individual repositories owned by the organization.
//
// PUT /orgs/{org}/interaction-limits
func (s *Server) handleInteractionsSetRestrictionsForOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-org"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/interaction-limits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), InteractionsSetRestrictionsForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: InteractionsSetRestrictionsForOrgOperation,
			ID:   "interactions/set-restrictions-for-org",
		}
	)
	params, err := decodeInteractionsSetRestrictionsForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeInteractionsSetRestrictionsForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response InteractionsSetRestrictionsForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    InteractionsSetRestrictionsForOrgOperation,
			OperationSummary: "Set interaction restrictions for an organization",
			OperationID:      "interactions/set-restrictions-for-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *InteractionLimit
			Params   = InteractionsSetRestrictionsForOrgParams
			Response = InteractionsSetRestrictionsForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackInteractionsSetRestrictionsForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.InteractionsSetRestrictionsForOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.InteractionsSetRestrictionsForOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsSetRestrictionsForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleInteractionsSetRestrictionsForRepoRequest handles interactions/set-restrictions-for-repo operation.
//
// Temporarily restricts interactions to a certain type of GitHub user within the given repository.
// You must have owner or admin access to set these restrictions. If an interaction limit is set for
// the user or organization that owns this repository, you will receive a `409 Conflict` response and
// will not be able to use this endpoint to change the interaction limit for a single repository.
//
// PUT /repos/{owner}/{repo}/interaction-limits
func (s *Server) handleInteractionsSetRestrictionsForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("interactions/set-restrictions-for-repo"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/interaction-limits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), InteractionsSetRestrictionsForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: InteractionsSetRestrictionsForRepoOperation,
			ID:   "interactions/set-restrictions-for-repo",
		}
	)
	params, err := decodeInteractionsSetRestrictionsForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeInteractionsSetRestrictionsForRepoRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response InteractionsSetRestrictionsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    InteractionsSetRestrictionsForRepoOperation,
			OperationSummary: "Set interaction restrictions for a repository",
			OperationID:      "interactions/set-restrictions-for-repo",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *InteractionLimit
			Params   = InteractionsSetRestrictionsForRepoParams
			Response = InteractionsSetRestrictionsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackInteractionsSetRestrictionsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.InteractionsSetRestrictionsForRepo(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.InteractionsSetRestrictionsForRepo(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeInteractionsSetRestrictionsForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesAddAssigneesRequest handles issues/add-assignees operation.
//
// Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/assignees
func (s *Server) handleIssuesAddAssigneesRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/add-assignees"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/assignees"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesAddAssigneesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesAddAssigneesOperation,
			ID:   "issues/add-assignees",
		}
	)
	params, err := decodeIssuesAddAssigneesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeIssuesAddAssigneesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *IssueSimple
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesAddAssigneesOperation,
			OperationSummary: "Add assignees to an issue",
			OperationID:      "issues/add-assignees",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptIssuesAddAssigneesReq
			Params   = IssuesAddAssigneesParams
			Response = *IssueSimple
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesAddAssigneesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesAddAssignees(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesAddAssignees(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesAddAssigneesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesCheckUserCanBeAssignedRequest handles issues/check-user-can-be-assigned operation.
//
// Checks if a user has permission to be assigned to an issue in this repository.
// If the `assignee` can be assigned to issues in the repository, a `204` header with no content is
// returned.
// Otherwise a `404` status code is returned.
//
// GET /repos/{owner}/{repo}/assignees/{assignee}
func (s *Server) handleIssuesCheckUserCanBeAssignedRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/check-user-can-be-assigned"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/assignees/{assignee}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesCheckUserCanBeAssignedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesCheckUserCanBeAssignedOperation,
			ID:   "issues/check-user-can-be-assigned",
		}
	)
	params, err := decodeIssuesCheckUserCanBeAssignedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesCheckUserCanBeAssignedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesCheckUserCanBeAssignedOperation,
			OperationSummary: "Check if a user can be assigned",
			OperationID:      "issues/check-user-can-be-assigned",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "assignee",
					In:   "path",
				}: params.Assignee,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesCheckUserCanBeAssignedParams
			Response = IssuesCheckUserCanBeAssignedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesCheckUserCanBeAssignedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesCheckUserCanBeAssigned(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesCheckUserCanBeAssigned(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesCheckUserCanBeAssignedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesCreateRequest handles issues/create operation.
//
// Any user with pull access to a repository can create an issue. If [issues are disabled in the
// repository](https://help.github.com/articles/disabling-issues/), the API returns a `410 Gone`
// status.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/issues
func (s *Server) handleIssuesCreateRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesCreateOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesCreateOperation,
			ID:   "issues/create",
		}
	)
	params, err := decodeIssuesCreateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeIssuesCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesCreateOperation,
			OperationSummary: "Create an issue",
			OperationID:      "issues/create",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *IssuesCreateReq
			Params   = IssuesCreateParams
			Response = IssuesCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesCreateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesCreate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesCreate(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesCreateResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesCreateCommentRequest handles issues/create-comment operation.
//
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/comments
func (s *Server) handleIssuesCreateCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-comment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesCreateCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesCreateCommentOperation,
			ID:   "issues/create-comment",
		}
	)
	params, err := decodeIssuesCreateCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeIssuesCreateCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesCreateCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesCreateCommentOperation,
			OperationSummary: "Create an issue comment",
			OperationID:      "issues/create-comment",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = *IssuesCreateCommentReq
			Params   = IssuesCreateCommentParams
			Response = IssuesCreateCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesCreateCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesCreateComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesCreateComment(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesCreateCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesCreateLabelRequest handles issues/create-label operation.
//
// Create a label.
//
// POST /repos/{owner}/{repo}/labels
func (s *Server) handleIssuesCreateLabelRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-label"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/labels"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesCreateLabelOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesCreateLabelOperation,
			ID:   "issues/create-label",
		}
	)
	params, err := decodeIssuesCreateLabelParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeIssuesCreateLabelRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesCreateLabelRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesCreateLabelOperation,
			OperationSummary: "Create a label",
			OperationID:      "issues/create-label",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *IssuesCreateLabelReq
			Params   = IssuesCreateLabelParams
			Response = IssuesCreateLabelRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesCreateLabelParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesCreateLabel(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesCreateLabel(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesCreateLabelResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesCreateMilestoneRequest handles issues/create-milestone operation.
//
// Create a milestone.
//
// POST /repos/{owner}/{repo}/milestones
func (s *Server) handleIssuesCreateMilestoneRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/create-milestone"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/milestones"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesCreateMilestoneOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesCreateMilestoneOperation,
			ID:   "issues/create-milestone",
		}
	)
	params, err := decodeIssuesCreateMilestoneParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeIssuesCreateMilestoneRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesCreateMilestoneRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesCreateMilestoneOperation,
			OperationSummary: "Create a milestone",
			OperationID:      "issues/create-milestone",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *IssuesCreateMilestoneReq
			Params   = IssuesCreateMilestoneParams
			Response = IssuesCreateMilestoneRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesCreateMilestoneParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesCreateMilestone(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesCreateMilestone(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesCreateMilestoneResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesDeleteCommentRequest handles issues/delete-comment operation.
//
// Delete an issue comment.
//
// DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}
func (s *Server) handleIssuesDeleteCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-comment"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/comments/{comment_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesDeleteCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesDeleteCommentOperation,
			ID:   "issues/delete-comment",
		}
	)
	params, err := decodeIssuesDeleteCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *IssuesDeleteCommentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesDeleteCommentOperation,
			OperationSummary: "Delete an issue comment",
			OperationID:      "issues/delete-comment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesDeleteCommentParams
			Response = *IssuesDeleteCommentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesDeleteCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.IssuesDeleteComment(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.IssuesDeleteComment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesDeleteCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesDeleteLabelRequest handles issues/delete-label operation.
//
// Delete a label.
//
// DELETE /repos/{owner}/{repo}/labels/{name}
func (s *Server) handleIssuesDeleteLabelRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-label"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/labels/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesDeleteLabelOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesDeleteLabelOperation,
			ID:   "issues/delete-label",
		}
	)
	params, err := decodeIssuesDeleteLabelParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *IssuesDeleteLabelNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesDeleteLabelOperation,
			OperationSummary: "Delete a label",
			OperationID:      "issues/delete-label",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesDeleteLabelParams
			Response = *IssuesDeleteLabelNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesDeleteLabelParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.IssuesDeleteLabel(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.IssuesDeleteLabel(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesDeleteLabelResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesDeleteMilestoneRequest handles issues/delete-milestone operation.
//
// Delete a milestone.
//
// DELETE /repos/{owner}/{repo}/milestones/{milestone_number}
func (s *Server) handleIssuesDeleteMilestoneRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/delete-milestone"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/milestones/{milestone_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesDeleteMilestoneOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesDeleteMilestoneOperation,
			ID:   "issues/delete-milestone",
		}
	)
	params, err := decodeIssuesDeleteMilestoneParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesDeleteMilestoneRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesDeleteMilestoneOperation,
			OperationSummary: "Delete a milestone",
			OperationID:      "issues/delete-milestone",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "milestone_number",
					In:   "path",
				}: params.MilestoneNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesDeleteMilestoneParams
			Response = IssuesDeleteMilestoneRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesDeleteMilestoneParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesDeleteMilestone(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesDeleteMilestone(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesDeleteMilestoneResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesGetRequest handles issues/get operation.
//
// The API returns a [`301 Moved Permanently` status](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was
// [transferred](https://help.github.com/articles/transferring-an-issue-to-another-repository/) to
// another repository. If
// the issue was transferred to or deleted from a repository where the authenticated user lacks read
// access, the API
// returns a `404 Not Found` status. If the issue was deleted from a repository where the
// authenticated user has read
// access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted
// issues, subscribe
// to the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}
func (s *Server) handleIssuesGetRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesGetOperation,
			ID:   "issues/get",
		}
	)
	params, err := decodeIssuesGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesGetOperation,
			OperationSummary: "Get an issue",
			OperationID:      "issues/get",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesGetParams
			Response = IssuesGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesGetCommentRequest handles issues/get-comment operation.
//
// Get an issue comment.
//
// GET /repos/{owner}/{repo}/issues/comments/{comment_id}
func (s *Server) handleIssuesGetCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-comment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/comments/{comment_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesGetCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesGetCommentOperation,
			ID:   "issues/get-comment",
		}
	)
	params, err := decodeIssuesGetCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesGetCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesGetCommentOperation,
			OperationSummary: "Get an issue comment",
			OperationID:      "issues/get-comment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesGetCommentParams
			Response = IssuesGetCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesGetCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesGetComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesGetComment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesGetCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesGetEventRequest handles issues/get-event operation.
//
// Get an issue event.
//
// GET /repos/{owner}/{repo}/issues/events/{event_id}
func (s *Server) handleIssuesGetEventRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-event"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/events/{event_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesGetEventOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesGetEventOperation,
			ID:   "issues/get-event",
		}
	)
	params, err := decodeIssuesGetEventParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesGetEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesGetEventOperation,
			OperationSummary: "Get an issue event",
			OperationID:      "issues/get-event",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "event_id",
					In:   "path",
				}: params.EventID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesGetEventParams
			Response = IssuesGetEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesGetEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesGetEvent(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesGetEvent(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesGetEventResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesGetLabelRequest handles issues/get-label operation.
//
// Get a label.
//
// GET /repos/{owner}/{repo}/labels/{name}
func (s *Server) handleIssuesGetLabelRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-label"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/labels/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesGetLabelOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesGetLabelOperation,
			ID:   "issues/get-label",
		}
	)
	params, err := decodeIssuesGetLabelParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesGetLabelRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesGetLabelOperation,
			OperationSummary: "Get a label",
			OperationID:      "issues/get-label",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesGetLabelParams
			Response = IssuesGetLabelRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesGetLabelParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesGetLabel(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesGetLabel(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesGetLabelResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesGetMilestoneRequest handles issues/get-milestone operation.
//
// Get a milestone.
//
// GET /repos/{owner}/{repo}/milestones/{milestone_number}
func (s *Server) handleIssuesGetMilestoneRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/get-milestone"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/milestones/{milestone_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesGetMilestoneOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesGetMilestoneOperation,
			ID:   "issues/get-milestone",
		}
	)
	params, err := decodeIssuesGetMilestoneParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesGetMilestoneRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesGetMilestoneOperation,
			OperationSummary: "Get a milestone",
			OperationID:      "issues/get-milestone",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "milestone_number",
					In:   "path",
				}: params.MilestoneNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesGetMilestoneParams
			Response = IssuesGetMilestoneRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesGetMilestoneParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesGetMilestone(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesGetMilestone(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesGetMilestoneResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesListRequest handles issues/list operation.
//
// List issues assigned to the authenticated user across all visible repositories including owned
// repositories, member
// repositories, and organization repositories. You can use the `filter` query parameter to fetch
// issues that are not
// necessarily assigned to you.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /issues
func (s *Server) handleIssuesListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/issues"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesListOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesListOperation,
			ID:   "issues/list",
		}
	)
	params, err := decodeIssuesListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesListOperation,
			OperationSummary: "List issues assigned to the authenticated user",
			OperationID:      "issues/list",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "labels",
					In:   "query",
				}: params.Labels,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "collab",
					In:   "query",
				}: params.Collab,
				{
					Name: "orgs",
					In:   "query",
				}: params.Orgs,
				{
					Name: "owned",
					In:   "query",
				}: params.Owned,
				{
					Name: "pulls",
					In:   "query",
				}: params.Pulls,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListParams
			Response = IssuesListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesListAssigneesRequest handles issues/list-assignees operation.
//
// Lists the [available assignees](https://help.github.
// com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.
//
// GET /repos/{owner}/{repo}/assignees
func (s *Server) handleIssuesListAssigneesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-assignees"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/assignees"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesListAssigneesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesListAssigneesOperation,
			ID:   "issues/list-assignees",
		}
	)
	params, err := decodeIssuesListAssigneesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesListAssigneesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesListAssigneesOperation,
			OperationSummary: "List assignees",
			OperationID:      "issues/list-assignees",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListAssigneesParams
			Response = IssuesListAssigneesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListAssigneesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListAssignees(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListAssignees(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListAssigneesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesListCommentsRequest handles issues/list-comments operation.
//
// Issue Comments are ordered by ascending ID.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/comments
func (s *Server) handleIssuesListCommentsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-comments"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesListCommentsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesListCommentsOperation,
			ID:   "issues/list-comments",
		}
	)
	params, err := decodeIssuesListCommentsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesListCommentsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesListCommentsOperation,
			OperationSummary: "List issue comments",
			OperationID:      "issues/list-comments",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListCommentsParams
			Response = IssuesListCommentsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListCommentsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListComments(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListComments(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListCommentsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesListCommentsForRepoRequest handles issues/list-comments-for-repo operation.
//
// By default, Issue Comments are ordered by ascending ID.
//
// GET /repos/{owner}/{repo}/issues/comments
func (s *Server) handleIssuesListCommentsForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-comments-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesListCommentsForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesListCommentsForRepoOperation,
			ID:   "issues/list-comments-for-repo",
		}
	)
	params, err := decodeIssuesListCommentsForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesListCommentsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesListCommentsForRepoOperation,
			OperationSummary: "List issue comments for a repository",
			OperationID:      "issues/list-comments-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListCommentsForRepoParams
			Response = IssuesListCommentsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListCommentsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListCommentsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListCommentsForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListCommentsForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesListEventsForRepoRequest handles issues/list-events-for-repo operation.
//
// List issue events for a repository.
//
// GET /repos/{owner}/{repo}/issues/events
func (s *Server) handleIssuesListEventsForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-events-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesListEventsForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesListEventsForRepoOperation,
			ID:   "issues/list-events-for-repo",
		}
	)
	params, err := decodeIssuesListEventsForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesListEventsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesListEventsForRepoOperation,
			OperationSummary: "List issue events for a repository",
			OperationID:      "issues/list-events-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListEventsForRepoParams
			Response = IssuesListEventsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListEventsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListEventsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListEventsForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListEventsForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesListForAuthenticatedUserRequest handles issues/list-for-authenticated-user operation.
//
// List issues across owned and member repositories assigned to the authenticated user.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /user/issues
func (s *Server) handleIssuesListForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/issues"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesListForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesListForAuthenticatedUserOperation,
			ID:   "issues/list-for-authenticated-user",
		}
	)
	params, err := decodeIssuesListForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesListForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesListForAuthenticatedUserOperation,
			OperationSummary: "List user account issues assigned to the authenticated user",
			OperationID:      "issues/list-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "labels",
					In:   "query",
				}: params.Labels,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListForAuthenticatedUserParams
			Response = IssuesListForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesListForOrgRequest handles issues/list-for-org operation.
//
// List issues in an organization assigned to the authenticated user.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /orgs/{org}/issues
func (s *Server) handleIssuesListForOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/issues"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesListForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesListForOrgOperation,
			ID:   "issues/list-for-org",
		}
	)
	params, err := decodeIssuesListForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesListForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesListForOrgOperation,
			OperationSummary: "List organization issues assigned to the authenticated user",
			OperationID:      "issues/list-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "labels",
					In:   "query",
				}: params.Labels,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListForOrgParams
			Response = IssuesListForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesListForRepoRequest handles issues/list-for-repo operation.
//
// List issues in a repository.
// **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a
// pull request. For this
// reason, "Issues" endpoints may return both issues and pull requests in the response. You can
// identify pull requests by
// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints
// will be an _issue id_. To find out the pull
// request id, use the "[List pull requests](https://docs.github.
// com/rest/reference/pulls#list-pull-requests)" endpoint.
//
// GET /repos/{owner}/{repo}/issues
func (s *Server) handleIssuesListForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesListForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesListForRepoOperation,
			ID:   "issues/list-for-repo",
		}
	)
	params, err := decodeIssuesListForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesListForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesListForRepoOperation,
			OperationSummary: "List repository issues",
			OperationID:      "issues/list-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "milestone",
					In:   "query",
				}: params.Milestone,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "assignee",
					In:   "query",
				}: params.Assignee,
				{
					Name: "creator",
					In:   "query",
				}: params.Creator,
				{
					Name: "mentioned",
					In:   "query",
				}: params.Mentioned,
				{
					Name: "labels",
					In:   "query",
				}: params.Labels,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListForRepoParams
			Response = IssuesListForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesListLabelsForMilestoneRequest handles issues/list-labels-for-milestone operation.
//
// List labels for issues in a milestone.
//
// GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels
func (s *Server) handleIssuesListLabelsForMilestoneRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-for-milestone"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/milestones/{milestone_number}/labels"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesListLabelsForMilestoneOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesListLabelsForMilestoneOperation,
			ID:   "issues/list-labels-for-milestone",
		}
	)
	params, err := decodeIssuesListLabelsForMilestoneParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *IssuesListLabelsForMilestoneOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesListLabelsForMilestoneOperation,
			OperationSummary: "List labels for issues in a milestone",
			OperationID:      "issues/list-labels-for-milestone",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "milestone_number",
					In:   "path",
				}: params.MilestoneNumber,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListLabelsForMilestoneParams
			Response = *IssuesListLabelsForMilestoneOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListLabelsForMilestoneParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListLabelsForMilestone(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListLabelsForMilestone(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListLabelsForMilestoneResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesListLabelsForRepoRequest handles issues/list-labels-for-repo operation.
//
// List labels for a repository.
//
// GET /repos/{owner}/{repo}/labels
func (s *Server) handleIssuesListLabelsForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/labels"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesListLabelsForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesListLabelsForRepoOperation,
			ID:   "issues/list-labels-for-repo",
		}
	)
	params, err := decodeIssuesListLabelsForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesListLabelsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesListLabelsForRepoOperation,
			OperationSummary: "List labels for a repository",
			OperationID:      "issues/list-labels-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListLabelsForRepoParams
			Response = IssuesListLabelsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListLabelsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListLabelsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListLabelsForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListLabelsForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesListLabelsOnIssueRequest handles issues/list-labels-on-issue operation.
//
// List labels for an issue.
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/labels
func (s *Server) handleIssuesListLabelsOnIssueRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-labels-on-issue"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/labels"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesListLabelsOnIssueOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesListLabelsOnIssueOperation,
			ID:   "issues/list-labels-on-issue",
		}
	)
	params, err := decodeIssuesListLabelsOnIssueParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesListLabelsOnIssueRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesListLabelsOnIssueOperation,
			OperationSummary: "List labels for an issue",
			OperationID:      "issues/list-labels-on-issue",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListLabelsOnIssueParams
			Response = IssuesListLabelsOnIssueRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListLabelsOnIssueParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListLabelsOnIssue(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListLabelsOnIssue(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListLabelsOnIssueResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesListMilestonesRequest handles issues/list-milestones operation.
//
// List milestones.
//
// GET /repos/{owner}/{repo}/milestones
func (s *Server) handleIssuesListMilestonesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/list-milestones"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/milestones"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesListMilestonesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesListMilestonesOperation,
			ID:   "issues/list-milestones",
		}
	)
	params, err := decodeIssuesListMilestonesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesListMilestonesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesListMilestonesOperation,
			OperationSummary: "List milestones",
			OperationID:      "issues/list-milestones",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesListMilestonesParams
			Response = IssuesListMilestonesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesListMilestonesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesListMilestones(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesListMilestones(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesListMilestonesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesLockRequest handles issues/lock operation.
//
// Users with push access can lock an issue or pull request's conversation.
// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero
// when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /repos/{owner}/{repo}/issues/{issue_number}/lock
func (s *Server) handleIssuesLockRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/lock"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/lock"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesLockOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesLockOperation,
			ID:   "issues/lock",
		}
	)
	params, err := decodeIssuesLockParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeIssuesLockRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesLockRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesLockOperation,
			OperationSummary: "Lock an issue",
			OperationID:      "issues/lock",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptNilIssuesLockReq
			Params   = IssuesLockParams
			Response = IssuesLockRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesLockParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesLock(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesLock(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesLockResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesRemoveAllLabelsRequest handles issues/remove-all-labels operation.
//
// Remove all labels from an issue.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels
func (s *Server) handleIssuesRemoveAllLabelsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-all-labels"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/labels"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesRemoveAllLabelsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesRemoveAllLabelsOperation,
			ID:   "issues/remove-all-labels",
		}
	)
	params, err := decodeIssuesRemoveAllLabelsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesRemoveAllLabelsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesRemoveAllLabelsOperation,
			OperationSummary: "Remove all labels from an issue",
			OperationID:      "issues/remove-all-labels",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesRemoveAllLabelsParams
			Response = IssuesRemoveAllLabelsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesRemoveAllLabelsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesRemoveAllLabels(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesRemoveAllLabels(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesRemoveAllLabelsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesRemoveAssigneesRequest handles issues/remove-assignees operation.
//
// Removes one or more assignees from an issue.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees
func (s *Server) handleIssuesRemoveAssigneesRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-assignees"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/assignees"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesRemoveAssigneesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesRemoveAssigneesOperation,
			ID:   "issues/remove-assignees",
		}
	)
	params, err := decodeIssuesRemoveAssigneesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeIssuesRemoveAssigneesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *IssueSimple
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesRemoveAssigneesOperation,
			OperationSummary: "Remove assignees from an issue",
			OperationID:      "issues/remove-assignees",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptIssuesRemoveAssigneesReq
			Params   = IssuesRemoveAssigneesParams
			Response = *IssueSimple
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesRemoveAssigneesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesRemoveAssignees(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesRemoveAssignees(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesRemoveAssigneesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesRemoveLabelRequest handles issues/remove-label operation.
//
// Removes the specified label from the issue, and returns the remaining labels on the issue. This
// endpoint returns a `404 Not Found` status if the label does not exist.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}
func (s *Server) handleIssuesRemoveLabelRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/remove-label"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesRemoveLabelOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesRemoveLabelOperation,
			ID:   "issues/remove-label",
		}
	)
	params, err := decodeIssuesRemoveLabelParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesRemoveLabelRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesRemoveLabelOperation,
			OperationSummary: "Remove a label from an issue",
			OperationID:      "issues/remove-label",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesRemoveLabelParams
			Response = IssuesRemoveLabelRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesRemoveLabelParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesRemoveLabel(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesRemoveLabel(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesRemoveLabelResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesUnlockRequest handles issues/unlock operation.
//
// Users with push access can unlock an issue's conversation.
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock
func (s *Server) handleIssuesUnlockRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/unlock"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/lock"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesUnlockOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesUnlockOperation,
			ID:   "issues/unlock",
		}
	)
	params, err := decodeIssuesUnlockParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response IssuesUnlockRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesUnlockOperation,
			OperationSummary: "Unlock an issue",
			OperationID:      "issues/unlock",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = IssuesUnlockParams
			Response = IssuesUnlockRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesUnlockParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesUnlock(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesUnlock(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesUnlockResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesUpdateRequest handles issues/update operation.
//
// Issue owners and users with push access can edit an issue.
//
// PATCH /repos/{owner}/{repo}/issues/{issue_number}
func (s *Server) handleIssuesUpdateRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesUpdateOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesUpdateOperation,
			ID:   "issues/update",
		}
	)
	params, err := decodeIssuesUpdateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeIssuesUpdateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesUpdateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesUpdateOperation,
			OperationSummary: "Update an issue",
			OperationID:      "issues/update",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptIssuesUpdateReq
			Params   = IssuesUpdateParams
			Response = IssuesUpdateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesUpdateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesUpdate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesUpdate(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesUpdateResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesUpdateCommentRequest handles issues/update-comment operation.
//
// Update an issue comment.
//
// PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}
func (s *Server) handleIssuesUpdateCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-comment"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/comments/{comment_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesUpdateCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesUpdateCommentOperation,
			ID:   "issues/update-comment",
		}
	)
	params, err := decodeIssuesUpdateCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeIssuesUpdateCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response IssuesUpdateCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesUpdateCommentOperation,
			OperationSummary: "Update an issue comment",
			OperationID:      "issues/update-comment",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = *IssuesUpdateCommentReq
			Params   = IssuesUpdateCommentParams
			Response = IssuesUpdateCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesUpdateCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesUpdateComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesUpdateComment(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesUpdateCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesUpdateLabelRequest handles issues/update-label operation.
//
// Update a label.
//
// PATCH /repos/{owner}/{repo}/labels/{name}
func (s *Server) handleIssuesUpdateLabelRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-label"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/labels/{name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesUpdateLabelOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesUpdateLabelOperation,
			ID:   "issues/update-label",
		}
	)
	params, err := decodeIssuesUpdateLabelParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeIssuesUpdateLabelRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Label
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesUpdateLabelOperation,
			OperationSummary: "Update a label",
			OperationID:      "issues/update-label",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "name",
					In:   "path",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = OptIssuesUpdateLabelReq
			Params   = IssuesUpdateLabelParams
			Response = *Label
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesUpdateLabelParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesUpdateLabel(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesUpdateLabel(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesUpdateLabelResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleIssuesUpdateMilestoneRequest handles issues/update-milestone operation.
//
// Update a milestone.
//
// PATCH /repos/{owner}/{repo}/milestones/{milestone_number}
func (s *Server) handleIssuesUpdateMilestoneRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("issues/update-milestone"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/milestones/{milestone_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), IssuesUpdateMilestoneOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: IssuesUpdateMilestoneOperation,
			ID:   "issues/update-milestone",
		}
	)
	params, err := decodeIssuesUpdateMilestoneParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeIssuesUpdateMilestoneRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Milestone
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    IssuesUpdateMilestoneOperation,
			OperationSummary: "Update a milestone",
			OperationID:      "issues/update-milestone",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "milestone_number",
					In:   "path",
				}: params.MilestoneNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptIssuesUpdateMilestoneReq
			Params   = IssuesUpdateMilestoneParams
			Response = *Milestone
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackIssuesUpdateMilestoneParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.IssuesUpdateMilestone(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.IssuesUpdateMilestone(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeIssuesUpdateMilestoneResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleLicensesGetRequest handles licenses/get operation.
//
// Get a license.
//
// GET /licenses/{license}
func (s *Server) handleLicensesGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/licenses/{license}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), LicensesGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: LicensesGetOperation,
			ID:   "licenses/get",
		}
	)
	params, err := decodeLicensesGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response LicensesGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    LicensesGetOperation,
			OperationSummary: "Get a license",
			OperationID:      "licenses/get",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "license",
					In:   "path",
				}: params.License,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = LicensesGetParams
			Response = LicensesGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackLicensesGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.LicensesGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.LicensesGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeLicensesGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleLicensesGetAllCommonlyUsedRequest handles licenses/get-all-commonly-used operation.
//
// Get all commonly used licenses.
//
// GET /licenses
func (s *Server) handleLicensesGetAllCommonlyUsedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get-all-commonly-used"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/licenses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), LicensesGetAllCommonlyUsedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: LicensesGetAllCommonlyUsedOperation,
			ID:   "licenses/get-all-commonly-used",
		}
	)
	params, err := decodeLicensesGetAllCommonlyUsedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response LicensesGetAllCommonlyUsedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    LicensesGetAllCommonlyUsedOperation,
			OperationSummary: "Get all commonly used licenses",
			OperationID:      "licenses/get-all-commonly-used",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "featured",
					In:   "query",
				}: params.Featured,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = LicensesGetAllCommonlyUsedParams
			Response = LicensesGetAllCommonlyUsedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackLicensesGetAllCommonlyUsedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.LicensesGetAllCommonlyUsed(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.LicensesGetAllCommonlyUsed(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeLicensesGetAllCommonlyUsedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleLicensesGetForRepoRequest handles licenses/get-for-repo operation.
//
// This method returns the contents of the repository's license file, if one is detected.
// Similar to [Get repository content](https://docs.github.
// com/rest/reference/repos#get-repository-content), this method also supports [custom media
// types](https://docs.github.com/rest/overview/media-types) for retrieving the raw license content
// or rendered license HTML.
//
// GET /repos/{owner}/{repo}/license
func (s *Server) handleLicensesGetForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("licenses/get-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/license"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), LicensesGetForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: LicensesGetForRepoOperation,
			ID:   "licenses/get-for-repo",
		}
	)
	params, err := decodeLicensesGetForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *LicenseContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    LicensesGetForRepoOperation,
			OperationSummary: "Get the license for a repository",
			OperationID:      "licenses/get-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = LicensesGetForRepoParams
			Response = *LicenseContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackLicensesGetForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.LicensesGetForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.LicensesGetForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeLicensesGetForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMarkdownRenderRequest handles markdown/render operation.
//
// Render a Markdown document.
//
// POST /markdown
func (s *Server) handleMarkdownRenderRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("markdown/render"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/markdown"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MarkdownRenderOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MarkdownRenderOperation,
			ID:   "markdown/render",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeMarkdownRenderRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MarkdownRenderRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MarkdownRenderOperation,
			OperationSummary: "Render a Markdown document",
			OperationID:      "markdown/render",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *MarkdownRenderReq
			Params   = struct{}
			Response = MarkdownRenderRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MarkdownRender(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.MarkdownRender(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMarkdownRenderResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMarkdownRenderRawRequest handles markdown/render-raw operation.
//
// You must send Markdown as plain text (using a `Content-Type` header of `text/plain` or
// `text/x-markdown`) to this endpoint, rather than using JSON format. In raw mode, [GitHub Flavored
// Markdown](https://github.github.com/gfm/) is not supported and Markdown will be rendered in plain
// format like a README.md file. Markdown content must be 400 KB or less.
//
// POST /markdown/raw
func (s *Server) handleMarkdownRenderRawRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("markdown/render-raw"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/markdown/raw"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MarkdownRenderRawOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MarkdownRenderRawOperation,
			ID:   "markdown/render-raw",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeMarkdownRenderRawRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MarkdownRenderRawRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MarkdownRenderRawOperation,
			OperationSummary: "Render a Markdown document in raw mode",
			OperationID:      "markdown/render-raw",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = MarkdownRenderRawReq
			Params   = struct{}
			Response = MarkdownRenderRawRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MarkdownRenderRaw(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.MarkdownRenderRaw(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMarkdownRenderRawResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMetaGetRequest handles meta/get operation.
//
// Returns meta information about GitHub, including a list of GitHub's IP addresses. For more
// information, see "[About GitHub's IP addresses](https://help.github.
// com/articles/about-github-s-ip-addresses/)."
// **Note:** The IP addresses shown in the documentation's response are only example values. You must
// always query the API directly to get the latest list of IP addresses.
//
// GET /meta
func (s *Server) handleMetaGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/meta"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MetaGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err error
	)

	var rawBody []byte

	var response MetaGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MetaGetOperation,
			OperationSummary: "Get GitHub meta information",
			OperationID:      "meta/get",
			Body:             nil,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = MetaGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MetaGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.MetaGet(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMetaGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMetaGetOctocatRequest handles meta/get-octocat operation.
//
// Get the octocat as ASCII art.
//
// GET /octocat
func (s *Server) handleMetaGetOctocatRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/get-octocat"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/octocat"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MetaGetOctocatOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MetaGetOctocatOperation,
			ID:   "meta/get-octocat",
		}
	)
	params, err := decodeMetaGetOctocatParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response MetaGetOctocatOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MetaGetOctocatOperation,
			OperationSummary: "Get Octocat",
			OperationID:      "meta/get-octocat",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "s",
					In:   "query",
				}: params.S,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MetaGetOctocatParams
			Response = MetaGetOctocatOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMetaGetOctocatParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MetaGetOctocat(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MetaGetOctocat(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMetaGetOctocatResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMetaGetZenRequest handles meta/get-zen operation.
//
// Get a random sentence from the Zen of GitHub.
//
// GET /zen
func (s *Server) handleMetaGetZenRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/get-zen"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/zen"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MetaGetZenOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err error
	)

	var rawBody []byte

	var response MetaGetZenOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MetaGetZenOperation,
			OperationSummary: "Get the Zen of GitHub",
			OperationID:      "meta/get-zen",
			Body:             nil,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = MetaGetZenOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MetaGetZen(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.MetaGetZen(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMetaGetZenResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMetaRootRequest handles meta/root operation.
//
// Get Hypermedia links to resources accessible in GitHub's REST API.
//
// GET /
func (s *Server) handleMetaRootRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("meta/root"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MetaRootOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err error
	)

	var rawBody []byte

	var response *MetaRootOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MetaRootOperation,
			OperationSummary: "GitHub API Root",
			OperationID:      "meta/root",
			Body:             nil,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *MetaRootOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MetaRoot(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.MetaRoot(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMetaRootResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsCancelImportRequest handles migrations/cancel-import operation.
//
// Stop an import for a repository.
//
// DELETE /repos/{owner}/{repo}/import
func (s *Server) handleMigrationsCancelImportRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/cancel-import"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/import"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsCancelImportOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsCancelImportOperation,
			ID:   "migrations/cancel-import",
		}
	)
	params, err := decodeMigrationsCancelImportParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *MigrationsCancelImportNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsCancelImportOperation,
			OperationSummary: "Cancel an import",
			OperationID:      "migrations/cancel-import",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsCancelImportParams
			Response = *MigrationsCancelImportNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsCancelImportParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.MigrationsCancelImport(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.MigrationsCancelImport(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsCancelImportResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsDeleteArchiveForAuthenticatedUserRequest handles migrations/delete-archive-for-authenticated-user operation.
//
// Deletes a previous migration archive. Downloadable migration archives are automatically deleted
// after seven days. Migration metadata, which is returned in the [List user migrations](https://docs.
// github.com/rest/reference/migrations#list-user-migrations) and [Get a user migration
// status](https://docs.github.com/rest/reference/migrations#get-a-user-migration-status) endpoints,
// will continue to be available even after an archive is deleted.
//
// DELETE /user/migrations/{migration_id}/archive
func (s *Server) handleMigrationsDeleteArchiveForAuthenticatedUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/delete-archive-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/migrations/{migration_id}/archive"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsDeleteArchiveForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsDeleteArchiveForAuthenticatedUserOperation,
			ID:   "migrations/delete-archive-for-authenticated-user",
		}
	)
	params, err := decodeMigrationsDeleteArchiveForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response MigrationsDeleteArchiveForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsDeleteArchiveForAuthenticatedUserOperation,
			OperationSummary: "Delete a user migration archive",
			OperationID:      "migrations/delete-archive-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsDeleteArchiveForAuthenticatedUserParams
			Response = MigrationsDeleteArchiveForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsDeleteArchiveForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsDeleteArchiveForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsDeleteArchiveForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsDeleteArchiveForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsDeleteArchiveForOrgRequest handles migrations/delete-archive-for-org operation.
//
// Deletes a previous migration archive. Migration archives are automatically deleted after seven
// days.
//
// DELETE /orgs/{org}/migrations/{migration_id}/archive
func (s *Server) handleMigrationsDeleteArchiveForOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/delete-archive-for-org"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/migrations/{migration_id}/archive"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsDeleteArchiveForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsDeleteArchiveForOrgOperation,
			ID:   "migrations/delete-archive-for-org",
		}
	)
	params, err := decodeMigrationsDeleteArchiveForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response MigrationsDeleteArchiveForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsDeleteArchiveForOrgOperation,
			OperationSummary: "Delete an organization migration archive",
			OperationID:      "migrations/delete-archive-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsDeleteArchiveForOrgParams
			Response = MigrationsDeleteArchiveForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsDeleteArchiveForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsDeleteArchiveForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsDeleteArchiveForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsDeleteArchiveForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsDownloadArchiveForOrgRequest handles migrations/download-archive-for-org operation.
//
// Fetches the URL to a migration archive.
//
// GET /orgs/{org}/migrations/{migration_id}/archive
func (s *Server) handleMigrationsDownloadArchiveForOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/download-archive-for-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/migrations/{migration_id}/archive"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsDownloadArchiveForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsDownloadArchiveForOrgOperation,
			ID:   "migrations/download-archive-for-org",
		}
	)
	params, err := decodeMigrationsDownloadArchiveForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response MigrationsDownloadArchiveForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsDownloadArchiveForOrgOperation,
			OperationSummary: "Download an organization migration archive",
			OperationID:      "migrations/download-archive-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsDownloadArchiveForOrgParams
			Response = MigrationsDownloadArchiveForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsDownloadArchiveForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsDownloadArchiveForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsDownloadArchiveForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsDownloadArchiveForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsGetArchiveForAuthenticatedUserRequest handles migrations/get-archive-for-authenticated-user operation.
//
// Fetches the URL to download the migration archive as a `tar.gz` file. Depending on the resources
// your repository uses, the migration archive can contain JSON files with data for these objects:
// *   attachments
// *   bases
// *   commit\_comments
// *   issue\_comments
// *   issue\_events
// *   issues
// *   milestones
// *   organizations
// *   projects
// *   protected\_branches
// *   pull\_request\_reviews
// *   pull\_requests
// *   releases
// *   repositories
// *   review\_comments
// *   schema
// *   users
// The archive will also contain an `attachments` directory that includes all attachment files
// uploaded to GitHub.com and a `repositories` directory that contains the repository's Git data.
//
// GET /user/migrations/{migration_id}/archive
func (s *Server) handleMigrationsGetArchiveForAuthenticatedUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-archive-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/migrations/{migration_id}/archive"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsGetArchiveForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsGetArchiveForAuthenticatedUserOperation,
			ID:   "migrations/get-archive-for-authenticated-user",
		}
	)
	params, err := decodeMigrationsGetArchiveForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response MigrationsGetArchiveForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsGetArchiveForAuthenticatedUserOperation,
			OperationSummary: "Download a user migration archive",
			OperationID:      "migrations/get-archive-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetArchiveForAuthenticatedUserParams
			Response = MigrationsGetArchiveForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetArchiveForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsGetArchiveForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsGetArchiveForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetArchiveForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsGetCommitAuthorsRequest handles migrations/get-commit-authors operation.
//
// Each type of source control system represents authors in a different way. For example, a Git
// commit author has a display name and an email address, but a Subversion commit author just has a
// username. The GitHub Importer will make the author information valid, but the author might not be
// correct. For example, it will change the bare Subversion username `hubot` into something like
// `hubot <hubot@12341234-abab-fefe-8787-fedcba987654>`.
// This endpoint and the [Map a commit author](https://docs.github.
// com/rest/reference/migrations#map-a-commit-author) endpoint allow you to provide correct Git
// author information.
//
// GET /repos/{owner}/{repo}/import/authors
func (s *Server) handleMigrationsGetCommitAuthorsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-commit-authors"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/import/authors"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsGetCommitAuthorsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsGetCommitAuthorsOperation,
			ID:   "migrations/get-commit-authors",
		}
	)
	params, err := decodeMigrationsGetCommitAuthorsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response MigrationsGetCommitAuthorsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsGetCommitAuthorsOperation,
			OperationSummary: "Get commit authors",
			OperationID:      "migrations/get-commit-authors",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetCommitAuthorsParams
			Response = MigrationsGetCommitAuthorsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetCommitAuthorsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsGetCommitAuthors(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsGetCommitAuthors(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetCommitAuthorsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsGetImportStatusRequest handles migrations/get-import-status operation.
//
// View the progress of an import.
// **Import status**
// This section includes details about the possible values of the `status` field of the Import
// Progress response.
// An import that does not have errors will progress through these steps:
// *   `detecting` - the "detection" step of the import is in progress because the request did not
// include a `vcs` parameter. The import is identifying the type of source control present at the URL.
// *   `importing` - the "raw" step of the import is in progress. This is where commit data is
// fetched from the original repository. The import progress response will include `commit_count`
// (the total number of raw commits that will be imported) and `percent` (0 - 100, the current
// progress through the import).
// *   `mapping` - the "rewrite" step of the import is in progress. This is where SVN branches are
// converted to Git branches, and where author updates are applied. The import progress response does
// not include progress information.
// *   `pushing` - the "push" step of the import is in progress. This is where the importer updates
// the repository on GitHub. The import progress response will include `push_percent`, which is the
// percent value reported by `git push` when it is "Writing objects".
// *   `complete` - the import is complete, and the repository is ready on GitHub.
// If there are problems, you will see one of these in the `status` field:
// *   `auth_failed` - the import requires authentication in order to connect to the original
// repository. To update authentication for the import, please see the [Update an
// import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
// *   `error` - the import encountered an error. The import progress response will include the
// `failed_step` and an error message. Contact [GitHub Support](https://support.github.
// com/contact?tags=dotcom-rest-api) for more information.
// *   `detection_needs_auth` - the importer requires authentication for the originating repository
// to continue detection. To update authentication for the import, please see the [Update an
// import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
// *   `detection_found_nothing` - the importer didn't recognize any source control at the URL. To
// resolve, [Cancel the import](https://docs.github.com/rest/reference/migrations#cancel-an-import)
// and [retry](https://docs.github.com/rest/reference/migrations#start-an-import) with the correct
// URL.
// *   `detection_found_multiple` - the importer found several projects or repositories at the
// provided URL. When this is the case, the Import Progress response will also include a
// `project_choices` field with the possible project choices as values. To update project choice,
// please see the [Update an import](https://docs.github.
// com/rest/reference/migrations#update-an-import) section.
// **The project_choices field**
// When multiple projects are found at the provided URL, the response hash will include a
// `project_choices` field, the value of which is an array of hashes each representing a project
// choice. The exact key/value pairs of the project hashes will differ depending on the version
// control type.
// **Git LFS related fields**
// This section includes details about Git LFS related fields that may be present in the Import
// Progress response.
// *   `use_lfs` - describes whether the import has been opted in or out of using Git LFS. The value
// can be `opt_in`, `opt_out`, or `undecided` if no action has been taken.
// *   `has_large_files` - the boolean value describing whether files larger than 100MB were found
// during the `importing` step.
// *   `large_files_size` - the total size in gigabytes of files larger than 100MB found in the
// originating repository.
// *   `large_files_count` - the total number of files larger than 100MB found in the originating
// repository. To see a list of these files, make a "Get Large Files" request.
//
// GET /repos/{owner}/{repo}/import
func (s *Server) handleMigrationsGetImportStatusRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-import-status"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/import"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsGetImportStatusOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsGetImportStatusOperation,
			ID:   "migrations/get-import-status",
		}
	)
	params, err := decodeMigrationsGetImportStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response MigrationsGetImportStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsGetImportStatusOperation,
			OperationSummary: "Get an import status",
			OperationID:      "migrations/get-import-status",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetImportStatusParams
			Response = MigrationsGetImportStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetImportStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsGetImportStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsGetImportStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetImportStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsGetLargeFilesRequest handles migrations/get-large-files operation.
//
// List files larger than 100MB found during the import.
//
// GET /repos/{owner}/{repo}/import/large_files
func (s *Server) handleMigrationsGetLargeFilesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-large-files"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/import/large_files"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsGetLargeFilesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsGetLargeFilesOperation,
			ID:   "migrations/get-large-files",
		}
	)
	params, err := decodeMigrationsGetLargeFilesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []PorterLargeFile
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsGetLargeFilesOperation,
			OperationSummary: "Get large files",
			OperationID:      "migrations/get-large-files",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetLargeFilesParams
			Response = []PorterLargeFile
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetLargeFilesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsGetLargeFiles(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsGetLargeFiles(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetLargeFilesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsGetStatusForAuthenticatedUserRequest handles migrations/get-status-for-authenticated-user operation.
//
// Fetches a single user migration. The response includes the `state` of the migration, which can be
// one of the following values:
// *   `pending` - the migration hasn't started yet.
// *   `exporting` - the migration is in progress.
// *   `exported` - the migration finished successfully.
// *   `failed` - the migration failed.
// Once the migration has been `exported` you can [download the migration archive](https://docs.
// github.com/rest/reference/migrations#download-a-user-migration-archive).
//
// GET /user/migrations/{migration_id}
func (s *Server) handleMigrationsGetStatusForAuthenticatedUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-status-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/migrations/{migration_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsGetStatusForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsGetStatusForAuthenticatedUserOperation,
			ID:   "migrations/get-status-for-authenticated-user",
		}
	)
	params, err := decodeMigrationsGetStatusForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response MigrationsGetStatusForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsGetStatusForAuthenticatedUserOperation,
			OperationSummary: "Get a user migration status",
			OperationID:      "migrations/get-status-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
				{
					Name: "exclude",
					In:   "query",
				}: params.Exclude,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetStatusForAuthenticatedUserParams
			Response = MigrationsGetStatusForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetStatusForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsGetStatusForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsGetStatusForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetStatusForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsGetStatusForOrgRequest handles migrations/get-status-for-org operation.
//
// Fetches the status of a migration.
// The `state` of a migration can be one of the following values:
// *   `pending`, which means the migration hasn't started yet.
// *   `exporting`, which means the migration is in progress.
// *   `exported`, which means the migration finished successfully.
// *   `failed`, which means the migration failed.
//
// GET /orgs/{org}/migrations/{migration_id}
func (s *Server) handleMigrationsGetStatusForOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/get-status-for-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/migrations/{migration_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsGetStatusForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsGetStatusForOrgOperation,
			ID:   "migrations/get-status-for-org",
		}
	)
	params, err := decodeMigrationsGetStatusForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response MigrationsGetStatusForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsGetStatusForOrgOperation,
			OperationSummary: "Get an organization migration status",
			OperationID:      "migrations/get-status-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
				{
					Name: "exclude",
					In:   "query",
				}: params.Exclude,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsGetStatusForOrgParams
			Response = MigrationsGetStatusForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsGetStatusForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsGetStatusForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsGetStatusForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsGetStatusForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsListForAuthenticatedUserRequest handles migrations/list-for-authenticated-user operation.
//
// Lists all migrations a user has started.
//
// GET /user/migrations
func (s *Server) handleMigrationsListForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/migrations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsListForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsListForAuthenticatedUserOperation,
			ID:   "migrations/list-for-authenticated-user",
		}
	)
	params, err := decodeMigrationsListForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response MigrationsListForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsListForAuthenticatedUserOperation,
			OperationSummary: "List user migrations",
			OperationID:      "migrations/list-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsListForAuthenticatedUserParams
			Response = MigrationsListForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsListForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsListForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsListForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsListForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsListForOrgRequest handles migrations/list-for-org operation.
//
// Lists the most recent migrations.
//
// GET /orgs/{org}/migrations
func (s *Server) handleMigrationsListForOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-for-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/migrations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsListForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsListForOrgOperation,
			ID:   "migrations/list-for-org",
		}
	)
	params, err := decodeMigrationsListForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *MigrationsListForOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsListForOrgOperation,
			OperationSummary: "List organization migrations",
			OperationID:      "migrations/list-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "exclude",
					In:   "query",
				}: params.Exclude,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsListForOrgParams
			Response = *MigrationsListForOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsListForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsListForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsListForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsListForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsListReposForOrgRequest handles migrations/list-repos-for-org operation.
//
// List all the repositories for this organization migration.
//
// GET /orgs/{org}/migrations/{migration_id}/repositories
func (s *Server) handleMigrationsListReposForOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-repos-for-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/migrations/{migration_id}/repositories"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsListReposForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsListReposForOrgOperation,
			ID:   "migrations/list-repos-for-org",
		}
	)
	params, err := decodeMigrationsListReposForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response MigrationsListReposForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsListReposForOrgOperation,
			OperationSummary: "List repositories in an organization migration",
			OperationID:      "migrations/list-repos-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsListReposForOrgParams
			Response = MigrationsListReposForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsListReposForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsListReposForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsListReposForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsListReposForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsListReposForUserRequest handles migrations/list-repos-for-user operation.
//
// Lists all the repositories for this user migration.
//
// GET /user/migrations/{migration_id}/repositories
func (s *Server) handleMigrationsListReposForUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/list-repos-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/migrations/{migration_id}/repositories"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsListReposForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsListReposForUserOperation,
			ID:   "migrations/list-repos-for-user",
		}
	)
	params, err := decodeMigrationsListReposForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response MigrationsListReposForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsListReposForUserOperation,
			OperationSummary: "List repositories for a user migration",
			OperationID:      "migrations/list-repos-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsListReposForUserParams
			Response = MigrationsListReposForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsListReposForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsListReposForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsListReposForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsListReposForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsMapCommitAuthorRequest handles migrations/map-commit-author operation.
//
// Update an author's identity for the import. Your application can continue updating authors any
// time before you push new commits to the repository.
//
// PATCH /repos/{owner}/{repo}/import/authors/{author_id}
func (s *Server) handleMigrationsMapCommitAuthorRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/map-commit-author"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/import/authors/{author_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsMapCommitAuthorOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsMapCommitAuthorOperation,
			ID:   "migrations/map-commit-author",
		}
	)
	params, err := decodeMigrationsMapCommitAuthorParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeMigrationsMapCommitAuthorRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MigrationsMapCommitAuthorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsMapCommitAuthorOperation,
			OperationSummary: "Map a commit author",
			OperationID:      "migrations/map-commit-author",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "author_id",
					In:   "path",
				}: params.AuthorID,
			},
			Raw: r,
		}

		type (
			Request  = OptMigrationsMapCommitAuthorReq
			Params   = MigrationsMapCommitAuthorParams
			Response = MigrationsMapCommitAuthorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsMapCommitAuthorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsMapCommitAuthor(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsMapCommitAuthor(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsMapCommitAuthorResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsSetLfsPreferenceRequest handles migrations/set-lfs-preference operation.
//
// You can import repositories from Subversion, Mercurial, and TFS that include files larger than
// 100MB. This ability is powered by [Git LFS](https://git-lfs.github.com). You can learn more about
// our LFS feature and working with large files [on our help site](https://help.github.
// com/articles/versioning-large-files/).
//
// PATCH /repos/{owner}/{repo}/import/lfs
func (s *Server) handleMigrationsSetLfsPreferenceRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/set-lfs-preference"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/import/lfs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsSetLfsPreferenceOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsSetLfsPreferenceOperation,
			ID:   "migrations/set-lfs-preference",
		}
	)
	params, err := decodeMigrationsSetLfsPreferenceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeMigrationsSetLfsPreferenceRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MigrationsSetLfsPreferenceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsSetLfsPreferenceOperation,
			OperationSummary: "Update Git LFS preference",
			OperationID:      "migrations/set-lfs-preference",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *MigrationsSetLfsPreferenceReq
			Params   = MigrationsSetLfsPreferenceParams
			Response = MigrationsSetLfsPreferenceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsSetLfsPreferenceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsSetLfsPreference(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsSetLfsPreference(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsSetLfsPreferenceResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsStartForAuthenticatedUserRequest handles migrations/start-for-authenticated-user operation.
//
// Initiates the generation of a user migration archive.
//
// POST /user/migrations
func (s *Server) handleMigrationsStartForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user/migrations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsStartForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsStartForAuthenticatedUserOperation,
			ID:   "migrations/start-for-authenticated-user",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeMigrationsStartForAuthenticatedUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MigrationsStartForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsStartForAuthenticatedUserOperation,
			OperationSummary: "Start a user migration",
			OperationID:      "migrations/start-for-authenticated-user",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *MigrationsStartForAuthenticatedUserReq
			Params   = struct{}
			Response = MigrationsStartForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsStartForAuthenticatedUser(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsStartForAuthenticatedUser(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsStartForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsStartForOrgRequest handles migrations/start-for-org operation.
//
// Initiates the generation of a migration archive.
//
// POST /orgs/{org}/migrations
func (s *Server) handleMigrationsStartForOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-for-org"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/migrations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsStartForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsStartForOrgOperation,
			ID:   "migrations/start-for-org",
		}
	)
	params, err := decodeMigrationsStartForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeMigrationsStartForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MigrationsStartForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsStartForOrgOperation,
			OperationSummary: "Start an organization migration",
			OperationID:      "migrations/start-for-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *MigrationsStartForOrgReq
			Params   = MigrationsStartForOrgParams
			Response = MigrationsStartForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsStartForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsStartForOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsStartForOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsStartForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsStartImportRequest handles migrations/start-import operation.
//
// Start a source import to a GitHub repository using GitHub Importer.
//
// PUT /repos/{owner}/{repo}/import
func (s *Server) handleMigrationsStartImportRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/start-import"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/import"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsStartImportOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsStartImportOperation,
			ID:   "migrations/start-import",
		}
	)
	params, err := decodeMigrationsStartImportParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeMigrationsStartImportRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response MigrationsStartImportRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsStartImportOperation,
			OperationSummary: "Start an import",
			OperationID:      "migrations/start-import",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *MigrationsStartImportReq
			Params   = MigrationsStartImportParams
			Response = MigrationsStartImportRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsStartImportParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsStartImport(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsStartImport(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsStartImportResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsUnlockRepoForAuthenticatedUserRequest handles migrations/unlock-repo-for-authenticated-user operation.
//
// Unlocks a repository. You can lock repositories when you [start a user migration](https://docs.
// github.com/rest/reference/migrations#start-a-user-migration). Once the migration is complete you
// can unlock each repository to begin using it again or [delete the repository](https://docs.github.
// com/rest/reference/repos#delete-a-repository) if you no longer need the source data. Returns a
// status of `404 Not Found` if the repository is not locked.
//
// DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock
func (s *Server) handleMigrationsUnlockRepoForAuthenticatedUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/unlock-repo-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/migrations/{migration_id}/repos/{repo_name}/lock"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsUnlockRepoForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsUnlockRepoForAuthenticatedUserOperation,
			ID:   "migrations/unlock-repo-for-authenticated-user",
		}
	)
	params, err := decodeMigrationsUnlockRepoForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response MigrationsUnlockRepoForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsUnlockRepoForAuthenticatedUserOperation,
			OperationSummary: "Unlock a user repository",
			OperationID:      "migrations/unlock-repo-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
				{
					Name: "repo_name",
					In:   "path",
				}: params.RepoName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsUnlockRepoForAuthenticatedUserParams
			Response = MigrationsUnlockRepoForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsUnlockRepoForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsUnlockRepoForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsUnlockRepoForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsUnlockRepoForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsUnlockRepoForOrgRequest handles migrations/unlock-repo-for-org operation.
//
// Unlocks a repository that was locked for migration. You should unlock each migrated repository and
// [delete them](https://docs.github.com/rest/reference/repos#delete-a-repository) when the migration
// is complete and you no longer need the source data.
//
// DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock
func (s *Server) handleMigrationsUnlockRepoForOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/unlock-repo-for-org"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsUnlockRepoForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsUnlockRepoForOrgOperation,
			ID:   "migrations/unlock-repo-for-org",
		}
	)
	params, err := decodeMigrationsUnlockRepoForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response MigrationsUnlockRepoForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsUnlockRepoForOrgOperation,
			OperationSummary: "Unlock an organization repository",
			OperationID:      "migrations/unlock-repo-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "migration_id",
					In:   "path",
				}: params.MigrationID,
				{
					Name: "repo_name",
					In:   "path",
				}: params.RepoName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = MigrationsUnlockRepoForOrgParams
			Response = MigrationsUnlockRepoForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsUnlockRepoForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsUnlockRepoForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsUnlockRepoForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsUnlockRepoForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleMigrationsUpdateImportRequest handles migrations/update-import operation.
//
// An import can be updated with credentials or a project choice by passing in the appropriate
// parameters in this API
// request. If no parameters are provided, the import will be restarted.
//
// PATCH /repos/{owner}/{repo}/import
func (s *Server) handleMigrationsUpdateImportRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrations/update-import"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/import"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), MigrationsUpdateImportOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: MigrationsUpdateImportOperation,
			ID:   "migrations/update-import",
		}
	)
	params, err := decodeMigrationsUpdateImportParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeMigrationsUpdateImportRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Import
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    MigrationsUpdateImportOperation,
			OperationSummary: "Update an import",
			OperationID:      "migrations/update-import",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptNilMigrationsUpdateImportReq
			Params   = MigrationsUpdateImportParams
			Response = *Import
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackMigrationsUpdateImportParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.MigrationsUpdateImport(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.MigrationsUpdateImport(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeMigrationsUpdateImportResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOAuthAuthorizationsCreateAuthorizationRequest handles oauth-authorizations/create-authorization operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// **Warning:** Apps must use the [web application flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens
// that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will
// be unable to access GitHub SAML organizations. For more information, see the [blog
// post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
// Creates OAuth tokens using [Basic Authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#basic-authentication). If you have two-factor
// authentication setup, Basic Authentication for this endpoint requires that you use a one-time
// password (OTP) and your username and password instead of tokens. For more information, see
// "[Working with two-factor authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
// To create tokens for a particular OAuth application using this endpoint, you must authenticate as
// the user you want to create an authorization for and provide the app's client ID and secret, found
// on your OAuth application's settings page. If your OAuth application intends to create multiple
// tokens for one user, use `fingerprint` to differentiate between them.
// You can also create tokens on GitHub from the [personal access tokens settings](https://github.
// com/settings/tokens) page. Read more about these tokens in [the GitHub Help
// documentation](https://help.github.com/articles/creating-an-access-token-for-command-line-use).
// Organizations that enforce SAML SSO require personal access tokens to be allowed. Read more about
// allowing tokens in [the GitHub Help documentation](https://help.github.
// com/articles/about-identity-and-access-management-with-saml-single-sign-on).
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /authorizations
func (s *Server) handleOAuthAuthorizationsCreateAuthorizationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/create-authorization"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/authorizations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OAuthAuthorizationsCreateAuthorizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OAuthAuthorizationsCreateAuthorizationOperation,
			ID:   "oauth-authorizations/create-authorization",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeOAuthAuthorizationsCreateAuthorizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OAuthAuthorizationsCreateAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OAuthAuthorizationsCreateAuthorizationOperation,
			OperationSummary: "Create a new authorization",
			OperationID:      "oauth-authorizations/create-authorization",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = OptOAuthAuthorizationsCreateAuthorizationReq
			Params   = struct{}
			Response = OAuthAuthorizationsCreateAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsCreateAuthorization(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsCreateAuthorization(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsCreateAuthorizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOAuthAuthorizationsDeleteAuthorizationRequest handles oauth-authorizations/delete-authorization operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /authorizations/{authorization_id}
func (s *Server) handleOAuthAuthorizationsDeleteAuthorizationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/delete-authorization"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/authorizations/{authorization_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OAuthAuthorizationsDeleteAuthorizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OAuthAuthorizationsDeleteAuthorizationOperation,
			ID:   "oauth-authorizations/delete-authorization",
		}
	)
	params, err := decodeOAuthAuthorizationsDeleteAuthorizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OAuthAuthorizationsDeleteAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OAuthAuthorizationsDeleteAuthorizationOperation,
			OperationSummary: "Delete an authorization",
			OperationID:      "oauth-authorizations/delete-authorization",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "authorization_id",
					In:   "path",
				}: params.AuthorizationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsDeleteAuthorizationParams
			Response = OAuthAuthorizationsDeleteAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsDeleteAuthorizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsDeleteAuthorization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsDeleteAuthorization(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsDeleteAuthorizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOAuthAuthorizationsDeleteGrantRequest handles oauth-authorizations/delete-grant operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// Deleting an OAuth application's grant will also delete all OAuth tokens associated with the
// application for your user. Once deleted, the application has no access to your account and is no
// longer listed on [the application authorizations settings screen within GitHub](https://github.
// com/settings/applications#authorized).
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /applications/grants/{grant_id}
func (s *Server) handleOAuthAuthorizationsDeleteGrantRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/delete-grant"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/applications/grants/{grant_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OAuthAuthorizationsDeleteGrantOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OAuthAuthorizationsDeleteGrantOperation,
			ID:   "oauth-authorizations/delete-grant",
		}
	)
	params, err := decodeOAuthAuthorizationsDeleteGrantParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OAuthAuthorizationsDeleteGrantRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OAuthAuthorizationsDeleteGrantOperation,
			OperationSummary: "Delete a grant",
			OperationID:      "oauth-authorizations/delete-grant",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "grant_id",
					In:   "path",
				}: params.GrantID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsDeleteGrantParams
			Response = OAuthAuthorizationsDeleteGrantRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsDeleteGrantParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsDeleteGrant(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsDeleteGrant(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsDeleteGrantResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOAuthAuthorizationsGetAuthorizationRequest handles oauth-authorizations/get-authorization operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /authorizations/{authorization_id}
func (s *Server) handleOAuthAuthorizationsGetAuthorizationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-authorization"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/authorizations/{authorization_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OAuthAuthorizationsGetAuthorizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OAuthAuthorizationsGetAuthorizationOperation,
			ID:   "oauth-authorizations/get-authorization",
		}
	)
	params, err := decodeOAuthAuthorizationsGetAuthorizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OAuthAuthorizationsGetAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OAuthAuthorizationsGetAuthorizationOperation,
			OperationSummary: "Get a single authorization",
			OperationID:      "oauth-authorizations/get-authorization",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "authorization_id",
					In:   "path",
				}: params.AuthorizationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsGetAuthorizationParams
			Response = OAuthAuthorizationsGetAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsGetAuthorizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsGetAuthorization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsGetAuthorization(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetAuthorizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOAuthAuthorizationsGetGrantRequest handles oauth-authorizations/get-grant operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /applications/grants/{grant_id}
func (s *Server) handleOAuthAuthorizationsGetGrantRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-grant"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/applications/grants/{grant_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OAuthAuthorizationsGetGrantOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OAuthAuthorizationsGetGrantOperation,
			ID:   "oauth-authorizations/get-grant",
		}
	)
	params, err := decodeOAuthAuthorizationsGetGrantParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OAuthAuthorizationsGetGrantRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OAuthAuthorizationsGetGrantOperation,
			OperationSummary: "Get a single grant",
			OperationID:      "oauth-authorizations/get-grant",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "grant_id",
					In:   "path",
				}: params.GrantID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsGetGrantParams
			Response = OAuthAuthorizationsGetGrantRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsGetGrantParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsGetGrant(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsGetGrant(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetGrantResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest handles oauth-authorizations/get-or-create-authorization-for-app operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// **Warning:** Apps must use the [web application flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens
// that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will
// be unable to access GitHub SAML organizations. For more information, see the [blog
// post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
// Creates a new authorization for the specified OAuth application, only if an authorization for that
// application doesn't already exist for the user. The URL includes the 20 character client ID for
// the OAuth app that is requesting the token. It returns the user's existing authorization for the
// application if one is present. Otherwise, it creates and returns a new one.
// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that
// you use a one-time password (OTP) and your username and password instead of tokens. For more
// information, see "[Working with two-factor authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /authorizations/clients/{client_id}
func (s *Server) handleOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-or-create-authorization-for-app"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/authorizations/clients/{client_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OAuthAuthorizationsGetOrCreateAuthorizationForAppOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OAuthAuthorizationsGetOrCreateAuthorizationForAppOperation,
			ID:   "oauth-authorizations/get-or-create-authorization-for-app",
		}
	)
	params, err := decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OAuthAuthorizationsGetOrCreateAuthorizationForAppRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OAuthAuthorizationsGetOrCreateAuthorizationForAppOperation,
			OperationSummary: "Get-or-create an authorization for a specific app",
			OperationID:      "oauth-authorizations/get-or-create-authorization-for-app",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "client_id",
					In:   "path",
				}: params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = *OAuthAuthorizationsGetOrCreateAuthorizationForAppReq
			Params   = OAuthAuthorizationsGetOrCreateAuthorizationForAppParams
			Response = OAuthAuthorizationsGetOrCreateAuthorizationForAppRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsGetOrCreateAuthorizationForAppParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsGetOrCreateAuthorizationForApp(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsGetOrCreateAuthorizationForApp(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetOrCreateAuthorizationForAppResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest handles oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// **Warning:** Apps must use the [web application flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens
// that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will
// be unable to access GitHub SAML organizations. For more information, see the [blog
// post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
// This method will create a new authorization for the specified OAuth application, only if an
// authorization for that application and fingerprint do not already exist for the user. The URL
// includes the 20 character client ID for the OAuth app that is requesting the token. `fingerprint`
// is a unique string to distinguish an authorization from others created for the same client ID and
// user. It returns the user's existing authorization for the application if one is present.
// Otherwise, it creates and returns a new one.
// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that
// you use a one-time password (OTP) and your username and password instead of tokens. For more
// information, see "[Working with two-factor authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication).".
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /authorizations/clients/{client_id}/{fingerprint}
func (s *Server) handleOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/authorizations/clients/{client_id}/{fingerprint}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintOperation,
			ID:   "oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint",
		}
	)
	params, err := decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintOperation,
			OperationSummary: "Get-or-create an authorization for a specific app and fingerprint",
			OperationID:      "oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "client_id",
					In:   "path",
				}: params.ClientID,
				{
					Name: "fingerprint",
					In:   "path",
				}: params.Fingerprint,
			},
			Raw: r,
		}

		type (
			Request  = *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq
			Params   = OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams
			Response = OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprint(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOAuthAuthorizationsListAuthorizationsRequest handles oauth-authorizations/list-authorizations operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.
// com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth
// Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed
// on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /authorizations
func (s *Server) handleOAuthAuthorizationsListAuthorizationsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/list-authorizations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/authorizations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OAuthAuthorizationsListAuthorizationsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OAuthAuthorizationsListAuthorizationsOperation,
			ID:   "oauth-authorizations/list-authorizations",
		}
	)
	params, err := decodeOAuthAuthorizationsListAuthorizationsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OAuthAuthorizationsListAuthorizationsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OAuthAuthorizationsListAuthorizationsOperation,
			OperationSummary: "List your authorizations",
			OperationID:      "oauth-authorizations/list-authorizations",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "client_id",
					In:   "query",
				}: params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsListAuthorizationsParams
			Response = OAuthAuthorizationsListAuthorizationsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsListAuthorizationsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsListAuthorizations(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsListAuthorizations(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsListAuthorizationsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOAuthAuthorizationsListGrantsRequest handles oauth-authorizations/list-grants operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// You can use this API to list the set of OAuth applications that have been granted access to your
// account. Unlike the [list your authorizations](https://docs.github.
// com/rest/reference/oauth-authorizations#list-your-authorizations) API, this API does not manage
// individual tokens. This API will return one entry for each OAuth application that has been granted
// access to your account, regardless of the number of tokens an application has generated for your
// user. The list of OAuth applications returned matches what is shown on [the application
// authorizations settings screen within GitHub](https://github.com/settings/applications#authorized).
//
//	The `scopes` returned are the union of scopes authorized for the application. For example, if an
//
// application has one token with `repo` scope and another token with `user` scope, the grant will
// return `["repo", "user"]`.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /applications/grants
func (s *Server) handleOAuthAuthorizationsListGrantsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/list-grants"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/applications/grants"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OAuthAuthorizationsListGrantsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OAuthAuthorizationsListGrantsOperation,
			ID:   "oauth-authorizations/list-grants",
		}
	)
	params, err := decodeOAuthAuthorizationsListGrantsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OAuthAuthorizationsListGrantsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OAuthAuthorizationsListGrantsOperation,
			OperationSummary: "List your grants",
			OperationID:      "oauth-authorizations/list-grants",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "client_id",
					In:   "query",
				}: params.ClientID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OAuthAuthorizationsListGrantsParams
			Response = OAuthAuthorizationsListGrantsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsListGrantsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsListGrants(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsListGrants(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsListGrantsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOAuthAuthorizationsUpdateAuthorizationRequest handles oauth-authorizations/update-authorization operation.
//
// **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.
// com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access
// tokens and OAuth tokens, and you must now create these tokens using our [web application
// flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The
// [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be
// removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog
// post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
// If you have two-factor authentication setup, Basic Authentication for this endpoint requires that
// you use a one-time password (OTP) and your username and password instead of tokens. For more
// information, see "[Working with two-factor authentication](https://docs.github.
// com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
// You can only send one of these scope keys at a time.
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /authorizations/{authorization_id}
func (s *Server) handleOAuthAuthorizationsUpdateAuthorizationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("oauth-authorizations/update-authorization"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/authorizations/{authorization_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OAuthAuthorizationsUpdateAuthorizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OAuthAuthorizationsUpdateAuthorizationOperation,
			ID:   "oauth-authorizations/update-authorization",
		}
	)
	params, err := decodeOAuthAuthorizationsUpdateAuthorizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeOAuthAuthorizationsUpdateAuthorizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OAuthAuthorizationsUpdateAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OAuthAuthorizationsUpdateAuthorizationOperation,
			OperationSummary: "Update an existing authorization",
			OperationID:      "oauth-authorizations/update-authorization",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "authorization_id",
					In:   "path",
				}: params.AuthorizationID,
			},
			Raw: r,
		}

		type (
			Request  = OptOAuthAuthorizationsUpdateAuthorizationReq
			Params   = OAuthAuthorizationsUpdateAuthorizationParams
			Response = OAuthAuthorizationsUpdateAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOAuthAuthorizationsUpdateAuthorizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuthAuthorizationsUpdateAuthorization(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuthAuthorizationsUpdateAuthorization(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuthAuthorizationsUpdateAuthorizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsBlockUserRequest handles orgs/block-user operation.
//
// Block a user from an organization.
//
// PUT /orgs/{org}/blocks/{username}
func (s *Server) handleOrgsBlockUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/block-user"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/blocks/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsBlockUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsBlockUserOperation,
			ID:   "orgs/block-user",
		}
	)
	params, err := decodeOrgsBlockUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsBlockUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsBlockUserOperation,
			OperationSummary: "Block a user from an organization",
			OperationID:      "orgs/block-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsBlockUserParams
			Response = OrgsBlockUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsBlockUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsBlockUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsBlockUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsBlockUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsCancelInvitationRequest handles orgs/cancel-invitation operation.
//
// Cancel an organization invitation. In order to cancel an organization invitation, the
// authenticated user must be an organization owner.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications).
//
// DELETE /orgs/{org}/invitations/{invitation_id}
func (s *Server) handleOrgsCancelInvitationRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/cancel-invitation"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/invitations/{invitation_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsCancelInvitationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsCancelInvitationOperation,
			ID:   "orgs/cancel-invitation",
		}
	)
	params, err := decodeOrgsCancelInvitationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsCancelInvitationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsCancelInvitationOperation,
			OperationSummary: "Cancel an organization invitation",
			OperationID:      "orgs/cancel-invitation",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "invitation_id",
					In:   "path",
				}: params.InvitationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsCancelInvitationParams
			Response = OrgsCancelInvitationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCancelInvitationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsCancelInvitation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsCancelInvitation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCancelInvitationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsCheckBlockedUserRequest handles orgs/check-blocked-user operation.
//
// Check if a user is blocked by an organization.
//
// GET /orgs/{org}/blocks/{username}
func (s *Server) handleOrgsCheckBlockedUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-blocked-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/blocks/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsCheckBlockedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsCheckBlockedUserOperation,
			ID:   "orgs/check-blocked-user",
		}
	)
	params, err := decodeOrgsCheckBlockedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsCheckBlockedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsCheckBlockedUserOperation,
			OperationSummary: "Check if a user is blocked by an organization",
			OperationID:      "orgs/check-blocked-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsCheckBlockedUserParams
			Response = OrgsCheckBlockedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCheckBlockedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsCheckBlockedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsCheckBlockedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCheckBlockedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsCheckMembershipForUserRequest handles orgs/check-membership-for-user operation.
//
// Check if a user is, publicly or privately, a member of the organization.
//
// GET /orgs/{org}/members/{username}
func (s *Server) handleOrgsCheckMembershipForUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-membership-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/members/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsCheckMembershipForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsCheckMembershipForUserOperation,
			ID:   "orgs/check-membership-for-user",
		}
	)
	params, err := decodeOrgsCheckMembershipForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsCheckMembershipForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsCheckMembershipForUserOperation,
			OperationSummary: "Check organization membership for a user",
			OperationID:      "orgs/check-membership-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsCheckMembershipForUserParams
			Response = OrgsCheckMembershipForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCheckMembershipForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsCheckMembershipForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsCheckMembershipForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCheckMembershipForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsCheckPublicMembershipForUserRequest handles orgs/check-public-membership-for-user operation.
//
// Check public organization membership for a user.
//
// GET /orgs/{org}/public_members/{username}
func (s *Server) handleOrgsCheckPublicMembershipForUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/check-public-membership-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/public_members/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsCheckPublicMembershipForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsCheckPublicMembershipForUserOperation,
			ID:   "orgs/check-public-membership-for-user",
		}
	)
	params, err := decodeOrgsCheckPublicMembershipForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsCheckPublicMembershipForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsCheckPublicMembershipForUserOperation,
			OperationSummary: "Check public organization membership for a user",
			OperationID:      "orgs/check-public-membership-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsCheckPublicMembershipForUserParams
			Response = OrgsCheckPublicMembershipForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCheckPublicMembershipForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsCheckPublicMembershipForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsCheckPublicMembershipForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCheckPublicMembershipForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsConvertMemberToOutsideCollaboratorRequest handles orgs/convert-member-to-outside-collaborator operation.
//
// When an organization member is converted to an outside collaborator, they'll only have access to
// the repositories that their current team membership allows. The user will no longer be a member of
// the organization. For more information, see "[Converting an organization member to an outside
// collaborator](https://help.github.
// com/articles/converting-an-organization-member-to-an-outside-collaborator/)".
//
// PUT /orgs/{org}/outside_collaborators/{username}
func (s *Server) handleOrgsConvertMemberToOutsideCollaboratorRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/convert-member-to-outside-collaborator"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/outside_collaborators/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsConvertMemberToOutsideCollaboratorOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsConvertMemberToOutsideCollaboratorOperation,
			ID:   "orgs/convert-member-to-outside-collaborator",
		}
	)
	params, err := decodeOrgsConvertMemberToOutsideCollaboratorParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsConvertMemberToOutsideCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsConvertMemberToOutsideCollaboratorOperation,
			OperationSummary: "Convert an organization member to outside collaborator",
			OperationID:      "orgs/convert-member-to-outside-collaborator",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsConvertMemberToOutsideCollaboratorParams
			Response = OrgsConvertMemberToOutsideCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsConvertMemberToOutsideCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsConvertMemberToOutsideCollaborator(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsConvertMemberToOutsideCollaborator(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsConvertMemberToOutsideCollaboratorResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsCreateInvitationRequest handles orgs/create-invitation operation.
//
// Invite people to an organization by using their GitHub user ID or their email address. In order to
// create invitations in an organization, the authenticated user must be an organization owner.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /orgs/{org}/invitations
func (s *Server) handleOrgsCreateInvitationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/create-invitation"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/invitations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsCreateInvitationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsCreateInvitationOperation,
			ID:   "orgs/create-invitation",
		}
	)
	params, err := decodeOrgsCreateInvitationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeOrgsCreateInvitationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OrgsCreateInvitationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsCreateInvitationOperation,
			OperationSummary: "Create an organization invitation",
			OperationID:      "orgs/create-invitation",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = OptOrgsCreateInvitationReq
			Params   = OrgsCreateInvitationParams
			Response = OrgsCreateInvitationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCreateInvitationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsCreateInvitation(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsCreateInvitation(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCreateInvitationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsCreateWebhookRequest handles orgs/create-webhook operation.
//
// Here's how you can create a hook that posts payloads in JSON format:.
//
// POST /orgs/{org}/hooks
func (s *Server) handleOrgsCreateWebhookRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/create-webhook"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsCreateWebhookOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsCreateWebhookOperation,
			ID:   "orgs/create-webhook",
		}
	)
	params, err := decodeOrgsCreateWebhookParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeOrgsCreateWebhookRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OrgsCreateWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsCreateWebhookOperation,
			OperationSummary: "Create an organization webhook",
			OperationID:      "orgs/create-webhook",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *OrgsCreateWebhookReq
			Params   = OrgsCreateWebhookParams
			Response = OrgsCreateWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsCreateWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsCreateWebhook(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsCreateWebhook(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsCreateWebhookResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsDeleteWebhookRequest handles orgs/delete-webhook operation.
//
// Delete an organization webhook.
//
// DELETE /orgs/{org}/hooks/{hook_id}
func (s *Server) handleOrgsDeleteWebhookRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/delete-webhook"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsDeleteWebhookOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsDeleteWebhookOperation,
			ID:   "orgs/delete-webhook",
		}
	)
	params, err := decodeOrgsDeleteWebhookParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsDeleteWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsDeleteWebhookOperation,
			OperationSummary: "Delete an organization webhook",
			OperationID:      "orgs/delete-webhook",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsDeleteWebhookParams
			Response = OrgsDeleteWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsDeleteWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsDeleteWebhook(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsDeleteWebhook(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsDeleteWebhookResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsGetRequest handles orgs/get operation.
//
// To see many of the organization response values, you need to be an authenticated organization
// owner with the `admin:org` scope. When the value of `two_factor_requirement_enabled` is `true`,
// the organization requires all members, billing managers, and outside collaborators to enable
// [two-factor authentication](https://help.github.
// com/articles/securing-your-account-with-two-factor-authentication-2fa/).
// GitHub Apps with the `Organization plan` permission can use this endpoint to retrieve information
// about an organization's GitHub plan. See "[Authenticating with GitHub Apps](https://docs.github.
// com/apps/building-github-apps/authenticating-with-github-apps/)" for details. For an example
// response, see 'Response with GitHub plan information' below.".
//
// GET /orgs/{org}
func (s *Server) handleOrgsGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsGetOperation,
			ID:   "orgs/get",
		}
	)
	params, err := decodeOrgsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsGetOperation,
			OperationSummary: "Get an organization",
			OperationID:      "orgs/get",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetParams
			Response = OrgsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsGetAuditLogRequest handles orgs/get-audit-log operation.
//
// Gets the audit log for an organization. For more information, see "[Reviewing the audit log for
// your organization](https://docs.github.
// com/github/setting-up-and-managing-organizations-and-teams/reviewing-the-audit-log-for-your-organization)."
// To use this endpoint, you must be an organization owner, and you must use an access token with the
// `admin:org` scope. GitHub Apps must have the `organization_administration` read permission to use
// this endpoint.
//
// GET /orgs/{org}/audit-log
func (s *Server) handleOrgsGetAuditLogRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-audit-log"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/audit-log"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsGetAuditLogOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsGetAuditLogOperation,
			ID:   "orgs/get-audit-log",
		}
	)
	params, err := decodeOrgsGetAuditLogParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []AuditLogEvent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsGetAuditLogOperation,
			OperationSummary: "Get the audit log for an organization",
			OperationID:      "orgs/get-audit-log",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "phrase",
					In:   "query",
				}: params.Phrase,
				{
					Name: "include",
					In:   "query",
				}: params.Include,
				{
					Name: "after",
					In:   "query",
				}: params.After,
				{
					Name: "before",
					In:   "query",
				}: params.Before,
				{
					Name: "order",
					In:   "query",
				}: params.Order,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetAuditLogParams
			Response = []AuditLogEvent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetAuditLogParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsGetAuditLog(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsGetAuditLog(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetAuditLogResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsGetMembershipForAuthenticatedUserRequest handles orgs/get-membership-for-authenticated-user operation.
//
// Get an organization membership for the authenticated user.
//
// GET /user/memberships/orgs/{org}
func (s *Server) handleOrgsGetMembershipForAuthenticatedUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-membership-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/memberships/orgs/{org}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsGetMembershipForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsGetMembershipForAuthenticatedUserOperation,
			ID:   "orgs/get-membership-for-authenticated-user",
		}
	)
	params, err := decodeOrgsGetMembershipForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsGetMembershipForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsGetMembershipForAuthenticatedUserOperation,
			OperationSummary: "Get an organization membership for the authenticated user",
			OperationID:      "orgs/get-membership-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetMembershipForAuthenticatedUserParams
			Response = OrgsGetMembershipForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetMembershipForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsGetMembershipForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsGetMembershipForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsGetMembershipForUserRequest handles orgs/get-membership-for-user operation.
//
// In order to get a user's membership with an organization, the authenticated user must be an
// organization member. The `state` parameter in the response can be used to identify the user's
// membership status.
//
// GET /orgs/{org}/memberships/{username}
func (s *Server) handleOrgsGetMembershipForUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-membership-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/memberships/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsGetMembershipForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsGetMembershipForUserOperation,
			ID:   "orgs/get-membership-for-user",
		}
	)
	params, err := decodeOrgsGetMembershipForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsGetMembershipForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsGetMembershipForUserOperation,
			OperationSummary: "Get organization membership for a user",
			OperationID:      "orgs/get-membership-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetMembershipForUserParams
			Response = OrgsGetMembershipForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetMembershipForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsGetMembershipForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsGetMembershipForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetMembershipForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsGetWebhookRequest handles orgs/get-webhook operation.
//
// Returns a webhook configured in an organization. To get only the webhook `config` properties, see
// "[Get a webhook configuration for an
// organization](/rest/reference/orgs#get-a-webhook-configuration-for-an-organization).".
//
// GET /orgs/{org}/hooks/{hook_id}
func (s *Server) handleOrgsGetWebhookRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsGetWebhookOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsGetWebhookOperation,
			ID:   "orgs/get-webhook",
		}
	)
	params, err := decodeOrgsGetWebhookParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsGetWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsGetWebhookOperation,
			OperationSummary: "Get an organization webhook",
			OperationID:      "orgs/get-webhook",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetWebhookParams
			Response = OrgsGetWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsGetWebhook(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsGetWebhook(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetWebhookResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsGetWebhookConfigForOrgRequest handles orgs/get-webhook-config-for-org operation.
//
// Returns the webhook configuration for an organization. To get more information about the webhook,
// including the `active` state and `events`, use "[Get an organization webhook
// ](/rest/reference/orgs#get-an-organization-webhook)."
// Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the
// `organization_hooks:read` permission.
//
// GET /orgs/{org}/hooks/{hook_id}/config
func (s *Server) handleOrgsGetWebhookConfigForOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook-config-for-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}/config"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsGetWebhookConfigForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsGetWebhookConfigForOrgOperation,
			ID:   "orgs/get-webhook-config-for-org",
		}
	)
	params, err := decodeOrgsGetWebhookConfigForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsGetWebhookConfigForOrgOperation,
			OperationSummary: "Get a webhook configuration for an organization",
			OperationID:      "orgs/get-webhook-config-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetWebhookConfigForOrgParams
			Response = *WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetWebhookConfigForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsGetWebhookConfigForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsGetWebhookConfigForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetWebhookConfigForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsGetWebhookDeliveryRequest handles orgs/get-webhook-delivery operation.
//
// Returns a delivery for a webhook configured in an organization.
//
// GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}
func (s *Server) handleOrgsGetWebhookDeliveryRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/get-webhook-delivery"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsGetWebhookDeliveryOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsGetWebhookDeliveryOperation,
			ID:   "orgs/get-webhook-delivery",
		}
	)
	params, err := decodeOrgsGetWebhookDeliveryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsGetWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsGetWebhookDeliveryOperation,
			OperationSummary: "Get a webhook delivery for an organization webhook",
			OperationID:      "orgs/get-webhook-delivery",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
				{
					Name: "delivery_id",
					In:   "path",
				}: params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsGetWebhookDeliveryParams
			Response = OrgsGetWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsGetWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsGetWebhookDelivery(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsGetWebhookDelivery(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsGetWebhookDeliveryResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsListRequest handles orgs/list operation.
//
// Lists all organizations, in the order that they were created on GitHub.
// **Note:** Pagination is powered exclusively by the `since` parameter. Use the [Link
// header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the
// URL for the next page of organizations.
//
// GET /organizations
func (s *Server) handleOrgsListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/organizations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsListOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsListOperation,
			ID:   "orgs/list",
		}
	)
	params, err := decodeOrgsListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsListOperation,
			OperationSummary: "List organizations",
			OperationID:      "orgs/list",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListParams
			Response = OrgsListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsListBlockedUsersRequest handles orgs/list-blocked-users operation.
//
// List the users blocked by an organization.
//
// GET /orgs/{org}/blocks
func (s *Server) handleOrgsListBlockedUsersRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-blocked-users"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/blocks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsListBlockedUsersOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsListBlockedUsersOperation,
			ID:   "orgs/list-blocked-users",
		}
	)
	params, err := decodeOrgsListBlockedUsersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsListBlockedUsersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsListBlockedUsersOperation,
			OperationSummary: "List users blocked by an organization",
			OperationID:      "orgs/list-blocked-users",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListBlockedUsersParams
			Response = OrgsListBlockedUsersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListBlockedUsersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListBlockedUsers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListBlockedUsers(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListBlockedUsersResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsListFailedInvitationsRequest handles orgs/list-failed-invitations operation.
//
// The return hash contains `failed_at` and `failed_reason` fields which represent the time at which
// the invitation failed and the reason for the failure.
//
// GET /orgs/{org}/failed_invitations
func (s *Server) handleOrgsListFailedInvitationsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-failed-invitations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/failed_invitations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsListFailedInvitationsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsListFailedInvitationsOperation,
			ID:   "orgs/list-failed-invitations",
		}
	)
	params, err := decodeOrgsListFailedInvitationsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsListFailedInvitationsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsListFailedInvitationsOperation,
			OperationSummary: "List failed organization invitations",
			OperationID:      "orgs/list-failed-invitations",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListFailedInvitationsParams
			Response = OrgsListFailedInvitationsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListFailedInvitationsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListFailedInvitations(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListFailedInvitations(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListFailedInvitationsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsListForAuthenticatedUserRequest handles orgs/list-for-authenticated-user operation.
//
// List organizations for the authenticated user.
// **OAuth scope requirements**
// This only lists organizations that your authorization allows you to operate on in some way (e.g.,
// you can list teams with `read:org` scope, you can publicize your organization membership with
// `user` scope, etc.). Therefore, this API requires at least `user` or `read:org` scope. OAuth
// requests with insufficient scope receive a `403 Forbidden` response.
//
// GET /user/orgs
func (s *Server) handleOrgsListForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/orgs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsListForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsListForAuthenticatedUserOperation,
			ID:   "orgs/list-for-authenticated-user",
		}
	)
	params, err := decodeOrgsListForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsListForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsListForAuthenticatedUserOperation,
			OperationSummary: "List organizations for the authenticated user",
			OperationID:      "orgs/list-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListForAuthenticatedUserParams
			Response = OrgsListForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsListForUserRequest handles orgs/list-for-user operation.
//
// List [public organization memberships](https://help.github.
// com/articles/publicizing-or-concealing-organization-membership) for the specified user.
// This method only lists _public_ memberships, regardless of authentication. If you need to fetch
// all of the organization memberships (public and private) for the authenticated user, use the [List
// organizations for the authenticated user](https://docs.github.
// com/rest/reference/orgs#list-organizations-for-the-authenticated-user) API instead.
//
// GET /users/{username}/orgs
func (s *Server) handleOrgsListForUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/orgs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsListForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsListForUserOperation,
			ID:   "orgs/list-for-user",
		}
	)
	params, err := decodeOrgsListForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *OrgsListForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsListForUserOperation,
			OperationSummary: "List organizations for a user",
			OperationID:      "orgs/list-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListForUserParams
			Response = *OrgsListForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsListInvitationTeamsRequest handles orgs/list-invitation-teams operation.
//
// List all teams associated with an invitation. In order to see invitations in an organization, the
// authenticated user must be an organization owner.
//
// GET /orgs/{org}/invitations/{invitation_id}/teams
func (s *Server) handleOrgsListInvitationTeamsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-invitation-teams"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/invitations/{invitation_id}/teams"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsListInvitationTeamsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsListInvitationTeamsOperation,
			ID:   "orgs/list-invitation-teams",
		}
	)
	params, err := decodeOrgsListInvitationTeamsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsListInvitationTeamsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsListInvitationTeamsOperation,
			OperationSummary: "List organization invitation teams",
			OperationID:      "orgs/list-invitation-teams",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "invitation_id",
					In:   "path",
				}: params.InvitationID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListInvitationTeamsParams
			Response = OrgsListInvitationTeamsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListInvitationTeamsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListInvitationTeams(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListInvitationTeams(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListInvitationTeamsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsListMembersRequest handles orgs/list-members operation.
//
// List all users who are members of an organization. If the authenticated user is also a member of
// this organization then both concealed and public members will be returned.
//
// GET /orgs/{org}/members
func (s *Server) handleOrgsListMembersRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-members"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/members"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsListMembersOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsListMembersOperation,
			ID:   "orgs/list-members",
		}
	)
	params, err := decodeOrgsListMembersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsListMembersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsListMembersOperation,
			OperationSummary: "List organization members",
			OperationID:      "orgs/list-members",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "role",
					In:   "query",
				}: params.Role,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListMembersParams
			Response = OrgsListMembersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListMembersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListMembers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListMembers(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListMembersResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsListMembershipsForAuthenticatedUserRequest handles orgs/list-memberships-for-authenticated-user operation.
//
// List organization memberships for the authenticated user.
//
// GET /user/memberships/orgs
func (s *Server) handleOrgsListMembershipsForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-memberships-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/memberships/orgs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsListMembershipsForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsListMembershipsForAuthenticatedUserOperation,
			ID:   "orgs/list-memberships-for-authenticated-user",
		}
	)
	params, err := decodeOrgsListMembershipsForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsListMembershipsForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsListMembershipsForAuthenticatedUserOperation,
			OperationSummary: "List organization memberships for the authenticated user",
			OperationID:      "orgs/list-memberships-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListMembershipsForAuthenticatedUserParams
			Response = OrgsListMembershipsForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListMembershipsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListMembershipsForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListMembershipsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListMembershipsForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsListOutsideCollaboratorsRequest handles orgs/list-outside-collaborators operation.
//
// List all users who are outside collaborators of an organization.
//
// GET /orgs/{org}/outside_collaborators
func (s *Server) handleOrgsListOutsideCollaboratorsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-outside-collaborators"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/outside_collaborators"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsListOutsideCollaboratorsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsListOutsideCollaboratorsOperation,
			ID:   "orgs/list-outside-collaborators",
		}
	)
	params, err := decodeOrgsListOutsideCollaboratorsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *OrgsListOutsideCollaboratorsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsListOutsideCollaboratorsOperation,
			OperationSummary: "List outside collaborators for an organization",
			OperationID:      "orgs/list-outside-collaborators",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "filter",
					In:   "query",
				}: params.Filter,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListOutsideCollaboratorsParams
			Response = *OrgsListOutsideCollaboratorsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListOutsideCollaboratorsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListOutsideCollaborators(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListOutsideCollaborators(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListOutsideCollaboratorsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsListPendingInvitationsRequest handles orgs/list-pending-invitations operation.
//
// The return hash contains a `role` field which refers to the Organization Invitation role and will
// be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or
// `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be
// `null`.
//
// GET /orgs/{org}/invitations
func (s *Server) handleOrgsListPendingInvitationsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-pending-invitations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/invitations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsListPendingInvitationsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsListPendingInvitationsOperation,
			ID:   "orgs/list-pending-invitations",
		}
	)
	params, err := decodeOrgsListPendingInvitationsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsListPendingInvitationsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsListPendingInvitationsOperation,
			OperationSummary: "List pending organization invitations",
			OperationID:      "orgs/list-pending-invitations",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListPendingInvitationsParams
			Response = OrgsListPendingInvitationsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListPendingInvitationsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListPendingInvitations(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListPendingInvitations(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListPendingInvitationsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsListPublicMembersRequest handles orgs/list-public-members operation.
//
// Members of an organization can choose to have their membership publicized or not.
//
// GET /orgs/{org}/public_members
func (s *Server) handleOrgsListPublicMembersRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-public-members"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/public_members"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsListPublicMembersOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsListPublicMembersOperation,
			ID:   "orgs/list-public-members",
		}
	)
	params, err := decodeOrgsListPublicMembersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *OrgsListPublicMembersOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsListPublicMembersOperation,
			OperationSummary: "List public organization members",
			OperationID:      "orgs/list-public-members",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListPublicMembersParams
			Response = *OrgsListPublicMembersOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListPublicMembersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListPublicMembers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListPublicMembers(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListPublicMembersResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsListSamlSSOAuthorizationsRequest handles orgs/list-saml-sso-authorizations operation.
//
// Listing and deleting credential authorizations is available to organizations with GitHub
// Enterprise Cloud. For more information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products).
// An authenticated organization owner with the `read:org` scope can list all credential
// authorizations for an organization that uses SAML single sign-on (SSO). The credentials are either
// personal access tokens or SSH keys that organization members have authorized for the organization.
// For more information, see [About authentication with SAML single sign-on](https://help.github.
// com/en/articles/about-authentication-with-saml-single-sign-on).
//
// GET /orgs/{org}/credential-authorizations
func (s *Server) handleOrgsListSamlSSOAuthorizationsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-saml-sso-authorizations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/credential-authorizations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsListSamlSSOAuthorizationsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsListSamlSSOAuthorizationsOperation,
			ID:   "orgs/list-saml-sso-authorizations",
		}
	)
	params, err := decodeOrgsListSamlSSOAuthorizationsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []CredentialAuthorization
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsListSamlSSOAuthorizationsOperation,
			OperationSummary: "List SAML SSO authorizations for an organization",
			OperationID:      "orgs/list-saml-sso-authorizations",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListSamlSSOAuthorizationsParams
			Response = []CredentialAuthorization
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListSamlSSOAuthorizationsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListSamlSSOAuthorizations(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListSamlSSOAuthorizations(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListSamlSSOAuthorizationsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsListWebhookDeliveriesRequest handles orgs/list-webhook-deliveries operation.
//
// Returns a list of webhook deliveries for a webhook configured in an organization.
//
// GET /orgs/{org}/hooks/{hook_id}/deliveries
func (s *Server) handleOrgsListWebhookDeliveriesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-webhook-deliveries"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}/deliveries"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsListWebhookDeliveriesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsListWebhookDeliveriesOperation,
			ID:   "orgs/list-webhook-deliveries",
		}
	)
	params, err := decodeOrgsListWebhookDeliveriesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsListWebhookDeliveriesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsListWebhookDeliveriesOperation,
			OperationSummary: "List deliveries for an organization webhook",
			OperationID:      "orgs/list-webhook-deliveries",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "cursor",
					In:   "query",
				}: params.Cursor,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListWebhookDeliveriesParams
			Response = OrgsListWebhookDeliveriesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListWebhookDeliveriesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListWebhookDeliveries(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListWebhookDeliveries(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListWebhookDeliveriesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsListWebhooksRequest handles orgs/list-webhooks operation.
//
// List organization webhooks.
//
// GET /orgs/{org}/hooks
func (s *Server) handleOrgsListWebhooksRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/list-webhooks"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsListWebhooksOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsListWebhooksOperation,
			ID:   "orgs/list-webhooks",
		}
	)
	params, err := decodeOrgsListWebhooksParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsListWebhooksRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsListWebhooksOperation,
			OperationSummary: "List organization webhooks",
			OperationID:      "orgs/list-webhooks",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsListWebhooksParams
			Response = OrgsListWebhooksRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsListWebhooksParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsListWebhooks(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsListWebhooks(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsListWebhooksResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsPingWebhookRequest handles orgs/ping-webhook operation.
//
// This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the
// hook.
//
// POST /orgs/{org}/hooks/{hook_id}/pings
func (s *Server) handleOrgsPingWebhookRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/ping-webhook"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}/pings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsPingWebhookOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsPingWebhookOperation,
			ID:   "orgs/ping-webhook",
		}
	)
	params, err := decodeOrgsPingWebhookParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsPingWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsPingWebhookOperation,
			OperationSummary: "Ping an organization webhook",
			OperationID:      "orgs/ping-webhook",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsPingWebhookParams
			Response = OrgsPingWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsPingWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsPingWebhook(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsPingWebhook(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsPingWebhookResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsRedeliverWebhookDeliveryRequest handles orgs/redeliver-webhook-delivery operation.
//
// Redeliver a delivery for a webhook configured in an organization.
//
// POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
func (s *Server) handleOrgsRedeliverWebhookDeliveryRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/redeliver-webhook-delivery"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsRedeliverWebhookDeliveryOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsRedeliverWebhookDeliveryOperation,
			ID:   "orgs/redeliver-webhook-delivery",
		}
	)
	params, err := decodeOrgsRedeliverWebhookDeliveryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsRedeliverWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsRedeliverWebhookDeliveryOperation,
			OperationSummary: "Redeliver a delivery for an organization webhook",
			OperationID:      "orgs/redeliver-webhook-delivery",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
				{
					Name: "delivery_id",
					In:   "path",
				}: params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRedeliverWebhookDeliveryParams
			Response = OrgsRedeliverWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRedeliverWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsRedeliverWebhookDelivery(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsRedeliverWebhookDelivery(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRedeliverWebhookDeliveryResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsRemoveMemberRequest handles orgs/remove-member operation.
//
// Removing a user from this list will remove them from all teams and they will no longer have any
// access to the organization's repositories.
//
// DELETE /orgs/{org}/members/{username}
func (s *Server) handleOrgsRemoveMemberRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-member"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/members/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsRemoveMemberOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsRemoveMemberOperation,
			ID:   "orgs/remove-member",
		}
	)
	params, err := decodeOrgsRemoveMemberParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsRemoveMemberRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsRemoveMemberOperation,
			OperationSummary: "Remove an organization member",
			OperationID:      "orgs/remove-member",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRemoveMemberParams
			Response = OrgsRemoveMemberRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRemoveMemberParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsRemoveMember(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsRemoveMember(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRemoveMemberResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsRemoveMembershipForUserRequest handles orgs/remove-membership-for-user operation.
//
// In order to remove a user's membership with an organization, the authenticated user must be an
// organization owner.
// If the specified user is an active member of the organization, this will remove them from the
// organization. If the specified user has been invited to the organization, this will cancel their
// invitation. The specified user will receive an email notification in both cases.
//
// DELETE /orgs/{org}/memberships/{username}
func (s *Server) handleOrgsRemoveMembershipForUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-membership-for-user"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/memberships/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsRemoveMembershipForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsRemoveMembershipForUserOperation,
			ID:   "orgs/remove-membership-for-user",
		}
	)
	params, err := decodeOrgsRemoveMembershipForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsRemoveMembershipForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsRemoveMembershipForUserOperation,
			OperationSummary: "Remove organization membership for a user",
			OperationID:      "orgs/remove-membership-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRemoveMembershipForUserParams
			Response = OrgsRemoveMembershipForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRemoveMembershipForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsRemoveMembershipForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsRemoveMembershipForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRemoveMembershipForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsRemoveOutsideCollaboratorRequest handles orgs/remove-outside-collaborator operation.
//
// Removing a user from this list will remove them from all the organization's repositories.
//
// DELETE /orgs/{org}/outside_collaborators/{username}
func (s *Server) handleOrgsRemoveOutsideCollaboratorRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-outside-collaborator"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/outside_collaborators/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsRemoveOutsideCollaboratorOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsRemoveOutsideCollaboratorOperation,
			ID:   "orgs/remove-outside-collaborator",
		}
	)
	params, err := decodeOrgsRemoveOutsideCollaboratorParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsRemoveOutsideCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsRemoveOutsideCollaboratorOperation,
			OperationSummary: "Remove outside collaborator from an organization",
			OperationID:      "orgs/remove-outside-collaborator",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRemoveOutsideCollaboratorParams
			Response = OrgsRemoveOutsideCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRemoveOutsideCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsRemoveOutsideCollaborator(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsRemoveOutsideCollaborator(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRemoveOutsideCollaboratorResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsRemovePublicMembershipForAuthenticatedUserRequest handles orgs/remove-public-membership-for-authenticated-user operation.
//
// Remove public organization membership for the authenticated user.
//
// DELETE /orgs/{org}/public_members/{username}
func (s *Server) handleOrgsRemovePublicMembershipForAuthenticatedUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-public-membership-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/public_members/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsRemovePublicMembershipForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsRemovePublicMembershipForAuthenticatedUserOperation,
			ID:   "orgs/remove-public-membership-for-authenticated-user",
		}
	)
	params, err := decodeOrgsRemovePublicMembershipForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *OrgsRemovePublicMembershipForAuthenticatedUserNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsRemovePublicMembershipForAuthenticatedUserOperation,
			OperationSummary: "Remove public organization membership for the authenticated user",
			OperationID:      "orgs/remove-public-membership-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRemovePublicMembershipForAuthenticatedUserParams
			Response = *OrgsRemovePublicMembershipForAuthenticatedUserNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRemovePublicMembershipForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.OrgsRemovePublicMembershipForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.OrgsRemovePublicMembershipForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRemovePublicMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsRemoveSamlSSOAuthorizationRequest handles orgs/remove-saml-sso-authorization operation.
//
// Listing and deleting credential authorizations is available to organizations with GitHub
// Enterprise Cloud. For more information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products).
// An authenticated organization owner with the `admin:org` scope can remove a credential
// authorization for an organization that uses SAML SSO. Once you remove someone's credential
// authorization, they will need to create a new personal access token or SSH key and authorize it
// for the organization they want to access.
//
// DELETE /orgs/{org}/credential-authorizations/{credential_id}
func (s *Server) handleOrgsRemoveSamlSSOAuthorizationRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/remove-saml-sso-authorization"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/credential-authorizations/{credential_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsRemoveSamlSSOAuthorizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsRemoveSamlSSOAuthorizationOperation,
			ID:   "orgs/remove-saml-sso-authorization",
		}
	)
	params, err := decodeOrgsRemoveSamlSSOAuthorizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsRemoveSamlSSOAuthorizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsRemoveSamlSSOAuthorizationOperation,
			OperationSummary: "Remove a SAML SSO authorization for an organization",
			OperationID:      "orgs/remove-saml-sso-authorization",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "credential_id",
					In:   "path",
				}: params.CredentialID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsRemoveSamlSSOAuthorizationParams
			Response = OrgsRemoveSamlSSOAuthorizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsRemoveSamlSSOAuthorizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsRemoveSamlSSOAuthorization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsRemoveSamlSSOAuthorization(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsRemoveSamlSSOAuthorizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsSetMembershipForUserRequest handles orgs/set-membership-for-user operation.
//
// Only authenticated organization owners can add a member to the organization or update the member's
// role.
// *   If the authenticated user is _adding_ a member to the organization, the invited user will
// receive an email inviting them to the organization. The user's [membership status](https://docs.
// github.com/rest/reference/orgs#get-organization-membership-for-a-user) will be `pending` until
// they accept the invitation.
// *   Authenticated users can _update_ a user's membership by passing the `role` parameter. If the
// authenticated user changes a member's role to `admin`, the affected user will receive an email
// notifying them that they've been made an organization owner. If the authenticated user changes an
// owner's role to `member`, no email will be sent.
// **Rate limits**
// To prevent abuse, the authenticated user is limited to 50 organization invitations per 24 hour
// period. If the organization is more than one month old or on a paid plan, the limit is 500
// invitations per 24 hour period.
//
// PUT /orgs/{org}/memberships/{username}
func (s *Server) handleOrgsSetMembershipForUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/set-membership-for-user"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/memberships/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsSetMembershipForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsSetMembershipForUserOperation,
			ID:   "orgs/set-membership-for-user",
		}
	)
	params, err := decodeOrgsSetMembershipForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeOrgsSetMembershipForUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OrgsSetMembershipForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsSetMembershipForUserOperation,
			OperationSummary: "Set organization membership for a user",
			OperationID:      "orgs/set-membership-for-user",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = OptOrgsSetMembershipForUserReq
			Params   = OrgsSetMembershipForUserParams
			Response = OrgsSetMembershipForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsSetMembershipForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsSetMembershipForUser(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsSetMembershipForUser(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsSetMembershipForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsSetPublicMembershipForAuthenticatedUserRequest handles orgs/set-public-membership-for-authenticated-user operation.
//
// The user can publicize their own membership. (A user cannot publicize the membership for another
// user.)
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// PUT /orgs/{org}/public_members/{username}
func (s *Server) handleOrgsSetPublicMembershipForAuthenticatedUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/set-public-membership-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/public_members/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsSetPublicMembershipForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsSetPublicMembershipForAuthenticatedUserOperation,
			ID:   "orgs/set-public-membership-for-authenticated-user",
		}
	)
	params, err := decodeOrgsSetPublicMembershipForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response OrgsSetPublicMembershipForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsSetPublicMembershipForAuthenticatedUserOperation,
			OperationSummary: "Set public organization membership for the authenticated user",
			OperationID:      "orgs/set-public-membership-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsSetPublicMembershipForAuthenticatedUserParams
			Response = OrgsSetPublicMembershipForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsSetPublicMembershipForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsSetPublicMembershipForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsSetPublicMembershipForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsSetPublicMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsUnblockUserRequest handles orgs/unblock-user operation.
//
// Unblock a user from an organization.
//
// DELETE /orgs/{org}/blocks/{username}
func (s *Server) handleOrgsUnblockUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/unblock-user"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/blocks/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsUnblockUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsUnblockUserOperation,
			ID:   "orgs/unblock-user",
		}
	)
	params, err := decodeOrgsUnblockUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *OrgsUnblockUserNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsUnblockUserOperation,
			OperationSummary: "Unblock a user from an organization",
			OperationID:      "orgs/unblock-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = OrgsUnblockUserParams
			Response = *OrgsUnblockUserNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsUnblockUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.OrgsUnblockUser(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.OrgsUnblockUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsUnblockUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsUpdateMembershipForAuthenticatedUserRequest handles orgs/update-membership-for-authenticated-user operation.
//
// Update an organization membership for the authenticated user.
//
// PATCH /user/memberships/orgs/{org}
func (s *Server) handleOrgsUpdateMembershipForAuthenticatedUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-membership-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/user/memberships/orgs/{org}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsUpdateMembershipForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsUpdateMembershipForAuthenticatedUserOperation,
			ID:   "orgs/update-membership-for-authenticated-user",
		}
	)
	params, err := decodeOrgsUpdateMembershipForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeOrgsUpdateMembershipForAuthenticatedUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OrgsUpdateMembershipForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsUpdateMembershipForAuthenticatedUserOperation,
			OperationSummary: "Update an organization membership for the authenticated user",
			OperationID:      "orgs/update-membership-for-authenticated-user",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *OrgsUpdateMembershipForAuthenticatedUserReq
			Params   = OrgsUpdateMembershipForAuthenticatedUserParams
			Response = OrgsUpdateMembershipForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsUpdateMembershipForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsUpdateMembershipForAuthenticatedUser(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsUpdateMembershipForAuthenticatedUser(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsUpdateMembershipForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsUpdateWebhookRequest handles orgs/update-webhook operation.
//
// Updates a webhook configured in an organization. When you update a webhook, the `secret` will be
// overwritten. If you previously had a `secret` set, you must provide the same `secret` or set a new
// `secret` or the secret will be removed. If you are only updating individual webhook `config`
// properties, use "[Update a webhook configuration for an
// organization](/rest/reference/orgs#update-a-webhook-configuration-for-an-organization).".
//
// PATCH /orgs/{org}/hooks/{hook_id}
func (s *Server) handleOrgsUpdateWebhookRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-webhook"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsUpdateWebhookOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsUpdateWebhookOperation,
			ID:   "orgs/update-webhook",
		}
	)
	params, err := decodeOrgsUpdateWebhookParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeOrgsUpdateWebhookRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response OrgsUpdateWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsUpdateWebhookOperation,
			OperationSummary: "Update an organization webhook",
			OperationID:      "orgs/update-webhook",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = OptOrgsUpdateWebhookReq
			Params   = OrgsUpdateWebhookParams
			Response = OrgsUpdateWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsUpdateWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsUpdateWebhook(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsUpdateWebhook(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsUpdateWebhookResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOrgsUpdateWebhookConfigForOrgRequest handles orgs/update-webhook-config-for-org operation.
//
// Updates the webhook configuration for an organization. To update more information about the
// webhook, including the `active` state and `events`, use "[Update an organization webhook
// ](/rest/reference/orgs#update-an-organization-webhook)."
// Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the
// `organization_hooks:write` permission.
//
// PATCH /orgs/{org}/hooks/{hook_id}/config
func (s *Server) handleOrgsUpdateWebhookConfigForOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orgs/update-webhook-config-for-org"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/orgs/{org}/hooks/{hook_id}/config"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), OrgsUpdateWebhookConfigForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: OrgsUpdateWebhookConfigForOrgOperation,
			ID:   "orgs/update-webhook-config-for-org",
		}
	)
	params, err := decodeOrgsUpdateWebhookConfigForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeOrgsUpdateWebhookConfigForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    OrgsUpdateWebhookConfigForOrgOperation,
			OperationSummary: "Update a webhook configuration for an organization",
			OperationID:      "orgs/update-webhook-config-for-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = OptOrgsUpdateWebhookConfigForOrgReq
			Params   = OrgsUpdateWebhookConfigForOrgParams
			Response = *WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackOrgsUpdateWebhookConfigForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OrgsUpdateWebhookConfigForOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.OrgsUpdateWebhookConfigForOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOrgsUpdateWebhookConfigForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesDeletePackageForAuthenticatedUserRequest handles packages/delete-package-for-authenticated-user operation.
//
// Deletes a package owned by the authenticated user. You cannot delete a public package if any
// version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for
// further assistance.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:delete` scopes.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// DELETE /user/packages/{package_type}/{package_name}
func (s *Server) handlePackagesDeletePackageForAuthenticatedUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/packages/{package_type}/{package_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesDeletePackageForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesDeletePackageForAuthenticatedUserOperation,
			ID:   "packages/delete-package-for-authenticated-user",
		}
	)
	params, err := decodePackagesDeletePackageForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesDeletePackageForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesDeletePackageForAuthenticatedUserOperation,
			OperationSummary: "Delete a package for the authenticated user",
			OperationID:      "packages/delete-package-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageForAuthenticatedUserParams
			Response = PackagesDeletePackageForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesDeletePackageForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesDeletePackageForOrgRequest handles packages/delete-package-for-org operation.
//
// Deletes an entire package in an organization. You cannot delete a public package if any version of
// the package has more than 5,000 downloads. In this scenario, contact GitHub support for further
// assistance.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:delete` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container you want
// to delete.
//
// DELETE /orgs/{org}/packages/{package_type}/{package_name}
func (s *Server) handlePackagesDeletePackageForOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-org"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/packages/{package_type}/{package_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesDeletePackageForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesDeletePackageForOrgOperation,
			ID:   "packages/delete-package-for-org",
		}
	)
	params, err := decodePackagesDeletePackageForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesDeletePackageForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesDeletePackageForOrgOperation,
			OperationSummary: "Delete a package for an organization",
			OperationID:      "packages/delete-package-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageForOrgParams
			Response = PackagesDeletePackageForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesDeletePackageForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesDeletePackageForUserRequest handles packages/delete-package-for-user operation.
//
// Deletes an entire package for a user. You cannot delete a public package if any version of the
// package has more than 5,000 downloads. In this scenario, contact GitHub support for further
// assistance.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:delete` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container you want
// to delete.
//
// DELETE /users/{username}/packages/{package_type}/{package_name}
func (s *Server) handlePackagesDeletePackageForUserRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-for-user"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/users/{username}/packages/{package_type}/{package_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesDeletePackageForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesDeletePackageForUserOperation,
			ID:   "packages/delete-package-for-user",
		}
	)
	params, err := decodePackagesDeletePackageForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesDeletePackageForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesDeletePackageForUserOperation,
			OperationSummary: "Delete a package for a user",
			OperationID:      "packages/delete-package-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageForUserParams
			Response = PackagesDeletePackageForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesDeletePackageForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesDeletePackageVersionForAuthenticatedUserRequest handles packages/delete-package-version-for-authenticated-user operation.
//
// Deletes a specific package version for a package owned by the authenticated user.  If the package
// is public and the package version has more than 5,000 downloads, you cannot delete the package
// version. In this scenario, contact GitHub support for further assistance.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:delete` scopes.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesDeletePackageVersionForAuthenticatedUserRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/packages/{package_type}/{package_name}/versions/{package_version_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesDeletePackageVersionForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesDeletePackageVersionForAuthenticatedUserOperation,
			ID:   "packages/delete-package-version-for-authenticated-user",
		}
	)
	params, err := decodePackagesDeletePackageVersionForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesDeletePackageVersionForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesDeletePackageVersionForAuthenticatedUserOperation,
			OperationSummary: "Delete a package version for the authenticated user",
			OperationID:      "packages/delete-package-version-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageVersionForAuthenticatedUserParams
			Response = PackagesDeletePackageVersionForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageVersionForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesDeletePackageVersionForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageVersionForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesDeletePackageVersionForOrgRequest handles packages/delete-package-version-for-org operation.
//
// Deletes a specific package version in an organization. If the package is public and the package
// version has more than 5,000 downloads, you cannot delete the package version. In this scenario,
// contact GitHub support for further assistance.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:delete` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container you want
// to delete.
//
// DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesDeletePackageVersionForOrgRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-org"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesDeletePackageVersionForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesDeletePackageVersionForOrgOperation,
			ID:   "packages/delete-package-version-for-org",
		}
	)
	params, err := decodePackagesDeletePackageVersionForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesDeletePackageVersionForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesDeletePackageVersionForOrgOperation,
			OperationSummary: "Delete package version for an organization",
			OperationID:      "packages/delete-package-version-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageVersionForOrgParams
			Response = PackagesDeletePackageVersionForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageVersionForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesDeletePackageVersionForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageVersionForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageVersionForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesDeletePackageVersionForUserRequest handles packages/delete-package-version-for-user operation.
//
// Deletes a specific package version for a user. If the package is public and the package version
// has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact
// GitHub support for further assistance.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:delete` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container you want
// to delete.
//
// DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesDeletePackageVersionForUserRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/delete-package-version-for-user"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesDeletePackageVersionForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesDeletePackageVersionForUserOperation,
			ID:   "packages/delete-package-version-for-user",
		}
	)
	params, err := decodePackagesDeletePackageVersionForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesDeletePackageVersionForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesDeletePackageVersionForUserOperation,
			OperationSummary: "Delete package version for a user",
			OperationID:      "packages/delete-package-version-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesDeletePackageVersionForUserParams
			Response = PackagesDeletePackageVersionForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesDeletePackageVersionForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesDeletePackageVersionForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesDeletePackageVersionForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesDeletePackageVersionForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest handles packages/get-all-package-versions-for-package-owned-by-authenticated-user operation.
//
// Returns all package versions for a package owned by the authenticated user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /user/packages/{package_type}/{package_name}/versions
func (s *Server) handlePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/packages/{package_type}/{package_name}/versions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOperation,
			ID:   "packages/get-all-package-versions-for-package-owned-by-authenticated-user",
		}
	)
	params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOperation,
			OperationSummary: "Get all package versions for a package owned by the authenticated user",
			OperationID:      "packages/get-all-package-versions-for-package-owned-by-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "state",
					In:   "query",
				}: params.State,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams
			Response = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest handles packages/get-all-package-versions-for-package-owned-by-org operation.
//
// Returns all package versions for a package owned by an organization.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}/versions
func (s *Server) handlePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/packages/{package_type}/{package_name}/versions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesGetAllPackageVersionsForPackageOwnedByOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesGetAllPackageVersionsForPackageOwnedByOrgOperation,
			ID:   "packages/get-all-package-versions-for-package-owned-by-org",
		}
	)
	params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesGetAllPackageVersionsForPackageOwnedByOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesGetAllPackageVersionsForPackageOwnedByOrgOperation,
			OperationSummary: "Get all package versions for a package owned by an organization",
			OperationID:      "packages/get-all-package-versions-for-package-owned-by-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "state",
					In:   "query",
				}: params.State,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetAllPackageVersionsForPackageOwnedByOrgParams
			Response = PackagesGetAllPackageVersionsForPackageOwnedByOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetAllPackageVersionsForPackageOwnedByOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetAllPackageVersionsForPackageOwnedByOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesGetAllPackageVersionsForPackageOwnedByUserRequest handles packages/get-all-package-versions-for-package-owned-by-user operation.
//
// Returns all package versions for a public package owned by a specified user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /users/{username}/packages/{package_type}/{package_name}/versions
func (s *Server) handlePackagesGetAllPackageVersionsForPackageOwnedByUserRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-all-package-versions-for-package-owned-by-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/packages/{package_type}/{package_name}/versions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesGetAllPackageVersionsForPackageOwnedByUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesGetAllPackageVersionsForPackageOwnedByUserOperation,
			ID:   "packages/get-all-package-versions-for-package-owned-by-user",
		}
	)
	params, err := decodePackagesGetAllPackageVersionsForPackageOwnedByUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesGetAllPackageVersionsForPackageOwnedByUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesGetAllPackageVersionsForPackageOwnedByUserOperation,
			OperationSummary: "Get all package versions for a package owned by a user",
			OperationID:      "packages/get-all-package-versions-for-package-owned-by-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetAllPackageVersionsForPackageOwnedByUserParams
			Response = PackagesGetAllPackageVersionsForPackageOwnedByUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetAllPackageVersionsForPackageOwnedByUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetAllPackageVersionsForPackageOwnedByUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetAllPackageVersionsForPackageOwnedByUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetAllPackageVersionsForPackageOwnedByUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesGetPackageForAuthenticatedUserRequest handles packages/get-package-for-authenticated-user operation.
//
// Gets a specific package for a package owned by the authenticated user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /user/packages/{package_type}/{package_name}
func (s *Server) handlePackagesGetPackageForAuthenticatedUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/packages/{package_type}/{package_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesGetPackageForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesGetPackageForAuthenticatedUserOperation,
			ID:   "packages/get-package-for-authenticated-user",
		}
	)
	params, err := decodePackagesGetPackageForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *Package
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesGetPackageForAuthenticatedUserOperation,
			OperationSummary: "Get a package for the authenticated user",
			OperationID:      "packages/get-package-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageForAuthenticatedUserParams
			Response = *Package
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetPackageForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesGetPackageForOrganizationRequest handles packages/get-package-for-organization operation.
//
// Gets a specific package in an organization.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}
func (s *Server) handlePackagesGetPackageForOrganizationRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-organization"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/packages/{package_type}/{package_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesGetPackageForOrganizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesGetPackageForOrganizationOperation,
			ID:   "packages/get-package-for-organization",
		}
	)
	params, err := decodePackagesGetPackageForOrganizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *Package
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesGetPackageForOrganizationOperation,
			OperationSummary: "Get a package for an organization",
			OperationID:      "packages/get-package-for-organization",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageForOrganizationParams
			Response = *Package
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageForOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetPackageForOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageForOrganization(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageForOrganizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesGetPackageForUserRequest handles packages/get-package-for-user operation.
//
// Gets a specific package metadata for a public package owned by a user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /users/{username}/packages/{package_type}/{package_name}
func (s *Server) handlePackagesGetPackageForUserRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/packages/{package_type}/{package_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesGetPackageForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesGetPackageForUserOperation,
			ID:   "packages/get-package-for-user",
		}
	)
	params, err := decodePackagesGetPackageForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *Package
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesGetPackageForUserOperation,
			OperationSummary: "Get a package for a user",
			OperationID:      "packages/get-package-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageForUserParams
			Response = *Package
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetPackageForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesGetPackageVersionForAuthenticatedUserRequest handles packages/get-package-version-for-authenticated-user operation.
//
// Gets a specific package version for a package owned by the authenticated user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesGetPackageVersionForAuthenticatedUserRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/packages/{package_type}/{package_name}/versions/{package_version_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesGetPackageVersionForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesGetPackageVersionForAuthenticatedUserOperation,
			ID:   "packages/get-package-version-for-authenticated-user",
		}
	)
	params, err := decodePackagesGetPackageVersionForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *PackageVersion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesGetPackageVersionForAuthenticatedUserOperation,
			OperationSummary: "Get a package version for the authenticated user",
			OperationID:      "packages/get-package-version-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageVersionForAuthenticatedUserParams
			Response = *PackageVersion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageVersionForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetPackageVersionForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageVersionForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesGetPackageVersionForOrganizationRequest handles packages/get-package-version-for-organization operation.
//
// Gets a specific package version in an organization.
// You must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesGetPackageVersionForOrganizationRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-organization"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesGetPackageVersionForOrganizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesGetPackageVersionForOrganizationOperation,
			ID:   "packages/get-package-version-for-organization",
		}
	)
	params, err := decodePackagesGetPackageVersionForOrganizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *PackageVersion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesGetPackageVersionForOrganizationOperation,
			OperationSummary: "Get a package version for an organization",
			OperationID:      "packages/get-package-version-for-organization",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageVersionForOrganizationParams
			Response = *PackageVersion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageVersionForOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetPackageVersionForOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageVersionForOrganization(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageVersionForOrganizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesGetPackageVersionForUserRequest handles packages/get-package-version-for-user operation.
//
// Gets a specific package version for a public package owned by a specified user.
// At this time, to use this endpoint, you must authenticate using an access token with the
// `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}
func (s *Server) handlePackagesGetPackageVersionForUserRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/get-package-version-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesGetPackageVersionForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesGetPackageVersionForUserOperation,
			ID:   "packages/get-package-version-for-user",
		}
	)
	params, err := decodePackagesGetPackageVersionForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *PackageVersion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesGetPackageVersionForUserOperation,
			OperationSummary: "Get a package version for a user",
			OperationID:      "packages/get-package-version-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesGetPackageVersionForUserParams
			Response = *PackageVersion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesGetPackageVersionForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesGetPackageVersionForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesGetPackageVersionForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesGetPackageVersionForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesListPackagesForAuthenticatedUserRequest handles packages/list-packages-for-authenticated-user operation.
//
// Lists packages owned by the authenticated user within the user's namespace.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /user/packages
func (s *Server) handlePackagesListPackagesForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/packages"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesListPackagesForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesListPackagesForAuthenticatedUserOperation,
			ID:   "packages/list-packages-for-authenticated-user",
		}
	)
	params, err := decodePackagesListPackagesForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []Package
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesListPackagesForAuthenticatedUserOperation,
			OperationSummary: "List packages for the authenticated user's namespace",
			OperationID:      "packages/list-packages-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "query",
				}: params.PackageType,
				{
					Name: "visibility",
					In:   "query",
				}: params.Visibility,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesListPackagesForAuthenticatedUserParams
			Response = []Package
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesListPackagesForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesListPackagesForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesListPackagesForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesListPackagesForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesListPackagesForOrganizationRequest handles packages/list-packages-for-organization operation.
//
// Lists all packages in an organization readable by the user.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /orgs/{org}/packages
func (s *Server) handlePackagesListPackagesForOrganizationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-organization"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/packages"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesListPackagesForOrganizationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesListPackagesForOrganizationOperation,
			ID:   "packages/list-packages-for-organization",
		}
	)
	params, err := decodePackagesListPackagesForOrganizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesListPackagesForOrganizationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesListPackagesForOrganizationOperation,
			OperationSummary: "List packages for an organization",
			OperationID:      "packages/list-packages-for-organization",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "query",
				}: params.PackageType,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "visibility",
					In:   "query",
				}: params.Visibility,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesListPackagesForOrganizationParams
			Response = PackagesListPackagesForOrganizationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesListPackagesForOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesListPackagesForOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesListPackagesForOrganization(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesListPackagesForOrganizationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesListPackagesForUserRequest handles packages/list-packages-for-user operation.
//
// Lists all packages in a user's namespace for which the requesting user has access.
// To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
// If `package_type` is not `container`, your token must also include the `repo` scope.
//
// GET /users/{username}/packages
func (s *Server) handlePackagesListPackagesForUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/list-packages-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/packages"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesListPackagesForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesListPackagesForUserOperation,
			ID:   "packages/list-packages-for-user",
		}
	)
	params, err := decodePackagesListPackagesForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesListPackagesForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesListPackagesForUserOperation,
			OperationSummary: "List packages for a user",
			OperationID:      "packages/list-packages-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "query",
				}: params.PackageType,
				{
					Name: "visibility",
					In:   "query",
				}: params.Visibility,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesListPackagesForUserParams
			Response = PackagesListPackagesForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesListPackagesForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesListPackagesForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesListPackagesForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesListPackagesForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesRestorePackageForAuthenticatedUserRequest handles packages/restore-package-for-authenticated-user operation.
//
// Restores a package owned by the authenticated user.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:write` scopes. If `package_type` is not `container`, your token must also include the
// `repo` scope.
//
// POST /user/packages/{package_type}/{package_name}/restore
func (s *Server) handlePackagesRestorePackageForAuthenticatedUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user/packages/{package_type}/{package_name}/restore"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesRestorePackageForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesRestorePackageForAuthenticatedUserOperation,
			ID:   "packages/restore-package-for-authenticated-user",
		}
	)
	params, err := decodePackagesRestorePackageForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesRestorePackageForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesRestorePackageForAuthenticatedUserOperation,
			OperationSummary: "Restore a package for the authenticated user",
			OperationID:      "packages/restore-package-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "token",
					In:   "query",
				}: params.Token,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageForAuthenticatedUserParams
			Response = PackagesRestorePackageForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesRestorePackageForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesRestorePackageForOrgRequest handles packages/restore-package-for-org operation.
//
// Restores an entire package in an organization.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:write` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container that you
// want to restore.
//
// POST /orgs/{org}/packages/{package_type}/{package_name}/restore
func (s *Server) handlePackagesRestorePackageForOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-org"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/packages/{package_type}/{package_name}/restore"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesRestorePackageForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesRestorePackageForOrgOperation,
			ID:   "packages/restore-package-for-org",
		}
	)
	params, err := decodePackagesRestorePackageForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesRestorePackageForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesRestorePackageForOrgOperation,
			OperationSummary: "Restore a package for an organization",
			OperationID:      "packages/restore-package-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "token",
					In:   "query",
				}: params.Token,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageForOrgParams
			Response = PackagesRestorePackageForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesRestorePackageForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesRestorePackageForUserRequest handles packages/restore-package-for-user operation.
//
// Restores an entire package for a user.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:write` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container that you
// want to restore.
//
// POST /users/{username}/packages/{package_type}/{package_name}/restore
func (s *Server) handlePackagesRestorePackageForUserRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-for-user"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/users/{username}/packages/{package_type}/{package_name}/restore"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesRestorePackageForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesRestorePackageForUserOperation,
			ID:   "packages/restore-package-for-user",
		}
	)
	params, err := decodePackagesRestorePackageForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesRestorePackageForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesRestorePackageForUserOperation,
			OperationSummary: "Restore a package for a user",
			OperationID:      "packages/restore-package-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "token",
					In:   "query",
				}: params.Token,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageForUserParams
			Response = PackagesRestorePackageForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesRestorePackageForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesRestorePackageVersionForAuthenticatedUserRequest handles packages/restore-package-version-for-authenticated-user operation.
//
// Restores a package version owned by the authenticated user.
// You can restore a deleted package version under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:write` scopes. If `package_type` is not `container`, your token must also include the
// `repo` scope.
//
// POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (s *Server) handlePackagesRestorePackageVersionForAuthenticatedUserRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesRestorePackageVersionForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesRestorePackageVersionForAuthenticatedUserOperation,
			ID:   "packages/restore-package-version-for-authenticated-user",
		}
	)
	params, err := decodePackagesRestorePackageVersionForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesRestorePackageVersionForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesRestorePackageVersionForAuthenticatedUserOperation,
			OperationSummary: "Restore a package version for the authenticated user",
			OperationID:      "packages/restore-package-version-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageVersionForAuthenticatedUserParams
			Response = PackagesRestorePackageVersionForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageVersionForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesRestorePackageVersionForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageVersionForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageVersionForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesRestorePackageVersionForOrgRequest handles packages/restore-package-version-for-org operation.
//
// Restores a specific package version in an organization.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must have admin permissions in the organization and authenticate using
// an access token with the `packages:read` and `packages:write` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container that you
// want to restore.
//
// POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (s *Server) handlePackagesRestorePackageVersionForOrgRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-org"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesRestorePackageVersionForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesRestorePackageVersionForOrgOperation,
			ID:   "packages/restore-package-version-for-org",
		}
	)
	params, err := decodePackagesRestorePackageVersionForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesRestorePackageVersionForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesRestorePackageVersionForOrgOperation,
			OperationSummary: "Restore package version for an organization",
			OperationID:      "packages/restore-package-version-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageVersionForOrgParams
			Response = PackagesRestorePackageVersionForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageVersionForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesRestorePackageVersionForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageVersionForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageVersionForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePackagesRestorePackageVersionForUserRequest handles packages/restore-package-version-for-user operation.
//
// Restores a specific package version for a user.
// You can restore a deleted package under the following conditions:
// - The package was deleted within the last 30 days.
// - The same package namespace and version is still available and not reused for a new package. If
// the same package namespace is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted
// package's namespace first.
// To use this endpoint, you must authenticate using an access token with the `packages:read` and
// `packages:write` scopes. In addition:
// - If `package_type` is not `container`, your token must also include the `repo` scope.
// - If `package_type` is `container`, you must also have admin permissions to the container that you
// want to restore.
//
// POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore
func (s *Server) handlePackagesRestorePackageVersionForUserRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("packages/restore-package-version-for-user"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PackagesRestorePackageVersionForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PackagesRestorePackageVersionForUserOperation,
			ID:   "packages/restore-package-version-for-user",
		}
	)
	params, err := decodePackagesRestorePackageVersionForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PackagesRestorePackageVersionForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PackagesRestorePackageVersionForUserOperation,
			OperationSummary: "Restore package version for a user",
			OperationID:      "packages/restore-package-version-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "package_type",
					In:   "path",
				}: params.PackageType,
				{
					Name: "package_name",
					In:   "path",
				}: params.PackageName,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "package_version_id",
					In:   "path",
				}: params.PackageVersionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PackagesRestorePackageVersionForUserParams
			Response = PackagesRestorePackageVersionForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPackagesRestorePackageVersionForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PackagesRestorePackageVersionForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PackagesRestorePackageVersionForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePackagesRestorePackageVersionForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsAddCollaboratorRequest handles projects/add-collaborator operation.
//
// Adds a collaborator to an organization project and sets their permission level. You must be an
// organization owner or a project `admin` to add a collaborator.
//
// PUT /projects/{project_id}/collaborators/{username}
func (s *Server) handleProjectsAddCollaboratorRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/add-collaborator"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/projects/{project_id}/collaborators/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsAddCollaboratorOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsAddCollaboratorOperation,
			ID:   "projects/add-collaborator",
		}
	)
	params, err := decodeProjectsAddCollaboratorParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeProjectsAddCollaboratorRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsAddCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsAddCollaboratorOperation,
			OperationSummary: "Add project collaborator",
			OperationID:      "projects/add-collaborator",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = OptNilProjectsAddCollaboratorReq
			Params   = ProjectsAddCollaboratorParams
			Response = ProjectsAddCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsAddCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsAddCollaborator(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsAddCollaborator(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsAddCollaboratorResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsCreateColumnRequest handles projects/create-column operation.
//
// Create a project column.
//
// POST /projects/{project_id}/columns
func (s *Server) handleProjectsCreateColumnRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-column"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/projects/{project_id}/columns"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsCreateColumnOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsCreateColumnOperation,
			ID:   "projects/create-column",
		}
	)
	params, err := decodeProjectsCreateColumnParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeProjectsCreateColumnRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsCreateColumnRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsCreateColumnOperation,
			OperationSummary: "Create a project column",
			OperationID:      "projects/create-column",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = *ProjectsCreateColumnReq
			Params   = ProjectsCreateColumnParams
			Response = ProjectsCreateColumnRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsCreateColumnParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsCreateColumn(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsCreateColumn(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsCreateColumnResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsCreateForAuthenticatedUserRequest handles projects/create-for-authenticated-user operation.
//
// Create a user project.
//
// POST /user/projects
func (s *Server) handleProjectsCreateForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user/projects"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsCreateForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsCreateForAuthenticatedUserOperation,
			ID:   "projects/create-for-authenticated-user",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeProjectsCreateForAuthenticatedUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsCreateForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsCreateForAuthenticatedUserOperation,
			OperationSummary: "Create a user project",
			OperationID:      "projects/create-for-authenticated-user",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *ProjectsCreateForAuthenticatedUserReq
			Params   = struct{}
			Response = ProjectsCreateForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsCreateForAuthenticatedUser(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsCreateForAuthenticatedUser(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsCreateForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsCreateForOrgRequest handles projects/create-for-org operation.
//
// Creates an organization project board. Returns a `404 Not Found` status if projects are disabled
// in the organization. If you do not have sufficient privileges to perform this action, a `401
// Unauthorized` or `410 Gone` status is returned.
//
// POST /orgs/{org}/projects
func (s *Server) handleProjectsCreateForOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-org"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/projects"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsCreateForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsCreateForOrgOperation,
			ID:   "projects/create-for-org",
		}
	)
	params, err := decodeProjectsCreateForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeProjectsCreateForOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsCreateForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsCreateForOrgOperation,
			OperationSummary: "Create an organization project",
			OperationID:      "projects/create-for-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *ProjectsCreateForOrgReq
			Params   = ProjectsCreateForOrgParams
			Response = ProjectsCreateForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsCreateForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsCreateForOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsCreateForOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsCreateForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsCreateForRepoRequest handles projects/create-for-repo operation.
//
// Creates a repository project board. Returns a `404 Not Found` status if projects are disabled in
// the repository. If you do not have sufficient privileges to perform this action, a `401
// Unauthorized` or `410 Gone` status is returned.
//
// POST /repos/{owner}/{repo}/projects
func (s *Server) handleProjectsCreateForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/create-for-repo"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/projects"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsCreateForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsCreateForRepoOperation,
			ID:   "projects/create-for-repo",
		}
	)
	params, err := decodeProjectsCreateForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeProjectsCreateForRepoRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsCreateForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsCreateForRepoOperation,
			OperationSummary: "Create a repository project",
			OperationID:      "projects/create-for-repo",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ProjectsCreateForRepoReq
			Params   = ProjectsCreateForRepoParams
			Response = ProjectsCreateForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsCreateForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsCreateForRepo(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsCreateForRepo(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsCreateForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsDeleteRequest handles projects/delete operation.
//
// Deletes a project board. Returns a `404 Not Found` status if projects are disabled.
//
// DELETE /projects/{project_id}
func (s *Server) handleProjectsDeleteRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/projects/{project_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsDeleteOperation,
			ID:   "projects/delete",
		}
	)
	params, err := decodeProjectsDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ProjectsDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsDeleteOperation,
			OperationSummary: "Delete a project",
			OperationID:      "projects/delete",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsDeleteParams
			Response = ProjectsDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsDelete(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsDeleteResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsDeleteCardRequest handles projects/delete-card operation.
//
// Delete a project card.
//
// DELETE /projects/columns/cards/{card_id}
func (s *Server) handleProjectsDeleteCardRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete-card"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/projects/columns/cards/{card_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsDeleteCardOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsDeleteCardOperation,
			ID:   "projects/delete-card",
		}
	)
	params, err := decodeProjectsDeleteCardParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ProjectsDeleteCardRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsDeleteCardOperation,
			OperationSummary: "Delete a project card",
			OperationID:      "projects/delete-card",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "card_id",
					In:   "path",
				}: params.CardID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsDeleteCardParams
			Response = ProjectsDeleteCardRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsDeleteCardParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsDeleteCard(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsDeleteCard(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsDeleteCardResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsDeleteColumnRequest handles projects/delete-column operation.
//
// Delete a project column.
//
// DELETE /projects/columns/{column_id}
func (s *Server) handleProjectsDeleteColumnRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/delete-column"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/projects/columns/{column_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsDeleteColumnOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsDeleteColumnOperation,
			ID:   "projects/delete-column",
		}
	)
	params, err := decodeProjectsDeleteColumnParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ProjectsDeleteColumnRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsDeleteColumnOperation,
			OperationSummary: "Delete a project column",
			OperationID:      "projects/delete-column",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "column_id",
					In:   "path",
				}: params.ColumnID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsDeleteColumnParams
			Response = ProjectsDeleteColumnRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsDeleteColumnParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsDeleteColumn(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsDeleteColumn(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsDeleteColumnResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsGetRequest handles projects/get operation.
//
// Gets a project by its `id`. Returns a `404 Not Found` status if projects are disabled. If you do
// not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status
// is returned.
//
// GET /projects/{project_id}
func (s *Server) handleProjectsGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/projects/{project_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsGetOperation,
			ID:   "projects/get",
		}
	)
	params, err := decodeProjectsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ProjectsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsGetOperation,
			OperationSummary: "Get a project",
			OperationID:      "projects/get",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsGetParams
			Response = ProjectsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsGetCardRequest handles projects/get-card operation.
//
// Get a project card.
//
// GET /projects/columns/cards/{card_id}
func (s *Server) handleProjectsGetCardRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-card"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/projects/columns/cards/{card_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsGetCardOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsGetCardOperation,
			ID:   "projects/get-card",
		}
	)
	params, err := decodeProjectsGetCardParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ProjectsGetCardRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsGetCardOperation,
			OperationSummary: "Get a project card",
			OperationID:      "projects/get-card",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "card_id",
					In:   "path",
				}: params.CardID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsGetCardParams
			Response = ProjectsGetCardRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsGetCardParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsGetCard(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsGetCard(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsGetCardResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsGetColumnRequest handles projects/get-column operation.
//
// Get a project column.
//
// GET /projects/columns/{column_id}
func (s *Server) handleProjectsGetColumnRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-column"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/projects/columns/{column_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsGetColumnOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsGetColumnOperation,
			ID:   "projects/get-column",
		}
	)
	params, err := decodeProjectsGetColumnParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ProjectsGetColumnRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsGetColumnOperation,
			OperationSummary: "Get a project column",
			OperationID:      "projects/get-column",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "column_id",
					In:   "path",
				}: params.ColumnID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsGetColumnParams
			Response = ProjectsGetColumnRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsGetColumnParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsGetColumn(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsGetColumn(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsGetColumnResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsGetPermissionForUserRequest handles projects/get-permission-for-user operation.
//
// Returns the collaborator's permission level for an organization project. Possible values for the
// `permission` key: `admin`, `write`, `read`, `none`. You must be an organization owner or a project
// `admin` to review a user's permission level.
//
// GET /projects/{project_id}/collaborators/{username}/permission
func (s *Server) handleProjectsGetPermissionForUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/get-permission-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/projects/{project_id}/collaborators/{username}/permission"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsGetPermissionForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsGetPermissionForUserOperation,
			ID:   "projects/get-permission-for-user",
		}
	)
	params, err := decodeProjectsGetPermissionForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ProjectsGetPermissionForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsGetPermissionForUserOperation,
			OperationSummary: "Get project permission for a user",
			OperationID:      "projects/get-permission-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsGetPermissionForUserParams
			Response = ProjectsGetPermissionForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsGetPermissionForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsGetPermissionForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsGetPermissionForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsGetPermissionForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsListCardsRequest handles projects/list-cards operation.
//
// List project cards.
//
// GET /projects/columns/{column_id}/cards
func (s *Server) handleProjectsListCardsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-cards"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/projects/columns/{column_id}/cards"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsListCardsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsListCardsOperation,
			ID:   "projects/list-cards",
		}
	)
	params, err := decodeProjectsListCardsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ProjectsListCardsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsListCardsOperation,
			OperationSummary: "List project cards",
			OperationID:      "projects/list-cards",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "column_id",
					In:   "path",
				}: params.ColumnID,
				{
					Name: "archived_state",
					In:   "query",
				}: params.ArchivedState,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListCardsParams
			Response = ProjectsListCardsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListCardsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsListCards(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsListCards(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListCardsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsListCollaboratorsRequest handles projects/list-collaborators operation.
//
// Lists the collaborators for an organization project. For a project, the list of collaborators
// includes outside collaborators, organization members that are direct collaborators, organization
// members with access through team memberships, organization members with access through default
// organization permissions, and organization owners. You must be an organization owner or a project
// `admin` to list collaborators.
//
// GET /projects/{project_id}/collaborators
func (s *Server) handleProjectsListCollaboratorsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-collaborators"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/projects/{project_id}/collaborators"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsListCollaboratorsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsListCollaboratorsOperation,
			ID:   "projects/list-collaborators",
		}
	)
	params, err := decodeProjectsListCollaboratorsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ProjectsListCollaboratorsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsListCollaboratorsOperation,
			OperationSummary: "List project collaborators",
			OperationID:      "projects/list-collaborators",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
				{
					Name: "affiliation",
					In:   "query",
				}: params.Affiliation,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListCollaboratorsParams
			Response = ProjectsListCollaboratorsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListCollaboratorsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsListCollaborators(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsListCollaborators(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListCollaboratorsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsListColumnsRequest handles projects/list-columns operation.
//
// List project columns.
//
// GET /projects/{project_id}/columns
func (s *Server) handleProjectsListColumnsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-columns"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/projects/{project_id}/columns"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsListColumnsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsListColumnsOperation,
			ID:   "projects/list-columns",
		}
	)
	params, err := decodeProjectsListColumnsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ProjectsListColumnsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsListColumnsOperation,
			OperationSummary: "List project columns",
			OperationID:      "projects/list-columns",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListColumnsParams
			Response = ProjectsListColumnsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListColumnsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsListColumns(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsListColumns(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListColumnsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsListForOrgRequest handles projects/list-for-org operation.
//
// Lists the projects in an organization. Returns a `404 Not Found` status if projects are disabled
// in the organization. If you do not have sufficient privileges to perform this action, a `401
// Unauthorized` or `410 Gone` status is returned.
//
// GET /orgs/{org}/projects
func (s *Server) handleProjectsListForOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/projects"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsListForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsListForOrgOperation,
			ID:   "projects/list-for-org",
		}
	)
	params, err := decodeProjectsListForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ProjectsListForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsListForOrgOperation,
			OperationSummary: "List organization projects",
			OperationID:      "projects/list-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListForOrgParams
			Response = ProjectsListForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsListForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsListForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsListForRepoRequest handles projects/list-for-repo operation.
//
// Lists the projects in a repository. Returns a `404 Not Found` status if projects are disabled in
// the repository. If you do not have sufficient privileges to perform this action, a `401
// Unauthorized` or `410 Gone` status is returned.
//
// GET /repos/{owner}/{repo}/projects
func (s *Server) handleProjectsListForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/projects"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsListForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsListForRepoOperation,
			ID:   "projects/list-for-repo",
		}
	)
	params, err := decodeProjectsListForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ProjectsListForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsListForRepoOperation,
			OperationSummary: "List repository projects",
			OperationID:      "projects/list-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListForRepoParams
			Response = ProjectsListForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsListForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsListForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsListForUserRequest handles projects/list-for-user operation.
//
// List user projects.
//
// GET /users/{username}/projects
func (s *Server) handleProjectsListForUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/list-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/projects"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsListForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsListForUserOperation,
			ID:   "projects/list-for-user",
		}
	)
	params, err := decodeProjectsListForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ProjectsListForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsListForUserOperation,
			OperationSummary: "List user projects",
			OperationID:      "projects/list-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsListForUserParams
			Response = ProjectsListForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsListForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsListForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsListForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsListForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsMoveCardRequest handles projects/move-card operation.
//
// Move a project card.
//
// POST /projects/columns/cards/{card_id}/moves
func (s *Server) handleProjectsMoveCardRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/move-card"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/projects/columns/cards/{card_id}/moves"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsMoveCardOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsMoveCardOperation,
			ID:   "projects/move-card",
		}
	)
	params, err := decodeProjectsMoveCardParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeProjectsMoveCardRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsMoveCardRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsMoveCardOperation,
			OperationSummary: "Move a project card",
			OperationID:      "projects/move-card",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "card_id",
					In:   "path",
				}: params.CardID,
			},
			Raw: r,
		}

		type (
			Request  = *ProjectsMoveCardReq
			Params   = ProjectsMoveCardParams
			Response = ProjectsMoveCardRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsMoveCardParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsMoveCard(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsMoveCard(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsMoveCardResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsMoveColumnRequest handles projects/move-column operation.
//
// Move a project column.
//
// POST /projects/columns/{column_id}/moves
func (s *Server) handleProjectsMoveColumnRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/move-column"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/projects/columns/{column_id}/moves"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsMoveColumnOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsMoveColumnOperation,
			ID:   "projects/move-column",
		}
	)
	params, err := decodeProjectsMoveColumnParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeProjectsMoveColumnRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsMoveColumnRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsMoveColumnOperation,
			OperationSummary: "Move a project column",
			OperationID:      "projects/move-column",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "column_id",
					In:   "path",
				}: params.ColumnID,
			},
			Raw: r,
		}

		type (
			Request  = *ProjectsMoveColumnReq
			Params   = ProjectsMoveColumnParams
			Response = ProjectsMoveColumnRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsMoveColumnParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsMoveColumn(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsMoveColumn(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsMoveColumnResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsRemoveCollaboratorRequest handles projects/remove-collaborator operation.
//
// Removes a collaborator from an organization project. You must be an organization owner or a
// project `admin` to remove a collaborator.
//
// DELETE /projects/{project_id}/collaborators/{username}
func (s *Server) handleProjectsRemoveCollaboratorRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/remove-collaborator"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/projects/{project_id}/collaborators/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsRemoveCollaboratorOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsRemoveCollaboratorOperation,
			ID:   "projects/remove-collaborator",
		}
	)
	params, err := decodeProjectsRemoveCollaboratorParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ProjectsRemoveCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsRemoveCollaboratorOperation,
			OperationSummary: "Remove user as a collaborator",
			OperationID:      "projects/remove-collaborator",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectsRemoveCollaboratorParams
			Response = ProjectsRemoveCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsRemoveCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsRemoveCollaborator(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsRemoveCollaborator(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsRemoveCollaboratorResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsUpdateRequest handles projects/update operation.
//
// Updates a project board's information. Returns a `404 Not Found` status if projects are disabled.
// If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410
// Gone` status is returned.
//
// PATCH /projects/{project_id}
func (s *Server) handleProjectsUpdateRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/projects/{project_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsUpdateOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsUpdateOperation,
			ID:   "projects/update",
		}
	)
	params, err := decodeProjectsUpdateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeProjectsUpdateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsUpdateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsUpdateOperation,
			OperationSummary: "Update a project",
			OperationID:      "projects/update",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = OptProjectsUpdateReq
			Params   = ProjectsUpdateParams
			Response = ProjectsUpdateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsUpdateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsUpdate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsUpdate(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsUpdateResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsUpdateCardRequest handles projects/update-card operation.
//
// Update an existing project card.
//
// PATCH /projects/columns/cards/{card_id}
func (s *Server) handleProjectsUpdateCardRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update-card"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/projects/columns/cards/{card_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsUpdateCardOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsUpdateCardOperation,
			ID:   "projects/update-card",
		}
	)
	params, err := decodeProjectsUpdateCardParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeProjectsUpdateCardRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsUpdateCardRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsUpdateCardOperation,
			OperationSummary: "Update an existing project card",
			OperationID:      "projects/update-card",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "card_id",
					In:   "path",
				}: params.CardID,
			},
			Raw: r,
		}

		type (
			Request  = OptProjectsUpdateCardReq
			Params   = ProjectsUpdateCardParams
			Response = ProjectsUpdateCardRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsUpdateCardParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsUpdateCard(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsUpdateCard(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsUpdateCardResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectsUpdateColumnRequest handles projects/update-column operation.
//
// Update an existing project column.
//
// PATCH /projects/columns/{column_id}
func (s *Server) handleProjectsUpdateColumnRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("projects/update-column"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/projects/columns/{column_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ProjectsUpdateColumnOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectsUpdateColumnOperation,
			ID:   "projects/update-column",
		}
	)
	params, err := decodeProjectsUpdateColumnParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeProjectsUpdateColumnRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectsUpdateColumnRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectsUpdateColumnOperation,
			OperationSummary: "Update an existing project column",
			OperationID:      "projects/update-column",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "column_id",
					In:   "path",
				}: params.ColumnID,
			},
			Raw: r,
		}

		type (
			Request  = *ProjectsUpdateColumnReq
			Params   = ProjectsUpdateColumnParams
			Response = ProjectsUpdateColumnRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectsUpdateColumnParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectsUpdateColumn(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectsUpdateColumn(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectsUpdateColumnResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsCheckIfMergedRequest handles pulls/check-if-merged operation.
//
// Check if a pull request has been merged.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/merge
func (s *Server) handlePullsCheckIfMergedRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/check-if-merged"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/merge"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsCheckIfMergedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsCheckIfMergedOperation,
			ID:   "pulls/check-if-merged",
		}
	)
	params, err := decodePullsCheckIfMergedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PullsCheckIfMergedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsCheckIfMergedOperation,
			OperationSummary: "Check if a pull request has been merged",
			OperationID:      "pulls/check-if-merged",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsCheckIfMergedParams
			Response = PullsCheckIfMergedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsCheckIfMergedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsCheckIfMerged(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsCheckIfMerged(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsCheckIfMergedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsCreateRequest handles pulls/create operation.
//
// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// To open or update a pull request in a public repository, you must have write access to the head or
// the source branch. For organization-owned repositories, you must be a member of the organization
// that owns the repository to open or update a pull request.
// You can create a new pull request.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/pulls
func (s *Server) handlePullsCreateRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsCreateOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsCreateOperation,
			ID:   "pulls/create",
		}
	)
	params, err := decodePullsCreateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePullsCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsCreateOperation,
			OperationSummary: "Create a pull request",
			OperationID:      "pulls/create",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *PullsCreateReq
			Params   = PullsCreateParams
			Response = PullsCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsCreateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsCreate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsCreate(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsCreateResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsCreateReplyForReviewCommentRequest handles pulls/create-reply-for-review-comment operation.
//
// Creates a reply to a review comment for a pull request. For the `comment_id`, provide the ID of
// the review comment you are replying to. This must be the ID of a _top-level review comment_, not a
// reply to that comment. Replies to replies are not supported.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies
func (s *Server) handlePullsCreateReplyForReviewCommentRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-reply-for-review-comment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsCreateReplyForReviewCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsCreateReplyForReviewCommentOperation,
			ID:   "pulls/create-reply-for-review-comment",
		}
	)
	params, err := decodePullsCreateReplyForReviewCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePullsCreateReplyForReviewCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsCreateReplyForReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsCreateReplyForReviewCommentOperation,
			OperationSummary: "Create a reply for a review comment",
			OperationID:      "pulls/create-reply-for-review-comment",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = *PullsCreateReplyForReviewCommentReq
			Params   = PullsCreateReplyForReviewCommentParams
			Response = PullsCreateReplyForReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsCreateReplyForReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsCreateReplyForReviewComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsCreateReplyForReviewComment(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsCreateReplyForReviewCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsCreateReviewRequest handles pulls/create-review operation.
//
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
// Pull request reviews created in the `PENDING` state do not include the `submitted_at` property in
// the response.
// **Note:** To comment on a specific line in a file, you need to first determine the _position_ of
// that line in the diff. The GitHub REST API v3 offers the `application/vnd.github.v3.diff` [media
// type](https://docs.github.
// com/rest/overview/media-types#commits-commit-comparison-and-pull-requests). To see a pull request
// diff, add this media type to the `Accept` header of a call to the [single pull
// request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) endpoint.
// The `position` value equals the number of lines down from the first "@@" hunk header in the file
// you want to add a comment. The line just below the "@@" line is position 1, the next line is
// position 2, and so on. The position in the diff continues to increase through lines of whitespace
// and additional hunks until the beginning of a new file.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews
func (s *Server) handlePullsCreateReviewRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-review"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/reviews"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsCreateReviewOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsCreateReviewOperation,
			ID:   "pulls/create-review",
		}
	)
	params, err := decodePullsCreateReviewParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePullsCreateReviewRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsCreateReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsCreateReviewOperation,
			OperationSummary: "Create a review for a pull request",
			OperationID:      "pulls/create-review",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptPullsCreateReviewReq
			Params   = PullsCreateReviewParams
			Response = PullsCreateReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsCreateReviewParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsCreateReview(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsCreateReview(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsCreateReviewResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsCreateReviewCommentRequest handles pulls/create-review-comment operation.
//
// Creates a review comment in the pull request diff. To add a regular comment to a pull request
// timeline, see "[Create an issue comment](https://docs.github.
// com/rest/reference/issues#create-an-issue-comment)." We recommend creating a review comment using
// `line`, `side`, and optionally `start_line` and `start_side` if your comment applies to more than
// one line in the pull request diff.
// You can still create a review comment using the `position` parameter. When you use `position`, the
// `line`, `side`, `start_line`, and `start_side` parameters are not required. For more information,
// see the [`comfort-fade` preview notice](https://docs.github.
// com/rest/reference/pulls#create-a-review-comment-for-a-pull-request-preview-notices).
// **Note:** The position value equals the number of lines down from the first "@@" hunk header in
// the file you want to add a comment. The line just below the "@@" line is position 1, the next line
// is position 2, and so on. The position in the diff continues to increase through lines of
// whitespace and additional hunks until the beginning of a new file.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/comments
func (s *Server) handlePullsCreateReviewCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/create-review-comment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsCreateReviewCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsCreateReviewCommentOperation,
			ID:   "pulls/create-review-comment",
		}
	)
	params, err := decodePullsCreateReviewCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePullsCreateReviewCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsCreateReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsCreateReviewCommentOperation,
			OperationSummary: "Create a review comment for a pull request",
			OperationID:      "pulls/create-review-comment",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = *PullsCreateReviewCommentReq
			Params   = PullsCreateReviewCommentParams
			Response = PullsCreateReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsCreateReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsCreateReviewComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsCreateReviewComment(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsCreateReviewCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsDeletePendingReviewRequest handles pulls/delete-pending-review operation.
//
// Delete a pending review for a pull request.
//
// DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (s *Server) handlePullsDeletePendingReviewRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/delete-pending-review"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsDeletePendingReviewOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsDeletePendingReviewOperation,
			ID:   "pulls/delete-pending-review",
		}
	)
	params, err := decodePullsDeletePendingReviewParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PullsDeletePendingReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsDeletePendingReviewOperation,
			OperationSummary: "Delete a pending review for a pull request",
			OperationID:      "pulls/delete-pending-review",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "review_id",
					In:   "path",
				}: params.ReviewID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsDeletePendingReviewParams
			Response = PullsDeletePendingReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsDeletePendingReviewParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsDeletePendingReview(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsDeletePendingReview(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsDeletePendingReviewResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsDeleteReviewCommentRequest handles pulls/delete-review-comment operation.
//
// Deletes a review comment.
//
// DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (s *Server) handlePullsDeleteReviewCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/delete-review-comment"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/comments/{comment_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsDeleteReviewCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsDeleteReviewCommentOperation,
			ID:   "pulls/delete-review-comment",
		}
	)
	params, err := decodePullsDeleteReviewCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PullsDeleteReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsDeleteReviewCommentOperation,
			OperationSummary: "Delete a review comment for a pull request",
			OperationID:      "pulls/delete-review-comment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsDeleteReviewCommentParams
			Response = PullsDeleteReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsDeleteReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsDeleteReviewComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsDeleteReviewComment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsDeleteReviewCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsDismissReviewRequest handles pulls/dismiss-review operation.
//
// **Note:** To dismiss a pull request review on a [protected branch](https://docs.github.
// com/rest/reference/repos#branches), you must be a repository administrator or be included in the
// list of people or teams who can dismiss pull request reviews.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals
func (s *Server) handlePullsDismissReviewRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/dismiss-review"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsDismissReviewOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsDismissReviewOperation,
			ID:   "pulls/dismiss-review",
		}
	)
	params, err := decodePullsDismissReviewParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePullsDismissReviewRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsDismissReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsDismissReviewOperation,
			OperationSummary: "Dismiss a review for a pull request",
			OperationID:      "pulls/dismiss-review",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "review_id",
					In:   "path",
				}: params.ReviewID,
			},
			Raw: r,
		}

		type (
			Request  = *PullsDismissReviewReq
			Params   = PullsDismissReviewParams
			Response = PullsDismissReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsDismissReviewParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsDismissReview(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsDismissReview(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsDismissReviewResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsGetRequest handles pulls/get operation.
//
// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists details of a pull request by providing its number.
// When you get, [create](https://docs.github.com/rest/reference/pulls/#create-a-pull-request), or
// [edit](https://docs.github.com/rest/reference/pulls#update-a-pull-request) a pull request, GitHub
// creates a merge commit to test whether the pull request can be automatically merged into the base
// branch. This test commit is not added to the base branch or the head branch. You can review the
// status of the test commit using the `mergeable` key. For more information, see "[Checking
// mergeability of pull requests](https://docs.github.
// com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
// The value of the `mergeable` attribute can be `true`, `false`, or `null`. If the value is `null`,
// then GitHub has started a background job to compute the mergeability. After giving the job time to
// complete, resubmit the request. When the job finishes, you will see a non-`null` value for the
// `mergeable` attribute in the response. If `mergeable` is `true`, then `merge_commit_sha` will be
// the SHA of the _test_ merge commit.
// The value of the `merge_commit_sha` attribute changes depending on the state of the pull request.
// Before merging a pull request, the `merge_commit_sha` attribute holds the SHA of the _test_ merge
// commit. After merging a pull request, the `merge_commit_sha` attribute changes depending on how
// you merged the pull request:
//   - If merged as a [merge commit](https://help.github.com/articles/about-merge-methods-on-github/),
//     `merge_commit_sha` represents the SHA of the merge commit.
//   - If merged via a [squash](https://help.github.
//
// com/articles/about-merge-methods-on-github/#squashing-your-merge-commits), `merge_commit_sha`
// represents the SHA of the squashed commit on the base branch.
// *   If [rebased](https://help.github.
// com/articles/about-merge-methods-on-github/#rebasing-and-merging-your-commits), `merge_commit_sha`
// represents the commit that the base branch was updated to.
// Pass the appropriate [media type](https://docs.github.
// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and
// patch formats.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}
func (s *Server) handlePullsGetRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsGetOperation,
			ID:   "pulls/get",
		}
	)
	params, err := decodePullsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PullsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsGetOperation,
			OperationSummary: "Get a pull request",
			OperationID:      "pulls/get",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsGetParams
			Response = PullsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsGetReviewRequest handles pulls/get-review operation.
//
// Get a review for a pull request.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (s *Server) handlePullsGetReviewRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get-review"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsGetReviewOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsGetReviewOperation,
			ID:   "pulls/get-review",
		}
	)
	params, err := decodePullsGetReviewParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PullsGetReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsGetReviewOperation,
			OperationSummary: "Get a review for a pull request",
			OperationID:      "pulls/get-review",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "review_id",
					In:   "path",
				}: params.ReviewID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsGetReviewParams
			Response = PullsGetReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsGetReviewParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsGetReview(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsGetReview(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsGetReviewResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsGetReviewCommentRequest handles pulls/get-review-comment operation.
//
// Provides details for a review comment.
//
// GET /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (s *Server) handlePullsGetReviewCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/get-review-comment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/comments/{comment_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsGetReviewCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsGetReviewCommentOperation,
			ID:   "pulls/get-review-comment",
		}
	)
	params, err := decodePullsGetReviewCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PullsGetReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsGetReviewCommentOperation,
			OperationSummary: "Get a review comment for a pull request",
			OperationID:      "pulls/get-review-comment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsGetReviewCommentParams
			Response = PullsGetReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsGetReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsGetReviewComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsGetReviewComment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsGetReviewCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsListRequest handles pulls/list operation.
//
// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/pulls
func (s *Server) handlePullsListRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsListOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsListOperation,
			ID:   "pulls/list",
		}
	)
	params, err := decodePullsListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PullsListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsListOperation,
			OperationSummary: "List pull requests",
			OperationID:      "pulls/list",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "head",
					In:   "query",
				}: params.Head,
				{
					Name: "base",
					In:   "query",
				}: params.Base,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListParams
			Response = PullsListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsListCommentsForReviewRequest handles pulls/list-comments-for-review operation.
//
// List comments for a specific pull request review.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments
func (s *Server) handlePullsListCommentsForReviewRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-comments-for-review"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsListCommentsForReviewOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsListCommentsForReviewOperation,
			ID:   "pulls/list-comments-for-review",
		}
	)
	params, err := decodePullsListCommentsForReviewParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PullsListCommentsForReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsListCommentsForReviewOperation,
			OperationSummary: "List comments for a pull request review",
			OperationID:      "pulls/list-comments-for-review",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "review_id",
					In:   "path",
				}: params.ReviewID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListCommentsForReviewParams
			Response = PullsListCommentsForReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListCommentsForReviewParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsListCommentsForReview(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsListCommentsForReview(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListCommentsForReviewResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsListCommitsRequest handles pulls/list-commits operation.
//
// Lists a maximum of 250 commits for a pull request. To receive a complete commit list for pull
// requests with more than 250 commits, use the [List commits](https://docs.github.
// com/rest/reference/repos#list-commits) endpoint.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/commits
func (s *Server) handlePullsListCommitsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-commits"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/commits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsListCommitsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsListCommitsOperation,
			ID:   "pulls/list-commits",
		}
	)
	params, err := decodePullsListCommitsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *PullsListCommitsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsListCommitsOperation,
			OperationSummary: "List commits on a pull request",
			OperationID:      "pulls/list-commits",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListCommitsParams
			Response = *PullsListCommitsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListCommitsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsListCommits(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsListCommits(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListCommitsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsListFilesRequest handles pulls/list-files operation.
//
// **Note:** Responses include a maximum of 3000 files. The paginated response returns 30 files per
// page by default.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/files
func (s *Server) handlePullsListFilesRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-files"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/files"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsListFilesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsListFilesOperation,
			ID:   "pulls/list-files",
		}
	)
	params, err := decodePullsListFilesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response PullsListFilesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsListFilesOperation,
			OperationSummary: "List pull requests files",
			OperationID:      "pulls/list-files",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListFilesParams
			Response = PullsListFilesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListFilesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsListFiles(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsListFiles(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListFilesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsListRequestedReviewersRequest handles pulls/list-requested-reviewers operation.
//
// List requested reviewers for a pull request.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
func (s *Server) handlePullsListRequestedReviewersRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-requested-reviewers"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsListRequestedReviewersOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsListRequestedReviewersOperation,
			ID:   "pulls/list-requested-reviewers",
		}
	)
	params, err := decodePullsListRequestedReviewersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *PullRequestReviewRequestHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsListRequestedReviewersOperation,
			OperationSummary: "List requested reviewers for a pull request",
			OperationID:      "pulls/list-requested-reviewers",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListRequestedReviewersParams
			Response = *PullRequestReviewRequestHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListRequestedReviewersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsListRequestedReviewers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsListRequestedReviewers(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListRequestedReviewersResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsListReviewCommentsRequest handles pulls/list-review-comments operation.
//
// Lists all review comments for a pull request. By default, review comments are in ascending order
// by ID.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/comments
func (s *Server) handlePullsListReviewCommentsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-review-comments"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsListReviewCommentsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsListReviewCommentsOperation,
			ID:   "pulls/list-review-comments",
		}
	)
	params, err := decodePullsListReviewCommentsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *PullsListReviewCommentsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsListReviewCommentsOperation,
			OperationSummary: "List review comments on a pull request",
			OperationID:      "pulls/list-review-comments",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListReviewCommentsParams
			Response = *PullsListReviewCommentsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListReviewCommentsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsListReviewComments(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsListReviewComments(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListReviewCommentsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsListReviewCommentsForRepoRequest handles pulls/list-review-comments-for-repo operation.
//
// Lists review comments for all pull requests in a repository. By default, review comments are in
// ascending order by ID.
//
// GET /repos/{owner}/{repo}/pulls/comments
func (s *Server) handlePullsListReviewCommentsForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-review-comments-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsListReviewCommentsForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsListReviewCommentsForRepoOperation,
			ID:   "pulls/list-review-comments-for-repo",
		}
	)
	params, err := decodePullsListReviewCommentsForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *PullsListReviewCommentsForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsListReviewCommentsForRepoOperation,
			OperationSummary: "List review comments in a repository",
			OperationID:      "pulls/list-review-comments-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListReviewCommentsForRepoParams
			Response = *PullsListReviewCommentsForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListReviewCommentsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsListReviewCommentsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsListReviewCommentsForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListReviewCommentsForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsListReviewsRequest handles pulls/list-reviews operation.
//
// The list of reviews returns in chronological order.
//
// GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews
func (s *Server) handlePullsListReviewsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/list-reviews"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/reviews"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsListReviewsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsListReviewsOperation,
			ID:   "pulls/list-reviews",
		}
	)
	params, err := decodePullsListReviewsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *PullsListReviewsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsListReviewsOperation,
			OperationSummary: "List reviews for a pull request",
			OperationID:      "pulls/list-reviews",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PullsListReviewsParams
			Response = *PullsListReviewsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsListReviewsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsListReviews(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsListReviews(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsListReviewsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsMergeRequest handles pulls/merge operation.
//
// This endpoint triggers [notifications](https://docs.github.
// com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge
func (s *Server) handlePullsMergeRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/merge"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/merge"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsMergeOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsMergeOperation,
			ID:   "pulls/merge",
		}
	)
	params, err := decodePullsMergeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePullsMergeRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsMergeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsMergeOperation,
			OperationSummary: "Merge a pull request",
			OperationID:      "pulls/merge",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptNilPullsMergeReq
			Params   = PullsMergeParams
			Response = PullsMergeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsMergeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsMerge(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsMerge(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsMergeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsRemoveRequestedReviewersRequest handles pulls/remove-requested-reviewers operation.
//
// Remove requested reviewers from a pull request.
//
// DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers
func (s *Server) handlePullsRemoveRequestedReviewersRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/remove-requested-reviewers"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsRemoveRequestedReviewersOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsRemoveRequestedReviewersOperation,
			ID:   "pulls/remove-requested-reviewers",
		}
	)
	params, err := decodePullsRemoveRequestedReviewersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePullsRemoveRequestedReviewersRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsRemoveRequestedReviewersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsRemoveRequestedReviewersOperation,
			OperationSummary: "Remove requested reviewers from a pull request",
			OperationID:      "pulls/remove-requested-reviewers",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = *PullsRemoveRequestedReviewersReq
			Params   = PullsRemoveRequestedReviewersParams
			Response = PullsRemoveRequestedReviewersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsRemoveRequestedReviewersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsRemoveRequestedReviewers(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsRemoveRequestedReviewers(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsRemoveRequestedReviewersResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsSubmitReviewRequest handles pulls/submit-review operation.
//
// Submit a review for a pull request.
//
// POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events
func (s *Server) handlePullsSubmitReviewRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/submit-review"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsSubmitReviewOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsSubmitReviewOperation,
			ID:   "pulls/submit-review",
		}
	)
	params, err := decodePullsSubmitReviewParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePullsSubmitReviewRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsSubmitReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsSubmitReviewOperation,
			OperationSummary: "Submit a review for a pull request",
			OperationID:      "pulls/submit-review",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "review_id",
					In:   "path",
				}: params.ReviewID,
			},
			Raw: r,
		}

		type (
			Request  = *PullsSubmitReviewReq
			Params   = PullsSubmitReviewParams
			Response = PullsSubmitReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsSubmitReviewParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsSubmitReview(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsSubmitReview(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsSubmitReviewResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsUpdateRequest handles pulls/update operation.
//
// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for
// organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private
// repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// To open or update a pull request in a public repository, you must have write access to the head or
// the source branch. For organization-owned repositories, you must be a member of the organization
// that owns the repository to open or update a pull request.
//
// PATCH /repos/{owner}/{repo}/pulls/{pull_number}
func (s *Server) handlePullsUpdateRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsUpdateOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsUpdateOperation,
			ID:   "pulls/update",
		}
	)
	params, err := decodePullsUpdateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePullsUpdateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsUpdateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsUpdateOperation,
			OperationSummary: "Update a pull request",
			OperationID:      "pulls/update",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptPullsUpdateReq
			Params   = PullsUpdateParams
			Response = PullsUpdateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsUpdateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsUpdate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsUpdate(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsUpdateResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsUpdateBranchRequest handles pulls/update-branch operation.
//
// Updates the pull request branch with the latest upstream changes by merging HEAD from the base
// branch into the pull request branch.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch
func (s *Server) handlePullsUpdateBranchRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-branch"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/update-branch"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsUpdateBranchOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsUpdateBranchOperation,
			ID:   "pulls/update-branch",
		}
	)
	params, err := decodePullsUpdateBranchParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePullsUpdateBranchRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsUpdateBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsUpdateBranchOperation,
			OperationSummary: "Update a pull request branch",
			OperationID:      "pulls/update-branch",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptNilPullsUpdateBranchReq
			Params   = PullsUpdateBranchParams
			Response = PullsUpdateBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsUpdateBranchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsUpdateBranch(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsUpdateBranch(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsUpdateBranchResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsUpdateReviewRequest handles pulls/update-review operation.
//
// Update the review summary comment with new text.
//
// PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}
func (s *Server) handlePullsUpdateReviewRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-review"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsUpdateReviewOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsUpdateReviewOperation,
			ID:   "pulls/update-review",
		}
	)
	params, err := decodePullsUpdateReviewParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePullsUpdateReviewRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PullsUpdateReviewRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsUpdateReviewOperation,
			OperationSummary: "Update a review for a pull request",
			OperationID:      "pulls/update-review",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "pull_number",
					In:   "path",
				}: params.PullNumber,
				{
					Name: "review_id",
					In:   "path",
				}: params.ReviewID,
			},
			Raw: r,
		}

		type (
			Request  = *PullsUpdateReviewReq
			Params   = PullsUpdateReviewParams
			Response = PullsUpdateReviewRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsUpdateReviewParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsUpdateReview(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsUpdateReview(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsUpdateReviewResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePullsUpdateReviewCommentRequest handles pulls/update-review-comment operation.
//
// Enables you to edit a review comment.
//
// PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}
func (s *Server) handlePullsUpdateReviewCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("pulls/update-review-comment"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/comments/{comment_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), PullsUpdateReviewCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PullsUpdateReviewCommentOperation,
			ID:   "pulls/update-review-comment",
		}
	)
	params, err := decodePullsUpdateReviewCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodePullsUpdateReviewCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *PullRequestReviewComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PullsUpdateReviewCommentOperation,
			OperationSummary: "Update a review comment for a pull request",
			OperationID:      "pulls/update-review-comment",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = *PullsUpdateReviewCommentReq
			Params   = PullsUpdateReviewCommentParams
			Response = *PullRequestReviewComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPullsUpdateReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PullsUpdateReviewComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PullsUpdateReviewComment(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePullsUpdateReviewCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleRateLimitGetRequest handles rate-limit/get operation.
//
// **Note:** Accessing this endpoint does not count against your REST API rate limit.
// **Note:** The `rate` object is deprecated. If you're writing new API client code or updating
// existing code, you should use the `core` object instead of the `rate` object. The `core` object
// contains the same information that is present in the `rate` object.
//
// GET /rate_limit
func (s *Server) handleRateLimitGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("rate-limit/get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/rate_limit"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), RateLimitGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err error
	)

	var rawBody []byte

	var response RateLimitGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    RateLimitGetOperation,
			OperationSummary: "Get rate limit status for the authenticated user",
			OperationID:      "rate-limit/get",
			Body:             nil,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = RateLimitGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.RateLimitGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.RateLimitGet(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeRateLimitGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsCreateForCommitCommentRequest handles reactions/create-for-commit-comment operation.
//
// Create a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments). A
// response with an HTTP `200` status means that you already added the reaction type to this commit
// comment.
//
// POST /repos/{owner}/{repo}/comments/{comment_id}/reactions
func (s *Server) handleReactionsCreateForCommitCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-commit-comment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/comments/{comment_id}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsCreateForCommitCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsCreateForCommitCommentOperation,
			ID:   "reactions/create-for-commit-comment",
		}
	)
	params, err := decodeReactionsCreateForCommitCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReactionsCreateForCommitCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsCreateForCommitCommentOperation,
			OperationSummary: "Create reaction for a commit comment",
			OperationID:      "reactions/create-for-commit-comment",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForCommitCommentReq
			Params   = ReactionsCreateForCommitCommentParams
			Response = ReactionsCreateForCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForCommitComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForCommitComment(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForCommitCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsCreateForIssueRequest handles reactions/create-for-issue operation.
//
// Create a reaction to an [issue](https://docs.github.com/rest/reference/issues/). A response with
// an HTTP `200` status means that you already added the reaction type to this issue.
//
// POST /repos/{owner}/{repo}/issues/{issue_number}/reactions
func (s *Server) handleReactionsCreateForIssueRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-issue"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsCreateForIssueOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsCreateForIssueOperation,
			ID:   "reactions/create-for-issue",
		}
	)
	params, err := decodeReactionsCreateForIssueParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReactionsCreateForIssueRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForIssueRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsCreateForIssueOperation,
			OperationSummary: "Create reaction for an issue",
			OperationID:      "reactions/create-for-issue",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForIssueReq
			Params   = ReactionsCreateForIssueParams
			Response = ReactionsCreateForIssueRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForIssueParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForIssue(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForIssue(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForIssueResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsCreateForIssueCommentRequest handles reactions/create-for-issue-comment operation.
//
// Create a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments). A
// response with an HTTP `200` status means that you already added the reaction type to this issue
// comment.
//
// POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
func (s *Server) handleReactionsCreateForIssueCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-issue-comment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsCreateForIssueCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsCreateForIssueCommentOperation,
			ID:   "reactions/create-for-issue-comment",
		}
	)
	params, err := decodeReactionsCreateForIssueCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReactionsCreateForIssueCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForIssueCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsCreateForIssueCommentOperation,
			OperationSummary: "Create reaction for an issue comment",
			OperationID:      "reactions/create-for-issue-comment",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForIssueCommentReq
			Params   = ReactionsCreateForIssueCommentParams
			Response = ReactionsCreateForIssueCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForIssueCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForIssueComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForIssueComment(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForIssueCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsCreateForPullRequestReviewCommentRequest handles reactions/create-for-pull-request-review-comment operation.
//
// Create a reaction to a [pull request review comment](https://docs.github.
// com/rest/reference/pulls#comments). A response with an HTTP `200` status means that you already
// added the reaction type to this pull request review comment.
//
// POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
func (s *Server) handleReactionsCreateForPullRequestReviewCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-pull-request-review-comment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsCreateForPullRequestReviewCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsCreateForPullRequestReviewCommentOperation,
			ID:   "reactions/create-for-pull-request-review-comment",
		}
	)
	params, err := decodeReactionsCreateForPullRequestReviewCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReactionsCreateForPullRequestReviewCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForPullRequestReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsCreateForPullRequestReviewCommentOperation,
			OperationSummary: "Create reaction for a pull request review comment",
			OperationID:      "reactions/create-for-pull-request-review-comment",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForPullRequestReviewCommentReq
			Params   = ReactionsCreateForPullRequestReviewCommentParams
			Response = ReactionsCreateForPullRequestReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForPullRequestReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForPullRequestReviewComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForPullRequestReviewComment(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForPullRequestReviewCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsCreateForReleaseRequest handles reactions/create-for-release operation.
//
// Create a reaction to a [release](https://docs.github.com/rest/reference/repos#releases). A
// response with a `Status: 200 OK` means that you already added the reaction type to this release.
//
// POST /repos/{owner}/{repo}/releases/{release_id}/reactions
func (s *Server) handleReactionsCreateForReleaseRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-release"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/{release_id}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsCreateForReleaseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsCreateForReleaseOperation,
			ID:   "reactions/create-for-release",
		}
	)
	params, err := decodeReactionsCreateForReleaseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReactionsCreateForReleaseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForReleaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsCreateForReleaseOperation,
			OperationSummary: "Create reaction for a release",
			OperationID:      "reactions/create-for-release",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "release_id",
					In:   "path",
				}: params.ReleaseID,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForReleaseReq
			Params   = ReactionsCreateForReleaseParams
			Response = ReactionsCreateForReleaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForReleaseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForRelease(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForRelease(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForReleaseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsCreateForTeamDiscussionCommentInOrgRequest handles reactions/create-for-team-discussion-comment-in-org operation.
//
// Create a reaction to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A
// response with an HTTP `200` status means that you already added the reaction type to this team
// discussion comment.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) handleReactionsCreateForTeamDiscussionCommentInOrgRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-comment-in-org"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsCreateForTeamDiscussionCommentInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsCreateForTeamDiscussionCommentInOrgOperation,
			ID:   "reactions/create-for-team-discussion-comment-in-org",
		}
	)
	params, err := decodeReactionsCreateForTeamDiscussionCommentInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReactionsCreateForTeamDiscussionCommentInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForTeamDiscussionCommentInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsCreateForTeamDiscussionCommentInOrgOperation,
			OperationSummary: "Create reaction for a team discussion comment",
			OperationID:      "reactions/create-for-team-discussion-comment-in-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForTeamDiscussionCommentInOrgReq
			Params   = ReactionsCreateForTeamDiscussionCommentInOrgParams
			Response = ReactionsCreateForTeamDiscussionCommentInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForTeamDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForTeamDiscussionCommentInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForTeamDiscussionCommentInOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionCommentInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsCreateForTeamDiscussionCommentLegacyRequest handles reactions/create-for-team-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new "[Create reaction for a team discussion
// comment](https://docs.github.
// com/rest/reference/reactions#create-reaction-for-a-team-discussion-comment)" endpoint.
// Create a reaction to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A
// response with an HTTP `200` status means that you already added the reaction type to this team
// discussion comment.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) handleReactionsCreateForTeamDiscussionCommentLegacyRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-comment-legacy"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsCreateForTeamDiscussionCommentLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsCreateForTeamDiscussionCommentLegacyOperation,
			ID:   "reactions/create-for-team-discussion-comment-legacy",
		}
	)
	params, err := decodeReactionsCreateForTeamDiscussionCommentLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReactionsCreateForTeamDiscussionCommentLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Reaction
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsCreateForTeamDiscussionCommentLegacyOperation,
			OperationSummary: "Create reaction for a team discussion comment (Legacy)",
			OperationID:      "reactions/create-for-team-discussion-comment-legacy",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForTeamDiscussionCommentLegacyReq
			Params   = ReactionsCreateForTeamDiscussionCommentLegacyParams
			Response = *Reaction
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForTeamDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForTeamDiscussionCommentLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForTeamDiscussionCommentLegacy(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionCommentLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsCreateForTeamDiscussionInOrgRequest handles reactions/create-for-team-discussion-in-org operation.
//
// Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions).
//
//	OAuth access tokens require the `write:discussion` [scope](https://docs.github.
//
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200`
// status means that you already added the reaction type to this team discussion.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
func (s *Server) handleReactionsCreateForTeamDiscussionInOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-in-org"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsCreateForTeamDiscussionInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsCreateForTeamDiscussionInOrgOperation,
			ID:   "reactions/create-for-team-discussion-in-org",
		}
	)
	params, err := decodeReactionsCreateForTeamDiscussionInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReactionsCreateForTeamDiscussionInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReactionsCreateForTeamDiscussionInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsCreateForTeamDiscussionInOrgOperation,
			OperationSummary: "Create reaction for a team discussion",
			OperationID:      "reactions/create-for-team-discussion-in-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForTeamDiscussionInOrgReq
			Params   = ReactionsCreateForTeamDiscussionInOrgParams
			Response = ReactionsCreateForTeamDiscussionInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForTeamDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForTeamDiscussionInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForTeamDiscussionInOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsCreateForTeamDiscussionLegacyRequest handles reactions/create-for-team-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`Create reaction for a team
// discussion`](https://docs.github.
// com/rest/reference/reactions#create-reaction-for-a-team-discussion) endpoint.
// Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions).
//
//	OAuth access tokens require the `write:discussion` [scope](https://docs.github.
//
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200`
// status means that you already added the reaction type to this team discussion.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /teams/{team_id}/discussions/{discussion_number}/reactions
func (s *Server) handleReactionsCreateForTeamDiscussionLegacyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/create-for-team-discussion-legacy"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsCreateForTeamDiscussionLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsCreateForTeamDiscussionLegacyOperation,
			ID:   "reactions/create-for-team-discussion-legacy",
		}
	)
	params, err := decodeReactionsCreateForTeamDiscussionLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReactionsCreateForTeamDiscussionLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *Reaction
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsCreateForTeamDiscussionLegacyOperation,
			OperationSummary: "Create reaction for a team discussion (Legacy)",
			OperationID:      "reactions/create-for-team-discussion-legacy",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = *ReactionsCreateForTeamDiscussionLegacyReq
			Params   = ReactionsCreateForTeamDiscussionLegacyParams
			Response = *Reaction
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsCreateForTeamDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsCreateForTeamDiscussionLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsCreateForTeamDiscussionLegacy(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsCreateForTeamDiscussionLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsDeleteForCommitCommentRequest handles reactions/delete-for-commit-comment operation.
//
// **Note:** You can also specify a repository by `repository_id` using the route `DELETE
// /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id`.
// Delete a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
//
// DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForCommitCommentRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-commit-comment"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsDeleteForCommitCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsDeleteForCommitCommentOperation,
			ID:   "reactions/delete-for-commit-comment",
		}
	)
	params, err := decodeReactionsDeleteForCommitCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReactionsDeleteForCommitCommentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsDeleteForCommitCommentOperation,
			OperationSummary: "Delete a commit comment reaction",
			OperationID:      "reactions/delete-for-commit-comment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
				{
					Name: "reaction_id",
					In:   "path",
				}: params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForCommitCommentParams
			Response = *ReactionsDeleteForCommitCommentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReactionsDeleteForCommitComment(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReactionsDeleteForCommitComment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForCommitCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsDeleteForIssueRequest handles reactions/delete-for-issue operation.
//
// **Note:** You can also specify a repository by `repository_id` using the route `DELETE
// /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id`.
// Delete a reaction to an [issue](https://docs.github.com/rest/reference/issues/).
//
// DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForIssueRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-issue"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsDeleteForIssueOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsDeleteForIssueOperation,
			ID:   "reactions/delete-for-issue",
		}
	)
	params, err := decodeReactionsDeleteForIssueParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReactionsDeleteForIssueNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsDeleteForIssueOperation,
			OperationSummary: "Delete an issue reaction",
			OperationID:      "reactions/delete-for-issue",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
				{
					Name: "reaction_id",
					In:   "path",
				}: params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForIssueParams
			Response = *ReactionsDeleteForIssueNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForIssueParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReactionsDeleteForIssue(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReactionsDeleteForIssue(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForIssueResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsDeleteForIssueCommentRequest handles reactions/delete-for-issue-comment operation.
//
// **Note:** You can also specify a repository by `repository_id` using the route `DELETE delete
// /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id`.
// Delete a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
//
// DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForIssueCommentRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-issue-comment"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsDeleteForIssueCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsDeleteForIssueCommentOperation,
			ID:   "reactions/delete-for-issue-comment",
		}
	)
	params, err := decodeReactionsDeleteForIssueCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReactionsDeleteForIssueCommentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsDeleteForIssueCommentOperation,
			OperationSummary: "Delete an issue comment reaction",
			OperationID:      "reactions/delete-for-issue-comment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
				{
					Name: "reaction_id",
					In:   "path",
				}: params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForIssueCommentParams
			Response = *ReactionsDeleteForIssueCommentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForIssueCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReactionsDeleteForIssueComment(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReactionsDeleteForIssueComment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForIssueCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsDeleteForPullRequestCommentRequest handles reactions/delete-for-pull-request-comment operation.
//
// **Note:** You can also specify a repository by `repository_id` using the route `DELETE
// /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.`
// Delete a reaction to a [pull request review comment](https://docs.github.
// com/rest/reference/pulls#review-comments).
//
// DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForPullRequestCommentRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-pull-request-comment"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsDeleteForPullRequestCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsDeleteForPullRequestCommentOperation,
			ID:   "reactions/delete-for-pull-request-comment",
		}
	)
	params, err := decodeReactionsDeleteForPullRequestCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReactionsDeleteForPullRequestCommentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsDeleteForPullRequestCommentOperation,
			OperationSummary: "Delete a pull request comment reaction",
			OperationID:      "reactions/delete-for-pull-request-comment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
				{
					Name: "reaction_id",
					In:   "path",
				}: params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForPullRequestCommentParams
			Response = *ReactionsDeleteForPullRequestCommentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForPullRequestCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReactionsDeleteForPullRequestComment(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReactionsDeleteForPullRequestComment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForPullRequestCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsDeleteForTeamDiscussionRequest handles reactions/delete-for-team-discussion operation.
//
// **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route
// `DELETE
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id`.
// Delete a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions).
//
//	OAuth access tokens require the `write:discussion` [scope](https://docs.github.
//
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForTeamDiscussionRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-team-discussion"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsDeleteForTeamDiscussionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsDeleteForTeamDiscussionOperation,
			ID:   "reactions/delete-for-team-discussion",
		}
	)
	params, err := decodeReactionsDeleteForTeamDiscussionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReactionsDeleteForTeamDiscussionNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsDeleteForTeamDiscussionOperation,
			OperationSummary: "Delete team discussion reaction",
			OperationID:      "reactions/delete-for-team-discussion",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "reaction_id",
					In:   "path",
				}: params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForTeamDiscussionParams
			Response = *ReactionsDeleteForTeamDiscussionNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForTeamDiscussionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReactionsDeleteForTeamDiscussion(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReactionsDeleteForTeamDiscussion(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForTeamDiscussionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsDeleteForTeamDiscussionCommentRequest handles reactions/delete-for-team-discussion-comment operation.
//
// **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route
// `DELETE
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`.
// Delete a reaction to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}
func (s *Server) handleReactionsDeleteForTeamDiscussionCommentRequest(args [5]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-for-team-discussion-comment"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsDeleteForTeamDiscussionCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsDeleteForTeamDiscussionCommentOperation,
			ID:   "reactions/delete-for-team-discussion-comment",
		}
	)
	params, err := decodeReactionsDeleteForTeamDiscussionCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReactionsDeleteForTeamDiscussionCommentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsDeleteForTeamDiscussionCommentOperation,
			OperationSummary: "Delete team discussion comment reaction",
			OperationID:      "reactions/delete-for-team-discussion-comment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
				{
					Name: "reaction_id",
					In:   "path",
				}: params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteForTeamDiscussionCommentParams
			Response = *ReactionsDeleteForTeamDiscussionCommentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteForTeamDiscussionCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReactionsDeleteForTeamDiscussionComment(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReactionsDeleteForTeamDiscussionComment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteForTeamDiscussionCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsDeleteLegacyRequest handles reactions/delete-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Reactions
// API. We recommend migrating your existing code to use the new delete reactions endpoints. For more
// information, see this [blog post](https://developer.github.
// com/changes/2020-02-26-new-delete-reactions-endpoints/).
// OAuth access tokens require the `write:discussion` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), when deleting a [team
// discussion](https://docs.github.com/rest/reference/teams#discussions) or [team discussion
// comment](https://docs.github.com/rest/reference/teams#discussion-comments).
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /reactions/{reaction_id}
func (s *Server) handleReactionsDeleteLegacyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/delete-legacy"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/reactions/{reaction_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsDeleteLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsDeleteLegacyOperation,
			ID:   "reactions/delete-legacy",
		}
	)
	params, err := decodeReactionsDeleteLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReactionsDeleteLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsDeleteLegacyOperation,
			OperationSummary: "Delete a reaction (Legacy)",
			OperationID:      "reactions/delete-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "reaction_id",
					In:   "path",
				}: params.ReactionID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsDeleteLegacyParams
			Response = ReactionsDeleteLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsDeleteLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsDeleteLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsDeleteLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsDeleteLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsListForCommitCommentRequest handles reactions/list-for-commit-comment operation.
//
// List the reactions to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
//
// GET /repos/{owner}/{repo}/comments/{comment_id}/reactions
func (s *Server) handleReactionsListForCommitCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-commit-comment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/comments/{comment_id}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsListForCommitCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsListForCommitCommentOperation,
			ID:   "reactions/list-for-commit-comment",
		}
	)
	params, err := decodeReactionsListForCommitCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReactionsListForCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsListForCommitCommentOperation,
			OperationSummary: "List reactions for a commit comment",
			OperationID:      "reactions/list-for-commit-comment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
				{
					Name: "content",
					In:   "query",
				}: params.Content,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForCommitCommentParams
			Response = ReactionsListForCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsListForCommitComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsListForCommitComment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForCommitCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsListForIssueRequest handles reactions/list-for-issue operation.
//
// List the reactions to an [issue](https://docs.github.com/rest/reference/issues).
//
// GET /repos/{owner}/{repo}/issues/{issue_number}/reactions
func (s *Server) handleReactionsListForIssueRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-issue"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/{issue_number}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsListForIssueOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsListForIssueOperation,
			ID:   "reactions/list-for-issue",
		}
	)
	params, err := decodeReactionsListForIssueParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReactionsListForIssueRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsListForIssueOperation,
			OperationSummary: "List reactions for an issue",
			OperationID:      "reactions/list-for-issue",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "issue_number",
					In:   "path",
				}: params.IssueNumber,
				{
					Name: "content",
					In:   "query",
				}: params.Content,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForIssueParams
			Response = ReactionsListForIssueRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForIssueParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsListForIssue(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsListForIssue(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForIssueResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsListForIssueCommentRequest handles reactions/list-for-issue-comment operation.
//
// List the reactions to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
//
// GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions
func (s *Server) handleReactionsListForIssueCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-issue-comment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsListForIssueCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsListForIssueCommentOperation,
			ID:   "reactions/list-for-issue-comment",
		}
	)
	params, err := decodeReactionsListForIssueCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReactionsListForIssueCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsListForIssueCommentOperation,
			OperationSummary: "List reactions for an issue comment",
			OperationID:      "reactions/list-for-issue-comment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
				{
					Name: "content",
					In:   "query",
				}: params.Content,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForIssueCommentParams
			Response = ReactionsListForIssueCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForIssueCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsListForIssueComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsListForIssueComment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForIssueCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsListForPullRequestReviewCommentRequest handles reactions/list-for-pull-request-review-comment operation.
//
// List the reactions to a [pull request review comment](https://docs.github.
// com/rest/reference/pulls#review-comments).
//
// GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions
func (s *Server) handleReactionsListForPullRequestReviewCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-pull-request-review-comment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsListForPullRequestReviewCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsListForPullRequestReviewCommentOperation,
			ID:   "reactions/list-for-pull-request-review-comment",
		}
	)
	params, err := decodeReactionsListForPullRequestReviewCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReactionsListForPullRequestReviewCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsListForPullRequestReviewCommentOperation,
			OperationSummary: "List reactions for a pull request review comment",
			OperationID:      "reactions/list-for-pull-request-review-comment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
				{
					Name: "content",
					In:   "query",
				}: params.Content,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForPullRequestReviewCommentParams
			Response = ReactionsListForPullRequestReviewCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForPullRequestReviewCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsListForPullRequestReviewComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsListForPullRequestReviewComment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForPullRequestReviewCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsListForTeamDiscussionCommentInOrgRequest handles reactions/list-for-team-discussion-comment-in-org operation.
//
// List the reactions to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments/). OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) handleReactionsListForTeamDiscussionCommentInOrgRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-comment-in-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsListForTeamDiscussionCommentInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsListForTeamDiscussionCommentInOrgOperation,
			ID:   "reactions/list-for-team-discussion-comment-in-org",
		}
	)
	params, err := decodeReactionsListForTeamDiscussionCommentInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReactionsListForTeamDiscussionCommentInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsListForTeamDiscussionCommentInOrgOperation,
			OperationSummary: "List reactions for a team discussion comment",
			OperationID:      "reactions/list-for-team-discussion-comment-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
				{
					Name: "content",
					In:   "query",
				}: params.Content,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForTeamDiscussionCommentInOrgParams
			Response = *ReactionsListForTeamDiscussionCommentInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForTeamDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsListForTeamDiscussionCommentInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsListForTeamDiscussionCommentInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionCommentInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsListForTeamDiscussionCommentLegacyRequest handles reactions/list-for-team-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List reactions for a team discussion
// comment`](https://docs.github.
// com/rest/reference/reactions#list-reactions-for-a-team-discussion-comment) endpoint.
// List the reactions to a [team discussion comment](https://docs.github.
// com/rest/reference/teams#discussion-comments). OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions
func (s *Server) handleReactionsListForTeamDiscussionCommentLegacyRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-comment-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsListForTeamDiscussionCommentLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsListForTeamDiscussionCommentLegacyOperation,
			ID:   "reactions/list-for-team-discussion-comment-legacy",
		}
	)
	params, err := decodeReactionsListForTeamDiscussionCommentLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReactionsListForTeamDiscussionCommentLegacyOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsListForTeamDiscussionCommentLegacyOperation,
			OperationSummary: "List reactions for a team discussion comment (Legacy)",
			OperationID:      "reactions/list-for-team-discussion-comment-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
				{
					Name: "content",
					In:   "query",
				}: params.Content,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForTeamDiscussionCommentLegacyParams
			Response = *ReactionsListForTeamDiscussionCommentLegacyOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForTeamDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsListForTeamDiscussionCommentLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsListForTeamDiscussionCommentLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionCommentLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsListForTeamDiscussionInOrgRequest handles reactions/list-for-team-discussion-in-org operation.
//
// List the reactions to a [team discussion](https://docs.github.
// com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions
func (s *Server) handleReactionsListForTeamDiscussionInOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-in-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsListForTeamDiscussionInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsListForTeamDiscussionInOrgOperation,
			ID:   "reactions/list-for-team-discussion-in-org",
		}
	)
	params, err := decodeReactionsListForTeamDiscussionInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReactionsListForTeamDiscussionInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsListForTeamDiscussionInOrgOperation,
			OperationSummary: "List reactions for a team discussion",
			OperationID:      "reactions/list-for-team-discussion-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "content",
					In:   "query",
				}: params.Content,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForTeamDiscussionInOrgParams
			Response = *ReactionsListForTeamDiscussionInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForTeamDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsListForTeamDiscussionInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsListForTeamDiscussionInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReactionsListForTeamDiscussionLegacyRequest handles reactions/list-for-team-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List reactions for a team
// discussion`](https://docs.github.
// com/rest/reference/reactions#list-reactions-for-a-team-discussion) endpoint.
// List the reactions to a [team discussion](https://docs.github.
// com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions/{discussion_number}/reactions
func (s *Server) handleReactionsListForTeamDiscussionLegacyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reactions/list-for-team-discussion-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/reactions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReactionsListForTeamDiscussionLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReactionsListForTeamDiscussionLegacyOperation,
			ID:   "reactions/list-for-team-discussion-legacy",
		}
	)
	params, err := decodeReactionsListForTeamDiscussionLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReactionsListForTeamDiscussionLegacyOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReactionsListForTeamDiscussionLegacyOperation,
			OperationSummary: "List reactions for a team discussion (Legacy)",
			OperationID:      "reactions/list-for-team-discussion-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "content",
					In:   "query",
				}: params.Content,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReactionsListForTeamDiscussionLegacyParams
			Response = *ReactionsListForTeamDiscussionLegacyOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReactionsListForTeamDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReactionsListForTeamDiscussionLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReactionsListForTeamDiscussionLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReactionsListForTeamDiscussionLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposAcceptInvitationRequest handles repos/accept-invitation operation.
//
// Accept a repository invitation.
//
// PATCH /user/repository_invitations/{invitation_id}
func (s *Server) handleReposAcceptInvitationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/accept-invitation"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/user/repository_invitations/{invitation_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposAcceptInvitationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposAcceptInvitationOperation,
			ID:   "repos/accept-invitation",
		}
	)
	params, err := decodeReposAcceptInvitationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposAcceptInvitationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposAcceptInvitationOperation,
			OperationSummary: "Accept a repository invitation",
			OperationID:      "repos/accept-invitation",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "invitation_id",
					In:   "path",
				}: params.InvitationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposAcceptInvitationParams
			Response = ReposAcceptInvitationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAcceptInvitationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposAcceptInvitation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposAcceptInvitation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAcceptInvitationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposAddAppAccessRestrictionsRequest handles repos/add-app-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Grants the specified apps push access for this branch. Only installed GitHub Apps with `write`
// access to the `contents` permission can be added as authorized actors on a protected branch.
// | Type    | Description
//
//	|
//
// | ------- |
// ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**:
// The list of users, apps, and teams in total is limited to 100 items. |.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) handleReposAddAppAccessRestrictionsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-app-access-restrictions"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposAddAppAccessRestrictionsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposAddAppAccessRestrictionsOperation,
			ID:   "repos/add-app-access-restrictions",
		}
	)
	params, err := decodeReposAddAppAccessRestrictionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposAddAppAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposAddAppAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposAddAppAccessRestrictionsOperation,
			OperationSummary: "Add app access restrictions",
			OperationID:      "repos/add-app-access-restrictions",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposAddAppAccessRestrictionsReq
			Params   = ReposAddAppAccessRestrictionsParams
			Response = ReposAddAppAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAddAppAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposAddAppAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposAddAppAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAddAppAccessRestrictionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposAddCollaboratorRequest handles repos/add-collaborator operation.
//
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
// For more information the permission levels, see "[Repository permission levels for an
// organization](https://help.github.
// com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero
// when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs)."
// The invitee will receive a notification that they have been invited to the repository, which they
// must accept or decline. They may do this via the notifications page, the email they receive, or by
// using the [repository invitations API endpoints](https://docs.github.
// com/rest/reference/repos#invitations).
// **Rate limits**
// You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no
// limit if you are inviting organization members to an organization repository.
//
// PUT /repos/{owner}/{repo}/collaborators/{username}
func (s *Server) handleReposAddCollaboratorRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-collaborator"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/collaborators/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposAddCollaboratorOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposAddCollaboratorOperation,
			ID:   "repos/add-collaborator",
		}
	)
	params, err := decodeReposAddCollaboratorParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposAddCollaboratorRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposAddCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposAddCollaboratorOperation,
			OperationSummary: "Add a repository collaborator",
			OperationID:      "repos/add-collaborator",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = OptReposAddCollaboratorReq
			Params   = ReposAddCollaboratorParams
			Response = ReposAddCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAddCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposAddCollaborator(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposAddCollaborator(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAddCollaboratorResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposAddStatusCheckContextsRequest handles repos/add-status-check-contexts operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) handleReposAddStatusCheckContextsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-status-check-contexts"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposAddStatusCheckContextsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposAddStatusCheckContextsOperation,
			ID:   "repos/add-status-check-contexts",
		}
	)
	params, err := decodeReposAddStatusCheckContextsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposAddStatusCheckContextsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposAddStatusCheckContextsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposAddStatusCheckContextsOperation,
			OperationSummary: "Add status check contexts",
			OperationID:      "repos/add-status-check-contexts",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposAddStatusCheckContextsReq
			Params   = ReposAddStatusCheckContextsParams
			Response = ReposAddStatusCheckContextsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAddStatusCheckContextsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposAddStatusCheckContexts(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposAddStatusCheckContexts(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAddStatusCheckContextsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposAddTeamAccessRestrictionsRequest handles repos/add-team-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Grants the specified teams push access for this branch. You can also give push access to child
// teams.
// | Type    | Description
//
//	|
//
// | ------- |
// ------------------------------------------------------------------------------------------------------------------------------------------ |
// | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list of
// users, apps, and teams in total is limited to 100 items. |.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) handleReposAddTeamAccessRestrictionsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-team-access-restrictions"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposAddTeamAccessRestrictionsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposAddTeamAccessRestrictionsOperation,
			ID:   "repos/add-team-access-restrictions",
		}
	)
	params, err := decodeReposAddTeamAccessRestrictionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposAddTeamAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposAddTeamAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposAddTeamAccessRestrictionsOperation,
			OperationSummary: "Add team access restrictions",
			OperationID:      "repos/add-team-access-restrictions",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposAddTeamAccessRestrictionsReq
			Params   = ReposAddTeamAccessRestrictionsParams
			Response = ReposAddTeamAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAddTeamAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposAddTeamAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposAddTeamAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAddTeamAccessRestrictionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposAddUserAccessRestrictionsRequest handles repos/add-user-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Grants the specified people push access for this branch.
// | Type    | Description
//
//	|
//
// | ------- |
// ----------------------------------------------------------------------------------------------------------------------------- |
// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and
// teams in total is limited to 100 items. |.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) handleReposAddUserAccessRestrictionsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/add-user-access-restrictions"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposAddUserAccessRestrictionsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposAddUserAccessRestrictionsOperation,
			ID:   "repos/add-user-access-restrictions",
		}
	)
	params, err := decodeReposAddUserAccessRestrictionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposAddUserAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposAddUserAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposAddUserAccessRestrictionsOperation,
			OperationSummary: "Add user access restrictions",
			OperationID:      "repos/add-user-access-restrictions",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposAddUserAccessRestrictionsReq
			Params   = ReposAddUserAccessRestrictionsParams
			Response = ReposAddUserAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposAddUserAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposAddUserAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposAddUserAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposAddUserAccessRestrictionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCheckCollaboratorRequest handles repos/check-collaborator operation.
//
// For organization-owned repositories, the list of collaborators includes outside collaborators,
// organization members that are direct collaborators, organization members with access through team
// memberships, organization members with access through default organization permissions, and
// organization owners.
// Team members will include the members of child teams.
//
// GET /repos/{owner}/{repo}/collaborators/{username}
func (s *Server) handleReposCheckCollaboratorRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/check-collaborator"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/collaborators/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCheckCollaboratorOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCheckCollaboratorOperation,
			ID:   "repos/check-collaborator",
		}
	)
	params, err := decodeReposCheckCollaboratorParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposCheckCollaboratorRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCheckCollaboratorOperation,
			OperationSummary: "Check if a user is a repository collaborator",
			OperationID:      "repos/check-collaborator",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposCheckCollaboratorParams
			Response = ReposCheckCollaboratorRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCheckCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCheckCollaborator(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCheckCollaborator(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCheckCollaboratorResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCheckVulnerabilityAlertsRequest handles repos/check-vulnerability-alerts operation.
//
// Shows whether dependency alerts are enabled or disabled for a repository. The authenticated user
// must have admin access to the repository. For more information, see "[About security alerts for
// vulnerable dependencies](https://help.github.
// com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
//
// GET /repos/{owner}/{repo}/vulnerability-alerts
func (s *Server) handleReposCheckVulnerabilityAlertsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/check-vulnerability-alerts"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/vulnerability-alerts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCheckVulnerabilityAlertsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCheckVulnerabilityAlertsOperation,
			ID:   "repos/check-vulnerability-alerts",
		}
	)
	params, err := decodeReposCheckVulnerabilityAlertsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposCheckVulnerabilityAlertsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCheckVulnerabilityAlertsOperation,
			OperationSummary: "Check if vulnerability alerts are enabled for a repository",
			OperationID:      "repos/check-vulnerability-alerts",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposCheckVulnerabilityAlertsParams
			Response = ReposCheckVulnerabilityAlertsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCheckVulnerabilityAlertsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCheckVulnerabilityAlerts(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCheckVulnerabilityAlerts(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCheckVulnerabilityAlertsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCompareCommitsRequest handles repos/compare-commits operation.
//
// The `basehead` param is comprised of two parts: `base` and `head`. Both must be branch names in
// `repo`. To compare branches across other repositories in the same network as `repo`, use the
// format `<USERNAME>:branch`.
// The response from the API is equivalent to running the `git log base..head` command; however,
// commits are returned in chronological order. Pass the appropriate [media type](https://docs.github.
// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and
// patch formats.
// The response also includes details on the files that were changed between the two commits. This
// includes the status of the change (for example, if a file was added, removed, modified, or
// renamed), and details of the change itself. For example, files with a `renamed` status have a
// `previous_filename` field showing the previous filename of the file, and files with a `modified`
// status have a `patch` field showing the changes made to the file.
// **Working with large comparisons**
// To process a response with a large number of commits, you can use (`per_page` or `page`) to
// paginate the results. When using paging, the list of changed files is only returned with page 1,
// but includes all changed files for the entire comparison. For more information on working with
// pagination, see "[Traversing with pagination](/rest/guides/traversing-with-pagination)."
// When calling this API without any paging parameters (`per_page` or `page`), the returned list is
// limited to 250 commits and the last commit in the list is the most recent of the entire comparison.
//
//	When a paging parameter is specified, the first commit in the returned list of each page is the
//
// earliest.
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/compare/{basehead}
func (s *Server) handleReposCompareCommitsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/compare-commits"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/compare/{basehead}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCompareCommitsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCompareCommitsOperation,
			ID:   "repos/compare-commits",
		}
	)
	params, err := decodeReposCompareCommitsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposCompareCommitsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCompareCommitsOperation,
			OperationSummary: "Compare two commits",
			OperationID:      "repos/compare-commits",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "basehead",
					In:   "path",
				}: params.Basehead,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposCompareCommitsParams
			Response = ReposCompareCommitsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCompareCommitsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCompareCommits(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCompareCommits(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCompareCommitsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCreateAutolinkRequest handles repos/create-autolink operation.
//
// Users with admin access to the repository can create an autolink.
//
// POST /repos/{owner}/{repo}/autolinks
func (s *Server) handleReposCreateAutolinkRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-autolink"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/autolinks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCreateAutolinkOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCreateAutolinkOperation,
			ID:   "repos/create-autolink",
		}
	)
	params, err := decodeReposCreateAutolinkParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposCreateAutolinkRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateAutolinkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCreateAutolinkOperation,
			OperationSummary: "Create an autolink reference for a repository",
			OperationID:      "repos/create-autolink",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateAutolinkReq
			Params   = ReposCreateAutolinkParams
			Response = ReposCreateAutolinkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateAutolinkParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateAutolink(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateAutolink(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateAutolinkResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCreateCommitCommentRequest handles repos/create-commit-comment operation.
//
// Create a comment for a commit using its `:commit_sha`.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/commits/{commit_sha}/comments
func (s *Server) handleReposCreateCommitCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-comment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{commit_sha}/comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCreateCommitCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCreateCommitCommentOperation,
			ID:   "repos/create-commit-comment",
		}
	)
	params, err := decodeReposCreateCommitCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposCreateCommitCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCreateCommitCommentOperation,
			OperationSummary: "Create a commit comment",
			OperationID:      "repos/create-commit-comment",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "commit_sha",
					In:   "path",
				}: params.CommitSha,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateCommitCommentReq
			Params   = ReposCreateCommitCommentParams
			Response = ReposCreateCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateCommitComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateCommitComment(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateCommitCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCreateCommitSignatureProtectionRequest handles repos/create-commit-signature-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// When authenticated with admin or owner permissions to the repository, you can use this endpoint to
// require signed commits on a branch. You must enable branch protection to require signed commits.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (s *Server) handleReposCreateCommitSignatureProtectionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-signature-protection"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCreateCommitSignatureProtectionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCreateCommitSignatureProtectionOperation,
			ID:   "repos/create-commit-signature-protection",
		}
	)
	params, err := decodeReposCreateCommitSignatureProtectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposCreateCommitSignatureProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCreateCommitSignatureProtectionOperation,
			OperationSummary: "Create commit signature protection",
			OperationID:      "repos/create-commit-signature-protection",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposCreateCommitSignatureProtectionParams
			Response = ReposCreateCommitSignatureProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateCommitSignatureProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateCommitSignatureProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateCommitSignatureProtection(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateCommitSignatureProtectionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCreateCommitStatusRequest handles repos/create-commit-status operation.
//
// Users with push access in a repository can create commit statuses for a given SHA.
// Note: there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to
// create more than 1000 statuses will result in a validation error.
//
// POST /repos/{owner}/{repo}/statuses/{sha}
func (s *Server) handleReposCreateCommitStatusRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-commit-status"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/statuses/{sha}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCreateCommitStatusOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCreateCommitStatusOperation,
			ID:   "repos/create-commit-status",
		}
	)
	params, err := decodeReposCreateCommitStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposCreateCommitStatusRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *StatusHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCreateCommitStatusOperation,
			OperationSummary: "Create a commit status",
			OperationID:      "repos/create-commit-status",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "sha",
					In:   "path",
				}: params.Sha,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateCommitStatusReq
			Params   = ReposCreateCommitStatusParams
			Response = *StatusHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateCommitStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateCommitStatus(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateCommitStatus(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateCommitStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCreateDeployKeyRequest handles repos/create-deploy-key operation.
//
// You can create a read-only deploy key.
//
// POST /repos/{owner}/{repo}/keys
func (s *Server) handleReposCreateDeployKeyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deploy-key"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/keys"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCreateDeployKeyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCreateDeployKeyOperation,
			ID:   "repos/create-deploy-key",
		}
	)
	params, err := decodeReposCreateDeployKeyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposCreateDeployKeyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateDeployKeyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCreateDeployKeyOperation,
			OperationSummary: "Create a deploy key",
			OperationID:      "repos/create-deploy-key",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateDeployKeyReq
			Params   = ReposCreateDeployKeyParams
			Response = ReposCreateDeployKeyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateDeployKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateDeployKey(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateDeployKey(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateDeployKeyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCreateDeploymentRequest handles repos/create-deployment operation.
//
// Deployments offer a few configurable parameters with certain defaults.
// The `ref` parameter can be any named branch, tag, or SHA. At GitHub we often deploy branches and
// verify them
// before we merge a pull request.
// The `environment` parameter allows deployments to be issued to different runtime environments.
// Teams often have
// multiple environments for verifying their applications, such as `production`, `staging`, and `qa`.
// This parameter
// makes it easier to track which environments have requested deployments. The default environment is
// `production`.
// The `auto_merge` parameter is used to ensure that the requested ref is not behind the repository's
// default branch. If
// the ref _is_ behind the default branch for the repository, we will attempt to merge it for you. If
// the merge succeeds,
// the API will return a successful merge commit. If merge conflicts prevent the merge from
// succeeding, the API will
// return a failure response.
// By default, [commit statuses](https://docs.github.com/rest/reference/repos#statuses) for every
// submitted context must be in a `success`
// state. The `required_contexts` parameter allows you to specify a subset of contexts that must be
// `success`, or to
// specify contexts that have not yet been submitted. You are not required to use commit statuses to
// deploy. If you do
// not require any contexts or create any commit statuses, the deployment will always succeed.
// The `payload` parameter is available for any extra information that a deployment system might need.
//
//	It is a JSON text
//
// field that will be passed on when a deployment event is dispatched.
// The `task` parameter is used by the deployment system to allow different execution paths. In the
// web world this might
// be `deploy:migrations` to run schema changes on the system. In the compiled world this could be a
// flag to compile an
// application with debugging enabled.
// Users with `repo` or `repo_deployment` scopes can create a deployment for a given ref.
// #### Merged branch response
// You will see this response when GitHub automatically merges the base branch into the topic branch
// instead of creating
// a deployment. This auto-merge happens when:
// *   Auto-merge option is enabled in the repository
// *   Topic branch does not include the latest changes on the base branch, which is `master` in the
// response example
// *   There are no merge conflicts
// If there are no new commits in the base branch, a new request to create a deployment should give a
// successful
// response.
// #### Merge conflict response
// This error happens when the `auto_merge` option is enabled and when the default branch (in this
// case `master`), can't
// be merged into the branch that's being deployed (in this case `topic-branch`), due to merge
// conflicts.
// #### Failed commit status checks
// This error happens when the `required_contexts` parameter indicates that one or more contexts need
// to have a `success`
// status for the commit to be deployed, but one or more of the required contexts do not have a state
// of `success`.
//
// POST /repos/{owner}/{repo}/deployments
func (s *Server) handleReposCreateDeploymentRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deployment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/deployments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCreateDeploymentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCreateDeploymentOperation,
			ID:   "repos/create-deployment",
		}
	)
	params, err := decodeReposCreateDeploymentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposCreateDeploymentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateDeploymentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCreateDeploymentOperation,
			OperationSummary: "Create a deployment",
			OperationID:      "repos/create-deployment",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateDeploymentReq
			Params   = ReposCreateDeploymentParams
			Response = ReposCreateDeploymentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateDeploymentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateDeployment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateDeployment(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateDeploymentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCreateDeploymentStatusRequest handles repos/create-deployment-status operation.
//
// Users with `push` access can create deployment statuses for a given deployment.
// GitHub Apps require `read & write` access to "Deployments" and `read-only` access to "Repo
// contents" (for private repos). OAuth Apps require the `repo_deployment` scope.
//
// POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
func (s *Server) handleReposCreateDeploymentStatusRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-deployment-status"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/deployments/{deployment_id}/statuses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCreateDeploymentStatusOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCreateDeploymentStatusOperation,
			ID:   "repos/create-deployment-status",
		}
	)
	params, err := decodeReposCreateDeploymentStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposCreateDeploymentStatusRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateDeploymentStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCreateDeploymentStatusOperation,
			OperationSummary: "Create a deployment status",
			OperationID:      "repos/create-deployment-status",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "deployment_id",
					In:   "path",
				}: params.DeploymentID,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateDeploymentStatusReq
			Params   = ReposCreateDeploymentStatusParams
			Response = ReposCreateDeploymentStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateDeploymentStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateDeploymentStatus(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateDeploymentStatus(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateDeploymentStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCreateDispatchEventRequest handles repos/create-dispatch-event operation.
//
// You can use this endpoint to trigger a webhook event called `repository_dispatch` when you want
// activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook.
//
//	You must configure your GitHub Actions workflow or GitHub App to run when the
//
// `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see
// "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."
// The `client_payload` parameter is available for any extra information that your workflow might
// need. This parameter is a JSON payload that will be passed on when the webhook event is dispatched.
//
//	For example, the `client_payload` can include a message that a user would like to send using a
//
// GitHub Actions workflow. Or the `client_payload` can be used as a test to debug your workflow.
// This endpoint requires write access to the repository by providing either:
// - Personal access tokens with `repo` scope. For more information, see "[Creating a personal access
// token for the command line](https://help.github.
// com/articles/creating-a-personal-access-token-for-the-command-line)" in the GitHub Help
// documentation.
// - GitHub Apps with both `metadata:read` and `contents:read&write` permissions.
// This input example shows how you can use the `client_payload` as a test to debug your workflow.
//
// POST /repos/{owner}/{repo}/dispatches
func (s *Server) handleReposCreateDispatchEventRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-dispatch-event"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/dispatches"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCreateDispatchEventOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCreateDispatchEventOperation,
			ID:   "repos/create-dispatch-event",
		}
	)
	params, err := decodeReposCreateDispatchEventParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposCreateDispatchEventRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateDispatchEventRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCreateDispatchEventOperation,
			OperationSummary: "Create a repository dispatch event",
			OperationID:      "repos/create-dispatch-event",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateDispatchEventReq
			Params   = ReposCreateDispatchEventParams
			Response = ReposCreateDispatchEventRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateDispatchEventParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateDispatchEvent(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateDispatchEvent(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateDispatchEventResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCreateForAuthenticatedUserRequest handles repos/create-for-authenticated-user operation.
//
// Creates a new repository for the authenticated user.
// **OAuth scope requirements**
// When using [OAuth](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use
// `repo` scope to create an internal repository.
// *   `repo` scope to create a private repository.
//
// POST /user/repos
func (s *Server) handleReposCreateForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user/repos"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCreateForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCreateForAuthenticatedUserOperation,
			ID:   "repos/create-for-authenticated-user",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposCreateForAuthenticatedUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCreateForAuthenticatedUserOperation,
			OperationSummary: "Create a repository for the authenticated user",
			OperationID:      "repos/create-for-authenticated-user",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *ReposCreateForAuthenticatedUserReq
			Params   = struct{}
			Response = ReposCreateForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateForAuthenticatedUser(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateForAuthenticatedUser(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCreateForkRequest handles repos/create-fork operation.
//
// Create a fork for the authenticated user.
// **Note**: Forking a Repository happens asynchronously. You may have to wait a short period of time
// before you can access the git objects. If this takes longer than 5 minutes, be sure to contact
// [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
//
// POST /repos/{owner}/{repo}/forks
func (s *Server) handleReposCreateForkRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-fork"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/forks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCreateForkOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCreateForkOperation,
			ID:   "repos/create-fork",
		}
	)
	params, err := decodeReposCreateForkParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposCreateForkRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateForkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCreateForkOperation,
			OperationSummary: "Create a fork",
			OperationID:      "repos/create-fork",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptNilReposCreateForkReq
			Params   = ReposCreateForkParams
			Response = ReposCreateForkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateForkParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateFork(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateFork(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateForkResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCreateInOrgRequest handles repos/create-in-org operation.
//
// Creates a new repository in the specified organization. The authenticated user must be a member of
// the organization.
// **OAuth scope requirements**
// When using [OAuth](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use
// `repo` scope to create an internal repository.
// *   `repo` scope to create a private repository.
//
// POST /orgs/{org}/repos
func (s *Server) handleReposCreateInOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-in-org"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/repos"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCreateInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCreateInOrgOperation,
			ID:   "repos/create-in-org",
		}
	)
	params, err := decodeReposCreateInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposCreateInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCreateInOrgOperation,
			OperationSummary: "Create an organization repository",
			OperationID:      "repos/create-in-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateInOrgReq
			Params   = ReposCreateInOrgParams
			Response = ReposCreateInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateInOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCreateOrUpdateFileContentsRequest handles repos/create-or-update-file-contents operation.
//
// Creates a new file or replaces an existing file in a repository.
//
// PUT /repos/{owner}/{repo}/contents/{path}
func (s *Server) handleReposCreateOrUpdateFileContentsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-or-update-file-contents"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/contents/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCreateOrUpdateFileContentsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCreateOrUpdateFileContentsOperation,
			ID:   "repos/create-or-update-file-contents",
		}
	)
	params, err := decodeReposCreateOrUpdateFileContentsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposCreateOrUpdateFileContentsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateOrUpdateFileContentsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCreateOrUpdateFileContentsOperation,
			OperationSummary: "Create or update file contents",
			OperationID:      "repos/create-or-update-file-contents",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "path",
					In:   "path",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateOrUpdateFileContentsReq
			Params   = ReposCreateOrUpdateFileContentsParams
			Response = ReposCreateOrUpdateFileContentsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateOrUpdateFileContentsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateOrUpdateFileContents(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateOrUpdateFileContents(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateOrUpdateFileContentsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCreatePagesSiteRequest handles repos/create-pages-site operation.
//
// Configures a GitHub Pages site. For more information, see "[About GitHub
// Pages](/github/working-with-github-pages/about-github-pages).".
//
// POST /repos/{owner}/{repo}/pages
func (s *Server) handleReposCreatePagesSiteRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-pages-site"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pages"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCreatePagesSiteOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCreatePagesSiteOperation,
			ID:   "repos/create-pages-site",
		}
	)
	params, err := decodeReposCreatePagesSiteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposCreatePagesSiteRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreatePagesSiteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCreatePagesSiteOperation,
			OperationSummary: "Create a GitHub Pages site",
			OperationID:      "repos/create-pages-site",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = NilReposCreatePagesSiteReq
			Params   = ReposCreatePagesSiteParams
			Response = ReposCreatePagesSiteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreatePagesSiteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreatePagesSite(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreatePagesSite(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreatePagesSiteResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCreateReleaseRequest handles repos/create-release operation.
//
// Users with push access to the repository can create a release.
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// POST /repos/{owner}/{repo}/releases
func (s *Server) handleReposCreateReleaseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-release"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCreateReleaseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCreateReleaseOperation,
			ID:   "repos/create-release",
		}
	)
	params, err := decodeReposCreateReleaseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposCreateReleaseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateReleaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCreateReleaseOperation,
			OperationSummary: "Create a release",
			OperationID:      "repos/create-release",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateReleaseReq
			Params   = ReposCreateReleaseParams
			Response = ReposCreateReleaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateReleaseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateRelease(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateRelease(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateReleaseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCreateUsingTemplateRequest handles repos/create-using-template operation.
//
// Creates a new repository using a repository template. Use the `template_owner` and `template_repo`
// route parameters to specify the repository to use as the template. The authenticated user must own
// or be a member of an organization that owns the repository. To check if a repository is available
// to use as a template, get the repository's information using the [Get a repository](https://docs.
// github.com/rest/reference/repos#get-a-repository) endpoint and check that the `is_template` key is
// `true`.
// **OAuth scope requirements**
// When using [OAuth](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use
// `repo` scope to create an internal repository.
// *   `repo` scope to create a private repository.
//
// POST /repos/{template_owner}/{template_repo}/generate
func (s *Server) handleReposCreateUsingTemplateRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-using-template"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{template_owner}/{template_repo}/generate"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCreateUsingTemplateOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCreateUsingTemplateOperation,
			ID:   "repos/create-using-template",
		}
	)
	params, err := decodeReposCreateUsingTemplateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposCreateUsingTemplateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *RepositoryHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCreateUsingTemplateOperation,
			OperationSummary: "Create a repository using a template",
			OperationID:      "repos/create-using-template",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "template_owner",
					In:   "path",
				}: params.TemplateOwner,
				{
					Name: "template_repo",
					In:   "path",
				}: params.TemplateRepo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposCreateUsingTemplateReq
			Params   = ReposCreateUsingTemplateParams
			Response = *RepositoryHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateUsingTemplateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateUsingTemplate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateUsingTemplate(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateUsingTemplateResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposCreateWebhookRequest handles repos/create-webhook operation.
//
// Repositories can have multiple webhooks installed. Each webhook should have a unique `config`.
// Multiple webhooks can
// share the same `config` as long as those webhooks do not have any `events` that overlap.
//
// POST /repos/{owner}/{repo}/hooks
func (s *Server) handleReposCreateWebhookRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/create-webhook"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposCreateWebhookOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposCreateWebhookOperation,
			ID:   "repos/create-webhook",
		}
	)
	params, err := decodeReposCreateWebhookParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposCreateWebhookRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposCreateWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposCreateWebhookOperation,
			OperationSummary: "Create a repository webhook",
			OperationID:      "repos/create-webhook",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptNilReposCreateWebhookReq
			Params   = ReposCreateWebhookParams
			Response = ReposCreateWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposCreateWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposCreateWebhook(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposCreateWebhook(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposCreateWebhookResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeclineInvitationRequest handles repos/decline-invitation operation.
//
// Decline a repository invitation.
//
// DELETE /user/repository_invitations/{invitation_id}
func (s *Server) handleReposDeclineInvitationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/decline-invitation"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/repository_invitations/{invitation_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeclineInvitationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeclineInvitationOperation,
			ID:   "repos/decline-invitation",
		}
	)
	params, err := decodeReposDeclineInvitationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposDeclineInvitationRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeclineInvitationOperation,
			OperationSummary: "Decline a repository invitation",
			OperationID:      "repos/decline-invitation",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "invitation_id",
					In:   "path",
				}: params.InvitationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeclineInvitationParams
			Response = ReposDeclineInvitationRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeclineInvitationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeclineInvitation(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeclineInvitation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeclineInvitationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeleteRequest handles repos/delete operation.
//
// Deleting a repository requires admin access. If OAuth is used, the `delete_repo` scope is required.
// If an organization owner has configured the organization to prevent members from deleting
// organization-owned
// repositories, you will get a `403 Forbidden` response.
//
// DELETE /repos/{owner}/{repo}
func (s *Server) handleReposDeleteRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeleteOperation,
			ID:   "repos/delete",
		}
	)
	params, err := decodeReposDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeleteOperation,
			OperationSummary: "Delete a repository",
			OperationID:      "repos/delete",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteParams
			Response = ReposDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDelete(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeleteAccessRestrictionsRequest handles repos/delete-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Disables the ability to restrict who can push to this branch.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
func (s *Server) handleReposDeleteAccessRestrictionsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-access-restrictions"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeleteAccessRestrictionsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeleteAccessRestrictionsOperation,
			ID:   "repos/delete-access-restrictions",
		}
	)
	params, err := decodeReposDeleteAccessRestrictionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposDeleteAccessRestrictionsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeleteAccessRestrictionsOperation,
			OperationSummary: "Delete access restrictions",
			OperationID:      "repos/delete-access-restrictions",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteAccessRestrictionsParams
			Response = *ReposDeleteAccessRestrictionsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDeleteAccessRestrictions(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDeleteAccessRestrictions(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteAccessRestrictionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeleteAdminBranchProtectionRequest handles repos/delete-admin-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Removing admin enforcement requires admin or owner permissions to the repository and branch
// protection to be enabled.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (s *Server) handleReposDeleteAdminBranchProtectionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-admin-branch-protection"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeleteAdminBranchProtectionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeleteAdminBranchProtectionOperation,
			ID:   "repos/delete-admin-branch-protection",
		}
	)
	params, err := decodeReposDeleteAdminBranchProtectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposDeleteAdminBranchProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeleteAdminBranchProtectionOperation,
			OperationSummary: "Delete admin branch protection",
			OperationID:      "repos/delete-admin-branch-protection",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteAdminBranchProtectionParams
			Response = ReposDeleteAdminBranchProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteAdminBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeleteAdminBranchProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeleteAdminBranchProtection(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteAdminBranchProtectionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeleteAnEnvironmentRequest handles repos/delete-an-environment operation.
//
// You must authenticate using an access token with the repo scope to use this endpoint.
//
// DELETE /repos/{owner}/{repo}/environments/{environment_name}
func (s *Server) handleReposDeleteAnEnvironmentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-an-environment"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/environments/{environment_name}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeleteAnEnvironmentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeleteAnEnvironmentOperation,
			ID:   "repos/delete-an-environment",
		}
	)
	params, err := decodeReposDeleteAnEnvironmentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposDeleteAnEnvironmentNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeleteAnEnvironmentOperation,
			OperationSummary: "Delete an environment",
			OperationID:      "repos/delete-an-environment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "environment_name",
					In:   "path",
				}: params.EnvironmentName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteAnEnvironmentParams
			Response = *ReposDeleteAnEnvironmentNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteAnEnvironmentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDeleteAnEnvironment(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDeleteAnEnvironment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteAnEnvironmentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeleteAutolinkRequest handles repos/delete-autolink operation.
//
// This deletes a single autolink reference by ID that was configured for the given repository.
// Information about autolinks are only available to repository administrators.
//
// DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}
func (s *Server) handleReposDeleteAutolinkRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-autolink"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/autolinks/{autolink_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeleteAutolinkOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeleteAutolinkOperation,
			ID:   "repos/delete-autolink",
		}
	)
	params, err := decodeReposDeleteAutolinkParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposDeleteAutolinkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeleteAutolinkOperation,
			OperationSummary: "Delete an autolink reference from a repository",
			OperationID:      "repos/delete-autolink",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "autolink_id",
					In:   "path",
				}: params.AutolinkID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteAutolinkParams
			Response = ReposDeleteAutolinkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteAutolinkParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeleteAutolink(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeleteAutolink(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteAutolinkResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeleteBranchProtectionRequest handles repos/delete-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection
func (s *Server) handleReposDeleteBranchProtectionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-branch-protection"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeleteBranchProtectionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeleteBranchProtectionOperation,
			ID:   "repos/delete-branch-protection",
		}
	)
	params, err := decodeReposDeleteBranchProtectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposDeleteBranchProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeleteBranchProtectionOperation,
			OperationSummary: "Delete branch protection",
			OperationID:      "repos/delete-branch-protection",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteBranchProtectionParams
			Response = ReposDeleteBranchProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeleteBranchProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeleteBranchProtection(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteBranchProtectionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeleteCommitCommentRequest handles repos/delete-commit-comment operation.
//
// Delete a commit comment.
//
// DELETE /repos/{owner}/{repo}/comments/{comment_id}
func (s *Server) handleReposDeleteCommitCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-commit-comment"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/comments/{comment_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeleteCommitCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeleteCommitCommentOperation,
			ID:   "repos/delete-commit-comment",
		}
	)
	params, err := decodeReposDeleteCommitCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposDeleteCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeleteCommitCommentOperation,
			OperationSummary: "Delete a commit comment",
			OperationID:      "repos/delete-commit-comment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteCommitCommentParams
			Response = ReposDeleteCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeleteCommitComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeleteCommitComment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteCommitCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeleteCommitSignatureProtectionRequest handles repos/delete-commit-signature-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// When authenticated with admin or owner permissions to the repository, you can use this endpoint to
// disable required signed commits on a branch. You must enable branch protection to require signed
// commits.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (s *Server) handleReposDeleteCommitSignatureProtectionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-commit-signature-protection"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeleteCommitSignatureProtectionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeleteCommitSignatureProtectionOperation,
			ID:   "repos/delete-commit-signature-protection",
		}
	)
	params, err := decodeReposDeleteCommitSignatureProtectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposDeleteCommitSignatureProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeleteCommitSignatureProtectionOperation,
			OperationSummary: "Delete commit signature protection",
			OperationID:      "repos/delete-commit-signature-protection",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteCommitSignatureProtectionParams
			Response = ReposDeleteCommitSignatureProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteCommitSignatureProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeleteCommitSignatureProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeleteCommitSignatureProtection(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteCommitSignatureProtectionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeleteDeployKeyRequest handles repos/delete-deploy-key operation.
//
// Deploy keys are immutable. If you need to update a key, remove the key and create a new one
// instead.
//
// DELETE /repos/{owner}/{repo}/keys/{key_id}
func (s *Server) handleReposDeleteDeployKeyRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-deploy-key"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/keys/{key_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeleteDeployKeyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeleteDeployKeyOperation,
			ID:   "repos/delete-deploy-key",
		}
	)
	params, err := decodeReposDeleteDeployKeyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposDeleteDeployKeyNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeleteDeployKeyOperation,
			OperationSummary: "Delete a deploy key",
			OperationID:      "repos/delete-deploy-key",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "key_id",
					In:   "path",
				}: params.KeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteDeployKeyParams
			Response = *ReposDeleteDeployKeyNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteDeployKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDeleteDeployKey(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDeleteDeployKey(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteDeployKeyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeleteDeploymentRequest handles repos/delete-deployment operation.
//
// To ensure there can always be an active deployment, you can only delete an _inactive_ deployment.
// Anyone with `repo` or `repo_deployment` scopes can delete an inactive deployment.
// To set a deployment as inactive, you must:
// *   Create a new deployment that is active so that the system has a record of the current state,
// then delete the previously active deployment.
// *   Mark the active deployment as inactive by adding any non-successful deployment status.
// For more information, see "[Create a deployment](https://docs.github.
// com/rest/reference/repos/#create-a-deployment)" and "[Create a deployment status](https://docs.
// github.com/rest/reference/repos#create-a-deployment-status).".
//
// DELETE /repos/{owner}/{repo}/deployments/{deployment_id}
func (s *Server) handleReposDeleteDeploymentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-deployment"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/deployments/{deployment_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeleteDeploymentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeleteDeploymentOperation,
			ID:   "repos/delete-deployment",
		}
	)
	params, err := decodeReposDeleteDeploymentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposDeleteDeploymentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeleteDeploymentOperation,
			OperationSummary: "Delete a deployment",
			OperationID:      "repos/delete-deployment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "deployment_id",
					In:   "path",
				}: params.DeploymentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteDeploymentParams
			Response = ReposDeleteDeploymentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteDeploymentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeleteDeployment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeleteDeployment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteDeploymentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeleteFileRequest handles repos/delete-file operation.
//
// Deletes a file in a repository.
// You can provide an additional `committer` parameter, which is an object containing information
// about the committer. Or, you can provide an `author` parameter, which is an object containing
// information about the author.
// The `author` section is optional and is filled in with the `committer` information if omitted. If
// the `committer` information is omitted, the authenticated user's information is used.
// You must provide values for both `name` and `email`, whether you choose to use `author` or
// `committer`. Otherwise, you'll receive a `422` status code.
//
// DELETE /repos/{owner}/{repo}/contents/{path}
func (s *Server) handleReposDeleteFileRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-file"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/contents/{path}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeleteFileOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeleteFileOperation,
			ID:   "repos/delete-file",
		}
	)
	params, err := decodeReposDeleteFileParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposDeleteFileRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposDeleteFileRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeleteFileOperation,
			OperationSummary: "Delete a file",
			OperationID:      "repos/delete-file",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "path",
					In:   "path",
				}: params.Path,
			},
			Raw: r,
		}

		type (
			Request  = *ReposDeleteFileReq
			Params   = ReposDeleteFileParams
			Response = ReposDeleteFileRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteFileParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeleteFile(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeleteFile(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteFileResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeleteInvitationRequest handles repos/delete-invitation operation.
//
// Delete a repository invitation.
//
// DELETE /repos/{owner}/{repo}/invitations/{invitation_id}
func (s *Server) handleReposDeleteInvitationRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-invitation"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/invitations/{invitation_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeleteInvitationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeleteInvitationOperation,
			ID:   "repos/delete-invitation",
		}
	)
	params, err := decodeReposDeleteInvitationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposDeleteInvitationNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeleteInvitationOperation,
			OperationSummary: "Delete a repository invitation",
			OperationID:      "repos/delete-invitation",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "invitation_id",
					In:   "path",
				}: params.InvitationID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteInvitationParams
			Response = *ReposDeleteInvitationNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteInvitationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDeleteInvitation(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDeleteInvitation(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteInvitationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeletePagesSiteRequest handles repos/delete-pages-site operation.
//
// Delete a GitHub Pages site.
//
// DELETE /repos/{owner}/{repo}/pages
func (s *Server) handleReposDeletePagesSiteRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-pages-site"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pages"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeletePagesSiteOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeletePagesSiteOperation,
			ID:   "repos/delete-pages-site",
		}
	)
	params, err := decodeReposDeletePagesSiteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposDeletePagesSiteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeletePagesSiteOperation,
			OperationSummary: "Delete a GitHub Pages site",
			OperationID:      "repos/delete-pages-site",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeletePagesSiteParams
			Response = ReposDeletePagesSiteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeletePagesSiteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeletePagesSite(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeletePagesSite(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeletePagesSiteResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeletePullRequestReviewProtectionRequest handles repos/delete-pull-request-review-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (s *Server) handleReposDeletePullRequestReviewProtectionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-pull-request-review-protection"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeletePullRequestReviewProtectionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeletePullRequestReviewProtectionOperation,
			ID:   "repos/delete-pull-request-review-protection",
		}
	)
	params, err := decodeReposDeletePullRequestReviewProtectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposDeletePullRequestReviewProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeletePullRequestReviewProtectionOperation,
			OperationSummary: "Delete pull request review protection",
			OperationID:      "repos/delete-pull-request-review-protection",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeletePullRequestReviewProtectionParams
			Response = ReposDeletePullRequestReviewProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeletePullRequestReviewProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeletePullRequestReviewProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeletePullRequestReviewProtection(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeletePullRequestReviewProtectionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeleteReleaseRequest handles repos/delete-release operation.
//
// Users with push access to the repository can delete a release.
//
// DELETE /repos/{owner}/{repo}/releases/{release_id}
func (s *Server) handleReposDeleteReleaseRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-release"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/{release_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeleteReleaseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeleteReleaseOperation,
			ID:   "repos/delete-release",
		}
	)
	params, err := decodeReposDeleteReleaseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposDeleteReleaseNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeleteReleaseOperation,
			OperationSummary: "Delete a release",
			OperationID:      "repos/delete-release",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "release_id",
					In:   "path",
				}: params.ReleaseID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteReleaseParams
			Response = *ReposDeleteReleaseNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteReleaseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDeleteRelease(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDeleteRelease(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteReleaseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeleteReleaseAssetRequest handles repos/delete-release-asset operation.
//
// Delete a release asset.
//
// DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}
func (s *Server) handleReposDeleteReleaseAssetRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-release-asset"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/assets/{asset_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeleteReleaseAssetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeleteReleaseAssetOperation,
			ID:   "repos/delete-release-asset",
		}
	)
	params, err := decodeReposDeleteReleaseAssetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposDeleteReleaseAssetNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeleteReleaseAssetOperation,
			OperationSummary: "Delete a release asset",
			OperationID:      "repos/delete-release-asset",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "asset_id",
					In:   "path",
				}: params.AssetID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteReleaseAssetParams
			Response = *ReposDeleteReleaseAssetNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteReleaseAssetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDeleteReleaseAsset(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDeleteReleaseAsset(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteReleaseAssetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDeleteWebhookRequest handles repos/delete-webhook operation.
//
// Delete a repository webhook.
//
// DELETE /repos/{owner}/{repo}/hooks/{hook_id}
func (s *Server) handleReposDeleteWebhookRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/delete-webhook"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDeleteWebhookOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDeleteWebhookOperation,
			ID:   "repos/delete-webhook",
		}
	)
	params, err := decodeReposDeleteWebhookParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposDeleteWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDeleteWebhookOperation,
			OperationSummary: "Delete a repository webhook",
			OperationID:      "repos/delete-webhook",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDeleteWebhookParams
			Response = ReposDeleteWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDeleteWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDeleteWebhook(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDeleteWebhook(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDeleteWebhookResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDisableAutomatedSecurityFixesRequest handles repos/disable-automated-security-fixes operation.
//
// Disables automated security fixes for a repository. The authenticated user must have admin access
// to the repository. For more information, see "[Configuring automated security fixes](https://help.
// github.com/en/articles/configuring-automated-security-fixes)".
//
// DELETE /repos/{owner}/{repo}/automated-security-fixes
func (s *Server) handleReposDisableAutomatedSecurityFixesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-automated-security-fixes"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/automated-security-fixes"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDisableAutomatedSecurityFixesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDisableAutomatedSecurityFixesOperation,
			ID:   "repos/disable-automated-security-fixes",
		}
	)
	params, err := decodeReposDisableAutomatedSecurityFixesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposDisableAutomatedSecurityFixesNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDisableAutomatedSecurityFixesOperation,
			OperationSummary: "Disable automated security fixes",
			OperationID:      "repos/disable-automated-security-fixes",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDisableAutomatedSecurityFixesParams
			Response = *ReposDisableAutomatedSecurityFixesNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDisableAutomatedSecurityFixesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDisableAutomatedSecurityFixes(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDisableAutomatedSecurityFixes(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDisableAutomatedSecurityFixesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDisableLfsForRepoRequest handles repos/disable-lfs-for-repo operation.
//
// **Note:** The Git LFS API endpoints are currently in beta and are subject to change.
//
// DELETE /repos/{owner}/{repo}/lfs
func (s *Server) handleReposDisableLfsForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-lfs-for-repo"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/lfs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDisableLfsForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDisableLfsForRepoOperation,
			ID:   "repos/disable-lfs-for-repo",
		}
	)
	params, err := decodeReposDisableLfsForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposDisableLfsForRepoNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDisableLfsForRepoOperation,
			OperationSummary: "Disable Git LFS for a repository",
			OperationID:      "repos/disable-lfs-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDisableLfsForRepoParams
			Response = *ReposDisableLfsForRepoNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDisableLfsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDisableLfsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDisableLfsForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDisableLfsForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDisableVulnerabilityAlertsRequest handles repos/disable-vulnerability-alerts operation.
//
// Disables dependency alerts and the dependency graph for a repository. The authenticated user must
// have admin access to the repository. For more information, see "[About security alerts for
// vulnerable dependencies](https://help.github.
// com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
//
// DELETE /repos/{owner}/{repo}/vulnerability-alerts
func (s *Server) handleReposDisableVulnerabilityAlertsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/disable-vulnerability-alerts"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/vulnerability-alerts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDisableVulnerabilityAlertsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDisableVulnerabilityAlertsOperation,
			ID:   "repos/disable-vulnerability-alerts",
		}
	)
	params, err := decodeReposDisableVulnerabilityAlertsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposDisableVulnerabilityAlertsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDisableVulnerabilityAlertsOperation,
			OperationSummary: "Disable vulnerability alerts",
			OperationID:      "repos/disable-vulnerability-alerts",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDisableVulnerabilityAlertsParams
			Response = *ReposDisableVulnerabilityAlertsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDisableVulnerabilityAlertsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposDisableVulnerabilityAlerts(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposDisableVulnerabilityAlerts(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDisableVulnerabilityAlertsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDownloadTarballArchiveRequest handles repos/download-tarball-archive operation.
//
// Gets a redirect URL to download a tar archive for a repository. If you omit `:ref`, the
// repository’s default branch (usually
// `master`) will be used. Please make sure your HTTP framework is configured to follow redirects or
// you will need to use
// the `Location` header to make a second `GET` request.
// **Note**: For private repositories, these links are temporary and expire after five minutes.
//
// GET /repos/{owner}/{repo}/tarball/{ref}
func (s *Server) handleReposDownloadTarballArchiveRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/download-tarball-archive"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/tarball/{ref}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDownloadTarballArchiveOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDownloadTarballArchiveOperation,
			ID:   "repos/download-tarball-archive",
		}
	)
	params, err := decodeReposDownloadTarballArchiveParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposDownloadTarballArchiveFound
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDownloadTarballArchiveOperation,
			OperationSummary: "Download a repository archive (tar)",
			OperationID:      "repos/download-tarball-archive",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDownloadTarballArchiveParams
			Response = *ReposDownloadTarballArchiveFound
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDownloadTarballArchiveParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDownloadTarballArchive(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDownloadTarballArchive(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDownloadTarballArchiveResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposDownloadZipballArchiveRequest handles repos/download-zipball-archive operation.
//
// Gets a redirect URL to download a zip archive for a repository. If you omit `:ref`, the
// repository’s default branch (usually
// `master`) will be used. Please make sure your HTTP framework is configured to follow redirects or
// you will need to use
// the `Location` header to make a second `GET` request.
// **Note**: For private repositories, these links are temporary and expire after five minutes.
//
// GET /repos/{owner}/{repo}/zipball/{ref}
func (s *Server) handleReposDownloadZipballArchiveRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/download-zipball-archive"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/zipball/{ref}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposDownloadZipballArchiveOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposDownloadZipballArchiveOperation,
			ID:   "repos/download-zipball-archive",
		}
	)
	params, err := decodeReposDownloadZipballArchiveParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposDownloadZipballArchiveFound
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposDownloadZipballArchiveOperation,
			OperationSummary: "Download a repository archive (zip)",
			OperationID:      "repos/download-zipball-archive",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposDownloadZipballArchiveParams
			Response = *ReposDownloadZipballArchiveFound
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposDownloadZipballArchiveParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposDownloadZipballArchive(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposDownloadZipballArchive(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposDownloadZipballArchiveResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposEnableAutomatedSecurityFixesRequest handles repos/enable-automated-security-fixes operation.
//
// Enables automated security fixes for a repository. The authenticated user must have admin access
// to the repository. For more information, see "[Configuring automated security fixes](https://help.
// github.com/en/articles/configuring-automated-security-fixes)".
//
// PUT /repos/{owner}/{repo}/automated-security-fixes
func (s *Server) handleReposEnableAutomatedSecurityFixesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-automated-security-fixes"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/automated-security-fixes"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposEnableAutomatedSecurityFixesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposEnableAutomatedSecurityFixesOperation,
			ID:   "repos/enable-automated-security-fixes",
		}
	)
	params, err := decodeReposEnableAutomatedSecurityFixesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposEnableAutomatedSecurityFixesNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposEnableAutomatedSecurityFixesOperation,
			OperationSummary: "Enable automated security fixes",
			OperationID:      "repos/enable-automated-security-fixes",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposEnableAutomatedSecurityFixesParams
			Response = *ReposEnableAutomatedSecurityFixesNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposEnableAutomatedSecurityFixesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposEnableAutomatedSecurityFixes(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposEnableAutomatedSecurityFixes(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposEnableAutomatedSecurityFixesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposEnableLfsForRepoRequest handles repos/enable-lfs-for-repo operation.
//
// **Note:** The Git LFS API endpoints are currently in beta and are subject to change.
//
// PUT /repos/{owner}/{repo}/lfs
func (s *Server) handleReposEnableLfsForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-lfs-for-repo"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/lfs"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposEnableLfsForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposEnableLfsForRepoOperation,
			ID:   "repos/enable-lfs-for-repo",
		}
	)
	params, err := decodeReposEnableLfsForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposEnableLfsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposEnableLfsForRepoOperation,
			OperationSummary: "Enable Git LFS for a repository",
			OperationID:      "repos/enable-lfs-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposEnableLfsForRepoParams
			Response = ReposEnableLfsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposEnableLfsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposEnableLfsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposEnableLfsForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposEnableLfsForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposEnableVulnerabilityAlertsRequest handles repos/enable-vulnerability-alerts operation.
//
// Enables dependency alerts and the dependency graph for a repository. The authenticated user must
// have admin access to the repository. For more information, see "[About security alerts for
// vulnerable dependencies](https://help.github.
// com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
//
// PUT /repos/{owner}/{repo}/vulnerability-alerts
func (s *Server) handleReposEnableVulnerabilityAlertsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/enable-vulnerability-alerts"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/vulnerability-alerts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposEnableVulnerabilityAlertsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposEnableVulnerabilityAlertsOperation,
			ID:   "repos/enable-vulnerability-alerts",
		}
	)
	params, err := decodeReposEnableVulnerabilityAlertsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposEnableVulnerabilityAlertsNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposEnableVulnerabilityAlertsOperation,
			OperationSummary: "Enable vulnerability alerts",
			OperationID:      "repos/enable-vulnerability-alerts",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposEnableVulnerabilityAlertsParams
			Response = *ReposEnableVulnerabilityAlertsNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposEnableVulnerabilityAlertsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposEnableVulnerabilityAlerts(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposEnableVulnerabilityAlerts(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposEnableVulnerabilityAlertsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetRequest handles repos/get operation.
//
// The `parent` and `source` objects are present when the repository is a fork. `parent` is the
// repository this repository was forked from, `source` is the ultimate source for the network.
//
// GET /repos/{owner}/{repo}
func (s *Server) handleReposGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetOperation,
			ID:   "repos/get",
		}
	)
	params, err := decodeReposGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetOperation,
			OperationSummary: "Get a repository",
			OperationID:      "repos/get",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetParams
			Response = ReposGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetAccessRestrictionsRequest handles repos/get-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists who has access to this protected branch.
// **Note**: Users, apps, and teams `restrictions` are only available for organization-owned
// repositories.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions
func (s *Server) handleReposGetAccessRestrictionsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-access-restrictions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetAccessRestrictionsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetAccessRestrictionsOperation,
			ID:   "repos/get-access-restrictions",
		}
	)
	params, err := decodeReposGetAccessRestrictionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetAccessRestrictionsOperation,
			OperationSummary: "Get access restrictions",
			OperationID:      "repos/get-access-restrictions",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAccessRestrictionsParams
			Response = ReposGetAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetAccessRestrictions(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetAccessRestrictions(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAccessRestrictionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetAdminBranchProtectionRequest handles repos/get-admin-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (s *Server) handleReposGetAdminBranchProtectionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-admin-branch-protection"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetAdminBranchProtectionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetAdminBranchProtectionOperation,
			ID:   "repos/get-admin-branch-protection",
		}
	)
	params, err := decodeReposGetAdminBranchProtectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ProtectedBranchAdminEnforced
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetAdminBranchProtectionOperation,
			OperationSummary: "Get admin branch protection",
			OperationID:      "repos/get-admin-branch-protection",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAdminBranchProtectionParams
			Response = *ProtectedBranchAdminEnforced
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAdminBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetAdminBranchProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetAdminBranchProtection(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAdminBranchProtectionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetAllStatusCheckContextsRequest handles repos/get-all-status-check-contexts operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) handleReposGetAllStatusCheckContextsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-all-status-check-contexts"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetAllStatusCheckContextsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetAllStatusCheckContextsOperation,
			ID:   "repos/get-all-status-check-contexts",
		}
	)
	params, err := decodeReposGetAllStatusCheckContextsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetAllStatusCheckContextsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetAllStatusCheckContextsOperation,
			OperationSummary: "Get all status check contexts",
			OperationID:      "repos/get-all-status-check-contexts",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAllStatusCheckContextsParams
			Response = ReposGetAllStatusCheckContextsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAllStatusCheckContextsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetAllStatusCheckContexts(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetAllStatusCheckContexts(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAllStatusCheckContextsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetAllTopicsRequest handles repos/get-all-topics operation.
//
// Get all repository topics.
//
// GET /repos/{owner}/{repo}/topics
func (s *Server) handleReposGetAllTopicsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-all-topics"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/topics"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetAllTopicsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetAllTopicsOperation,
			ID:   "repos/get-all-topics",
		}
	)
	params, err := decodeReposGetAllTopicsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetAllTopicsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetAllTopicsOperation,
			OperationSummary: "Get all repository topics",
			OperationID:      "repos/get-all-topics",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAllTopicsParams
			Response = ReposGetAllTopicsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAllTopicsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetAllTopics(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetAllTopics(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAllTopicsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetAppsWithAccessToProtectedBranchRequest handles repos/get-apps-with-access-to-protected-branch operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists the GitHub Apps that have push access to this branch. Only installed GitHub Apps with
// `write` access to the `contents` permission can be added as authorized actors on a protected
// branch.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) handleReposGetAppsWithAccessToProtectedBranchRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-apps-with-access-to-protected-branch"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetAppsWithAccessToProtectedBranchOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetAppsWithAccessToProtectedBranchOperation,
			ID:   "repos/get-apps-with-access-to-protected-branch",
		}
	)
	params, err := decodeReposGetAppsWithAccessToProtectedBranchParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetAppsWithAccessToProtectedBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetAppsWithAccessToProtectedBranchOperation,
			OperationSummary: "Get apps with access to the protected branch",
			OperationID:      "repos/get-apps-with-access-to-protected-branch",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAppsWithAccessToProtectedBranchParams
			Response = ReposGetAppsWithAccessToProtectedBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAppsWithAccessToProtectedBranchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetAppsWithAccessToProtectedBranch(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetAppsWithAccessToProtectedBranch(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAppsWithAccessToProtectedBranchResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetAutolinkRequest handles repos/get-autolink operation.
//
// This returns a single autolink reference by ID that was configured for the given repository.
// Information about autolinks are only available to repository administrators.
//
// GET /repos/{owner}/{repo}/autolinks/{autolink_id}
func (s *Server) handleReposGetAutolinkRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-autolink"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/autolinks/{autolink_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetAutolinkOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetAutolinkOperation,
			ID:   "repos/get-autolink",
		}
	)
	params, err := decodeReposGetAutolinkParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetAutolinkRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetAutolinkOperation,
			OperationSummary: "Get an autolink reference of a repository",
			OperationID:      "repos/get-autolink",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "autolink_id",
					In:   "path",
				}: params.AutolinkID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetAutolinkParams
			Response = ReposGetAutolinkRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetAutolinkParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetAutolink(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetAutolink(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetAutolinkResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetBranchRequest handles repos/get-branch operation.
//
// Get a branch.
//
// GET /repos/{owner}/{repo}/branches/{branch}
func (s *Server) handleReposGetBranchRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-branch"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetBranchOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetBranchOperation,
			ID:   "repos/get-branch",
		}
	)
	params, err := decodeReposGetBranchParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetBranchOperation,
			OperationSummary: "Get a branch",
			OperationID:      "repos/get-branch",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetBranchParams
			Response = ReposGetBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetBranchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetBranch(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetBranch(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetBranchResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetBranchProtectionRequest handles repos/get-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection
func (s *Server) handleReposGetBranchProtectionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-branch-protection"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetBranchProtectionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetBranchProtectionOperation,
			ID:   "repos/get-branch-protection",
		}
	)
	params, err := decodeReposGetBranchProtectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetBranchProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetBranchProtectionOperation,
			OperationSummary: "Get branch protection",
			OperationID:      "repos/get-branch-protection",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetBranchProtectionParams
			Response = ReposGetBranchProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetBranchProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetBranchProtection(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetBranchProtectionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetClonesRequest handles repos/get-clones operation.
//
// Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps are
// aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
//
// GET /repos/{owner}/{repo}/traffic/clones
func (s *Server) handleReposGetClonesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-clones"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/traffic/clones"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetClonesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetClonesOperation,
			ID:   "repos/get-clones",
		}
	)
	params, err := decodeReposGetClonesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetClonesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetClonesOperation,
			OperationSummary: "Get repository clones",
			OperationID:      "repos/get-clones",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per",
					In:   "query",
				}: params.Per,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetClonesParams
			Response = ReposGetClonesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetClonesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetClones(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetClones(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetClonesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetCodeFrequencyStatsRequest handles repos/get-code-frequency-stats operation.
//
// Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
//
// GET /repos/{owner}/{repo}/stats/code_frequency
func (s *Server) handleReposGetCodeFrequencyStatsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-code-frequency-stats"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/stats/code_frequency"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetCodeFrequencyStatsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetCodeFrequencyStatsOperation,
			ID:   "repos/get-code-frequency-stats",
		}
	)
	params, err := decodeReposGetCodeFrequencyStatsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetCodeFrequencyStatsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetCodeFrequencyStatsOperation,
			OperationSummary: "Get the weekly commit activity",
			OperationID:      "repos/get-code-frequency-stats",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCodeFrequencyStatsParams
			Response = ReposGetCodeFrequencyStatsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCodeFrequencyStatsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetCodeFrequencyStats(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetCodeFrequencyStats(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCodeFrequencyStatsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetCollaboratorPermissionLevelRequest handles repos/get-collaborator-permission-level operation.
//
// Checks the repository permission of a collaborator. The possible repository permissions are
// `admin`, `write`, `read`, and `none`.
//
// GET /repos/{owner}/{repo}/collaborators/{username}/permission
func (s *Server) handleReposGetCollaboratorPermissionLevelRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-collaborator-permission-level"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/collaborators/{username}/permission"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetCollaboratorPermissionLevelOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetCollaboratorPermissionLevelOperation,
			ID:   "repos/get-collaborator-permission-level",
		}
	)
	params, err := decodeReposGetCollaboratorPermissionLevelParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetCollaboratorPermissionLevelRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetCollaboratorPermissionLevelOperation,
			OperationSummary: "Get repository permissions for a user",
			OperationID:      "repos/get-collaborator-permission-level",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCollaboratorPermissionLevelParams
			Response = ReposGetCollaboratorPermissionLevelRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCollaboratorPermissionLevelParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetCollaboratorPermissionLevel(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetCollaboratorPermissionLevel(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCollaboratorPermissionLevelResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetCombinedStatusForRefRequest handles repos/get-combined-status-for-ref operation.
//
// Users with pull access in a repository can access a combined view of commit statuses for a given
// ref. The ref can be a SHA, a branch name, or a tag name.
// The most recent status for each context is returned, up to 100. This field
// [paginates](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination) if there
// are over 100 contexts.
// Additionally, a combined `state` is returned. The `state` is one of:
// *   **failure** if any of the contexts report as `error` or `failure`
// *   **pending** if there are no statuses or a context is `pending`
// *   **success** if the latest status for all contexts is `success`.
//
// GET /repos/{owner}/{repo}/commits/{ref}/status
func (s *Server) handleReposGetCombinedStatusForRefRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-combined-status-for-ref"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{ref}/status"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetCombinedStatusForRefOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetCombinedStatusForRefOperation,
			ID:   "repos/get-combined-status-for-ref",
		}
	)
	params, err := decodeReposGetCombinedStatusForRefParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetCombinedStatusForRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetCombinedStatusForRefOperation,
			OperationSummary: "Get the combined status for a specific reference",
			OperationID:      "repos/get-combined-status-for-ref",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCombinedStatusForRefParams
			Response = ReposGetCombinedStatusForRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCombinedStatusForRefParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetCombinedStatusForRef(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetCombinedStatusForRef(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCombinedStatusForRefResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetCommitRequest handles repos/get-commit operation.
//
// Returns the contents of a single commit reference. You must have `read` access for the repository
// to use this endpoint.
// **Note:** If there are more than 300 files in the commit diff, the response will include
// pagination link headers for the remaining files, up to a limit of 3000 files. Each page contains
// the static commit information, and the only changes are to the file listing.
// You can pass the appropriate [media type](https://docs.github.
// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to  fetch `diff` and
// `patch` formats. Diffs with binary data will have no `patch` property.
// To return only the SHA-1 hash of the commit reference, you can provide the `sha` custom [media
// type](https://docs.github.
// com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) in the `Accept` header.
//
//	You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local
//
// reference's SHA-1 hash by providing the local SHA-1 reference as the ETag.
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/commits/{ref}
func (s *Server) handleReposGetCommitRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{ref}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetCommitOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetCommitOperation,
			ID:   "repos/get-commit",
		}
	)
	params, err := decodeReposGetCommitParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetCommitRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetCommitOperation,
			OperationSummary: "Get a commit",
			OperationID:      "repos/get-commit",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCommitParams
			Response = ReposGetCommitRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCommitParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetCommit(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetCommit(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCommitResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetCommitActivityStatsRequest handles repos/get-commit-activity-stats operation.
//
// Returns the last year of commit activity grouped by week. The `days` array is a group of commits
// per day, starting on `Sunday`.
//
// GET /repos/{owner}/{repo}/stats/commit_activity
func (s *Server) handleReposGetCommitActivityStatsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-activity-stats"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/stats/commit_activity"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetCommitActivityStatsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetCommitActivityStatsOperation,
			ID:   "repos/get-commit-activity-stats",
		}
	)
	params, err := decodeReposGetCommitActivityStatsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetCommitActivityStatsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetCommitActivityStatsOperation,
			OperationSummary: "Get the last year of commit activity",
			OperationID:      "repos/get-commit-activity-stats",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCommitActivityStatsParams
			Response = ReposGetCommitActivityStatsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCommitActivityStatsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetCommitActivityStats(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetCommitActivityStats(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCommitActivityStatsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetCommitCommentRequest handles repos/get-commit-comment operation.
//
// Get a commit comment.
//
// GET /repos/{owner}/{repo}/comments/{comment_id}
func (s *Server) handleReposGetCommitCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-comment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/comments/{comment_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetCommitCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetCommitCommentOperation,
			ID:   "repos/get-commit-comment",
		}
	)
	params, err := decodeReposGetCommitCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetCommitCommentOperation,
			OperationSummary: "Get a commit comment",
			OperationID:      "repos/get-commit-comment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCommitCommentParams
			Response = ReposGetCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetCommitComment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetCommitComment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCommitCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetCommitSignatureProtectionRequest handles repos/get-commit-signature-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// When authenticated with admin or owner permissions to the repository, you can use this endpoint to
// check whether a branch requires signed commits. An enabled status of `true` indicates you must
// sign commits on this branch. For more information, see [Signing commits with GPG](https://help.
// github.com/articles/signing-commits-with-gpg) in GitHub Help.
// **Note**: You must enable branch protection to require signed commits.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures
func (s *Server) handleReposGetCommitSignatureProtectionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-commit-signature-protection"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetCommitSignatureProtectionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetCommitSignatureProtectionOperation,
			ID:   "repos/get-commit-signature-protection",
		}
	)
	params, err := decodeReposGetCommitSignatureProtectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetCommitSignatureProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetCommitSignatureProtectionOperation,
			OperationSummary: "Get commit signature protection",
			OperationID:      "repos/get-commit-signature-protection",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCommitSignatureProtectionParams
			Response = ReposGetCommitSignatureProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCommitSignatureProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetCommitSignatureProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetCommitSignatureProtection(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCommitSignatureProtectionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetCommunityProfileMetricsRequest handles repos/get-community-profile-metrics operation.
//
// This endpoint will return all community profile metrics, including an
// overall health score, repository description, the presence of documentation, detected
// code of conduct, detected license, and the presence of ISSUE\_TEMPLATE, PULL\_REQUEST\_TEMPLATE,
// README, and CONTRIBUTING files.
// The `health_percentage` score is defined as a percentage of how many of
// these four documents are present: README, CONTRIBUTING, LICENSE, and
// CODE_OF_CONDUCT. For example, if all four documents are present, then
// the `health_percentage` is `100`. If only one is present, then the
// `health_percentage` is `25`.
// `content_reports_enabled` is only returned for organization-owned repositories.
//
// GET /repos/{owner}/{repo}/community/profile
func (s *Server) handleReposGetCommunityProfileMetricsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-community-profile-metrics"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/community/profile"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetCommunityProfileMetricsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetCommunityProfileMetricsOperation,
			ID:   "repos/get-community-profile-metrics",
		}
	)
	params, err := decodeReposGetCommunityProfileMetricsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *CommunityProfile
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetCommunityProfileMetricsOperation,
			OperationSummary: "Get community profile metrics",
			OperationID:      "repos/get-community-profile-metrics",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetCommunityProfileMetricsParams
			Response = *CommunityProfile
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetCommunityProfileMetricsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetCommunityProfileMetrics(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetCommunityProfileMetrics(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetCommunityProfileMetricsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetContributorsStatsRequest handles repos/get-contributors-stats operation.
//
// Returns the `total` number of commits authored by the contributor. In addition, the response
// includes a Weekly Hash (`weeks` array) with the following information:
// *   `w` - Start of the week, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time).
// *   `a` - Number of additions
// *   `d` - Number of deletions
// *   `c` - Number of commits.
//
// GET /repos/{owner}/{repo}/stats/contributors
func (s *Server) handleReposGetContributorsStatsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-contributors-stats"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/stats/contributors"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetContributorsStatsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetContributorsStatsOperation,
			ID:   "repos/get-contributors-stats",
		}
	)
	params, err := decodeReposGetContributorsStatsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetContributorsStatsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetContributorsStatsOperation,
			OperationSummary: "Get all contributor commit activity",
			OperationID:      "repos/get-contributors-stats",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetContributorsStatsParams
			Response = ReposGetContributorsStatsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetContributorsStatsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetContributorsStats(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetContributorsStats(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetContributorsStatsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetDeployKeyRequest handles repos/get-deploy-key operation.
//
// Get a deploy key.
//
// GET /repos/{owner}/{repo}/keys/{key_id}
func (s *Server) handleReposGetDeployKeyRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deploy-key"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/keys/{key_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetDeployKeyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetDeployKeyOperation,
			ID:   "repos/get-deploy-key",
		}
	)
	params, err := decodeReposGetDeployKeyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetDeployKeyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetDeployKeyOperation,
			OperationSummary: "Get a deploy key",
			OperationID:      "repos/get-deploy-key",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "key_id",
					In:   "path",
				}: params.KeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetDeployKeyParams
			Response = ReposGetDeployKeyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetDeployKeyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetDeployKey(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetDeployKey(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetDeployKeyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetDeploymentRequest handles repos/get-deployment operation.
//
// Get a deployment.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}
func (s *Server) handleReposGetDeploymentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deployment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/deployments/{deployment_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetDeploymentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetDeploymentOperation,
			ID:   "repos/get-deployment",
		}
	)
	params, err := decodeReposGetDeploymentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetDeploymentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetDeploymentOperation,
			OperationSummary: "Get a deployment",
			OperationID:      "repos/get-deployment",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "deployment_id",
					In:   "path",
				}: params.DeploymentID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetDeploymentParams
			Response = ReposGetDeploymentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetDeploymentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetDeployment(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetDeployment(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetDeploymentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetDeploymentStatusRequest handles repos/get-deployment-status operation.
//
// Users with pull access can view a deployment status for a deployment:.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}
func (s *Server) handleReposGetDeploymentStatusRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-deployment-status"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetDeploymentStatusOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetDeploymentStatusOperation,
			ID:   "repos/get-deployment-status",
		}
	)
	params, err := decodeReposGetDeploymentStatusParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetDeploymentStatusRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetDeploymentStatusOperation,
			OperationSummary: "Get a deployment status",
			OperationID:      "repos/get-deployment-status",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "deployment_id",
					In:   "path",
				}: params.DeploymentID,
				{
					Name: "status_id",
					In:   "path",
				}: params.StatusID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetDeploymentStatusParams
			Response = ReposGetDeploymentStatusRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetDeploymentStatusParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetDeploymentStatus(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetDeploymentStatus(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetDeploymentStatusResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetLatestPagesBuildRequest handles repos/get-latest-pages-build operation.
//
// Get latest Pages build.
//
// GET /repos/{owner}/{repo}/pages/builds/latest
func (s *Server) handleReposGetLatestPagesBuildRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-latest-pages-build"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pages/builds/latest"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetLatestPagesBuildOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetLatestPagesBuildOperation,
			ID:   "repos/get-latest-pages-build",
		}
	)
	params, err := decodeReposGetLatestPagesBuildParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *PageBuild
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetLatestPagesBuildOperation,
			OperationSummary: "Get latest Pages build",
			OperationID:      "repos/get-latest-pages-build",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetLatestPagesBuildParams
			Response = *PageBuild
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetLatestPagesBuildParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetLatestPagesBuild(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetLatestPagesBuild(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetLatestPagesBuildResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetLatestReleaseRequest handles repos/get-latest-release operation.
//
// View the latest published full release for the repository.
// The latest release is the most recent non-prerelease, non-draft release, sorted by the
// `created_at` attribute. The `created_at` attribute is the date of the commit used for the release,
// and not the date when the release was drafted or published.
//
// GET /repos/{owner}/{repo}/releases/latest
func (s *Server) handleReposGetLatestReleaseRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-latest-release"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/latest"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetLatestReleaseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetLatestReleaseOperation,
			ID:   "repos/get-latest-release",
		}
	)
	params, err := decodeReposGetLatestReleaseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *Release
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetLatestReleaseOperation,
			OperationSummary: "Get the latest release",
			OperationID:      "repos/get-latest-release",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetLatestReleaseParams
			Response = *Release
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetLatestReleaseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetLatestRelease(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetLatestRelease(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetLatestReleaseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetPagesRequest handles repos/get-pages operation.
//
// Get a GitHub Pages site.
//
// GET /repos/{owner}/{repo}/pages
func (s *Server) handleReposGetPagesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pages"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetPagesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetPagesOperation,
			ID:   "repos/get-pages",
		}
	)
	params, err := decodeReposGetPagesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetPagesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetPagesOperation,
			OperationSummary: "Get a GitHub Pages site",
			OperationID:      "repos/get-pages",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetPagesParams
			Response = ReposGetPagesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetPagesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetPages(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetPages(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetPagesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetPagesBuildRequest handles repos/get-pages-build operation.
//
// Get GitHub Pages build.
//
// GET /repos/{owner}/{repo}/pages/builds/{build_id}
func (s *Server) handleReposGetPagesBuildRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages-build"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pages/builds/{build_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetPagesBuildOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetPagesBuildOperation,
			ID:   "repos/get-pages-build",
		}
	)
	params, err := decodeReposGetPagesBuildParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *PageBuild
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetPagesBuildOperation,
			OperationSummary: "Get GitHub Pages build",
			OperationID:      "repos/get-pages-build",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "build_id",
					In:   "path",
				}: params.BuildID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetPagesBuildParams
			Response = *PageBuild
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetPagesBuildParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetPagesBuild(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetPagesBuild(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetPagesBuildResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetPagesHealthCheckRequest handles repos/get-pages-health-check operation.
//
// Gets a health check of the DNS settings for the `CNAME` record configured for a repository's
// GitHub Pages.
// The first request to this endpoint returns a `202 Accepted` status and starts an asynchronous
// background task to get the results for the domain. After the background task completes, subsequent
// requests to this endpoint return a `200 OK` status with the health check results in the response.
// Users must have admin or owner permissions. GitHub Apps must have the `pages:write` and
// `administration:write` permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/pages/health
func (s *Server) handleReposGetPagesHealthCheckRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pages-health-check"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pages/health"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetPagesHealthCheckOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetPagesHealthCheckOperation,
			ID:   "repos/get-pages-health-check",
		}
	)
	params, err := decodeReposGetPagesHealthCheckParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetPagesHealthCheckRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetPagesHealthCheckOperation,
			OperationSummary: "Get a DNS health check for GitHub Pages",
			OperationID:      "repos/get-pages-health-check",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetPagesHealthCheckParams
			Response = ReposGetPagesHealthCheckRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetPagesHealthCheckParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetPagesHealthCheck(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetPagesHealthCheck(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetPagesHealthCheckResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetParticipationStatsRequest handles repos/get-participation-stats operation.
//
// Returns the total commit counts for the `owner` and total commit counts in `all`. `all` is
// everyone combined, including the `owner` in the last 52 weeks. If you'd like to get the commit
// counts for non-owners, you can subtract `owner` from `all`.
// The array order is oldest week (index 0) to most recent week.
//
// GET /repos/{owner}/{repo}/stats/participation
func (s *Server) handleReposGetParticipationStatsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-participation-stats"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/stats/participation"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetParticipationStatsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetParticipationStatsOperation,
			ID:   "repos/get-participation-stats",
		}
	)
	params, err := decodeReposGetParticipationStatsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetParticipationStatsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetParticipationStatsOperation,
			OperationSummary: "Get the weekly commit count",
			OperationID:      "repos/get-participation-stats",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetParticipationStatsParams
			Response = ReposGetParticipationStatsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetParticipationStatsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetParticipationStats(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetParticipationStats(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetParticipationStatsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetPullRequestReviewProtectionRequest handles repos/get-pull-request-review-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (s *Server) handleReposGetPullRequestReviewProtectionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-pull-request-review-protection"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetPullRequestReviewProtectionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetPullRequestReviewProtectionOperation,
			ID:   "repos/get-pull-request-review-protection",
		}
	)
	params, err := decodeReposGetPullRequestReviewProtectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ProtectedBranchPullRequestReview
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetPullRequestReviewProtectionOperation,
			OperationSummary: "Get pull request review protection",
			OperationID:      "repos/get-pull-request-review-protection",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetPullRequestReviewProtectionParams
			Response = *ProtectedBranchPullRequestReview
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetPullRequestReviewProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetPullRequestReviewProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetPullRequestReviewProtection(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetPullRequestReviewProtectionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetPunchCardStatsRequest handles repos/get-punch-card-stats operation.
//
// Each array contains the day number, hour number, and number of commits:
// *   `0-6`: Sunday - Saturday
// *   `0-23`: Hour of day
// *   Number of commits
// For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on
// Tuesdays. All times are based on the time zone of individual commits.
//
// GET /repos/{owner}/{repo}/stats/punch_card
func (s *Server) handleReposGetPunchCardStatsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-punch-card-stats"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/stats/punch_card"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetPunchCardStatsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetPunchCardStatsOperation,
			ID:   "repos/get-punch-card-stats",
		}
	)
	params, err := decodeReposGetPunchCardStatsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetPunchCardStatsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetPunchCardStatsOperation,
			OperationSummary: "Get the hourly commit count for each day",
			OperationID:      "repos/get-punch-card-stats",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetPunchCardStatsParams
			Response = ReposGetPunchCardStatsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetPunchCardStatsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetPunchCardStats(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetPunchCardStats(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetPunchCardStatsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetReadmeRequest handles repos/get-readme operation.
//
// Gets the preferred README for a repository.
// READMEs support [custom media types](https://docs.github.
// com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
//
// GET /repos/{owner}/{repo}/readme
func (s *Server) handleReposGetReadmeRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-readme"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/readme"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetReadmeOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetReadmeOperation,
			ID:   "repos/get-readme",
		}
	)
	params, err := decodeReposGetReadmeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetReadmeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetReadmeOperation,
			OperationSummary: "Get a repository README",
			OperationID:      "repos/get-readme",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "query",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetReadmeParams
			Response = ReposGetReadmeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetReadmeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetReadme(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetReadme(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetReadmeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetReadmeInDirectoryRequest handles repos/get-readme-in-directory operation.
//
// Gets the README from a repository directory.
// READMEs support [custom media types](https://docs.github.
// com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
//
// GET /repos/{owner}/{repo}/readme/{dir}
func (s *Server) handleReposGetReadmeInDirectoryRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-readme-in-directory"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/readme/{dir}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetReadmeInDirectoryOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetReadmeInDirectoryOperation,
			ID:   "repos/get-readme-in-directory",
		}
	)
	params, err := decodeReposGetReadmeInDirectoryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetReadmeInDirectoryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetReadmeInDirectoryOperation,
			OperationSummary: "Get a repository README for a directory",
			OperationID:      "repos/get-readme-in-directory",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "dir",
					In:   "path",
				}: params.Dir,
				{
					Name: "ref",
					In:   "query",
				}: params.Ref,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetReadmeInDirectoryParams
			Response = ReposGetReadmeInDirectoryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetReadmeInDirectoryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetReadmeInDirectory(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetReadmeInDirectory(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetReadmeInDirectoryResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetReleaseRequest handles repos/get-release operation.
//
// **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release
// assets. This key is a [hypermedia resource](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#hypermedia).
//
// GET /repos/{owner}/{repo}/releases/{release_id}
func (s *Server) handleReposGetReleaseRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/{release_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetReleaseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetReleaseOperation,
			ID:   "repos/get-release",
		}
	)
	params, err := decodeReposGetReleaseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetReleaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetReleaseOperation,
			OperationSummary: "Get a release",
			OperationID:      "repos/get-release",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "release_id",
					In:   "path",
				}: params.ReleaseID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetReleaseParams
			Response = ReposGetReleaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetReleaseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetRelease(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetRelease(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetReleaseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetReleaseAssetRequest handles repos/get-release-asset operation.
//
// To download the asset's binary content, set the `Accept` header of the request to
// [`application/octet-stream`](https://docs.github.com/rest/overview/media-types). The API will
// either redirect the client to the location, or stream it directly if possible. API clients should
// handle both a `200` or `302` response.
//
// GET /repos/{owner}/{repo}/releases/assets/{asset_id}
func (s *Server) handleReposGetReleaseAssetRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release-asset"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/assets/{asset_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetReleaseAssetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetReleaseAssetOperation,
			ID:   "repos/get-release-asset",
		}
	)
	params, err := decodeReposGetReleaseAssetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetReleaseAssetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetReleaseAssetOperation,
			OperationSummary: "Get a release asset",
			OperationID:      "repos/get-release-asset",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "asset_id",
					In:   "path",
				}: params.AssetID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetReleaseAssetParams
			Response = ReposGetReleaseAssetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetReleaseAssetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetReleaseAsset(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetReleaseAsset(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetReleaseAssetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetReleaseByTagRequest handles repos/get-release-by-tag operation.
//
// Get a published release with the specified tag.
//
// GET /repos/{owner}/{repo}/releases/tags/{tag}
func (s *Server) handleReposGetReleaseByTagRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-release-by-tag"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/tags/{tag}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetReleaseByTagOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetReleaseByTagOperation,
			ID:   "repos/get-release-by-tag",
		}
	)
	params, err := decodeReposGetReleaseByTagParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetReleaseByTagRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetReleaseByTagOperation,
			OperationSummary: "Get a release by tag name",
			OperationID:      "repos/get-release-by-tag",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "tag",
					In:   "path",
				}: params.Tag,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetReleaseByTagParams
			Response = ReposGetReleaseByTagRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetReleaseByTagParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetReleaseByTag(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetReleaseByTag(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetReleaseByTagResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetStatusChecksProtectionRequest handles repos/get-status-checks-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (s *Server) handleReposGetStatusChecksProtectionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-status-checks-protection"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetStatusChecksProtectionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetStatusChecksProtectionOperation,
			ID:   "repos/get-status-checks-protection",
		}
	)
	params, err := decodeReposGetStatusChecksProtectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetStatusChecksProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetStatusChecksProtectionOperation,
			OperationSummary: "Get status checks protection",
			OperationID:      "repos/get-status-checks-protection",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetStatusChecksProtectionParams
			Response = ReposGetStatusChecksProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetStatusChecksProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetStatusChecksProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetStatusChecksProtection(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetStatusChecksProtectionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetTeamsWithAccessToProtectedBranchRequest handles repos/get-teams-with-access-to-protected-branch operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists the teams who have push access to this branch. The list includes child teams.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) handleReposGetTeamsWithAccessToProtectedBranchRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-teams-with-access-to-protected-branch"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetTeamsWithAccessToProtectedBranchOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetTeamsWithAccessToProtectedBranchOperation,
			ID:   "repos/get-teams-with-access-to-protected-branch",
		}
	)
	params, err := decodeReposGetTeamsWithAccessToProtectedBranchParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetTeamsWithAccessToProtectedBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetTeamsWithAccessToProtectedBranchOperation,
			OperationSummary: "Get teams with access to the protected branch",
			OperationID:      "repos/get-teams-with-access-to-protected-branch",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetTeamsWithAccessToProtectedBranchParams
			Response = ReposGetTeamsWithAccessToProtectedBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetTeamsWithAccessToProtectedBranchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetTeamsWithAccessToProtectedBranch(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetTeamsWithAccessToProtectedBranch(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetTeamsWithAccessToProtectedBranchResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetTopPathsRequest handles repos/get-top-paths operation.
//
// Get the top 10 popular contents over the last 14 days.
//
// GET /repos/{owner}/{repo}/traffic/popular/paths
func (s *Server) handleReposGetTopPathsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-top-paths"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/traffic/popular/paths"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetTopPathsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetTopPathsOperation,
			ID:   "repos/get-top-paths",
		}
	)
	params, err := decodeReposGetTopPathsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetTopPathsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetTopPathsOperation,
			OperationSummary: "Get top referral paths",
			OperationID:      "repos/get-top-paths",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetTopPathsParams
			Response = ReposGetTopPathsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetTopPathsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetTopPaths(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetTopPaths(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetTopPathsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetTopReferrersRequest handles repos/get-top-referrers operation.
//
// Get the top 10 referrers over the last 14 days.
//
// GET /repos/{owner}/{repo}/traffic/popular/referrers
func (s *Server) handleReposGetTopReferrersRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-top-referrers"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/traffic/popular/referrers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetTopReferrersOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetTopReferrersOperation,
			ID:   "repos/get-top-referrers",
		}
	)
	params, err := decodeReposGetTopReferrersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetTopReferrersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetTopReferrersOperation,
			OperationSummary: "Get top referral sources",
			OperationID:      "repos/get-top-referrers",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetTopReferrersParams
			Response = ReposGetTopReferrersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetTopReferrersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetTopReferrers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetTopReferrers(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetTopReferrersResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetUsersWithAccessToProtectedBranchRequest handles repos/get-users-with-access-to-protected-branch operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Lists the people who have push access to this branch.
//
// GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) handleReposGetUsersWithAccessToProtectedBranchRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-users-with-access-to-protected-branch"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetUsersWithAccessToProtectedBranchOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetUsersWithAccessToProtectedBranchOperation,
			ID:   "repos/get-users-with-access-to-protected-branch",
		}
	)
	params, err := decodeReposGetUsersWithAccessToProtectedBranchParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetUsersWithAccessToProtectedBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetUsersWithAccessToProtectedBranchOperation,
			OperationSummary: "Get users with access to the protected branch",
			OperationID:      "repos/get-users-with-access-to-protected-branch",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetUsersWithAccessToProtectedBranchParams
			Response = ReposGetUsersWithAccessToProtectedBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetUsersWithAccessToProtectedBranchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetUsersWithAccessToProtectedBranch(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetUsersWithAccessToProtectedBranch(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetUsersWithAccessToProtectedBranchResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetViewsRequest handles repos/get-views operation.
//
// Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are
// aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
//
// GET /repos/{owner}/{repo}/traffic/views
func (s *Server) handleReposGetViewsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-views"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/traffic/views"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetViewsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetViewsOperation,
			ID:   "repos/get-views",
		}
	)
	params, err := decodeReposGetViewsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetViewsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetViewsOperation,
			OperationSummary: "Get page views",
			OperationID:      "repos/get-views",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per",
					In:   "query",
				}: params.Per,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetViewsParams
			Response = ReposGetViewsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetViewsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetViews(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetViews(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetViewsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetWebhookRequest handles repos/get-webhook operation.
//
// Returns a webhook configured in a repository. To get only the webhook `config` properties, see
// "[Get a webhook configuration for a
// repository](/rest/reference/repos#get-a-webhook-configuration-for-a-repository).".
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}
func (s *Server) handleReposGetWebhookRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetWebhookOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetWebhookOperation,
			ID:   "repos/get-webhook",
		}
	)
	params, err := decodeReposGetWebhookParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetWebhookOperation,
			OperationSummary: "Get a repository webhook",
			OperationID:      "repos/get-webhook",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetWebhookParams
			Response = ReposGetWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetWebhook(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetWebhook(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetWebhookResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetWebhookConfigForRepoRequest handles repos/get-webhook-config-for-repo operation.
//
// Returns the webhook configuration for a repository. To get more information about the webhook,
// including the `active` state and `events`, use "[Get a repository
// webhook](/rest/reference/orgs#get-a-repository-webhook)."
// Access tokens must have the `read:repo_hook` or `repo` scope, and GitHub Apps must have the
// `repository_hooks:read` permission.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/config
func (s *Server) handleReposGetWebhookConfigForRepoRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook-config-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}/config"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetWebhookConfigForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetWebhookConfigForRepoOperation,
			ID:   "repos/get-webhook-config-for-repo",
		}
	)
	params, err := decodeReposGetWebhookConfigForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetWebhookConfigForRepoOperation,
			OperationSummary: "Get a webhook configuration for a repository",
			OperationID:      "repos/get-webhook-config-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetWebhookConfigForRepoParams
			Response = *WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetWebhookConfigForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetWebhookConfigForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetWebhookConfigForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetWebhookConfigForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposGetWebhookDeliveryRequest handles repos/get-webhook-delivery operation.
//
// Returns a delivery for a webhook configured in a repository.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}
func (s *Server) handleReposGetWebhookDeliveryRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/get-webhook-delivery"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposGetWebhookDeliveryOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposGetWebhookDeliveryOperation,
			ID:   "repos/get-webhook-delivery",
		}
	)
	params, err := decodeReposGetWebhookDeliveryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposGetWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposGetWebhookDeliveryOperation,
			OperationSummary: "Get a delivery for a repository webhook",
			OperationID:      "repos/get-webhook-delivery",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
				{
					Name: "delivery_id",
					In:   "path",
				}: params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposGetWebhookDeliveryParams
			Response = ReposGetWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposGetWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposGetWebhookDelivery(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposGetWebhookDelivery(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposGetWebhookDeliveryResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListAutolinksRequest handles repos/list-autolinks operation.
//
// This returns a list of autolinks configured for the given repository.
// Information about autolinks are only available to repository administrators.
//
// GET /repos/{owner}/{repo}/autolinks
func (s *Server) handleReposListAutolinksRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-autolinks"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/autolinks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListAutolinksOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListAutolinksOperation,
			ID:   "repos/list-autolinks",
		}
	)
	params, err := decodeReposListAutolinksParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response []Autolink
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListAutolinksOperation,
			OperationSummary: "List all autolinks of a repository",
			OperationID:      "repos/list-autolinks",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListAutolinksParams
			Response = []Autolink
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListAutolinksParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListAutolinks(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListAutolinks(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListAutolinksResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListBranchesRequest handles repos/list-branches operation.
//
// List branches.
//
// GET /repos/{owner}/{repo}/branches
func (s *Server) handleReposListBranchesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-branches"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListBranchesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListBranchesOperation,
			ID:   "repos/list-branches",
		}
	)
	params, err := decodeReposListBranchesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposListBranchesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListBranchesOperation,
			OperationSummary: "List branches",
			OperationID:      "repos/list-branches",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "protected",
					In:   "query",
				}: params.Protected,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListBranchesParams
			Response = ReposListBranchesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListBranchesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListBranches(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListBranches(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListBranchesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListBranchesForHeadCommitRequest handles repos/list-branches-for-head-commit operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Returns all branches where the given commit SHA is the HEAD, or latest commit for the branch.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head
func (s *Server) handleReposListBranchesForHeadCommitRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-branches-for-head-commit"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListBranchesForHeadCommitOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListBranchesForHeadCommitOperation,
			ID:   "repos/list-branches-for-head-commit",
		}
	)
	params, err := decodeReposListBranchesForHeadCommitParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposListBranchesForHeadCommitRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListBranchesForHeadCommitOperation,
			OperationSummary: "List branches for HEAD commit",
			OperationID:      "repos/list-branches-for-head-commit",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "commit_sha",
					In:   "path",
				}: params.CommitSha,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListBranchesForHeadCommitParams
			Response = ReposListBranchesForHeadCommitRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListBranchesForHeadCommitParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListBranchesForHeadCommit(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListBranchesForHeadCommit(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListBranchesForHeadCommitResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListCollaboratorsRequest handles repos/list-collaborators operation.
//
// For organization-owned repositories, the list of collaborators includes outside collaborators,
// organization members that are direct collaborators, organization members with access through team
// memberships, organization members with access through default organization permissions, and
// organization owners.
// Team members will include the members of child teams.
//
// GET /repos/{owner}/{repo}/collaborators
func (s *Server) handleReposListCollaboratorsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-collaborators"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/collaborators"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListCollaboratorsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListCollaboratorsOperation,
			ID:   "repos/list-collaborators",
		}
	)
	params, err := decodeReposListCollaboratorsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposListCollaboratorsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListCollaboratorsOperation,
			OperationSummary: "List repository collaborators",
			OperationID:      "repos/list-collaborators",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "affiliation",
					In:   "query",
				}: params.Affiliation,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListCollaboratorsParams
			Response = ReposListCollaboratorsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListCollaboratorsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListCollaborators(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListCollaborators(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListCollaboratorsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListCommentsForCommitRequest handles repos/list-comments-for-commit operation.
//
// Use the `:commit_sha` to specify the commit that will have its comments listed.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/comments
func (s *Server) handleReposListCommentsForCommitRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-comments-for-commit"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{commit_sha}/comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListCommentsForCommitOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListCommentsForCommitOperation,
			ID:   "repos/list-comments-for-commit",
		}
	)
	params, err := decodeReposListCommentsForCommitParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposListCommentsForCommitOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListCommentsForCommitOperation,
			OperationSummary: "List commit comments",
			OperationID:      "repos/list-comments-for-commit",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "commit_sha",
					In:   "path",
				}: params.CommitSha,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListCommentsForCommitParams
			Response = *ReposListCommentsForCommitOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListCommentsForCommitParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListCommentsForCommit(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListCommentsForCommit(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListCommentsForCommitResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListCommitCommentsForRepoRequest handles repos/list-commit-comments-for-repo operation.
//
// Commit Comments use [these custom media types](https://docs.github.
// com/rest/reference/repos#custom-media-types). You can read more about the use of media types in
// the API [here](https://docs.github.com/rest/overview/media-types/).
// Comments are ordered by ascending ID.
//
// GET /repos/{owner}/{repo}/comments
func (s *Server) handleReposListCommitCommentsForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commit-comments-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListCommitCommentsForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListCommitCommentsForRepoOperation,
			ID:   "repos/list-commit-comments-for-repo",
		}
	)
	params, err := decodeReposListCommitCommentsForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposListCommitCommentsForRepoOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListCommitCommentsForRepoOperation,
			OperationSummary: "List commit comments for a repository",
			OperationID:      "repos/list-commit-comments-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListCommitCommentsForRepoParams
			Response = *ReposListCommitCommentsForRepoOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListCommitCommentsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListCommitCommentsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListCommitCommentsForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListCommitCommentsForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListCommitStatusesForRefRequest handles repos/list-commit-statuses-for-ref operation.
//
// Users with pull access in a repository can view commit statuses for a given ref. The ref can be a
// SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first
// status in the list will be the latest one.
// This resource is also available via a legacy route: `GET /repos/:owner/:repo/statuses/:ref`.
//
// GET /repos/{owner}/{repo}/commits/{ref}/statuses
func (s *Server) handleReposListCommitStatusesForRefRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commit-statuses-for-ref"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{ref}/statuses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListCommitStatusesForRefOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListCommitStatusesForRefOperation,
			ID:   "repos/list-commit-statuses-for-ref",
		}
	)
	params, err := decodeReposListCommitStatusesForRefParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposListCommitStatusesForRefRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListCommitStatusesForRefOperation,
			OperationSummary: "List commit statuses for a reference",
			OperationID:      "repos/list-commit-statuses-for-ref",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "ref",
					In:   "path",
				}: params.Ref,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListCommitStatusesForRefParams
			Response = ReposListCommitStatusesForRefRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListCommitStatusesForRefParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListCommitStatusesForRef(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListCommitStatusesForRef(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListCommitStatusesForRefResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListCommitsRequest handles repos/list-commits operation.
//
// **Signature verification object**
// The response will include a `verification` object that describes the result of verifying the
// commit's signature. The following fields are included in the `verification` object:
// | Name | Type | Description |
// | ---- | ---- | ----------- |
// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be
// verified. |
// | `reason` | `string` | The reason for verified value. Possible values and their meanings are
// enumerated in table below. |
// | `signature` | `string` | The signature that was extracted from the commit. |
// | `payload` | `string` | The value that was signed. |
// These are the possible values for `reason` in the `verification` object:
// | Value | Description |
// | ----- | ----------- |
// | `expired_key` | The key that made the signature is expired. |
// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the
// signature. |
// | `gpgverify_error` | There was an error communicating with the signature verification service. |
// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
// | `unsigned` | The object does not include a signature. |
// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
// | `no_user` | No user was associated with the `committer` email address in the commit. |
// | `unverified_email` | The `committer` email address in the commit was associated with a user, but
// the email address is not verified on her/his account. |
// | `bad_email` | The `committer` email address in the commit is not included in the identities of
// the PGP key that made the signature. |
// | `unknown_key` | The key that made the signature has not been registered with any user's account.
// |
// | `malformed_signature` | There was an error parsing the signature. |
// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was
// found in the signature. |
// | `valid` | None of the above errors applied, so the signature is considered to be verified. |.
//
// GET /repos/{owner}/{repo}/commits
func (s *Server) handleReposListCommitsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-commits"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListCommitsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListCommitsOperation,
			ID:   "repos/list-commits",
		}
	)
	params, err := decodeReposListCommitsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposListCommitsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListCommitsOperation,
			OperationSummary: "List commits",
			OperationID:      "repos/list-commits",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "sha",
					In:   "query",
				}: params.Sha,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
				{
					Name: "author",
					In:   "query",
				}: params.Author,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "until",
					In:   "query",
				}: params.Until,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListCommitsParams
			Response = ReposListCommitsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListCommitsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListCommits(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListCommits(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListCommitsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListContributorsRequest handles repos/list-contributors operation.
//
// Lists contributors to the specified repository and sorts them by the number of commits per
// contributor in descending order. This endpoint may return information that is a few hours old
// because the GitHub REST API v3 caches contributor data to improve performance.
// GitHub identifies contributors by author email address. This endpoint groups contribution counts
// by GitHub user, which includes all associated email addresses. To improve performance, only the
// first 500 author email addresses in the repository link to GitHub users. The rest will appear as
// anonymous contributors without associated GitHub user information.
//
// GET /repos/{owner}/{repo}/contributors
func (s *Server) handleReposListContributorsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-contributors"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/contributors"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListContributorsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListContributorsOperation,
			ID:   "repos/list-contributors",
		}
	)
	params, err := decodeReposListContributorsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposListContributorsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListContributorsOperation,
			OperationSummary: "List repository contributors",
			OperationID:      "repos/list-contributors",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "anon",
					In:   "query",
				}: params.Anon,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListContributorsParams
			Response = ReposListContributorsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListContributorsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListContributors(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListContributors(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListContributorsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListDeployKeysRequest handles repos/list-deploy-keys operation.
//
// List deploy keys.
//
// GET /repos/{owner}/{repo}/keys
func (s *Server) handleReposListDeployKeysRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deploy-keys"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/keys"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListDeployKeysOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListDeployKeysOperation,
			ID:   "repos/list-deploy-keys",
		}
	)
	params, err := decodeReposListDeployKeysParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposListDeployKeysOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListDeployKeysOperation,
			OperationSummary: "List deploy keys",
			OperationID:      "repos/list-deploy-keys",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListDeployKeysParams
			Response = *ReposListDeployKeysOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListDeployKeysParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListDeployKeys(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListDeployKeys(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListDeployKeysResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListDeploymentStatusesRequest handles repos/list-deployment-statuses operation.
//
// Users with pull access can view deployment statuses for a deployment:.
//
// GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses
func (s *Server) handleReposListDeploymentStatusesRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deployment-statuses"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/deployments/{deployment_id}/statuses"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListDeploymentStatusesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListDeploymentStatusesOperation,
			ID:   "repos/list-deployment-statuses",
		}
	)
	params, err := decodeReposListDeploymentStatusesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposListDeploymentStatusesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListDeploymentStatusesOperation,
			OperationSummary: "List deployment statuses",
			OperationID:      "repos/list-deployment-statuses",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "deployment_id",
					In:   "path",
				}: params.DeploymentID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListDeploymentStatusesParams
			Response = ReposListDeploymentStatusesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListDeploymentStatusesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListDeploymentStatuses(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListDeploymentStatuses(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListDeploymentStatusesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListDeploymentsRequest handles repos/list-deployments operation.
//
// Simple filtering of deployments is available via query parameters:.
//
// GET /repos/{owner}/{repo}/deployments
func (s *Server) handleReposListDeploymentsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-deployments"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/deployments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListDeploymentsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListDeploymentsOperation,
			ID:   "repos/list-deployments",
		}
	)
	params, err := decodeReposListDeploymentsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposListDeploymentsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListDeploymentsOperation,
			OperationSummary: "List deployments",
			OperationID:      "repos/list-deployments",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "sha",
					In:   "query",
				}: params.Sha,
				{
					Name: "ref",
					In:   "query",
				}: params.Ref,
				{
					Name: "task",
					In:   "query",
				}: params.Task,
				{
					Name: "environment",
					In:   "query",
				}: params.Environment,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListDeploymentsParams
			Response = *ReposListDeploymentsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListDeploymentsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListDeployments(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListDeployments(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListDeploymentsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListForAuthenticatedUserRequest handles repos/list-for-authenticated-user operation.
//
// Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or
// `:admin`) to access.
// The authenticated user has explicit permission to access repositories they own, repositories where
// they are a collaborator, and repositories that they can access through an organization membership.
//
// GET /user/repos
func (s *Server) handleReposListForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/repos"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListForAuthenticatedUserOperation,
			ID:   "repos/list-for-authenticated-user",
		}
	)
	params, err := decodeReposListForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposListForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListForAuthenticatedUserOperation,
			OperationSummary: "List repositories for the authenticated user",
			OperationID:      "repos/list-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "visibility",
					In:   "query",
				}: params.Visibility,
				{
					Name: "affiliation",
					In:   "query",
				}: params.Affiliation,
				{
					Name: "type",
					In:   "query",
				}: params.Type,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "before",
					In:   "query",
				}: params.Before,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListForAuthenticatedUserParams
			Response = ReposListForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListForOrgRequest handles repos/list-for-org operation.
//
// Lists repositories for the specified organization.
//
// GET /orgs/{org}/repos
func (s *Server) handleReposListForOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/repos"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListForOrgOperation,
			ID:   "repos/list-for-org",
		}
	)
	params, err := decodeReposListForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposListForOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListForOrgOperation,
			OperationSummary: "List organization repositories",
			OperationID:      "repos/list-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "type",
					In:   "query",
				}: params.Type,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListForOrgParams
			Response = *ReposListForOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListForUserRequest handles repos/list-for-user operation.
//
// Lists public repositories for the specified user. Note: For GitHub AE, this endpoint will list
// internal repositories for the specified user.
//
// GET /users/{username}/repos
func (s *Server) handleReposListForUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/repos"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListForUserOperation,
			ID:   "repos/list-for-user",
		}
	)
	params, err := decodeReposListForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposListForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListForUserOperation,
			OperationSummary: "List repositories for a user",
			OperationID:      "repos/list-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "type",
					In:   "query",
				}: params.Type,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListForUserParams
			Response = *ReposListForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListForksRequest handles repos/list-forks operation.
//
// List forks.
//
// GET /repos/{owner}/{repo}/forks
func (s *Server) handleReposListForksRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-forks"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/forks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListForksOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListForksOperation,
			ID:   "repos/list-forks",
		}
	)
	params, err := decodeReposListForksParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposListForksRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListForksOperation,
			OperationSummary: "List forks",
			OperationID:      "repos/list-forks",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListForksParams
			Response = ReposListForksRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListForksParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListForks(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListForks(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListForksResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListInvitationsRequest handles repos/list-invitations operation.
//
// When authenticating as a user with admin rights to a repository, this endpoint will list all
// currently open repository invitations.
//
// GET /repos/{owner}/{repo}/invitations
func (s *Server) handleReposListInvitationsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-invitations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/invitations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListInvitationsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListInvitationsOperation,
			ID:   "repos/list-invitations",
		}
	)
	params, err := decodeReposListInvitationsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposListInvitationsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListInvitationsOperation,
			OperationSummary: "List repository invitations",
			OperationID:      "repos/list-invitations",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListInvitationsParams
			Response = *ReposListInvitationsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListInvitationsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListInvitations(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListInvitations(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListInvitationsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListInvitationsForAuthenticatedUserRequest handles repos/list-invitations-for-authenticated-user operation.
//
// When authenticating as a user, this endpoint will list all currently open repository invitations
// for that user.
//
// GET /user/repository_invitations
func (s *Server) handleReposListInvitationsForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-invitations-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/repository_invitations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListInvitationsForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListInvitationsForAuthenticatedUserOperation,
			ID:   "repos/list-invitations-for-authenticated-user",
		}
	)
	params, err := decodeReposListInvitationsForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposListInvitationsForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListInvitationsForAuthenticatedUserOperation,
			OperationSummary: "List repository invitations for the authenticated user",
			OperationID:      "repos/list-invitations-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListInvitationsForAuthenticatedUserParams
			Response = ReposListInvitationsForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListInvitationsForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListInvitationsForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListInvitationsForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListInvitationsForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListLanguagesRequest handles repos/list-languages operation.
//
// Lists languages for the specified repository. The value shown for each language is the number of
// bytes of code written in that language.
//
// GET /repos/{owner}/{repo}/languages
func (s *Server) handleReposListLanguagesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-languages"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/languages"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListLanguagesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListLanguagesOperation,
			ID:   "repos/list-languages",
		}
	)
	params, err := decodeReposListLanguagesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response Language
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListLanguagesOperation,
			OperationSummary: "List repository languages",
			OperationID:      "repos/list-languages",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListLanguagesParams
			Response = Language
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListLanguagesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListLanguages(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListLanguages(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListLanguagesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListPagesBuildsRequest handles repos/list-pages-builds operation.
//
// List GitHub Pages builds.
//
// GET /repos/{owner}/{repo}/pages/builds
func (s *Server) handleReposListPagesBuildsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-pages-builds"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pages/builds"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListPagesBuildsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListPagesBuildsOperation,
			ID:   "repos/list-pages-builds",
		}
	)
	params, err := decodeReposListPagesBuildsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposListPagesBuildsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListPagesBuildsOperation,
			OperationSummary: "List GitHub Pages builds",
			OperationID:      "repos/list-pages-builds",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListPagesBuildsParams
			Response = *ReposListPagesBuildsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListPagesBuildsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListPagesBuilds(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListPagesBuilds(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListPagesBuildsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListPublicRequest handles repos/list-public operation.
//
// Lists all public repositories in the order that they were created.
// Note:
// - For GitHub Enterprise Server, this endpoint will only list repositories available to all users
// on the enterprise.
// - Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.
// github.com/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page
// of repositories.
//
// GET /repositories
func (s *Server) handleReposListPublicRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-public"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repositories"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListPublicOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListPublicOperation,
			ID:   "repos/list-public",
		}
	)
	params, err := decodeReposListPublicParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposListPublicRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListPublicOperation,
			OperationSummary: "List public repositories",
			OperationID:      "repos/list-public",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "since",
					In:   "query",
				}: params.Since,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListPublicParams
			Response = ReposListPublicRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListPublicParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListPublic(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListPublic(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListPublicResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListPullRequestsAssociatedWithCommitRequest handles repos/list-pull-requests-associated-with-commit operation.
//
// Lists the merged pull request that introduced the commit to the repository. If the commit is not
// present in the default branch, additionally returns open pull requests associated with the commit.
// The results may include open and closed pull requests. Additional preview headers may be required
// to see certain details for associated pull requests, such as whether a pull request is in a draft
// state. For more information about previews that might affect this endpoint, see the [List pull
// requests](https://docs.github.com/rest/reference/pulls#list-pull-requests) endpoint.
//
// GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls
func (s *Server) handleReposListPullRequestsAssociatedWithCommitRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-pull-requests-associated-with-commit"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/commits/{commit_sha}/pulls"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListPullRequestsAssociatedWithCommitOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListPullRequestsAssociatedWithCommitOperation,
			ID:   "repos/list-pull-requests-associated-with-commit",
		}
	)
	params, err := decodeReposListPullRequestsAssociatedWithCommitParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposListPullRequestsAssociatedWithCommitOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListPullRequestsAssociatedWithCommitOperation,
			OperationSummary: "List pull requests associated with a commit",
			OperationID:      "repos/list-pull-requests-associated-with-commit",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "commit_sha",
					In:   "path",
				}: params.CommitSha,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListPullRequestsAssociatedWithCommitParams
			Response = *ReposListPullRequestsAssociatedWithCommitOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListPullRequestsAssociatedWithCommitParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListPullRequestsAssociatedWithCommit(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListPullRequestsAssociatedWithCommit(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListPullRequestsAssociatedWithCommitResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListReleaseAssetsRequest handles repos/list-release-assets operation.
//
// List release assets.
//
// GET /repos/{owner}/{repo}/releases/{release_id}/assets
func (s *Server) handleReposListReleaseAssetsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-release-assets"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/{release_id}/assets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListReleaseAssetsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListReleaseAssetsOperation,
			ID:   "repos/list-release-assets",
		}
	)
	params, err := decodeReposListReleaseAssetsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposListReleaseAssetsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListReleaseAssetsOperation,
			OperationSummary: "List release assets",
			OperationID:      "repos/list-release-assets",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "release_id",
					In:   "path",
				}: params.ReleaseID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListReleaseAssetsParams
			Response = *ReposListReleaseAssetsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListReleaseAssetsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListReleaseAssets(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListReleaseAssets(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListReleaseAssetsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListReleasesRequest handles repos/list-releases operation.
//
// This returns a list of releases, which does not include regular Git tags that have not been
// associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.
// github.com/rest/reference/repos#list-repository-tags).
// Information about published releases are available to everyone. Only users with push access will
// receive listings for draft releases.
//
// GET /repos/{owner}/{repo}/releases
func (s *Server) handleReposListReleasesRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-releases"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListReleasesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListReleasesOperation,
			ID:   "repos/list-releases",
		}
	)
	params, err := decodeReposListReleasesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposListReleasesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListReleasesOperation,
			OperationSummary: "List releases",
			OperationID:      "repos/list-releases",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListReleasesParams
			Response = ReposListReleasesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListReleasesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListReleases(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListReleases(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListReleasesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListTagsRequest handles repos/list-tags operation.
//
// List repository tags.
//
// GET /repos/{owner}/{repo}/tags
func (s *Server) handleReposListTagsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-tags"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/tags"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListTagsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListTagsOperation,
			ID:   "repos/list-tags",
		}
	)
	params, err := decodeReposListTagsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposListTagsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListTagsOperation,
			OperationSummary: "List repository tags",
			OperationID:      "repos/list-tags",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListTagsParams
			Response = *ReposListTagsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListTagsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListTags(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListTags(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListTagsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListTeamsRequest handles repos/list-teams operation.
//
// List repository teams.
//
// GET /repos/{owner}/{repo}/teams
func (s *Server) handleReposListTeamsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-teams"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/teams"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListTeamsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListTeamsOperation,
			ID:   "repos/list-teams",
		}
	)
	params, err := decodeReposListTeamsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposListTeamsOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListTeamsOperation,
			OperationSummary: "List repository teams",
			OperationID:      "repos/list-teams",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListTeamsParams
			Response = *ReposListTeamsOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListTeamsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListTeams(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListTeams(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListTeamsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListWebhookDeliveriesRequest handles repos/list-webhook-deliveries operation.
//
// Returns a list of webhook deliveries for a webhook configured in a repository.
//
// GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries
func (s *Server) handleReposListWebhookDeliveriesRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-webhook-deliveries"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}/deliveries"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListWebhookDeliveriesOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListWebhookDeliveriesOperation,
			ID:   "repos/list-webhook-deliveries",
		}
	)
	params, err := decodeReposListWebhookDeliveriesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposListWebhookDeliveriesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListWebhookDeliveriesOperation,
			OperationSummary: "List deliveries for a repository webhook",
			OperationID:      "repos/list-webhook-deliveries",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "cursor",
					In:   "query",
				}: params.Cursor,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListWebhookDeliveriesParams
			Response = ReposListWebhookDeliveriesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListWebhookDeliveriesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListWebhookDeliveries(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListWebhookDeliveries(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListWebhookDeliveriesResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposListWebhooksRequest handles repos/list-webhooks operation.
//
// List repository webhooks.
//
// GET /repos/{owner}/{repo}/hooks
func (s *Server) handleReposListWebhooksRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/list-webhooks"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposListWebhooksOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposListWebhooksOperation,
			ID:   "repos/list-webhooks",
		}
	)
	params, err := decodeReposListWebhooksParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposListWebhooksRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposListWebhooksOperation,
			OperationSummary: "List repository webhooks",
			OperationID:      "repos/list-webhooks",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposListWebhooksParams
			Response = ReposListWebhooksRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposListWebhooksParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposListWebhooks(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposListWebhooks(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposListWebhooksResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposMergeRequest handles repos/merge operation.
//
// Merge a branch.
//
// POST /repos/{owner}/{repo}/merges
func (s *Server) handleReposMergeRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/merge"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/merges"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposMergeOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposMergeOperation,
			ID:   "repos/merge",
		}
	)
	params, err := decodeReposMergeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposMergeRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposMergeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposMergeOperation,
			OperationSummary: "Merge a branch",
			OperationID:      "repos/merge",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposMergeReq
			Params   = ReposMergeParams
			Response = ReposMergeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposMergeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposMerge(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposMerge(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposMergeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposMergeUpstreamRequest handles repos/merge-upstream operation.
//
// **Note:** This endpoint is currently in beta and subject to change.
// Sync a branch of a forked repository to keep it up-to-date with the upstream repository.
//
// POST /repos/{owner}/{repo}/merge-upstream
func (s *Server) handleReposMergeUpstreamRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/merge-upstream"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/merge-upstream"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposMergeUpstreamOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposMergeUpstreamOperation,
			ID:   "repos/merge-upstream",
		}
	)
	params, err := decodeReposMergeUpstreamParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposMergeUpstreamRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposMergeUpstreamRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposMergeUpstreamOperation,
			OperationSummary: "Sync a fork branch with the upstream repository",
			OperationID:      "repos/merge-upstream",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposMergeUpstreamReq
			Params   = ReposMergeUpstreamParams
			Response = ReposMergeUpstreamRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposMergeUpstreamParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposMergeUpstream(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposMergeUpstream(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposMergeUpstreamResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposPingWebhookRequest handles repos/ping-webhook operation.
//
// This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the
// hook.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/pings
func (s *Server) handleReposPingWebhookRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/ping-webhook"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}/pings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposPingWebhookOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposPingWebhookOperation,
			ID:   "repos/ping-webhook",
		}
	)
	params, err := decodeReposPingWebhookParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposPingWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposPingWebhookOperation,
			OperationSummary: "Ping a repository webhook",
			OperationID:      "repos/ping-webhook",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposPingWebhookParams
			Response = ReposPingWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposPingWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposPingWebhook(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposPingWebhook(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposPingWebhookResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposRedeliverWebhookDeliveryRequest handles repos/redeliver-webhook-delivery operation.
//
// Redeliver a webhook delivery for a webhook configured in a repository.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts
func (s *Server) handleReposRedeliverWebhookDeliveryRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/redeliver-webhook-delivery"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposRedeliverWebhookDeliveryOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposRedeliverWebhookDeliveryOperation,
			ID:   "repos/redeliver-webhook-delivery",
		}
	)
	params, err := decodeReposRedeliverWebhookDeliveryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposRedeliverWebhookDeliveryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposRedeliverWebhookDeliveryOperation,
			OperationSummary: "Redeliver a delivery for a repository webhook",
			OperationID:      "repos/redeliver-webhook-delivery",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
				{
					Name: "delivery_id",
					In:   "path",
				}: params.DeliveryID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposRedeliverWebhookDeliveryParams
			Response = ReposRedeliverWebhookDeliveryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRedeliverWebhookDeliveryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposRedeliverWebhookDelivery(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposRedeliverWebhookDelivery(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRedeliverWebhookDeliveryResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposRemoveAppAccessRestrictionsRequest handles repos/remove-app-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Removes the ability of an app to push to this branch. Only installed GitHub Apps with `write`
// access to the `contents` permission can be added as authorized actors on a protected branch.
// | Type    | Description
//
//	|
//
// | ------- |
// ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**:
// The list of users, apps, and teams in total is limited to 100 items. |.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) handleReposRemoveAppAccessRestrictionsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-app-access-restrictions"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposRemoveAppAccessRestrictionsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposRemoveAppAccessRestrictionsOperation,
			ID:   "repos/remove-app-access-restrictions",
		}
	)
	params, err := decodeReposRemoveAppAccessRestrictionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposRemoveAppAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposRemoveAppAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposRemoveAppAccessRestrictionsOperation,
			OperationSummary: "Remove app access restrictions",
			OperationID:      "repos/remove-app-access-restrictions",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposRemoveAppAccessRestrictionsReq
			Params   = ReposRemoveAppAccessRestrictionsParams
			Response = ReposRemoveAppAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveAppAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposRemoveAppAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposRemoveAppAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveAppAccessRestrictionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposRemoveCollaboratorRequest handles repos/remove-collaborator operation.
//
// Remove a repository collaborator.
//
// DELETE /repos/{owner}/{repo}/collaborators/{username}
func (s *Server) handleReposRemoveCollaboratorRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-collaborator"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/collaborators/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposRemoveCollaboratorOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposRemoveCollaboratorOperation,
			ID:   "repos/remove-collaborator",
		}
	)
	params, err := decodeReposRemoveCollaboratorParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposRemoveCollaboratorNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposRemoveCollaboratorOperation,
			OperationSummary: "Remove a repository collaborator",
			OperationID:      "repos/remove-collaborator",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposRemoveCollaboratorParams
			Response = *ReposRemoveCollaboratorNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveCollaboratorParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposRemoveCollaborator(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposRemoveCollaborator(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveCollaboratorResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposRemoveStatusCheckContextsRequest handles repos/remove-status-check-contexts operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) handleReposRemoveStatusCheckContextsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-status-check-contexts"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposRemoveStatusCheckContextsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposRemoveStatusCheckContextsOperation,
			ID:   "repos/remove-status-check-contexts",
		}
	)
	params, err := decodeReposRemoveStatusCheckContextsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposRemoveStatusCheckContextsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposRemoveStatusCheckContextsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposRemoveStatusCheckContextsOperation,
			OperationSummary: "Remove status check contexts",
			OperationID:      "repos/remove-status-check-contexts",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposRemoveStatusCheckContextsReq
			Params   = ReposRemoveStatusCheckContextsParams
			Response = ReposRemoveStatusCheckContextsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveStatusCheckContextsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposRemoveStatusCheckContexts(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposRemoveStatusCheckContexts(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveStatusCheckContextsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposRemoveStatusCheckProtectionRequest handles repos/remove-status-check-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (s *Server) handleReposRemoveStatusCheckProtectionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-status-check-protection"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposRemoveStatusCheckProtectionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposRemoveStatusCheckProtectionOperation,
			ID:   "repos/remove-status-check-protection",
		}
	)
	params, err := decodeReposRemoveStatusCheckProtectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ReposRemoveStatusCheckProtectionNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposRemoveStatusCheckProtectionOperation,
			OperationSummary: "Remove status check protection",
			OperationID:      "repos/remove-status-check-protection",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposRemoveStatusCheckProtectionParams
			Response = *ReposRemoveStatusCheckProtectionNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveStatusCheckProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.ReposRemoveStatusCheckProtection(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.ReposRemoveStatusCheckProtection(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveStatusCheckProtectionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposRemoveTeamAccessRestrictionsRequest handles repos/remove-team-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Removes the ability of a team to push to this branch. You can also remove push access for child
// teams.
// | Type    | Description
//
//	|
//
// | ------- |
// --------------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | Teams that should no longer have push access. Use the team's `slug`. **Note**: The
// list of users, apps, and teams in total is limited to 100 items. |.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) handleReposRemoveTeamAccessRestrictionsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-team-access-restrictions"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposRemoveTeamAccessRestrictionsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposRemoveTeamAccessRestrictionsOperation,
			ID:   "repos/remove-team-access-restrictions",
		}
	)
	params, err := decodeReposRemoveTeamAccessRestrictionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposRemoveTeamAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposRemoveTeamAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposRemoveTeamAccessRestrictionsOperation,
			OperationSummary: "Remove team access restrictions",
			OperationID:      "repos/remove-team-access-restrictions",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposRemoveTeamAccessRestrictionsReq
			Params   = ReposRemoveTeamAccessRestrictionsParams
			Response = ReposRemoveTeamAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveTeamAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposRemoveTeamAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposRemoveTeamAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveTeamAccessRestrictionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposRemoveUserAccessRestrictionsRequest handles repos/remove-user-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Removes the ability of a user to push to this branch.
// | Type    | Description
//
//	|
//
// | ------- |
// --------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | Usernames of the people who should no longer have push access. **Note**: The list of
// users, apps, and teams in total is limited to 100 items. |.
//
// DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) handleReposRemoveUserAccessRestrictionsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/remove-user-access-restrictions"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposRemoveUserAccessRestrictionsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposRemoveUserAccessRestrictionsOperation,
			ID:   "repos/remove-user-access-restrictions",
		}
	)
	params, err := decodeReposRemoveUserAccessRestrictionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposRemoveUserAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposRemoveUserAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposRemoveUserAccessRestrictionsOperation,
			OperationSummary: "Remove user access restrictions",
			OperationID:      "repos/remove-user-access-restrictions",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposRemoveUserAccessRestrictionsReq
			Params   = ReposRemoveUserAccessRestrictionsParams
			Response = ReposRemoveUserAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRemoveUserAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposRemoveUserAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposRemoveUserAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRemoveUserAccessRestrictionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposRenameBranchRequest handles repos/rename-branch operation.
//
// Renames a branch in a repository.
// **Note:** Although the API responds immediately, the branch rename process might take some extra
// time to complete in the background. You won't be able to push to the old branch name while the
// rename process is in progress. For more information, see "[Renaming a branch](https://docs.github.
// com/github/administering-a-repository/renaming-a-branch)".
// The permissions required to use this endpoint depends on whether you are renaming the default
// branch.
// To rename a non-default branch:
// * Users must have push access.
// * GitHub Apps must have the `contents:write` repository permission.
// To rename the default branch:
// * Users must have admin or owner permissions.
// * GitHub Apps must have the `administration:write` repository permission.
//
// POST /repos/{owner}/{repo}/branches/{branch}/rename
func (s *Server) handleReposRenameBranchRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/rename-branch"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/rename"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposRenameBranchOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposRenameBranchOperation,
			ID:   "repos/rename-branch",
		}
	)
	params, err := decodeReposRenameBranchParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposRenameBranchRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposRenameBranchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposRenameBranchOperation,
			OperationSummary: "Rename a branch",
			OperationID:      "repos/rename-branch",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposRenameBranchReq
			Params   = ReposRenameBranchParams
			Response = ReposRenameBranchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRenameBranchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposRenameBranch(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposRenameBranch(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRenameBranchResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposReplaceAllTopicsRequest handles repos/replace-all-topics operation.
//
// Replace all repository topics.
//
// PUT /repos/{owner}/{repo}/topics
func (s *Server) handleReposReplaceAllTopicsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/replace-all-topics"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/topics"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposReplaceAllTopicsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposReplaceAllTopicsOperation,
			ID:   "repos/replace-all-topics",
		}
	)
	params, err := decodeReposReplaceAllTopicsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposReplaceAllTopicsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposReplaceAllTopicsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposReplaceAllTopicsOperation,
			OperationSummary: "Replace all repository topics",
			OperationID:      "repos/replace-all-topics",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposReplaceAllTopicsReq
			Params   = ReposReplaceAllTopicsParams
			Response = ReposReplaceAllTopicsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposReplaceAllTopicsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposReplaceAllTopics(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposReplaceAllTopics(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposReplaceAllTopicsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposRequestPagesBuildRequest handles repos/request-pages-build operation.
//
// You can request that your site be built from the latest revision on the default branch. This has
// the same effect as pushing a commit to your default branch, but does not require an additional
// commit. Manually triggering page builds can be helpful when diagnosing build warnings and failures.
// Build requests are limited to one concurrent build per repository and one concurrent build per
// requester. If you request a build while another is still in progress, the second request will be
// queued until the first completes.
//
// POST /repos/{owner}/{repo}/pages/builds
func (s *Server) handleReposRequestPagesBuildRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/request-pages-build"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/pages/builds"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposRequestPagesBuildOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposRequestPagesBuildOperation,
			ID:   "repos/request-pages-build",
		}
	)
	params, err := decodeReposRequestPagesBuildParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *PageBuildStatus
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposRequestPagesBuildOperation,
			OperationSummary: "Request a GitHub Pages build",
			OperationID:      "repos/request-pages-build",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposRequestPagesBuildParams
			Response = *PageBuildStatus
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposRequestPagesBuildParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposRequestPagesBuild(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposRequestPagesBuild(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposRequestPagesBuildResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposSetAdminBranchProtectionRequest handles repos/set-admin-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Adding admin enforcement requires admin or owner permissions to the repository and branch
// protection to be enabled.
//
// POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins
func (s *Server) handleReposSetAdminBranchProtectionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-admin-branch-protection"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposSetAdminBranchProtectionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposSetAdminBranchProtectionOperation,
			ID:   "repos/set-admin-branch-protection",
		}
	)
	params, err := decodeReposSetAdminBranchProtectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *ProtectedBranchAdminEnforced
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposSetAdminBranchProtectionOperation,
			OperationSummary: "Set admin branch protection",
			OperationID:      "repos/set-admin-branch-protection",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposSetAdminBranchProtectionParams
			Response = *ProtectedBranchAdminEnforced
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposSetAdminBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposSetAdminBranchProtection(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposSetAdminBranchProtection(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposSetAdminBranchProtectionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposSetAppAccessRestrictionsRequest handles repos/set-app-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Replaces the list of apps that have push access to this branch. This removes all apps that
// previously had push access and grants push access to the new list of apps. Only installed GitHub
// Apps with `write` access to the `contents` permission can be added as authorized actors on a
// protected branch.
// | Type    | Description
//
//	|
//
// | ------- |
// ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
// | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**:
// The list of users, apps, and teams in total is limited to 100 items. |.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps
func (s *Server) handleReposSetAppAccessRestrictionsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-app-access-restrictions"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposSetAppAccessRestrictionsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposSetAppAccessRestrictionsOperation,
			ID:   "repos/set-app-access-restrictions",
		}
	)
	params, err := decodeReposSetAppAccessRestrictionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposSetAppAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposSetAppAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposSetAppAccessRestrictionsOperation,
			OperationSummary: "Set app access restrictions",
			OperationID:      "repos/set-app-access-restrictions",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposSetAppAccessRestrictionsReq
			Params   = ReposSetAppAccessRestrictionsParams
			Response = ReposSetAppAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposSetAppAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposSetAppAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposSetAppAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposSetAppAccessRestrictionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposSetStatusCheckContextsRequest handles repos/set-status-check-contexts operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts
func (s *Server) handleReposSetStatusCheckContextsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-status-check-contexts"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposSetStatusCheckContextsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposSetStatusCheckContextsOperation,
			ID:   "repos/set-status-check-contexts",
		}
	)
	params, err := decodeReposSetStatusCheckContextsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposSetStatusCheckContextsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposSetStatusCheckContextsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposSetStatusCheckContextsOperation,
			OperationSummary: "Set status check contexts",
			OperationID:      "repos/set-status-check-contexts",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposSetStatusCheckContextsReq
			Params   = ReposSetStatusCheckContextsParams
			Response = ReposSetStatusCheckContextsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposSetStatusCheckContextsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposSetStatusCheckContexts(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposSetStatusCheckContexts(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposSetStatusCheckContextsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposSetTeamAccessRestrictionsRequest handles repos/set-team-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Replaces the list of teams that have push access to this branch. This removes all teams that
// previously had push access and grants push access to the new list of teams. Team restrictions
// include child teams.
// | Type    | Description
//
//	|
//
// | ------- |
// ------------------------------------------------------------------------------------------------------------------------------------------ |
// | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list of
// users, apps, and teams in total is limited to 100 items. |.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams
func (s *Server) handleReposSetTeamAccessRestrictionsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-team-access-restrictions"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposSetTeamAccessRestrictionsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposSetTeamAccessRestrictionsOperation,
			ID:   "repos/set-team-access-restrictions",
		}
	)
	params, err := decodeReposSetTeamAccessRestrictionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposSetTeamAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposSetTeamAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposSetTeamAccessRestrictionsOperation,
			OperationSummary: "Set team access restrictions",
			OperationID:      "repos/set-team-access-restrictions",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposSetTeamAccessRestrictionsReq
			Params   = ReposSetTeamAccessRestrictionsParams
			Response = ReposSetTeamAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposSetTeamAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposSetTeamAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposSetTeamAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposSetTeamAccessRestrictionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposSetUserAccessRestrictionsRequest handles repos/set-user-access-restrictions operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Replaces the list of people that have push access to this branch. This removes all people that
// previously had push access and grants push access to the new list of people.
// | Type    | Description
//
//	|
//
// | ------- |
// ----------------------------------------------------------------------------------------------------------------------------- |
// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and
// teams in total is limited to 100 items. |.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users
func (s *Server) handleReposSetUserAccessRestrictionsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/set-user-access-restrictions"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposSetUserAccessRestrictionsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposSetUserAccessRestrictionsOperation,
			ID:   "repos/set-user-access-restrictions",
		}
	)
	params, err := decodeReposSetUserAccessRestrictionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposSetUserAccessRestrictionsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposSetUserAccessRestrictionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposSetUserAccessRestrictionsOperation,
			OperationSummary: "Set user access restrictions",
			OperationID:      "repos/set-user-access-restrictions",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposSetUserAccessRestrictionsReq
			Params   = ReposSetUserAccessRestrictionsParams
			Response = ReposSetUserAccessRestrictionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposSetUserAccessRestrictionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposSetUserAccessRestrictions(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposSetUserAccessRestrictions(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposSetUserAccessRestrictionsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposTestPushWebhookRequest handles repos/test-push-webhook operation.
//
// This will trigger the hook with the latest push to the current repository if the hook is
// subscribed to `push` events. If the hook is not subscribed to `push` events, the server will
// respond with 204 but no test POST will be generated.
// **Note**: Previously `/repos/:owner/:repo/hooks/:hook_id/test`.
//
// POST /repos/{owner}/{repo}/hooks/{hook_id}/tests
func (s *Server) handleReposTestPushWebhookRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/test-push-webhook"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}/tests"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposTestPushWebhookOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposTestPushWebhookOperation,
			ID:   "repos/test-push-webhook",
		}
	)
	params, err := decodeReposTestPushWebhookParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ReposTestPushWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposTestPushWebhookOperation,
			OperationSummary: "Test the push repository webhook",
			OperationID:      "repos/test-push-webhook",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ReposTestPushWebhookParams
			Response = ReposTestPushWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposTestPushWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposTestPushWebhook(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposTestPushWebhook(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposTestPushWebhookResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposTransferRequest handles repos/transfer operation.
//
// A transfer request will need to be accepted by the new owner when transferring a personal
// repository to another user. The response will contain the original `owner`, and the transfer will
// continue asynchronously. For more details on the requirements to transfer personal and
// organization-owned repositories, see [about repository transfers](https://help.github.
// com/articles/about-repository-transfers/).
//
// POST /repos/{owner}/{repo}/transfer
func (s *Server) handleReposTransferRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/transfer"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/transfer"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposTransferOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposTransferOperation,
			ID:   "repos/transfer",
		}
	)
	params, err := decodeReposTransferParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposTransferRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *MinimalRepository
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposTransferOperation,
			OperationSummary: "Transfer a repository",
			OperationID:      "repos/transfer",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = *ReposTransferReq
			Params   = ReposTransferParams
			Response = *MinimalRepository
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposTransferParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposTransfer(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposTransfer(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposTransferResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposUpdateRequest handles repos/update operation.
//
// **Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.
// github.com/rest/reference/repos#replace-all-repository-topics) endpoint.
//
// PATCH /repos/{owner}/{repo}
func (s *Server) handleReposUpdateRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposUpdateOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposUpdateOperation,
			ID:   "repos/update",
		}
	)
	params, err := decodeReposUpdateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposUpdateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposUpdateOperation,
			OperationSummary: "Update a repository",
			OperationID:      "repos/update",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateReq
			Params   = ReposUpdateParams
			Response = ReposUpdateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdate(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposUpdateBranchProtectionRequest handles repos/update-branch-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Protecting a branch requires admin or owner permissions to the repository.
// **Note**: Passing new arrays of `users` and `teams` replaces their previous values.
// **Note**: The list of users, apps, and teams in total is limited to 100 items.
//
// PUT /repos/{owner}/{repo}/branches/{branch}/protection
func (s *Server) handleReposUpdateBranchProtectionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-branch-protection"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposUpdateBranchProtectionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposUpdateBranchProtectionOperation,
			ID:   "repos/update-branch-protection",
		}
	)
	params, err := decodeReposUpdateBranchProtectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposUpdateBranchProtectionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateBranchProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposUpdateBranchProtectionOperation,
			OperationSummary: "Update branch protection",
			OperationID:      "repos/update-branch-protection",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = *ReposUpdateBranchProtectionReq
			Params   = ReposUpdateBranchProtectionParams
			Response = ReposUpdateBranchProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateBranchProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdateBranchProtection(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdateBranchProtection(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateBranchProtectionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposUpdateCommitCommentRequest handles repos/update-commit-comment operation.
//
// Update a commit comment.
//
// PATCH /repos/{owner}/{repo}/comments/{comment_id}
func (s *Server) handleReposUpdateCommitCommentRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-commit-comment"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/comments/{comment_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposUpdateCommitCommentOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposUpdateCommitCommentOperation,
			ID:   "repos/update-commit-comment",
		}
	)
	params, err := decodeReposUpdateCommitCommentParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposUpdateCommitCommentRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateCommitCommentRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposUpdateCommitCommentOperation,
			OperationSummary: "Update a commit comment",
			OperationID:      "repos/update-commit-comment",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "comment_id",
					In:   "path",
				}: params.CommentID,
			},
			Raw: r,
		}

		type (
			Request  = *ReposUpdateCommitCommentReq
			Params   = ReposUpdateCommitCommentParams
			Response = ReposUpdateCommitCommentRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateCommitCommentParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdateCommitComment(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdateCommitComment(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateCommitCommentResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposUpdateInvitationRequest handles repos/update-invitation operation.
//
// Update a repository invitation.
//
// PATCH /repos/{owner}/{repo}/invitations/{invitation_id}
func (s *Server) handleReposUpdateInvitationRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-invitation"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/invitations/{invitation_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposUpdateInvitationOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposUpdateInvitationOperation,
			ID:   "repos/update-invitation",
		}
	)
	params, err := decodeReposUpdateInvitationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposUpdateInvitationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *RepositoryInvitation
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposUpdateInvitationOperation,
			OperationSummary: "Update a repository invitation",
			OperationID:      "repos/update-invitation",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "invitation_id",
					In:   "path",
				}: params.InvitationID,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateInvitationReq
			Params   = ReposUpdateInvitationParams
			Response = *RepositoryInvitation
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateInvitationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdateInvitation(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdateInvitation(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateInvitationResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposUpdatePullRequestReviewProtectionRequest handles repos/update-pull-request-review-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Updating pull request review enforcement requires admin or owner permissions to the repository and
// branch protection to be enabled.
// **Note**: Passing new arrays of `users` and `teams` replaces their previous values.
//
// PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews
func (s *Server) handleReposUpdatePullRequestReviewProtectionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-pull-request-review-protection"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposUpdatePullRequestReviewProtectionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposUpdatePullRequestReviewProtectionOperation,
			ID:   "repos/update-pull-request-review-protection",
		}
	)
	params, err := decodeReposUpdatePullRequestReviewProtectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposUpdatePullRequestReviewProtectionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdatePullRequestReviewProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposUpdatePullRequestReviewProtectionOperation,
			OperationSummary: "Update pull request review protection",
			OperationID:      "repos/update-pull-request-review-protection",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdatePullRequestReviewProtectionReq
			Params   = ReposUpdatePullRequestReviewProtectionParams
			Response = ReposUpdatePullRequestReviewProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdatePullRequestReviewProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdatePullRequestReviewProtection(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdatePullRequestReviewProtection(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdatePullRequestReviewProtectionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposUpdateReleaseRequest handles repos/update-release operation.
//
// Users with push access to the repository can edit a release.
//
// PATCH /repos/{owner}/{repo}/releases/{release_id}
func (s *Server) handleReposUpdateReleaseRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-release"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/{release_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposUpdateReleaseOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposUpdateReleaseOperation,
			ID:   "repos/update-release",
		}
	)
	params, err := decodeReposUpdateReleaseParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposUpdateReleaseRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateReleaseRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposUpdateReleaseOperation,
			OperationSummary: "Update a release",
			OperationID:      "repos/update-release",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "release_id",
					In:   "path",
				}: params.ReleaseID,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateReleaseReq
			Params   = ReposUpdateReleaseParams
			Response = ReposUpdateReleaseRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateReleaseParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdateRelease(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdateRelease(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateReleaseResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposUpdateReleaseAssetRequest handles repos/update-release-asset operation.
//
// Users with push access to the repository can edit a release asset.
//
// PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}
func (s *Server) handleReposUpdateReleaseAssetRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-release-asset"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/assets/{asset_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposUpdateReleaseAssetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposUpdateReleaseAssetOperation,
			ID:   "repos/update-release-asset",
		}
	)
	params, err := decodeReposUpdateReleaseAssetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposUpdateReleaseAssetRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ReleaseAsset
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposUpdateReleaseAssetOperation,
			OperationSummary: "Update a release asset",
			OperationID:      "repos/update-release-asset",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "asset_id",
					In:   "path",
				}: params.AssetID,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateReleaseAssetReq
			Params   = ReposUpdateReleaseAssetParams
			Response = *ReleaseAsset
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateReleaseAssetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdateReleaseAsset(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdateReleaseAsset(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateReleaseAssetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposUpdateStatusCheckProtectionRequest handles repos/update-status-check-protection operation.
//
// Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
// Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
// products](https://help.github.com/github/getting-started-with-github/githubs-products) in the
// GitHub Help documentation.
// Updating required status checks requires admin or owner permissions to the repository and branch
// protection to be enabled.
//
// PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks
func (s *Server) handleReposUpdateStatusCheckProtectionRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-status-check-protection"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposUpdateStatusCheckProtectionOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposUpdateStatusCheckProtectionOperation,
			ID:   "repos/update-status-check-protection",
		}
	)
	params, err := decodeReposUpdateStatusCheckProtectionParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposUpdateStatusCheckProtectionRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateStatusCheckProtectionRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposUpdateStatusCheckProtectionOperation,
			OperationSummary: "Update status check protection",
			OperationID:      "repos/update-status-check-protection",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "branch",
					In:   "path",
				}: params.Branch,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateStatusCheckProtectionReq
			Params   = ReposUpdateStatusCheckProtectionParams
			Response = ReposUpdateStatusCheckProtectionRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateStatusCheckProtectionParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdateStatusCheckProtection(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdateStatusCheckProtection(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateStatusCheckProtectionResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposUpdateWebhookRequest handles repos/update-webhook operation.
//
// Updates a webhook configured in a repository. If you previously had a `secret` set, you must
// provide the same `secret` or set a new `secret` or the secret will be removed. If you are only
// updating individual webhook `config` properties, use "[Update a webhook configuration for a
// repository](/rest/reference/repos#update-a-webhook-configuration-for-a-repository).".
//
// PATCH /repos/{owner}/{repo}/hooks/{hook_id}
func (s *Server) handleReposUpdateWebhookRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-webhook"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposUpdateWebhookOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposUpdateWebhookOperation,
			ID:   "repos/update-webhook",
		}
	)
	params, err := decodeReposUpdateWebhookParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposUpdateWebhookRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ReposUpdateWebhookRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposUpdateWebhookOperation,
			OperationSummary: "Update a repository webhook",
			OperationID:      "repos/update-webhook",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateWebhookReq
			Params   = ReposUpdateWebhookParams
			Response = ReposUpdateWebhookRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateWebhookParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdateWebhook(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdateWebhook(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateWebhookResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposUpdateWebhookConfigForRepoRequest handles repos/update-webhook-config-for-repo operation.
//
// Updates the webhook configuration for a repository. To update more information about the webhook,
// including the `active` state and `events`, use "[Update a repository
// webhook](/rest/reference/orgs#update-a-repository-webhook)."
// Access tokens must have the `write:repo_hook` or `repo` scope, and GitHub Apps must have the
// `repository_hooks:write` permission.
//
// PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config
func (s *Server) handleReposUpdateWebhookConfigForRepoRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/update-webhook-config-for-repo"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/hooks/{hook_id}/config"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposUpdateWebhookConfigForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposUpdateWebhookConfigForRepoOperation,
			ID:   "repos/update-webhook-config-for-repo",
		}
	)
	params, err := decodeReposUpdateWebhookConfigForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposUpdateWebhookConfigForRepoRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *WebhookConfig
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposUpdateWebhookConfigForRepoOperation,
			OperationSummary: "Update a webhook configuration for a repository",
			OperationID:      "repos/update-webhook-config-for-repo",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "hook_id",
					In:   "path",
				}: params.HookID,
			},
			Raw: r,
		}

		type (
			Request  = OptReposUpdateWebhookConfigForRepoReq
			Params   = ReposUpdateWebhookConfigForRepoParams
			Response = *WebhookConfig
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUpdateWebhookConfigForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUpdateWebhookConfigForRepo(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUpdateWebhookConfigForRepo(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUpdateWebhookConfigForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleReposUploadReleaseAssetRequest handles repos/upload-release-asset operation.
//
// This endpoint makes use of [a Hypermedia relation](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#hypermedia) to determine which URL to access. The
// endpoint you call to upload release assets is specific to your release. Use the `upload_url`
// returned in
// the response of the [Create a release endpoint](https://docs.github.
// com/rest/reference/repos#create-a-release) to upload a release asset.
// You need to use an HTTP client which supports [SNI](http://en.wikipedia.
// org/wiki/Server_Name_Indication) to make calls to this endpoint.
// Most libraries will set the required `Content-Length` header automatically. Use the required
// `Content-Type` header to provide the media type of the asset. For a list of media types, see
// [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example:
// `application/zip`
// GitHub expects the asset data in its raw binary form, rather than JSON. You will send the raw
// binary content of the asset as the request body. Everything else about the endpoint is the same as
// the rest of the API. For example,
// you'll still need to pass your authentication to be able to upload an asset.
// When an upstream failure occurs, you will receive a `502 Bad Gateway` status. This may leave an
// empty asset with a state of `starter`. It can be safely deleted.
// **Notes:**
// *   GitHub renames asset filenames that have special characters, non-alphanumeric characters, and
// leading or trailing periods. The "[List assets for a release](https://docs.github.
// com/rest/reference/repos#list-assets-for-a-release)"
// endpoint lists the renamed filenames. For more information and help, contact [GitHub
// Support](https://support.github.com/contact?tags=dotcom-rest-api).
// *   If you upload an asset with the same filename as another uploaded asset, you'll receive an
// error and must delete the old file before you can re-upload the new asset.
//
// POST /repos/{owner}/{repo}/releases/{release_id}/assets
func (s *Server) handleReposUploadReleaseAssetRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repos/upload-release-asset"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/releases/{release_id}/assets"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ReposUploadReleaseAssetOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ReposUploadReleaseAssetOperation,
			ID:   "repos/upload-release-asset",
		}
	)
	params, err := decodeReposUploadReleaseAssetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeReposUploadReleaseAssetRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *ReleaseAsset
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ReposUploadReleaseAssetOperation,
			OperationSummary: "Upload a release asset",
			OperationID:      "repos/upload-release-asset",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "release_id",
					In:   "path",
				}: params.ReleaseID,
				{
					Name: "name",
					In:   "query",
				}: params.Name,
				{
					Name: "label",
					In:   "query",
				}: params.Label,
			},
			Raw: r,
		}

		type (
			Request  = *ReposUploadReleaseAssetReqWithContentType
			Params   = ReposUploadReleaseAssetParams
			Response = *ReleaseAsset
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackReposUploadReleaseAssetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ReposUploadReleaseAsset(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ReposUploadReleaseAsset(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeReposUploadReleaseAssetResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleScimDeleteUserFromOrgRequest handles scim/delete-user-from-org operation.
//
// Delete a SCIM user from an organization.
//
// DELETE /scim/v2/organizations/{org}/Users/{scim_user_id}
func (s *Server) handleScimDeleteUserFromOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("scim/delete-user-from-org"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/scim/v2/organizations/{org}/Users/{scim_user_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), ScimDeleteUserFromOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ScimDeleteUserFromOrgOperation,
			ID:   "scim/delete-user-from-org",
		}
	)
	params, err := decodeScimDeleteUserFromOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ScimDeleteUserFromOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ScimDeleteUserFromOrgOperation,
			OperationSummary: "Delete a SCIM user from an organization",
			OperationID:      "scim/delete-user-from-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "scim_user_id",
					In:   "path",
				}: params.ScimUserID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ScimDeleteUserFromOrgParams
			Response = ScimDeleteUserFromOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackScimDeleteUserFromOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ScimDeleteUserFromOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ScimDeleteUserFromOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeScimDeleteUserFromOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSearchCodeRequest handles search/code operation.
//
// Searches for query terms inside of a file. This method returns up to 100 results [per
// page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for code, you can get text match metadata for the file **content** and file
// **path** fields when you pass the `text-match` media type. For more details about how to receive
// highlighted search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you want to find the definition of the `addClass` function inside
// [jQuery](https://github.com/jquery/jquery) repository, your query would look something like this:
// `q=addClass+in:file+language:js+repo:jquery/jquery`
// This query searches for the keyword `addClass` within a file's contents. The query limits the
// search to files where the language is JavaScript in the `jquery/jquery` repository.
// #### Considerations for code search
// Due to the complexity of searching code, there are a few restrictions on how searches are
// performed:
// *   Only the _default branch_ is considered. In most cases, this will be the `master` branch.
// *   Only files smaller than 384 KB are searchable.
// *   You must always include at least one search term when searching source code. For example,
// searching for [`language:go`](https://github.com/search?utf8=%E2%9C%93&q=language%3Ago&type=Code)
// is not valid, while [`amazing
// language:go`](https://github.com/search?utf8=%E2%9C%93&q=amazing+language%3Ago&type=Code) is.
//
// GET /search/code
func (s *Server) handleSearchCodeRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/code"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/search/code"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), SearchCodeOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: SearchCodeOperation,
			ID:   "search/code",
		}
	)
	params, err := decodeSearchCodeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response SearchCodeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    SearchCodeOperation,
			OperationSummary: "Search code",
			OperationID:      "search/code",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "q",
					In:   "query",
				}: params.Q,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "order",
					In:   "query",
				}: params.Order,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchCodeParams
			Response = SearchCodeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchCodeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchCode(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchCode(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchCodeResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSearchCommitsRequest handles search/commits operation.
//
// Find commits via various criteria on the default branch (usually `master`). This method returns up
// to 100 results [per page](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for commits, you can get text match metadata for the **message** field when you
// provide the `text-match` media type. For more details about how to receive highlighted search
// results, see [Text match
// metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
// For example, if you want to find commits related to CSS in the
// [octocat/Spoon-Knife](https://github.com/octocat/Spoon-Knife) repository. Your query would look
// something like this:
// `q=repo:octocat/Spoon-Knife+css`.
//
// GET /search/commits
func (s *Server) handleSearchCommitsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/commits"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/search/commits"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), SearchCommitsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: SearchCommitsOperation,
			ID:   "search/commits",
		}
	)
	params, err := decodeSearchCommitsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response SearchCommitsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    SearchCommitsOperation,
			OperationSummary: "Search commits",
			OperationID:      "search/commits",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "q",
					In:   "query",
				}: params.Q,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "order",
					In:   "query",
				}: params.Order,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchCommitsParams
			Response = SearchCommitsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchCommitsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchCommits(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchCommits(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchCommitsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSearchIssuesAndPullRequestsRequest handles search/issues-and-pull-requests operation.
//
// Find issues by state and keyword. This method returns up to 100 results [per page](https://docs.
// github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for issues, you can get text match metadata for the issue **title**, issue **body**,
//
//	and issue **comment body** fields when you pass the `text-match` media type. For more details
//
// about how to receive highlighted
// search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you want to find the oldest unresolved Python bugs on Windows. Your query might
// look something like this.
// `q=windows+label:bug+language:python+state:open&sort=created&order=asc`
// This query searches for the keyword `windows`, within any open issue that is labeled as `bug`. The
// search runs across repositories whose primary language is Python. The results are sorted by
// creation date in ascending order, which means the oldest issues appear first in the search results.
// **Note:** For [user-to-server](https://docs.github.
// com/developers/apps/identifying-and-authorizing-users-for-github-apps#user-to-server-requests)
// GitHub App requests, you can't retrieve a combination of issues and pull requests in a single
// query. Requests that don't include the `is:issue` or `is:pull-request` qualifier will receive an
// HTTP `422 Unprocessable Entity` response. To get results for both issues and pull requests, you
// must send separate queries for issues and pull requests. For more information about the `is`
// qualifier, see "[Searching only issues or pull requests](https://docs.github.
// com/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-only-issues-or-pull-requests).".
//
// GET /search/issues
func (s *Server) handleSearchIssuesAndPullRequestsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/issues-and-pull-requests"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/search/issues"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), SearchIssuesAndPullRequestsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: SearchIssuesAndPullRequestsOperation,
			ID:   "search/issues-and-pull-requests",
		}
	)
	params, err := decodeSearchIssuesAndPullRequestsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response SearchIssuesAndPullRequestsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    SearchIssuesAndPullRequestsOperation,
			OperationSummary: "Search issues and pull requests",
			OperationID:      "search/issues-and-pull-requests",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "q",
					In:   "query",
				}: params.Q,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "order",
					In:   "query",
				}: params.Order,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchIssuesAndPullRequestsParams
			Response = SearchIssuesAndPullRequestsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchIssuesAndPullRequestsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchIssuesAndPullRequests(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchIssuesAndPullRequests(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchIssuesAndPullRequestsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSearchLabelsRequest handles search/labels operation.
//
// Find labels in a repository with names or descriptions that match search keywords. Returns up to
// 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for labels, you can get text match metadata for the label **name** and
// **description** fields when you pass the `text-match` media type. For more details about how to
// receive highlighted search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you want to find labels in the `linguist` repository that match `bug`, `defect`,
// or `enhancement`. Your query might look like this:
// `q=bug+defect+enhancement&repository_id=64778136`
// The labels that best match the query appear first in the search results.
//
// GET /search/labels
func (s *Server) handleSearchLabelsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/labels"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/search/labels"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), SearchLabelsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: SearchLabelsOperation,
			ID:   "search/labels",
		}
	)
	params, err := decodeSearchLabelsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response SearchLabelsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    SearchLabelsOperation,
			OperationSummary: "Search labels",
			OperationID:      "search/labels",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "repository_id",
					In:   "query",
				}: params.RepositoryID,
				{
					Name: "q",
					In:   "query",
				}: params.Q,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "order",
					In:   "query",
				}: params.Order,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchLabelsParams
			Response = SearchLabelsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchLabelsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchLabels(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchLabels(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchLabelsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSearchReposRequest handles search/repos operation.
//
// Find repositories via various criteria. This method returns up to 100 results [per
// page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for repositories, you can get text match metadata for the **name** and
// **description** fields when you pass the `text-match` media type. For more details about how to
// receive highlighted search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you want to search for popular Tetris repositories written in assembly code, your
// query might look like this:
// `q=tetris+language:assembly&sort=stars&order=desc`
// This query searches for repositories with the word `tetris` in the name, the description, or the
// README. The results are limited to repositories where the primary language is assembly. The
// results are sorted by stars in descending order, so that the most popular repositories appear
// first in the search results.
// When you include the `mercy` preview header, you can also search for multiple topics by adding
// more `topic:` instances. For example, your query might look like this:
// `q=topic:ruby+topic:rails`.
//
// GET /search/repositories
func (s *Server) handleSearchReposRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/repos"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/search/repositories"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), SearchReposOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: SearchReposOperation,
			ID:   "search/repos",
		}
	)
	params, err := decodeSearchReposParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response SearchReposRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    SearchReposOperation,
			OperationSummary: "Search repositories",
			OperationID:      "search/repos",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "q",
					In:   "query",
				}: params.Q,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "order",
					In:   "query",
				}: params.Order,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchReposParams
			Response = SearchReposRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchReposParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchRepos(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchRepos(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchReposResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSearchTopicsRequest handles search/topics operation.
//
// Find topics via various criteria. Results are sorted by best match. This method returns up to 100
// results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
// See "[Searching topics](https://help.github.com/articles/searching-topics/)" for a detailed list
// of qualifiers.
// When searching for topics, you can get text match metadata for the topic's **short\_description**,
// **description**, **name**, or **display\_name** field when you pass the `text-match` media type.
// For more details about how to receive highlighted search results, see [Text match
// metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
// For example, if you want to search for topics related to Ruby that are featured on https://github.
// com/topics. Your query might look like this:
// `q=ruby+is:featured`
// This query searches for topics with the keyword `ruby` and limits the results to find only topics
// that are featured. The topics that are the best match for the query appear first in the search
// results.
//
// GET /search/topics
func (s *Server) handleSearchTopicsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/topics"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/search/topics"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), SearchTopicsOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: SearchTopicsOperation,
			ID:   "search/topics",
		}
	)
	params, err := decodeSearchTopicsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response SearchTopicsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    SearchTopicsOperation,
			OperationSummary: "Search topics",
			OperationID:      "search/topics",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "q",
					In:   "query",
				}: params.Q,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchTopicsParams
			Response = SearchTopicsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchTopicsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchTopics(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchTopics(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchTopicsResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSearchUsersRequest handles search/users operation.
//
// Find users via various criteria. This method returns up to 100 results [per page](https://docs.
// github.com/rest/overview/resources-in-the-rest-api#pagination).
// When searching for users, you can get text match metadata for the issue **login**, **email**, and
// **name** fields when you pass the `text-match` media type. For more details about highlighting
// search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata). For more details about how to receive highlighted
// search results, see [Text match metadata](https://docs.github.
// com/rest/reference/search#text-match-metadata).
// For example, if you're looking for a list of popular users, you might try this query:
// `q=tom+repos:%3E42+followers:%3E1000`
// This query searches for users with the name `tom`. The results are restricted to users with more
// than 42 repositories and over 1,000 followers.
//
// GET /search/users
func (s *Server) handleSearchUsersRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search/users"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/search/users"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), SearchUsersOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: SearchUsersOperation,
			ID:   "search/users",
		}
	)
	params, err := decodeSearchUsersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response SearchUsersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    SearchUsersOperation,
			OperationSummary: "Search users",
			OperationID:      "search/users",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "q",
					In:   "query",
				}: params.Q,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
				{
					Name: "order",
					In:   "query",
				}: params.Order,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SearchUsersParams
			Response = SearchUsersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSearchUsersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SearchUsers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SearchUsers(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSearchUsersResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSecretScanningGetAlertRequest handles secret-scanning/get-alert operation.
//
// Gets a single secret scanning alert detected in a private repository. To use this endpoint, you
// must be an administrator for the repository or organization, and you must use an access token with
// the `repo` scope or `security_events` scope.
// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
func (s *Server) handleSecretScanningGetAlertRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/get-alert"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), SecretScanningGetAlertOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: SecretScanningGetAlertOperation,
			ID:   "secret-scanning/get-alert",
		}
	)
	params, err := decodeSecretScanningGetAlertParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response SecretScanningGetAlertRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    SecretScanningGetAlertOperation,
			OperationSummary: "Get a secret scanning alert",
			OperationID:      "secret-scanning/get-alert",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "alert_number",
					In:   "path",
				}: params.AlertNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SecretScanningGetAlertParams
			Response = SecretScanningGetAlertRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSecretScanningGetAlertParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SecretScanningGetAlert(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SecretScanningGetAlert(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSecretScanningGetAlertResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSecretScanningListAlertsForOrgRequest handles secret-scanning/list-alerts-for-org operation.
//
// Lists all secret scanning alerts for all eligible repositories in an organization, from newest to
// oldest.
// To use this endpoint, you must be an administrator for the repository or organization, and you
// must use an access token with the `repo` scope or `security_events` scope.
// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
//
// GET /orgs/{org}/secret-scanning/alerts
func (s *Server) handleSecretScanningListAlertsForOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/list-alerts-for-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/secret-scanning/alerts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), SecretScanningListAlertsForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: SecretScanningListAlertsForOrgOperation,
			ID:   "secret-scanning/list-alerts-for-org",
		}
	)
	params, err := decodeSecretScanningListAlertsForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response SecretScanningListAlertsForOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    SecretScanningListAlertsForOrgOperation,
			OperationSummary: "List secret scanning alerts by organization",
			OperationID:      "secret-scanning/list-alerts-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "secret_type",
					In:   "query",
				}: params.SecretType,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SecretScanningListAlertsForOrgParams
			Response = SecretScanningListAlertsForOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSecretScanningListAlertsForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SecretScanningListAlertsForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SecretScanningListAlertsForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSecretScanningListAlertsForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSecretScanningListAlertsForRepoRequest handles secret-scanning/list-alerts-for-repo operation.
//
// Lists all secret scanning alerts for a private repository, from newest to oldest. To use this
// endpoint, you must be an administrator for the repository or organization, and you must use an
// access token with the `repo` scope or `security_events` scope.
// GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
//
// GET /repos/{owner}/{repo}/secret-scanning/alerts
func (s *Server) handleSecretScanningListAlertsForRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/list-alerts-for-repo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/secret-scanning/alerts"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), SecretScanningListAlertsForRepoOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: SecretScanningListAlertsForRepoOperation,
			ID:   "secret-scanning/list-alerts-for-repo",
		}
	)
	params, err := decodeSecretScanningListAlertsForRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response SecretScanningListAlertsForRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    SecretScanningListAlertsForRepoOperation,
			OperationSummary: "List secret scanning alerts for a repository",
			OperationID:      "secret-scanning/list-alerts-for-repo",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "state",
					In:   "query",
				}: params.State,
				{
					Name: "secret_type",
					In:   "query",
				}: params.SecretType,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = SecretScanningListAlertsForRepoParams
			Response = SecretScanningListAlertsForRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSecretScanningListAlertsForRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SecretScanningListAlertsForRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SecretScanningListAlertsForRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSecretScanningListAlertsForRepoResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSecretScanningUpdateAlertRequest handles secret-scanning/update-alert operation.
//
// Updates the status of a secret scanning alert in a private repository. To use this endpoint, you
// must be an administrator for the repository or organization, and you must use an access token with
// the `repo` scope or `security_events` scope.
// GitHub Apps must have the `secret_scanning_alerts` write permission to use this endpoint.
//
// PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}
func (s *Server) handleSecretScanningUpdateAlertRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("secret-scanning/update-alert"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), SecretScanningUpdateAlertOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: SecretScanningUpdateAlertOperation,
			ID:   "secret-scanning/update-alert",
		}
	)
	params, err := decodeSecretScanningUpdateAlertParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeSecretScanningUpdateAlertRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response SecretScanningUpdateAlertRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    SecretScanningUpdateAlertOperation,
			OperationSummary: "Update a secret scanning alert",
			OperationID:      "secret-scanning/update-alert",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
				{
					Name: "alert_number",
					In:   "path",
				}: params.AlertNumber,
			},
			Raw: r,
		}

		type (
			Request  = *SecretScanningUpdateAlertReq
			Params   = SecretScanningUpdateAlertParams
			Response = SecretScanningUpdateAlertRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSecretScanningUpdateAlertParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SecretScanningUpdateAlert(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SecretScanningUpdateAlert(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSecretScanningUpdateAlertResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsAddMemberLegacyRequest handles teams/add-member-legacy operation.
//
// The "Add team member" endpoint (described below) is deprecated.
// We recommend using the [Add or update team membership for a user](https://docs.github.
// com/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint instead. It allows you
// to invite new organization members to your teams.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// To add someone to a team, the authenticated user must be an organization owner or a team
// maintainer in the team they're changing. The person being added to the team must be a member of
// the team's organization.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /teams/{team_id}/members/{username}
func (s *Server) handleTeamsAddMemberLegacyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-member-legacy"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/members/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsAddMemberLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsAddMemberLegacyOperation,
			ID:   "teams/add-member-legacy",
		}
	)
	params, err := decodeTeamsAddMemberLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsAddMemberLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsAddMemberLegacyOperation,
			OperationSummary: "Add team member (Legacy)",
			OperationID:      "teams/add-member-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsAddMemberLegacyParams
			Response = TeamsAddMemberLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddMemberLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsAddMemberLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsAddMemberLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddMemberLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsAddOrUpdateMembershipForUserInOrgRequest handles teams/add-or-update-membership-for-user-in-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// Adds an organization member to a team. An authenticated organization owner or team maintainer can
// add organization members to a team.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
// An organization owner can add someone who is not part of the team's organization to a team. When
// an organization owner adds someone to a team who is not an organization member, this endpoint will
// send an invitation to the person via email. This newly-created membership will be in the "pending"
// state until the person accepts the invitation, at which point the membership will transition to
// the "active" state and the user will be added as a member of the team.
// If the user is already a member of the team, this endpoint will update the role of the team
// member's role. To update the membership of a team member, the authenticated user must be an
// organization owner or a team maintainer.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT
// /organizations/{org_id}/team/{team_id}/memberships/{username}`.
//
// PUT /orgs/{org}/teams/{team_slug}/memberships/{username}
func (s *Server) handleTeamsAddOrUpdateMembershipForUserInOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-membership-for-user-in-org"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/memberships/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsAddOrUpdateMembershipForUserInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsAddOrUpdateMembershipForUserInOrgOperation,
			ID:   "teams/add-or-update-membership-for-user-in-org",
		}
	)
	params, err := decodeTeamsAddOrUpdateMembershipForUserInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsAddOrUpdateMembershipForUserInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsAddOrUpdateMembershipForUserInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsAddOrUpdateMembershipForUserInOrgOperation,
			OperationSummary: "Add or update team membership for a user",
			OperationID:      "teams/add-or-update-membership-for-user-in-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsAddOrUpdateMembershipForUserInOrgReq
			Params   = TeamsAddOrUpdateMembershipForUserInOrgParams
			Response = TeamsAddOrUpdateMembershipForUserInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateMembershipForUserInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsAddOrUpdateMembershipForUserInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsAddOrUpdateMembershipForUserInOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateMembershipForUserInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsAddOrUpdateMembershipForUserLegacyRequest handles teams/add-or-update-membership-for-user-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Add or update team membership for a
// user](https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user)
// endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// If the user is already a member of the team's organization, this endpoint will add the user to the
// team. To add a membership between an organization member and a team, the authenticated user must
// be an organization owner or a team maintainer.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
// If the user is unaffiliated with the team's organization, this endpoint will send an invitation to
// the user via email. This newly-created membership will be in the "pending" state until the user
// accepts the invitation, at which point the membership will transition to the "active" state and
// the user will be added as a member of the team. To add a membership between an unaffiliated user
// and a team, the authenticated user must be an organization owner.
// If the user is already a member of the team, this endpoint will update the role of the team
// member's role. To update the membership of a team member, the authenticated user must be an
// organization owner or a team maintainer.
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /teams/{team_id}/memberships/{username}
func (s *Server) handleTeamsAddOrUpdateMembershipForUserLegacyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-membership-for-user-legacy"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/memberships/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsAddOrUpdateMembershipForUserLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsAddOrUpdateMembershipForUserLegacyOperation,
			ID:   "teams/add-or-update-membership-for-user-legacy",
		}
	)
	params, err := decodeTeamsAddOrUpdateMembershipForUserLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsAddOrUpdateMembershipForUserLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsAddOrUpdateMembershipForUserLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsAddOrUpdateMembershipForUserLegacyOperation,
			OperationSummary: "Add or update team membership for a user (Legacy)",
			OperationID:      "teams/add-or-update-membership-for-user-legacy",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsAddOrUpdateMembershipForUserLegacyReq
			Params   = TeamsAddOrUpdateMembershipForUserLegacyParams
			Response = TeamsAddOrUpdateMembershipForUserLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateMembershipForUserLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsAddOrUpdateMembershipForUserLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsAddOrUpdateMembershipForUserLegacy(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateMembershipForUserLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsAddOrUpdateProjectPermissionsInOrgRequest handles teams/add-or-update-project-permissions-in-org operation.
//
// Adds an organization project to a team. To add a project to a team or update the team's permission
// on a project, the authenticated user must have `admin` permissions for the project. The project
// and team must be part of the same organization.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT
// /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
//
// PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (s *Server) handleTeamsAddOrUpdateProjectPermissionsInOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-project-permissions-in-org"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/projects/{project_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsAddOrUpdateProjectPermissionsInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsAddOrUpdateProjectPermissionsInOrgOperation,
			ID:   "teams/add-or-update-project-permissions-in-org",
		}
	)
	params, err := decodeTeamsAddOrUpdateProjectPermissionsInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsAddOrUpdateProjectPermissionsInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsAddOrUpdateProjectPermissionsInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsAddOrUpdateProjectPermissionsInOrgOperation,
			OperationSummary: "Add or update team project permissions",
			OperationID:      "teams/add-or-update-project-permissions-in-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = OptNilTeamsAddOrUpdateProjectPermissionsInOrgReq
			Params   = TeamsAddOrUpdateProjectPermissionsInOrgParams
			Response = TeamsAddOrUpdateProjectPermissionsInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateProjectPermissionsInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsAddOrUpdateProjectPermissionsInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsAddOrUpdateProjectPermissionsInOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateProjectPermissionsInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsAddOrUpdateProjectPermissionsLegacyRequest handles teams/add-or-update-project-permissions-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Add or update team project
// permissions](https://docs.github.com/rest/reference/teams#add-or-update-team-project-permissions)
// endpoint.
// Adds an organization project to a team. To add a project to a team or update the team's permission
// on a project, the authenticated user must have `admin` permissions for the project. The project
// and team must be part of the same organization.
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /teams/{team_id}/projects/{project_id}
func (s *Server) handleTeamsAddOrUpdateProjectPermissionsLegacyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-project-permissions-legacy"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/projects/{project_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsAddOrUpdateProjectPermissionsLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsAddOrUpdateProjectPermissionsLegacyOperation,
			ID:   "teams/add-or-update-project-permissions-legacy",
		}
	)
	params, err := decodeTeamsAddOrUpdateProjectPermissionsLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsAddOrUpdateProjectPermissionsLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsAddOrUpdateProjectPermissionsLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsAddOrUpdateProjectPermissionsLegacyOperation,
			OperationSummary: "Add or update team project permissions (Legacy)",
			OperationID:      "teams/add-or-update-project-permissions-legacy",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsAddOrUpdateProjectPermissionsLegacyReq
			Params   = TeamsAddOrUpdateProjectPermissionsLegacyParams
			Response = TeamsAddOrUpdateProjectPermissionsLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateProjectPermissionsLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsAddOrUpdateProjectPermissionsLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsAddOrUpdateProjectPermissionsLegacy(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateProjectPermissionsLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsAddOrUpdateRepoPermissionsInOrgRequest handles teams/add-or-update-repo-permissions-in-org operation.
//
// To add a repository to a team or update the team's permission on a repository, the authenticated
// user must have admin access to the repository, and must be able to see the team. The repository
// must be owned by the organization, or a direct fork of a repository owned by the organization. You
// will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is
// not owned by the organization. Note that, if you choose not to pass any parameters, you'll need to
// set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP
// verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT
// /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
// For more information about the permission levels, see "[Repository permission levels for an
// organization](https://help.github.
// com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
//
// PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (s *Server) handleTeamsAddOrUpdateRepoPermissionsInOrgRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-repo-permissions-in-org"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsAddOrUpdateRepoPermissionsInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsAddOrUpdateRepoPermissionsInOrgOperation,
			ID:   "teams/add-or-update-repo-permissions-in-org",
		}
	)
	params, err := decodeTeamsAddOrUpdateRepoPermissionsInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsAddOrUpdateRepoPermissionsInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamsAddOrUpdateRepoPermissionsInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsAddOrUpdateRepoPermissionsInOrgOperation,
			OperationSummary: "Add or update team repository permissions",
			OperationID:      "teams/add-or-update-repo-permissions-in-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsAddOrUpdateRepoPermissionsInOrgReq
			Params   = TeamsAddOrUpdateRepoPermissionsInOrgParams
			Response = *TeamsAddOrUpdateRepoPermissionsInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateRepoPermissionsInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsAddOrUpdateRepoPermissionsInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsAddOrUpdateRepoPermissionsInOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateRepoPermissionsInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsAddOrUpdateRepoPermissionsLegacyRequest handles teams/add-or-update-repo-permissions-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new "[Add or update team repository
// permissions](https://docs.github.
// com/rest/reference/teams#add-or-update-team-repository-permissions)" endpoint.
// To add a repository to a team or update the team's permission on a repository, the authenticated
// user must have admin access to the repository, and must be able to see the team. The repository
// must be owned by the organization, or a direct fork of a repository owned by the organization. You
// will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is
// not owned by the organization.
// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero
// when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs).".
//
// Deprecated: schema marks this operation as deprecated.
//
// PUT /teams/{team_id}/repos/{owner}/{repo}
func (s *Server) handleTeamsAddOrUpdateRepoPermissionsLegacyRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/add-or-update-repo-permissions-legacy"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/repos/{owner}/{repo}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsAddOrUpdateRepoPermissionsLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsAddOrUpdateRepoPermissionsLegacyOperation,
			ID:   "teams/add-or-update-repo-permissions-legacy",
		}
	)
	params, err := decodeTeamsAddOrUpdateRepoPermissionsLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsAddOrUpdateRepoPermissionsLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsAddOrUpdateRepoPermissionsLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsAddOrUpdateRepoPermissionsLegacyOperation,
			OperationSummary: "Add or update team repository permissions (Legacy)",
			OperationID:      "teams/add-or-update-repo-permissions-legacy",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsAddOrUpdateRepoPermissionsLegacyReq
			Params   = TeamsAddOrUpdateRepoPermissionsLegacyParams
			Response = TeamsAddOrUpdateRepoPermissionsLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsAddOrUpdateRepoPermissionsLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsAddOrUpdateRepoPermissionsLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsAddOrUpdateRepoPermissionsLegacy(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsAddOrUpdateRepoPermissionsLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsCheckPermissionsForProjectInOrgRequest handles teams/check-permissions-for-project-in-org operation.
//
// Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The
// response includes projects inherited from a parent team.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
//
// GET /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (s *Server) handleTeamsCheckPermissionsForProjectInOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-project-in-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/projects/{project_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsCheckPermissionsForProjectInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsCheckPermissionsForProjectInOrgOperation,
			ID:   "teams/check-permissions-for-project-in-org",
		}
	)
	params, err := decodeTeamsCheckPermissionsForProjectInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsCheckPermissionsForProjectInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsCheckPermissionsForProjectInOrgOperation,
			OperationSummary: "Check team permissions for a project",
			OperationID:      "teams/check-permissions-for-project-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsCheckPermissionsForProjectInOrgParams
			Response = TeamsCheckPermissionsForProjectInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCheckPermissionsForProjectInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCheckPermissionsForProjectInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCheckPermissionsForProjectInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForProjectInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsCheckPermissionsForProjectLegacyRequest handles teams/check-permissions-for-project-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Check team permissions for a
// project](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-project)
// endpoint.
// Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The
// response includes projects inherited from a parent team.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/projects/{project_id}
func (s *Server) handleTeamsCheckPermissionsForProjectLegacyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-project-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/projects/{project_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsCheckPermissionsForProjectLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsCheckPermissionsForProjectLegacyOperation,
			ID:   "teams/check-permissions-for-project-legacy",
		}
	)
	params, err := decodeTeamsCheckPermissionsForProjectLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsCheckPermissionsForProjectLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsCheckPermissionsForProjectLegacyOperation,
			OperationSummary: "Check team permissions for a project (Legacy)",
			OperationID:      "teams/check-permissions-for-project-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsCheckPermissionsForProjectLegacyParams
			Response = TeamsCheckPermissionsForProjectLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCheckPermissionsForProjectLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCheckPermissionsForProjectLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCheckPermissionsForProjectLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForProjectLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsCheckPermissionsForRepoInOrgRequest handles teams/check-permissions-for-repo-in-org operation.
//
// Checks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a
// repository. Repositories inherited through a parent team will also be checked.
// You can also get information about the specified repository, including what permissions the team
// grants on it, by passing the following custom [media type](https://docs.github.
// com/rest/overview/media-types/) via the `application/vnd.github.v3.repository+json` accept header.
// If a team doesn't have permission for the repository, you will receive a `404 Not Found` response
// status.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
//
// GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (s *Server) handleTeamsCheckPermissionsForRepoInOrgRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-repo-in-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsCheckPermissionsForRepoInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsCheckPermissionsForRepoInOrgOperation,
			ID:   "teams/check-permissions-for-repo-in-org",
		}
	)
	params, err := decodeTeamsCheckPermissionsForRepoInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsCheckPermissionsForRepoInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsCheckPermissionsForRepoInOrgOperation,
			OperationSummary: "Check team permissions for a repository",
			OperationID:      "teams/check-permissions-for-repo-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsCheckPermissionsForRepoInOrgParams
			Response = TeamsCheckPermissionsForRepoInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCheckPermissionsForRepoInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCheckPermissionsForRepoInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCheckPermissionsForRepoInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForRepoInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsCheckPermissionsForRepoLegacyRequest handles teams/check-permissions-for-repo-legacy operation.
//
// **Note**: Repositories inherited through a parent team will also be checked.
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Check team permissions for a
// repository](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-repository)
// endpoint.
// You can also get information about the specified repository, including what permissions the team
// grants on it, by passing the following custom [media type](https://docs.github.
// com/rest/overview/media-types/) via the `Accept` header:.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/repos/{owner}/{repo}
func (s *Server) handleTeamsCheckPermissionsForRepoLegacyRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/check-permissions-for-repo-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/repos/{owner}/{repo}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsCheckPermissionsForRepoLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsCheckPermissionsForRepoLegacyOperation,
			ID:   "teams/check-permissions-for-repo-legacy",
		}
	)
	params, err := decodeTeamsCheckPermissionsForRepoLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsCheckPermissionsForRepoLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsCheckPermissionsForRepoLegacyOperation,
			OperationSummary: "Check team permissions for a repository (Legacy)",
			OperationID:      "teams/check-permissions-for-repo-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsCheckPermissionsForRepoLegacyParams
			Response = TeamsCheckPermissionsForRepoLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCheckPermissionsForRepoLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCheckPermissionsForRepoLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCheckPermissionsForRepoLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCheckPermissionsForRepoLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsCreateRequest handles teams/create operation.
//
// To create a team, the authenticated user must be a member or owner of `{org}`. By default,
// organization members can create teams. Organization owners can limit team creation to organization
// owners. For more information, see "[Setting team creation permissions](https://help.github.
// com/en/articles/setting-team-creation-permissions-in-your-organization)."
// When you create a new team, you automatically become a team maintainer without explicitly adding
// yourself to the optional array of `maintainers`. For more information, see "[About
// teams](https://help.github.
// com/en/github/setting-up-and-managing-organizations-and-teams/about-teams)".
//
// POST /orgs/{org}/teams
func (s *Server) handleTeamsCreateRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsCreateOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsCreateOperation,
			ID:   "teams/create",
		}
	)
	params, err := decodeTeamsCreateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsCreateOperation,
			OperationSummary: "Create a team",
			OperationID:      "teams/create",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsCreateReq
			Params   = TeamsCreateParams
			Response = TeamsCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCreate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCreate(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsCreateDiscussionCommentInOrgRequest handles teams/create-discussion-comment-in-org operation.
//
// Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
//
// POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
func (s *Server) handleTeamsCreateDiscussionCommentInOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-comment-in-org"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsCreateDiscussionCommentInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsCreateDiscussionCommentInOrgOperation,
			ID:   "teams/create-discussion-comment-in-org",
		}
	)
	params, err := decodeTeamsCreateDiscussionCommentInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsCreateDiscussionCommentInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsCreateDiscussionCommentInOrgOperation,
			OperationSummary: "Create a discussion comment",
			OperationID:      "teams/create-discussion-comment-in-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsCreateDiscussionCommentInOrgReq
			Params   = TeamsCreateDiscussionCommentInOrgParams
			Response = *TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCreateDiscussionCommentInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCreateDiscussionCommentInOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateDiscussionCommentInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsCreateDiscussionCommentLegacyRequest handles teams/create-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Create a discussion
// comment](https://docs.github.com/rest/reference/teams#create-a-discussion-comment) endpoint.
// Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /teams/{team_id}/discussions/{discussion_number}/comments
func (s *Server) handleTeamsCreateDiscussionCommentLegacyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-comment-legacy"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsCreateDiscussionCommentLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsCreateDiscussionCommentLegacyOperation,
			ID:   "teams/create-discussion-comment-legacy",
		}
	)
	params, err := decodeTeamsCreateDiscussionCommentLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsCreateDiscussionCommentLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsCreateDiscussionCommentLegacyOperation,
			OperationSummary: "Create a discussion comment (Legacy)",
			OperationID:      "teams/create-discussion-comment-legacy",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsCreateDiscussionCommentLegacyReq
			Params   = TeamsCreateDiscussionCommentLegacyParams
			Response = *TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCreateDiscussionCommentLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCreateDiscussionCommentLegacy(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateDiscussionCommentLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsCreateDiscussionInOrgRequest handles teams/create-discussion-in-org operation.
//
// Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST
// /organizations/{org_id}/team/{team_id}/discussions`.
//
// POST /orgs/{org}/teams/{team_slug}/discussions
func (s *Server) handleTeamsCreateDiscussionInOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-in-org"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsCreateDiscussionInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsCreateDiscussionInOrgOperation,
			ID:   "teams/create-discussion-in-org",
		}
	)
	params, err := decodeTeamsCreateDiscussionInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsCreateDiscussionInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsCreateDiscussionInOrgOperation,
			OperationSummary: "Create a discussion",
			OperationID:      "teams/create-discussion-in-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsCreateDiscussionInOrgReq
			Params   = TeamsCreateDiscussionInOrgParams
			Response = *TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCreateDiscussionInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCreateDiscussionInOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateDiscussionInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsCreateDiscussionLegacyRequest handles teams/create-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`Create a discussion`](https://docs.
// github.com/rest/reference/teams#create-a-discussion) endpoint.
// Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// This endpoint triggers [notifications](https://docs.github.
// com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating
// content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary
// rate limits](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary
// rate limits](https://docs.github.
// com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /teams/{team_id}/discussions
func (s *Server) handleTeamsCreateDiscussionLegacyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-discussion-legacy"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsCreateDiscussionLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsCreateDiscussionLegacyOperation,
			ID:   "teams/create-discussion-legacy",
		}
	)
	params, err := decodeTeamsCreateDiscussionLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsCreateDiscussionLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsCreateDiscussionLegacyOperation,
			OperationSummary: "Create a discussion (Legacy)",
			OperationID:      "teams/create-discussion-legacy",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsCreateDiscussionLegacyReq
			Params   = TeamsCreateDiscussionLegacyParams
			Response = *TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCreateDiscussionLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCreateDiscussionLegacy(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateDiscussionLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest handles teams/create-or-update-idp-group-connections-in-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// Creates, updates, or removes a connection between a team and an IdP group. When adding groups to a
// team, you must include all new and existing groups to avoid replacing existing groups with the new
// ones. Specifying an empty `groups` array will remove all connections for a team.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
// /organizations/{org_id}/team/{team_id}/team-sync/group-mappings`.
//
// PATCH /orgs/{org}/teams/{team_slug}/team-sync/group-mappings
func (s *Server) handleTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-or-update-idp-group-connections-in-org"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/team-sync/group-mappings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsCreateOrUpdateIdpGroupConnectionsInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsCreateOrUpdateIdpGroupConnectionsInOrgOperation,
			ID:   "teams/create-or-update-idp-group-connections-in-org",
		}
	)
	params, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *GroupMapping
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsCreateOrUpdateIdpGroupConnectionsInOrgOperation,
			OperationSummary: "Create or update IdP group connections",
			OperationID:      "teams/create-or-update-idp-group-connections-in-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq
			Params   = TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams
			Response = *GroupMapping
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateOrUpdateIdpGroupConnectionsInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCreateOrUpdateIdpGroupConnectionsInOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest handles teams/create-or-update-idp-group-connections-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`Create or update IdP group
// connections`](https://docs.github.com/rest/reference/teams#create-or-update-idp-group-connections)
// endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// Creates, updates, or removes a connection between a team and an IdP group. When adding groups to a
// team, you must include all new and existing groups to avoid replacing existing groups with the new
// ones. Specifying an empty `groups` array will remove all connections for a team.
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /teams/{team_id}/team-sync/group-mappings
func (s *Server) handleTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/create-or-update-idp-group-connections-legacy"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/team-sync/group-mappings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsCreateOrUpdateIdpGroupConnectionsLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsCreateOrUpdateIdpGroupConnectionsLegacyOperation,
			ID:   "teams/create-or-update-idp-group-connections-legacy",
		}
	)
	params, err := decodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsCreateOrUpdateIdpGroupConnectionsLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsCreateOrUpdateIdpGroupConnectionsLegacyOperation,
			OperationSummary: "Create or update IdP group connections (Legacy)",
			OperationID:      "teams/create-or-update-idp-group-connections-legacy",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq
			Params   = TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams
			Response = TeamsCreateOrUpdateIdpGroupConnectionsLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsCreateOrUpdateIdpGroupConnectionsLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsCreateOrUpdateIdpGroupConnectionsLegacy(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsDeleteDiscussionCommentInOrgRequest handles teams/delete-discussion-comment-in-org operation.
//
// Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsDeleteDiscussionCommentInOrgRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-comment-in-org"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsDeleteDiscussionCommentInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsDeleteDiscussionCommentInOrgOperation,
			ID:   "teams/delete-discussion-comment-in-org",
		}
	)
	params, err := decodeTeamsDeleteDiscussionCommentInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsDeleteDiscussionCommentInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsDeleteDiscussionCommentInOrgOperation,
			OperationSummary: "Delete a discussion comment",
			OperationID:      "teams/delete-discussion-comment-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteDiscussionCommentInOrgParams
			Response = *TeamsDeleteDiscussionCommentInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsDeleteDiscussionCommentInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsDeleteDiscussionCommentInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionCommentInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsDeleteDiscussionCommentLegacyRequest handles teams/delete-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Delete a discussion
// comment](https://docs.github.com/rest/reference/teams#delete-a-discussion-comment) endpoint.
// Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsDeleteDiscussionCommentLegacyRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-comment-legacy"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsDeleteDiscussionCommentLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsDeleteDiscussionCommentLegacyOperation,
			ID:   "teams/delete-discussion-comment-legacy",
		}
	)
	params, err := decodeTeamsDeleteDiscussionCommentLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsDeleteDiscussionCommentLegacyNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsDeleteDiscussionCommentLegacyOperation,
			OperationSummary: "Delete a discussion comment (Legacy)",
			OperationID:      "teams/delete-discussion-comment-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteDiscussionCommentLegacyParams
			Response = *TeamsDeleteDiscussionCommentLegacyNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsDeleteDiscussionCommentLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsDeleteDiscussionCommentLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionCommentLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsDeleteDiscussionInOrgRequest handles teams/delete-discussion-in-org operation.
//
// Delete a discussion from a team's page. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (s *Server) handleTeamsDeleteDiscussionInOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-in-org"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsDeleteDiscussionInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsDeleteDiscussionInOrgOperation,
			ID:   "teams/delete-discussion-in-org",
		}
	)
	params, err := decodeTeamsDeleteDiscussionInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsDeleteDiscussionInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsDeleteDiscussionInOrgOperation,
			OperationSummary: "Delete a discussion",
			OperationID:      "teams/delete-discussion-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteDiscussionInOrgParams
			Response = *TeamsDeleteDiscussionInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsDeleteDiscussionInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsDeleteDiscussionInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsDeleteDiscussionLegacyRequest handles teams/delete-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`Delete a discussion`](https://docs.
// github.com/rest/reference/teams#delete-a-discussion) endpoint.
// Delete a discussion from a team's page. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/discussions/{discussion_number}
func (s *Server) handleTeamsDeleteDiscussionLegacyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-discussion-legacy"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsDeleteDiscussionLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsDeleteDiscussionLegacyOperation,
			ID:   "teams/delete-discussion-legacy",
		}
	)
	params, err := decodeTeamsDeleteDiscussionLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsDeleteDiscussionLegacyNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsDeleteDiscussionLegacyOperation,
			OperationSummary: "Delete a discussion (Legacy)",
			OperationID:      "teams/delete-discussion-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteDiscussionLegacyParams
			Response = *TeamsDeleteDiscussionLegacyNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsDeleteDiscussionLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsDeleteDiscussionLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteDiscussionLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsDeleteInOrgRequest handles teams/delete-in-org operation.
//
// To delete a team, the authenticated user must be an organization owner or team maintainer.
// If you are an organization owner, deleting a parent team will delete all of its child teams as
// well.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}`.
//
// DELETE /orgs/{org}/teams/{team_slug}
func (s *Server) handleTeamsDeleteInOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-in-org"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsDeleteInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsDeleteInOrgOperation,
			ID:   "teams/delete-in-org",
		}
	)
	params, err := decodeTeamsDeleteInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsDeleteInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsDeleteInOrgOperation,
			OperationSummary: "Delete a team",
			OperationID:      "teams/delete-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteInOrgParams
			Response = *TeamsDeleteInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsDeleteInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsDeleteInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsDeleteLegacyRequest handles teams/delete-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Delete a team](https://docs.github.
// com/rest/reference/teams#delete-a-team) endpoint.
// To delete a team, the authenticated user must be an organization owner or team maintainer.
// If you are an organization owner, deleting a parent team will delete all of its child teams as
// well.
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}
func (s *Server) handleTeamsDeleteLegacyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/delete-legacy"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/teams/{team_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsDeleteLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsDeleteLegacyOperation,
			ID:   "teams/delete-legacy",
		}
	)
	params, err := decodeTeamsDeleteLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsDeleteLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsDeleteLegacyOperation,
			OperationSummary: "Delete a team (Legacy)",
			OperationID:      "teams/delete-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsDeleteLegacyParams
			Response = TeamsDeleteLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsDeleteLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsDeleteLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsDeleteLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsDeleteLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsGetByNameRequest handles teams/get-by-name operation.
//
// Gets a team using the team's `slug`. GitHub generates the `slug` from the team `name`.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}`.
//
// GET /orgs/{org}/teams/{team_slug}
func (s *Server) handleTeamsGetByNameRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-by-name"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsGetByNameOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsGetByNameOperation,
			ID:   "teams/get-by-name",
		}
	)
	params, err := decodeTeamsGetByNameParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsGetByNameRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsGetByNameOperation,
			OperationSummary: "Get a team by name",
			OperationID:      "teams/get-by-name",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetByNameParams
			Response = TeamsGetByNameRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetByNameParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetByName(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetByName(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetByNameResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsGetDiscussionCommentInOrgRequest handles teams/get-discussion-comment-in-org operation.
//
// Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsGetDiscussionCommentInOrgRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-comment-in-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsGetDiscussionCommentInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsGetDiscussionCommentInOrgOperation,
			ID:   "teams/get-discussion-comment-in-org",
		}
	)
	params, err := decodeTeamsGetDiscussionCommentInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsGetDiscussionCommentInOrgOperation,
			OperationSummary: "Get a discussion comment",
			OperationID:      "teams/get-discussion-comment-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetDiscussionCommentInOrgParams
			Response = *TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetDiscussionCommentInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetDiscussionCommentInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetDiscussionCommentInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsGetDiscussionCommentLegacyRequest handles teams/get-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Get a discussion comment](https://docs.
// github.com/rest/reference/teams#get-a-discussion-comment) endpoint.
// Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsGetDiscussionCommentLegacyRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-comment-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsGetDiscussionCommentLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsGetDiscussionCommentLegacyOperation,
			ID:   "teams/get-discussion-comment-legacy",
		}
	)
	params, err := decodeTeamsGetDiscussionCommentLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsGetDiscussionCommentLegacyOperation,
			OperationSummary: "Get a discussion comment (Legacy)",
			OperationID:      "teams/get-discussion-comment-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetDiscussionCommentLegacyParams
			Response = *TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetDiscussionCommentLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetDiscussionCommentLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetDiscussionCommentLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsGetDiscussionInOrgRequest handles teams/get-discussion-in-org operation.
//
// Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (s *Server) handleTeamsGetDiscussionInOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-in-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsGetDiscussionInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsGetDiscussionInOrgOperation,
			ID:   "teams/get-discussion-in-org",
		}
	)
	params, err := decodeTeamsGetDiscussionInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsGetDiscussionInOrgOperation,
			OperationSummary: "Get a discussion",
			OperationID:      "teams/get-discussion-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetDiscussionInOrgParams
			Response = *TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetDiscussionInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetDiscussionInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetDiscussionInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsGetDiscussionLegacyRequest handles teams/get-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Get a discussion](https://docs.github.
// com/rest/reference/teams#get-a-discussion) endpoint.
// Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions/{discussion_number}
func (s *Server) handleTeamsGetDiscussionLegacyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-discussion-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsGetDiscussionLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsGetDiscussionLegacyOperation,
			ID:   "teams/get-discussion-legacy",
		}
	)
	params, err := decodeTeamsGetDiscussionLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsGetDiscussionLegacyOperation,
			OperationSummary: "Get a discussion (Legacy)",
			OperationID:      "teams/get-discussion-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetDiscussionLegacyParams
			Response = *TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetDiscussionLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetDiscussionLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetDiscussionLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsGetLegacyRequest handles teams/get-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the [Get a team by name](https://docs.github.
// com/rest/reference/teams#get-a-team-by-name) endpoint.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}
func (s *Server) handleTeamsGetLegacyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsGetLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsGetLegacyOperation,
			ID:   "teams/get-legacy",
		}
	)
	params, err := decodeTeamsGetLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsGetLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsGetLegacyOperation,
			OperationSummary: "Get a team (Legacy)",
			OperationID:      "teams/get-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetLegacyParams
			Response = TeamsGetLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsGetMemberLegacyRequest handles teams/get-member-legacy operation.
//
// The "Get team member" endpoint (described below) is deprecated.
// We recommend using the [Get team membership for a user](https://docs.github.
// com/rest/reference/teams#get-team-membership-for-a-user) endpoint instead. It allows you to get
// both active and pending memberships.
// To list members in a team, the team must be visible to the authenticated user.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/members/{username}
func (s *Server) handleTeamsGetMemberLegacyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-member-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/members/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsGetMemberLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsGetMemberLegacyOperation,
			ID:   "teams/get-member-legacy",
		}
	)
	params, err := decodeTeamsGetMemberLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsGetMemberLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsGetMemberLegacyOperation,
			OperationSummary: "Get team member (Legacy)",
			OperationID:      "teams/get-member-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetMemberLegacyParams
			Response = TeamsGetMemberLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetMemberLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetMemberLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetMemberLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetMemberLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsGetMembershipForUserInOrgRequest handles teams/get-membership-for-user-in-org operation.
//
// Team members will include the members of child teams.
// To get a user's membership with a team, the team must be visible to the authenticated user.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/memberships/{username}`.
// **Note:**
// The response contains the `state` of the membership and the member's `role`.
// The `role` for organization owners is set to `maintainer`. For more information about `maintainer`
// roles, see see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).
//
// GET /orgs/{org}/teams/{team_slug}/memberships/{username}
func (s *Server) handleTeamsGetMembershipForUserInOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-membership-for-user-in-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/memberships/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsGetMembershipForUserInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsGetMembershipForUserInOrgOperation,
			ID:   "teams/get-membership-for-user-in-org",
		}
	)
	params, err := decodeTeamsGetMembershipForUserInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsGetMembershipForUserInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsGetMembershipForUserInOrgOperation,
			OperationSummary: "Get team membership for a user",
			OperationID:      "teams/get-membership-for-user-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetMembershipForUserInOrgParams
			Response = TeamsGetMembershipForUserInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetMembershipForUserInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetMembershipForUserInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetMembershipForUserInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetMembershipForUserInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsGetMembershipForUserLegacyRequest handles teams/get-membership-for-user-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Get team membership for a
// user](https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user) endpoint.
// Team members will include the members of child teams.
// To get a user's membership with a team, the team must be visible to the authenticated user.
// **Note:**
// The response contains the `state` of the membership and the member's `role`.
// The `role` for organization owners is set to `maintainer`. For more information about `maintainer`
// roles, see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/memberships/{username}
func (s *Server) handleTeamsGetMembershipForUserLegacyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/get-membership-for-user-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/memberships/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsGetMembershipForUserLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsGetMembershipForUserLegacyOperation,
			ID:   "teams/get-membership-for-user-legacy",
		}
	)
	params, err := decodeTeamsGetMembershipForUserLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsGetMembershipForUserLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsGetMembershipForUserLegacyOperation,
			OperationSummary: "Get team membership for a user (Legacy)",
			OperationID:      "teams/get-membership-for-user-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsGetMembershipForUserLegacyParams
			Response = TeamsGetMembershipForUserLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsGetMembershipForUserLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsGetMembershipForUserLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsGetMembershipForUserLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsGetMembershipForUserLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListRequest handles teams/list operation.
//
// Lists all teams in an organization that are visible to the authenticated user.
//
// GET /orgs/{org}/teams
func (s *Server) handleTeamsListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListOperation,
			ID:   "teams/list",
		}
	)
	params, err := decodeTeamsListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListOperation,
			OperationSummary: "List teams",
			OperationID:      "teams/list",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListParams
			Response = TeamsListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListChildInOrgRequest handles teams/list-child-in-org operation.
//
// Lists the child teams of the team specified by `{team_slug}`.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/teams`.
//
// GET /orgs/{org}/teams/{team_slug}/teams
func (s *Server) handleTeamsListChildInOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-child-in-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/teams"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListChildInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListChildInOrgOperation,
			ID:   "teams/list-child-in-org",
		}
	)
	params, err := decodeTeamsListChildInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsListChildInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListChildInOrgOperation,
			OperationSummary: "List child teams",
			OperationID:      "teams/list-child-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListChildInOrgParams
			Response = *TeamsListChildInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListChildInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListChildInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListChildInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListChildInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListChildLegacyRequest handles teams/list-child-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List child teams`](https://docs.github.
// com/rest/reference/teams#list-child-teams) endpoint.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/teams
func (s *Server) handleTeamsListChildLegacyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-child-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/teams"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListChildLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListChildLegacyOperation,
			ID:   "teams/list-child-legacy",
		}
	)
	params, err := decodeTeamsListChildLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsListChildLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListChildLegacyOperation,
			OperationSummary: "List child teams (Legacy)",
			OperationID:      "teams/list-child-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListChildLegacyParams
			Response = TeamsListChildLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListChildLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListChildLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListChildLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListChildLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListDiscussionCommentsInOrgRequest handles teams/list-discussion-comments-in-org operation.
//
// List all comments on a team discussion. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments
func (s *Server) handleTeamsListDiscussionCommentsInOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussion-comments-in-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListDiscussionCommentsInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListDiscussionCommentsInOrgOperation,
			ID:   "teams/list-discussion-comments-in-org",
		}
	)
	params, err := decodeTeamsListDiscussionCommentsInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsListDiscussionCommentsInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListDiscussionCommentsInOrgOperation,
			OperationSummary: "List discussion comments",
			OperationID:      "teams/list-discussion-comments-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListDiscussionCommentsInOrgParams
			Response = *TeamsListDiscussionCommentsInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListDiscussionCommentsInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListDiscussionCommentsInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListDiscussionCommentsInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListDiscussionCommentsInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListDiscussionCommentsLegacyRequest handles teams/list-discussion-comments-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [List discussion comments](https://docs.
// github.com/rest/reference/teams#list-discussion-comments) endpoint.
// List all comments on a team discussion. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions/{discussion_number}/comments
func (s *Server) handleTeamsListDiscussionCommentsLegacyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussion-comments-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/comments"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListDiscussionCommentsLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListDiscussionCommentsLegacyOperation,
			ID:   "teams/list-discussion-comments-legacy",
		}
	)
	params, err := decodeTeamsListDiscussionCommentsLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsListDiscussionCommentsLegacyOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListDiscussionCommentsLegacyOperation,
			OperationSummary: "List discussion comments (Legacy)",
			OperationID:      "teams/list-discussion-comments-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListDiscussionCommentsLegacyParams
			Response = *TeamsListDiscussionCommentsLegacyOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListDiscussionCommentsLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListDiscussionCommentsLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListDiscussionCommentsLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListDiscussionCommentsLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListDiscussionsInOrgRequest handles teams/list-discussions-in-org operation.
//
// List all discussions on a team's page. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/discussions`.
//
// GET /orgs/{org}/teams/{team_slug}/discussions
func (s *Server) handleTeamsListDiscussionsInOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussions-in-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListDiscussionsInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListDiscussionsInOrgOperation,
			ID:   "teams/list-discussions-in-org",
		}
	)
	params, err := decodeTeamsListDiscussionsInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsListDiscussionsInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListDiscussionsInOrgOperation,
			OperationSummary: "List discussions",
			OperationID:      "teams/list-discussions-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "pinned",
					In:   "query",
				}: params.Pinned,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListDiscussionsInOrgParams
			Response = *TeamsListDiscussionsInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListDiscussionsInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListDiscussionsInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListDiscussionsInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListDiscussionsInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListDiscussionsLegacyRequest handles teams/list-discussions-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List discussions`](https://docs.github.
// com/rest/reference/teams#list-discussions) endpoint.
// List all discussions on a team's page. OAuth access tokens require the `read:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/discussions
func (s *Server) handleTeamsListDiscussionsLegacyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-discussions-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListDiscussionsLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListDiscussionsLegacyOperation,
			ID:   "teams/list-discussions-legacy",
		}
	)
	params, err := decodeTeamsListDiscussionsLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsListDiscussionsLegacyOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListDiscussionsLegacyOperation,
			OperationSummary: "List discussions (Legacy)",
			OperationID:      "teams/list-discussions-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "direction",
					In:   "query",
				}: params.Direction,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListDiscussionsLegacyParams
			Response = *TeamsListDiscussionsLegacyOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListDiscussionsLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListDiscussionsLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListDiscussionsLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListDiscussionsLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListForAuthenticatedUserRequest handles teams/list-for-authenticated-user operation.
//
// List all of the teams across all of the organizations to which the authenticated user belongs.
// This method requires `user`, `repo`, or `read:org` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/) when authenticating via
// [OAuth](https://docs.github.com/apps/building-oauth-apps/).
//
// GET /user/teams
func (s *Server) handleTeamsListForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/teams"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListForAuthenticatedUserOperation,
			ID:   "teams/list-for-authenticated-user",
		}
	)
	params, err := decodeTeamsListForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsListForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListForAuthenticatedUserOperation,
			OperationSummary: "List teams for the authenticated user",
			OperationID:      "teams/list-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListForAuthenticatedUserParams
			Response = TeamsListForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListIdpGroupsForLegacyRequest handles teams/list-idp-groups-for-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List IdP groups for a
// team`](https://docs.github.com/rest/reference/teams#list-idp-groups-for-a-team) endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// List IdP groups connected to a team on GitHub.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/team-sync/group-mappings
func (s *Server) handleTeamsListIdpGroupsForLegacyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-for-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/team-sync/group-mappings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListIdpGroupsForLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListIdpGroupsForLegacyOperation,
			ID:   "teams/list-idp-groups-for-legacy",
		}
	)
	params, err := decodeTeamsListIdpGroupsForLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsListIdpGroupsForLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListIdpGroupsForLegacyOperation,
			OperationSummary: "List IdP groups for a team (Legacy)",
			OperationID:      "teams/list-idp-groups-for-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListIdpGroupsForLegacyParams
			Response = TeamsListIdpGroupsForLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListIdpGroupsForLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListIdpGroupsForLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListIdpGroupsForLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListIdpGroupsForLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListIdpGroupsForOrgRequest handles teams/list-idp-groups-for-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// List IdP groups available in an organization. You can limit your page results using the `per_page`
// parameter. GitHub generates a url-encoded `page` token using a cursor value for where the next
// page begins. For more information on cursor pagination, see "[Offset and Cursor Pagination
// explained](https://dev.to/jackmarchant/offset-and-cursor-pagination-explained-b89).".
//
// GET /orgs/{org}/team-sync/groups
func (s *Server) handleTeamsListIdpGroupsForOrgRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-for-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/team-sync/groups"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListIdpGroupsForOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListIdpGroupsForOrgOperation,
			ID:   "teams/list-idp-groups-for-org",
		}
	)
	params, err := decodeTeamsListIdpGroupsForOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *GroupMappingHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListIdpGroupsForOrgOperation,
			OperationSummary: "List IdP groups for an organization",
			OperationID:      "teams/list-idp-groups-for-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListIdpGroupsForOrgParams
			Response = *GroupMappingHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListIdpGroupsForOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListIdpGroupsForOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListIdpGroupsForOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListIdpGroupsForOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListIdpGroupsInOrgRequest handles teams/list-idp-groups-in-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// List IdP groups connected to a team on GitHub.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/team-sync/group-mappings`.
//
// GET /orgs/{org}/teams/{team_slug}/team-sync/group-mappings
func (s *Server) handleTeamsListIdpGroupsInOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-idp-groups-in-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/team-sync/group-mappings"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListIdpGroupsInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListIdpGroupsInOrgOperation,
			ID:   "teams/list-idp-groups-in-org",
		}
	)
	params, err := decodeTeamsListIdpGroupsInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *GroupMapping
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListIdpGroupsInOrgOperation,
			OperationSummary: "List IdP groups for a team",
			OperationID:      "teams/list-idp-groups-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListIdpGroupsInOrgParams
			Response = *GroupMapping
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListIdpGroupsInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListIdpGroupsInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListIdpGroupsInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListIdpGroupsInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListMembersInOrgRequest handles teams/list-members-in-org operation.
//
// Team members will include the members of child teams.
// To list members in a team, the team must be visible to the authenticated user.
//
// GET /orgs/{org}/teams/{team_slug}/members
func (s *Server) handleTeamsListMembersInOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-members-in-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/members"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListMembersInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListMembersInOrgOperation,
			ID:   "teams/list-members-in-org",
		}
	)
	params, err := decodeTeamsListMembersInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsListMembersInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListMembersInOrgOperation,
			OperationSummary: "List team members",
			OperationID:      "teams/list-members-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "role",
					In:   "query",
				}: params.Role,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListMembersInOrgParams
			Response = *TeamsListMembersInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListMembersInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListMembersInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListMembersInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListMembersInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListMembersLegacyRequest handles teams/list-members-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List team members`](https://docs.github.
// com/rest/reference/teams#list-team-members) endpoint.
// Team members will include the members of child teams.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/members
func (s *Server) handleTeamsListMembersLegacyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-members-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/members"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListMembersLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListMembersLegacyOperation,
			ID:   "teams/list-members-legacy",
		}
	)
	params, err := decodeTeamsListMembersLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsListMembersLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListMembersLegacyOperation,
			OperationSummary: "List team members (Legacy)",
			OperationID:      "teams/list-members-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "role",
					In:   "query",
				}: params.Role,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListMembersLegacyParams
			Response = TeamsListMembersLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListMembersLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListMembersLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListMembersLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListMembersLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListPendingInvitationsInOrgRequest handles teams/list-pending-invitations-in-org operation.
//
// The return hash contains a `role` field which refers to the Organization Invitation role and will
// be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or
// `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be
// `null`.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/invitations`.
//
// GET /orgs/{org}/teams/{team_slug}/invitations
func (s *Server) handleTeamsListPendingInvitationsInOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-pending-invitations-in-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/invitations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListPendingInvitationsInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListPendingInvitationsInOrgOperation,
			ID:   "teams/list-pending-invitations-in-org",
		}
	)
	params, err := decodeTeamsListPendingInvitationsInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsListPendingInvitationsInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListPendingInvitationsInOrgOperation,
			OperationSummary: "List pending team invitations",
			OperationID:      "teams/list-pending-invitations-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListPendingInvitationsInOrgParams
			Response = *TeamsListPendingInvitationsInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListPendingInvitationsInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListPendingInvitationsInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListPendingInvitationsInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListPendingInvitationsInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListPendingInvitationsLegacyRequest handles teams/list-pending-invitations-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List pending team
// invitations`](https://docs.github.com/rest/reference/teams#list-pending-team-invitations) endpoint.
// The return hash contains a `role` field which refers to the Organization Invitation role and will
// be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or
// `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be
// `null`.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/invitations
func (s *Server) handleTeamsListPendingInvitationsLegacyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-pending-invitations-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/invitations"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListPendingInvitationsLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListPendingInvitationsLegacyOperation,
			ID:   "teams/list-pending-invitations-legacy",
		}
	)
	params, err := decodeTeamsListPendingInvitationsLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsListPendingInvitationsLegacyOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListPendingInvitationsLegacyOperation,
			OperationSummary: "List pending team invitations (Legacy)",
			OperationID:      "teams/list-pending-invitations-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListPendingInvitationsLegacyParams
			Response = *TeamsListPendingInvitationsLegacyOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListPendingInvitationsLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListPendingInvitationsLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListPendingInvitationsLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListPendingInvitationsLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListProjectsInOrgRequest handles teams/list-projects-in-org operation.
//
// Lists the organization projects for a team.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/projects`.
//
// GET /orgs/{org}/teams/{team_slug}/projects
func (s *Server) handleTeamsListProjectsInOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-projects-in-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/projects"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListProjectsInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListProjectsInOrgOperation,
			ID:   "teams/list-projects-in-org",
		}
	)
	params, err := decodeTeamsListProjectsInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsListProjectsInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListProjectsInOrgOperation,
			OperationSummary: "List team projects",
			OperationID:      "teams/list-projects-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListProjectsInOrgParams
			Response = *TeamsListProjectsInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListProjectsInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListProjectsInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListProjectsInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListProjectsInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListProjectsLegacyRequest handles teams/list-projects-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [`List team projects`](https://docs.
// github.com/rest/reference/teams#list-team-projects) endpoint.
// Lists the organization projects for a team.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/projects
func (s *Server) handleTeamsListProjectsLegacyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-projects-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/projects"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListProjectsLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListProjectsLegacyOperation,
			ID:   "teams/list-projects-legacy",
		}
	)
	params, err := decodeTeamsListProjectsLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsListProjectsLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListProjectsLegacyOperation,
			OperationSummary: "List team projects (Legacy)",
			OperationID:      "teams/list-projects-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListProjectsLegacyParams
			Response = TeamsListProjectsLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListProjectsLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListProjectsLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListProjectsLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListProjectsLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListReposInOrgRequest handles teams/list-repos-in-org operation.
//
// Lists a team's repositories visible to the authenticated user.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET
// /organizations/{org_id}/team/{team_id}/repos`.
//
// GET /orgs/{org}/teams/{team_slug}/repos
func (s *Server) handleTeamsListReposInOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-repos-in-org"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/repos"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListReposInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListReposInOrgOperation,
			ID:   "teams/list-repos-in-org",
		}
	)
	params, err := decodeTeamsListReposInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsListReposInOrgOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListReposInOrgOperation,
			OperationSummary: "List team repositories",
			OperationID:      "teams/list-repos-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListReposInOrgParams
			Response = *TeamsListReposInOrgOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListReposInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListReposInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListReposInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListReposInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsListReposLegacyRequest handles teams/list-repos-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [List team repositories](https://docs.
// github.com/rest/reference/teams#list-team-repositories) endpoint.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /teams/{team_id}/repos
func (s *Server) handleTeamsListReposLegacyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/list-repos-legacy"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/repos"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsListReposLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsListReposLegacyOperation,
			ID:   "teams/list-repos-legacy",
		}
	)
	params, err := decodeTeamsListReposLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsListReposLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsListReposLegacyOperation,
			OperationSummary: "List team repositories (Legacy)",
			OperationID:      "teams/list-repos-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsListReposLegacyParams
			Response = TeamsListReposLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsListReposLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsListReposLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsListReposLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsListReposLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsRemoveMemberLegacyRequest handles teams/remove-member-legacy operation.
//
// The "Remove team member" endpoint (described below) is deprecated.
// We recommend using the [Remove team membership for a user](https://docs.github.
// com/rest/reference/teams#remove-team-membership-for-a-user) endpoint instead. It allows you to
// remove both active and pending memberships.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// To remove a team member, the authenticated user must have 'admin' permissions to the team or be an
// owner of the org that the team is associated with. Removing a team member does not delete the user,
//
//	it just removes them from the team.
//
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/).".
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/members/{username}
func (s *Server) handleTeamsRemoveMemberLegacyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-member-legacy"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/members/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsRemoveMemberLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsRemoveMemberLegacyOperation,
			ID:   "teams/remove-member-legacy",
		}
	)
	params, err := decodeTeamsRemoveMemberLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsRemoveMemberLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsRemoveMemberLegacyOperation,
			OperationSummary: "Remove team member (Legacy)",
			OperationID:      "teams/remove-member-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveMemberLegacyParams
			Response = TeamsRemoveMemberLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveMemberLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsRemoveMemberLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsRemoveMemberLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveMemberLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsRemoveMembershipForUserInOrgRequest handles teams/remove-membership-for-user-in-org operation.
//
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// To remove a membership between a user and a team, the authenticated user must have 'admin'
// permissions to the team or be an owner of the organization that the team is associated with.
// Removing team membership does not delete the user, it just removes their membership from the team.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/memberships/{username}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}
func (s *Server) handleTeamsRemoveMembershipForUserInOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-membership-for-user-in-org"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/memberships/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsRemoveMembershipForUserInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsRemoveMembershipForUserInOrgOperation,
			ID:   "teams/remove-membership-for-user-in-org",
		}
	)
	params, err := decodeTeamsRemoveMembershipForUserInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsRemoveMembershipForUserInOrgRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsRemoveMembershipForUserInOrgOperation,
			OperationSummary: "Remove team membership for a user",
			OperationID:      "teams/remove-membership-for-user-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveMembershipForUserInOrgParams
			Response = TeamsRemoveMembershipForUserInOrgRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveMembershipForUserInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsRemoveMembershipForUserInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsRemoveMembershipForUserInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveMembershipForUserInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsRemoveMembershipForUserLegacyRequest handles teams/remove-membership-for-user-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Remove team membership for a
// user](https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user) endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more
// information, see [GitHub's products](https://help.github.
// com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
// To remove a membership between a user and a team, the authenticated user must have 'admin'
// permissions to the team or be an owner of the organization that the team is associated with.
// Removing team membership does not delete the user, it just removes their membership from the team.
// **Note:** When you have team synchronization set up for a team with your organization's identity
// provider (IdP), you will see an error if you attempt to use the API for making changes to the
// team's membership. If you have access to manage group membership in your IdP, you can manage
// GitHub team membership through your identity provider, which automatically adds and removes team
// members in an organization. For more information, see "[Synchronizing teams between your identity
// provider and GitHub](https://help.github.
// com/articles/synchronizing-teams-between-your-identity-provider-and-github/).".
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/memberships/{username}
func (s *Server) handleTeamsRemoveMembershipForUserLegacyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-membership-for-user-legacy"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/memberships/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsRemoveMembershipForUserLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsRemoveMembershipForUserLegacyOperation,
			ID:   "teams/remove-membership-for-user-legacy",
		}
	)
	params, err := decodeTeamsRemoveMembershipForUserLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsRemoveMembershipForUserLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsRemoveMembershipForUserLegacyOperation,
			OperationSummary: "Remove team membership for a user (Legacy)",
			OperationID:      "teams/remove-membership-for-user-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveMembershipForUserLegacyParams
			Response = TeamsRemoveMembershipForUserLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveMembershipForUserLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsRemoveMembershipForUserLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsRemoveMembershipForUserLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveMembershipForUserLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsRemoveProjectInOrgRequest handles teams/remove-project-in-org operation.
//
// Removes an organization project from a team. An organization owner or a team maintainer can remove
// any project from the team. To remove a project from a team as an organization member, the
// authenticated user must have `read` access to both the team and project, or `admin` access to the
// team or project. This endpoint removes the project from the team, but does not delete the project.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}
func (s *Server) handleTeamsRemoveProjectInOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-project-in-org"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/projects/{project_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsRemoveProjectInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsRemoveProjectInOrgOperation,
			ID:   "teams/remove-project-in-org",
		}
	)
	params, err := decodeTeamsRemoveProjectInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsRemoveProjectInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsRemoveProjectInOrgOperation,
			OperationSummary: "Remove a project from a team",
			OperationID:      "teams/remove-project-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveProjectInOrgParams
			Response = *TeamsRemoveProjectInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveProjectInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsRemoveProjectInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsRemoveProjectInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveProjectInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsRemoveProjectLegacyRequest handles teams/remove-project-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Remove a project from a
// team](https://docs.github.com/rest/reference/teams#remove-a-project-from-a-team) endpoint.
// Removes an organization project from a team. An organization owner or a team maintainer can remove
// any project from the team. To remove a project from a team as an organization member, the
// authenticated user must have `read` access to both the team and project, or `admin` access to the
// team or project. **Note:** This endpoint removes the project from the team, but does not delete it.
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/projects/{project_id}
func (s *Server) handleTeamsRemoveProjectLegacyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-project-legacy"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/projects/{project_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsRemoveProjectLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsRemoveProjectLegacyOperation,
			ID:   "teams/remove-project-legacy",
		}
	)
	params, err := decodeTeamsRemoveProjectLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TeamsRemoveProjectLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsRemoveProjectLegacyOperation,
			OperationSummary: "Remove a project from a team (Legacy)",
			OperationID:      "teams/remove-project-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "project_id",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveProjectLegacyParams
			Response = TeamsRemoveProjectLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveProjectLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsRemoveProjectLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsRemoveProjectLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveProjectLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsRemoveRepoInOrgRequest handles teams/remove-repo-in-org operation.
//
// If the authenticated user is an organization owner or a team maintainer, they can remove any
// repositories from the team. To remove a repository from a team as an organization member, the
// authenticated user must have admin access to the repository and must be able to see the team. This
// does not delete the repository, it just removes it from the team.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE
// /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
//
// DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}
func (s *Server) handleTeamsRemoveRepoInOrgRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-repo-in-org"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsRemoveRepoInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsRemoveRepoInOrgOperation,
			ID:   "teams/remove-repo-in-org",
		}
	)
	params, err := decodeTeamsRemoveRepoInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsRemoveRepoInOrgNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsRemoveRepoInOrgOperation,
			OperationSummary: "Remove a repository from a team",
			OperationID:      "teams/remove-repo-in-org",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveRepoInOrgParams
			Response = *TeamsRemoveRepoInOrgNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveRepoInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsRemoveRepoInOrg(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsRemoveRepoInOrg(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveRepoInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsRemoveRepoLegacyRequest handles teams/remove-repo-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Remove a repository from a
// team](https://docs.github.com/rest/reference/teams#remove-a-repository-from-a-team) endpoint.
// If the authenticated user is an organization owner or a team maintainer, they can remove any
// repositories from the team. To remove a repository from a team as an organization member, the
// authenticated user must have admin access to the repository and must be able to see the team.
// NOTE: This does not delete the repository, it just removes it from the team.
//
// Deprecated: schema marks this operation as deprecated.
//
// DELETE /teams/{team_id}/repos/{owner}/{repo}
func (s *Server) handleTeamsRemoveRepoLegacyRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/remove-repo-legacy"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/repos/{owner}/{repo}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsRemoveRepoLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsRemoveRepoLegacyOperation,
			ID:   "teams/remove-repo-legacy",
		}
	)
	params, err := decodeTeamsRemoveRepoLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *TeamsRemoveRepoLegacyNoContent
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsRemoveRepoLegacyOperation,
			OperationSummary: "Remove a repository from a team (Legacy)",
			OperationID:      "teams/remove-repo-legacy",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "owner",
					In:   "path",
				}: params.Owner,
				{
					Name: "repo",
					In:   "path",
				}: params.Repo,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TeamsRemoveRepoLegacyParams
			Response = *TeamsRemoveRepoLegacyNoContent
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsRemoveRepoLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.TeamsRemoveRepoLegacy(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.TeamsRemoveRepoLegacy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsRemoveRepoLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsUpdateDiscussionCommentInOrgRequest handles teams/update-discussion-comment-in-org operation.
//
// Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
//
// PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsUpdateDiscussionCommentInOrgRequest(args [4]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-comment-in-org"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsUpdateDiscussionCommentInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsUpdateDiscussionCommentInOrgOperation,
			ID:   "teams/update-discussion-comment-in-org",
		}
	)
	params, err := decodeTeamsUpdateDiscussionCommentInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsUpdateDiscussionCommentInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsUpdateDiscussionCommentInOrgOperation,
			OperationSummary: "Update a discussion comment",
			OperationID:      "teams/update-discussion-comment-in-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsUpdateDiscussionCommentInOrgReq
			Params   = TeamsUpdateDiscussionCommentInOrgParams
			Response = *TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateDiscussionCommentInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsUpdateDiscussionCommentInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsUpdateDiscussionCommentInOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionCommentInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsUpdateDiscussionCommentLegacyRequest handles teams/update-discussion-comment-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Update a discussion
// comment](https://docs.github.com/rest/reference/teams#update-a-discussion-comment) endpoint.
// Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion`
// [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}
func (s *Server) handleTeamsUpdateDiscussionCommentLegacyRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-comment-legacy"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsUpdateDiscussionCommentLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsUpdateDiscussionCommentLegacyOperation,
			ID:   "teams/update-discussion-comment-legacy",
		}
	)
	params, err := decodeTeamsUpdateDiscussionCommentLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsUpdateDiscussionCommentLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamDiscussionComment
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsUpdateDiscussionCommentLegacyOperation,
			OperationSummary: "Update a discussion comment (Legacy)",
			OperationID:      "teams/update-discussion-comment-legacy",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
				{
					Name: "comment_number",
					In:   "path",
				}: params.CommentNumber,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsUpdateDiscussionCommentLegacyReq
			Params   = TeamsUpdateDiscussionCommentLegacyParams
			Response = *TeamDiscussionComment
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateDiscussionCommentLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsUpdateDiscussionCommentLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsUpdateDiscussionCommentLegacy(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionCommentLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsUpdateDiscussionInOrgRequest handles teams/update-discussion-in-org operation.
//
// Edits the title and body text of a discussion post. Only the parameters you provide are updated.
// OAuth access tokens require the `write:discussion` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
// /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
//
// PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}
func (s *Server) handleTeamsUpdateDiscussionInOrgRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-in-org"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsUpdateDiscussionInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsUpdateDiscussionInOrgOperation,
			ID:   "teams/update-discussion-in-org",
		}
	)
	params, err := decodeTeamsUpdateDiscussionInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsUpdateDiscussionInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsUpdateDiscussionInOrgOperation,
			OperationSummary: "Update a discussion",
			OperationID:      "teams/update-discussion-in-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsUpdateDiscussionInOrgReq
			Params   = TeamsUpdateDiscussionInOrgParams
			Response = *TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateDiscussionInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsUpdateDiscussionInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsUpdateDiscussionInOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsUpdateDiscussionLegacyRequest handles teams/update-discussion-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Update a discussion](https://docs.github.
// com/rest/reference/teams#update-a-discussion) endpoint.
// Edits the title and body text of a discussion post. Only the parameters you provide are updated.
// OAuth access tokens require the `write:discussion` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /teams/{team_id}/discussions/{discussion_number}
func (s *Server) handleTeamsUpdateDiscussionLegacyRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-discussion-legacy"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/teams/{team_id}/discussions/{discussion_number}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsUpdateDiscussionLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsUpdateDiscussionLegacyOperation,
			ID:   "teams/update-discussion-legacy",
		}
	)
	params, err := decodeTeamsUpdateDiscussionLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsUpdateDiscussionLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamDiscussion
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsUpdateDiscussionLegacyOperation,
			OperationSummary: "Update a discussion (Legacy)",
			OperationID:      "teams/update-discussion-legacy",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
				{
					Name: "discussion_number",
					In:   "path",
				}: params.DiscussionNumber,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsUpdateDiscussionLegacyReq
			Params   = TeamsUpdateDiscussionLegacyParams
			Response = *TeamDiscussion
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateDiscussionLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsUpdateDiscussionLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsUpdateDiscussionLegacy(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateDiscussionLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsUpdateInOrgRequest handles teams/update-in-org operation.
//
// To edit a team, the authenticated user must either be an organization owner or a team maintainer.
// **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH
// /organizations/{org_id}/team/{team_id}`.
//
// PATCH /orgs/{org}/teams/{team_slug}
func (s *Server) handleTeamsUpdateInOrgRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-in-org"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/orgs/{org}/teams/{team_slug}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsUpdateInOrgOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsUpdateInOrgOperation,
			ID:   "teams/update-in-org",
		}
	)
	params, err := decodeTeamsUpdateInOrgParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsUpdateInOrgRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *TeamFull
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsUpdateInOrgOperation,
			OperationSummary: "Update a team",
			OperationID:      "teams/update-in-org",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "org",
					In:   "path",
				}: params.Org,
				{
					Name: "team_slug",
					In:   "path",
				}: params.TeamSlug,
			},
			Raw: r,
		}

		type (
			Request  = OptTeamsUpdateInOrgReq
			Params   = TeamsUpdateInOrgParams
			Response = *TeamFull
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateInOrgParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsUpdateInOrg(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsUpdateInOrg(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateInOrgResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTeamsUpdateLegacyRequest handles teams/update-legacy operation.
//
// **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new [Update a team](https://docs.github.
// com/rest/reference/teams#update-a-team) endpoint.
// To edit a team, the authenticated user must either be an organization owner or a team maintainer.
// **Note:** With nested teams, the `privacy` for parent teams cannot be `secret`.
//
// Deprecated: schema marks this operation as deprecated.
//
// PATCH /teams/{team_id}
func (s *Server) handleTeamsUpdateLegacyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("teams/update-legacy"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/teams/{team_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), TeamsUpdateLegacyOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TeamsUpdateLegacyOperation,
			ID:   "teams/update-legacy",
		}
	)
	params, err := decodeTeamsUpdateLegacyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTeamsUpdateLegacyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TeamsUpdateLegacyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TeamsUpdateLegacyOperation,
			OperationSummary: "Update a team (Legacy)",
			OperationID:      "teams/update-legacy",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "team_id",
					In:   "path",
				}: params.TeamID,
			},
			Raw: r,
		}

		type (
			Request  = *TeamsUpdateLegacyReq
			Params   = TeamsUpdateLegacyParams
			Response = TeamsUpdateLegacyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTeamsUpdateLegacyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TeamsUpdateLegacy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TeamsUpdateLegacy(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTeamsUpdateLegacyResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersAddEmailForAuthenticatedRequest handles users/add-email-for-authenticated operation.
//
// This endpoint is accessible with the `user` scope.
//
// POST /user/emails
func (s *Server) handleUsersAddEmailForAuthenticatedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/add-email-for-authenticated"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user/emails"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersAddEmailForAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersAddEmailForAuthenticatedOperation,
			ID:   "users/add-email-for-authenticated",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeUsersAddEmailForAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersAddEmailForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersAddEmailForAuthenticatedOperation,
			OperationSummary: "Add an email address for the authenticated user",
			OperationID:      "users/add-email-for-authenticated",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = OptUsersAddEmailForAuthenticatedReq
			Params   = struct{}
			Response = UsersAddEmailForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersAddEmailForAuthenticated(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersAddEmailForAuthenticated(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersAddEmailForAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersBlockRequest handles users/block operation.
//
// Block a user.
//
// PUT /user/blocks/{username}
func (s *Server) handleUsersBlockRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/block"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/user/blocks/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersBlockOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersBlockOperation,
			ID:   "users/block",
		}
	)
	params, err := decodeUsersBlockParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersBlockRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersBlockOperation,
			OperationSummary: "Block a user",
			OperationID:      "users/block",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersBlockParams
			Response = UsersBlockRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersBlockParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersBlock(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersBlock(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersBlockResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersCheckBlockedRequest handles users/check-blocked operation.
//
// Check if a user is blocked by the authenticated user.
//
// GET /user/blocks/{username}
func (s *Server) handleUsersCheckBlockedRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-blocked"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/blocks/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersCheckBlockedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersCheckBlockedOperation,
			ID:   "users/check-blocked",
		}
	)
	params, err := decodeUsersCheckBlockedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersCheckBlockedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersCheckBlockedOperation,
			OperationSummary: "Check if a user is blocked by the authenticated user",
			OperationID:      "users/check-blocked",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersCheckBlockedParams
			Response = UsersCheckBlockedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersCheckBlockedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersCheckBlocked(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersCheckBlocked(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersCheckBlockedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersCheckFollowingForUserRequest handles users/check-following-for-user operation.
//
// Check if a user follows another user.
//
// GET /users/{username}/following/{target_user}
func (s *Server) handleUsersCheckFollowingForUserRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-following-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/following/{target_user}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersCheckFollowingForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersCheckFollowingForUserOperation,
			ID:   "users/check-following-for-user",
		}
	)
	params, err := decodeUsersCheckFollowingForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersCheckFollowingForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersCheckFollowingForUserOperation,
			OperationSummary: "Check if a user follows another user",
			OperationID:      "users/check-following-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "target_user",
					In:   "path",
				}: params.TargetUser,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersCheckFollowingForUserParams
			Response = UsersCheckFollowingForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersCheckFollowingForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersCheckFollowingForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersCheckFollowingForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersCheckFollowingForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersCheckPersonIsFollowedByAuthenticatedRequest handles users/check-person-is-followed-by-authenticated operation.
//
// Check if a person is followed by the authenticated user.
//
// GET /user/following/{username}
func (s *Server) handleUsersCheckPersonIsFollowedByAuthenticatedRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/check-person-is-followed-by-authenticated"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/following/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersCheckPersonIsFollowedByAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersCheckPersonIsFollowedByAuthenticatedOperation,
			ID:   "users/check-person-is-followed-by-authenticated",
		}
	)
	params, err := decodeUsersCheckPersonIsFollowedByAuthenticatedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersCheckPersonIsFollowedByAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersCheckPersonIsFollowedByAuthenticatedOperation,
			OperationSummary: "Check if a person is followed by the authenticated user",
			OperationID:      "users/check-person-is-followed-by-authenticated",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersCheckPersonIsFollowedByAuthenticatedParams
			Response = UsersCheckPersonIsFollowedByAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersCheckPersonIsFollowedByAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersCheckPersonIsFollowedByAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersCheckPersonIsFollowedByAuthenticated(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersCheckPersonIsFollowedByAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersCreateGpgKeyForAuthenticatedRequest handles users/create-gpg-key-for-authenticated operation.
//
// Adds a GPG key to the authenticated user's GitHub account. Requires that you are authenticated via
// Basic Auth, or OAuth with at least `write:gpg_key` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// POST /user/gpg_keys
func (s *Server) handleUsersCreateGpgKeyForAuthenticatedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/create-gpg-key-for-authenticated"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user/gpg_keys"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersCreateGpgKeyForAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersCreateGpgKeyForAuthenticatedOperation,
			ID:   "users/create-gpg-key-for-authenticated",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeUsersCreateGpgKeyForAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersCreateGpgKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersCreateGpgKeyForAuthenticatedOperation,
			OperationSummary: "Create a GPG key for the authenticated user",
			OperationID:      "users/create-gpg-key-for-authenticated",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *UsersCreateGpgKeyForAuthenticatedReq
			Params   = struct{}
			Response = UsersCreateGpgKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersCreateGpgKeyForAuthenticated(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersCreateGpgKeyForAuthenticated(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersCreateGpgKeyForAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersCreatePublicSSHKeyForAuthenticatedRequest handles users/create-public-ssh-key-for-authenticated operation.
//
// Adds a public SSH key to the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth, or OAuth with at least `write:public_key` [scope](https://docs.
// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// POST /user/keys
func (s *Server) handleUsersCreatePublicSSHKeyForAuthenticatedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/create-public-ssh-key-for-authenticated"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user/keys"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersCreatePublicSSHKeyForAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersCreatePublicSSHKeyForAuthenticatedOperation,
			ID:   "users/create-public-ssh-key-for-authenticated",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeUsersCreatePublicSSHKeyForAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersCreatePublicSSHKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersCreatePublicSSHKeyForAuthenticatedOperation,
			OperationSummary: "Create a public SSH key for the authenticated user",
			OperationID:      "users/create-public-ssh-key-for-authenticated",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *UsersCreatePublicSSHKeyForAuthenticatedReq
			Params   = struct{}
			Response = UsersCreatePublicSSHKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersCreatePublicSSHKeyForAuthenticated(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersCreatePublicSSHKeyForAuthenticated(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersCreatePublicSSHKeyForAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersDeleteEmailForAuthenticatedRequest handles users/delete-email-for-authenticated operation.
//
// This endpoint is accessible with the `user` scope.
//
// DELETE /user/emails
func (s *Server) handleUsersDeleteEmailForAuthenticatedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-email-for-authenticated"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/emails"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersDeleteEmailForAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersDeleteEmailForAuthenticatedOperation,
			ID:   "users/delete-email-for-authenticated",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeUsersDeleteEmailForAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersDeleteEmailForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersDeleteEmailForAuthenticatedOperation,
			OperationSummary: "Delete an email address for the authenticated user",
			OperationID:      "users/delete-email-for-authenticated",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = OptUsersDeleteEmailForAuthenticatedReq
			Params   = struct{}
			Response = UsersDeleteEmailForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersDeleteEmailForAuthenticated(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersDeleteEmailForAuthenticated(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersDeleteEmailForAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersDeleteGpgKeyForAuthenticatedRequest handles users/delete-gpg-key-for-authenticated operation.
//
// Removes a GPG key from the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth or via OAuth with at least `admin:gpg_key` [scope](https://docs.
// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /user/gpg_keys/{gpg_key_id}
func (s *Server) handleUsersDeleteGpgKeyForAuthenticatedRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-gpg-key-for-authenticated"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/gpg_keys/{gpg_key_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersDeleteGpgKeyForAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersDeleteGpgKeyForAuthenticatedOperation,
			ID:   "users/delete-gpg-key-for-authenticated",
		}
	)
	params, err := decodeUsersDeleteGpgKeyForAuthenticatedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersDeleteGpgKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersDeleteGpgKeyForAuthenticatedOperation,
			OperationSummary: "Delete a GPG key for the authenticated user",
			OperationID:      "users/delete-gpg-key-for-authenticated",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "gpg_key_id",
					In:   "path",
				}: params.GpgKeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersDeleteGpgKeyForAuthenticatedParams
			Response = UsersDeleteGpgKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersDeleteGpgKeyForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersDeleteGpgKeyForAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersDeleteGpgKeyForAuthenticated(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersDeleteGpgKeyForAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersDeletePublicSSHKeyForAuthenticatedRequest handles users/delete-public-ssh-key-for-authenticated operation.
//
// Removes a public SSH key from the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth or via OAuth with at least `admin:public_key` [scope](https://docs.
// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// DELETE /user/keys/{key_id}
func (s *Server) handleUsersDeletePublicSSHKeyForAuthenticatedRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/delete-public-ssh-key-for-authenticated"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/keys/{key_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersDeletePublicSSHKeyForAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersDeletePublicSSHKeyForAuthenticatedOperation,
			ID:   "users/delete-public-ssh-key-for-authenticated",
		}
	)
	params, err := decodeUsersDeletePublicSSHKeyForAuthenticatedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersDeletePublicSSHKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersDeletePublicSSHKeyForAuthenticatedOperation,
			OperationSummary: "Delete a public SSH key for the authenticated user",
			OperationID:      "users/delete-public-ssh-key-for-authenticated",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "key_id",
					In:   "path",
				}: params.KeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersDeletePublicSSHKeyForAuthenticatedParams
			Response = UsersDeletePublicSSHKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersDeletePublicSSHKeyForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersDeletePublicSSHKeyForAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersDeletePublicSSHKeyForAuthenticated(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersDeletePublicSSHKeyForAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersFollowRequest handles users/follow operation.
//
// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more
// information, see "[HTTP verbs](https://docs.github.
// com/rest/overview/resources-in-the-rest-api#http-verbs)."
// Following a user requires the user to be logged in and authenticated with basic auth or OAuth with
// the `user:follow` scope.
//
// PUT /user/following/{username}
func (s *Server) handleUsersFollowRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/follow"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/user/following/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersFollowOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersFollowOperation,
			ID:   "users/follow",
		}
	)
	params, err := decodeUsersFollowParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersFollowRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersFollowOperation,
			OperationSummary: "Follow a user",
			OperationID:      "users/follow",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersFollowParams
			Response = UsersFollowRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersFollowParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersFollow(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersFollow(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersFollowResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersGetAuthenticatedRequest handles users/get-authenticated operation.
//
// If the authenticated user is authenticated through basic authentication or OAuth with the `user`
// scope, then the response lists public and private profile information.
// If the authenticated user is authenticated through OAuth without the `user` scope, then the
// response lists only public profile information.
//
// GET /user
func (s *Server) handleUsersGetAuthenticatedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-authenticated"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersGetAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err error
	)

	var rawBody []byte

	var response UsersGetAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersGetAuthenticatedOperation,
			OperationSummary: "Get the authenticated user",
			OperationID:      "users/get-authenticated",
			Body:             nil,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = UsersGetAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersGetAuthenticated(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersGetAuthenticated(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersGetAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersGetByUsernameRequest handles users/get-by-username operation.
//
// Provides publicly available information about someone with a GitHub account.
// GitHub Apps with the `Plan` user permission can use this endpoint to retrieve information about a
// user's GitHub plan. The GitHub App must be authenticated as a user. See "[Identifying and
// authorizing users for GitHub Apps](https://docs.github.
// com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/)" for details
// about authentication. For an example response, see 'Response with GitHub plan information' below"
// The `email` key in the following response is the publicly visible email address from your GitHub
// [profile page](https://github.com/settings/profile). When setting up your profile, you can select
// a primary email address to be “public” which provides an email entry for this endpoint. If you
// do not set a public email address for `email`, then it will have a value of `null`. You only see
// publicly visible email addresses when authenticated with GitHub. For more information, see
// [Authentication](https://docs.github.com/rest/overview/resources-in-the-rest-api#authentication).
// The Emails API enables you to list all of your email addresses, and toggle a primary email to be
// visible publicly. For more information, see "[Emails API](https://docs.github.
// com/rest/reference/users#emails)".
//
// GET /users/{username}
func (s *Server) handleUsersGetByUsernameRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-by-username"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersGetByUsernameOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersGetByUsernameOperation,
			ID:   "users/get-by-username",
		}
	)
	params, err := decodeUsersGetByUsernameParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersGetByUsernameRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersGetByUsernameOperation,
			OperationSummary: "Get a user",
			OperationID:      "users/get-by-username",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersGetByUsernameParams
			Response = UsersGetByUsernameRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersGetByUsernameParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersGetByUsername(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersGetByUsername(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersGetByUsernameResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersGetContextForUserRequest handles users/get-context-for-user operation.
//
// Provides hovercard information when authenticated through basic auth or OAuth with the `repo`
// scope. You can find out more about someone in relation to their pull requests, issues,
// repositories, and organizations.
// The `subject_type` and `subject_id` parameters provide context for the person's hovercard, which
// returns more information than without the parameters. For example, if you wanted to find out more
// about `octocat` who owns the `Spoon-Knife` repository via cURL, it would look like this:
// ```shell
// curl -u username:token
// https://api.github.com/users/octocat/hovercard?subject_type=repository&subject_id=1300192
// ```.
//
// GET /users/{username}/hovercard
func (s *Server) handleUsersGetContextForUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-context-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/hovercard"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersGetContextForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersGetContextForUserOperation,
			ID:   "users/get-context-for-user",
		}
	)
	params, err := decodeUsersGetContextForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersGetContextForUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersGetContextForUserOperation,
			OperationSummary: "Get contextual information for a user",
			OperationID:      "users/get-context-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "subject_type",
					In:   "query",
				}: params.SubjectType,
				{
					Name: "subject_id",
					In:   "query",
				}: params.SubjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersGetContextForUserParams
			Response = UsersGetContextForUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersGetContextForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersGetContextForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersGetContextForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersGetContextForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersGetGpgKeyForAuthenticatedRequest handles users/get-gpg-key-for-authenticated operation.
//
// View extended details for a single GPG key. Requires that you are authenticated via Basic Auth or
// via OAuth with at least `read:gpg_key` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /user/gpg_keys/{gpg_key_id}
func (s *Server) handleUsersGetGpgKeyForAuthenticatedRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-gpg-key-for-authenticated"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/gpg_keys/{gpg_key_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersGetGpgKeyForAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersGetGpgKeyForAuthenticatedOperation,
			ID:   "users/get-gpg-key-for-authenticated",
		}
	)
	params, err := decodeUsersGetGpgKeyForAuthenticatedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersGetGpgKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersGetGpgKeyForAuthenticatedOperation,
			OperationSummary: "Get a GPG key for the authenticated user",
			OperationID:      "users/get-gpg-key-for-authenticated",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "gpg_key_id",
					In:   "path",
				}: params.GpgKeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersGetGpgKeyForAuthenticatedParams
			Response = UsersGetGpgKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersGetGpgKeyForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersGetGpgKeyForAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersGetGpgKeyForAuthenticated(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersGetGpgKeyForAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersGetPublicSSHKeyForAuthenticatedRequest handles users/get-public-ssh-key-for-authenticated operation.
//
// View extended details for a single public SSH key. Requires that you are authenticated via Basic
// Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /user/keys/{key_id}
func (s *Server) handleUsersGetPublicSSHKeyForAuthenticatedRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/get-public-ssh-key-for-authenticated"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/keys/{key_id}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersGetPublicSSHKeyForAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersGetPublicSSHKeyForAuthenticatedOperation,
			ID:   "users/get-public-ssh-key-for-authenticated",
		}
	)
	params, err := decodeUsersGetPublicSSHKeyForAuthenticatedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersGetPublicSSHKeyForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersGetPublicSSHKeyForAuthenticatedOperation,
			OperationSummary: "Get a public SSH key for the authenticated user",
			OperationID:      "users/get-public-ssh-key-for-authenticated",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "key_id",
					In:   "path",
				}: params.KeyID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersGetPublicSSHKeyForAuthenticatedParams
			Response = UsersGetPublicSSHKeyForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersGetPublicSSHKeyForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersGetPublicSSHKeyForAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersGetPublicSSHKeyForAuthenticated(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersGetPublicSSHKeyForAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersListRequest handles users/list operation.
//
// Lists all users, in the order that they signed up on GitHub. This list includes personal user
// accounts and organization accounts.
// Note: Pagination is powered exclusively by the `since` parameter. Use the [Link
// header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the
// URL for the next page of users.
//
// GET /users
func (s *Server) handleUsersListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersListOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersListOperation,
			ID:   "users/list",
		}
	)
	params, err := decodeUsersListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersListOperation,
			OperationSummary: "List users",
			OperationID:      "users/list",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "since",
					In:   "query",
				}: params.Since,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListParams
			Response = UsersListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersListBlockedByAuthenticatedRequest handles users/list-blocked-by-authenticated operation.
//
// List the users you've blocked on your personal account.
//
// GET /user/blocks
func (s *Server) handleUsersListBlockedByAuthenticatedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-blocked-by-authenticated"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/blocks"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersListBlockedByAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err error
	)

	var rawBody []byte

	var response UsersListBlockedByAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersListBlockedByAuthenticatedOperation,
			OperationSummary: "List users blocked by the authenticated user",
			OperationID:      "users/list-blocked-by-authenticated",
			Body:             nil,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = UsersListBlockedByAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListBlockedByAuthenticated(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListBlockedByAuthenticated(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListBlockedByAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersListEmailsForAuthenticatedRequest handles users/list-emails-for-authenticated operation.
//
// Lists all of your email addresses, and specifies which one is visible to the public. This endpoint
// is accessible with the `user:email` scope.
//
// GET /user/emails
func (s *Server) handleUsersListEmailsForAuthenticatedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-emails-for-authenticated"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/emails"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersListEmailsForAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersListEmailsForAuthenticatedOperation,
			ID:   "users/list-emails-for-authenticated",
		}
	)
	params, err := decodeUsersListEmailsForAuthenticatedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersListEmailsForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersListEmailsForAuthenticatedOperation,
			OperationSummary: "List email addresses for the authenticated user",
			OperationID:      "users/list-emails-for-authenticated",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListEmailsForAuthenticatedParams
			Response = UsersListEmailsForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListEmailsForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListEmailsForAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListEmailsForAuthenticated(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListEmailsForAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersListFollowedByAuthenticatedRequest handles users/list-followed-by-authenticated operation.
//
// Lists the people who the authenticated user follows.
//
// GET /user/following
func (s *Server) handleUsersListFollowedByAuthenticatedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followed-by-authenticated"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/following"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersListFollowedByAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersListFollowedByAuthenticatedOperation,
			ID:   "users/list-followed-by-authenticated",
		}
	)
	params, err := decodeUsersListFollowedByAuthenticatedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersListFollowedByAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersListFollowedByAuthenticatedOperation,
			OperationSummary: "List the people the authenticated user follows",
			OperationID:      "users/list-followed-by-authenticated",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListFollowedByAuthenticatedParams
			Response = UsersListFollowedByAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListFollowedByAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListFollowedByAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListFollowedByAuthenticated(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListFollowedByAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersListFollowersForAuthenticatedUserRequest handles users/list-followers-for-authenticated-user operation.
//
// Lists the people following the authenticated user.
//
// GET /user/followers
func (s *Server) handleUsersListFollowersForAuthenticatedUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followers-for-authenticated-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/followers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersListFollowersForAuthenticatedUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersListFollowersForAuthenticatedUserOperation,
			ID:   "users/list-followers-for-authenticated-user",
		}
	)
	params, err := decodeUsersListFollowersForAuthenticatedUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersListFollowersForAuthenticatedUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersListFollowersForAuthenticatedUserOperation,
			OperationSummary: "List followers of the authenticated user",
			OperationID:      "users/list-followers-for-authenticated-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListFollowersForAuthenticatedUserParams
			Response = UsersListFollowersForAuthenticatedUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListFollowersForAuthenticatedUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListFollowersForAuthenticatedUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListFollowersForAuthenticatedUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListFollowersForAuthenticatedUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersListFollowersForUserRequest handles users/list-followers-for-user operation.
//
// Lists the people following the specified user.
//
// GET /users/{username}/followers
func (s *Server) handleUsersListFollowersForUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-followers-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/followers"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersListFollowersForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersListFollowersForUserOperation,
			ID:   "users/list-followers-for-user",
		}
	)
	params, err := decodeUsersListFollowersForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *UsersListFollowersForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersListFollowersForUserOperation,
			OperationSummary: "List followers of a user",
			OperationID:      "users/list-followers-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListFollowersForUserParams
			Response = *UsersListFollowersForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListFollowersForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListFollowersForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListFollowersForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListFollowersForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersListFollowingForUserRequest handles users/list-following-for-user operation.
//
// Lists the people who the specified user follows.
//
// GET /users/{username}/following
func (s *Server) handleUsersListFollowingForUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-following-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/following"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersListFollowingForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersListFollowingForUserOperation,
			ID:   "users/list-following-for-user",
		}
	)
	params, err := decodeUsersListFollowingForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *UsersListFollowingForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersListFollowingForUserOperation,
			OperationSummary: "List the people a user follows",
			OperationID:      "users/list-following-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListFollowingForUserParams
			Response = *UsersListFollowingForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListFollowingForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListFollowingForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListFollowingForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListFollowingForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersListGpgKeysForAuthenticatedRequest handles users/list-gpg-keys-for-authenticated operation.
//
// Lists the current user's GPG keys. Requires that you are authenticated via Basic Auth or via OAuth
// with at least `read:gpg_key` [scope](https://docs.github.
// com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /user/gpg_keys
func (s *Server) handleUsersListGpgKeysForAuthenticatedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-gpg-keys-for-authenticated"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/gpg_keys"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersListGpgKeysForAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersListGpgKeysForAuthenticatedOperation,
			ID:   "users/list-gpg-keys-for-authenticated",
		}
	)
	params, err := decodeUsersListGpgKeysForAuthenticatedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersListGpgKeysForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersListGpgKeysForAuthenticatedOperation,
			OperationSummary: "List GPG keys for the authenticated user",
			OperationID:      "users/list-gpg-keys-for-authenticated",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListGpgKeysForAuthenticatedParams
			Response = UsersListGpgKeysForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListGpgKeysForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListGpgKeysForAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListGpgKeysForAuthenticated(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListGpgKeysForAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersListGpgKeysForUserRequest handles users/list-gpg-keys-for-user operation.
//
// Lists the GPG keys for a user. This information is accessible by anyone.
//
// GET /users/{username}/gpg_keys
func (s *Server) handleUsersListGpgKeysForUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-gpg-keys-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/gpg_keys"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersListGpgKeysForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersListGpgKeysForUserOperation,
			ID:   "users/list-gpg-keys-for-user",
		}
	)
	params, err := decodeUsersListGpgKeysForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *UsersListGpgKeysForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersListGpgKeysForUserOperation,
			OperationSummary: "List GPG keys for a user",
			OperationID:      "users/list-gpg-keys-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListGpgKeysForUserParams
			Response = *UsersListGpgKeysForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListGpgKeysForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListGpgKeysForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListGpgKeysForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListGpgKeysForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersListPublicEmailsForAuthenticatedRequest handles users/list-public-emails-for-authenticated operation.
//
// Lists your publicly visible email address, which you can set with the [Set primary email
// visibility for the authenticated user](https://docs.github.
// com/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user) endpoint. This
// endpoint is accessible with the `user:email` scope.
//
// GET /user/public_emails
func (s *Server) handleUsersListPublicEmailsForAuthenticatedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-emails-for-authenticated"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/public_emails"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersListPublicEmailsForAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersListPublicEmailsForAuthenticatedOperation,
			ID:   "users/list-public-emails-for-authenticated",
		}
	)
	params, err := decodeUsersListPublicEmailsForAuthenticatedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersListPublicEmailsForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersListPublicEmailsForAuthenticatedOperation,
			OperationSummary: "List public email addresses for the authenticated user",
			OperationID:      "users/list-public-emails-for-authenticated",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListPublicEmailsForAuthenticatedParams
			Response = UsersListPublicEmailsForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListPublicEmailsForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListPublicEmailsForAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListPublicEmailsForAuthenticated(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListPublicEmailsForAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersListPublicKeysForUserRequest handles users/list-public-keys-for-user operation.
//
// Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
//
// GET /users/{username}/keys
func (s *Server) handleUsersListPublicKeysForUserRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-keys-for-user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/users/{username}/keys"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersListPublicKeysForUserOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersListPublicKeysForUserOperation,
			ID:   "users/list-public-keys-for-user",
		}
	)
	params, err := decodeUsersListPublicKeysForUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response *UsersListPublicKeysForUserOKHeaders
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersListPublicKeysForUserOperation,
			OperationSummary: "List public keys for a user",
			OperationID:      "users/list-public-keys-for-user",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListPublicKeysForUserParams
			Response = *UsersListPublicKeysForUserOKHeaders
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListPublicKeysForUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListPublicKeysForUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListPublicKeysForUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListPublicKeysForUserResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersListPublicSSHKeysForAuthenticatedRequest handles users/list-public-ssh-keys-for-authenticated operation.
//
// Lists the public SSH keys for the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.
// github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
//
// GET /user/keys
func (s *Server) handleUsersListPublicSSHKeysForAuthenticatedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/list-public-ssh-keys-for-authenticated"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user/keys"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersListPublicSSHKeysForAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersListPublicSSHKeysForAuthenticatedOperation,
			ID:   "users/list-public-ssh-keys-for-authenticated",
		}
	)
	params, err := decodeUsersListPublicSSHKeysForAuthenticatedParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersListPublicSSHKeysForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersListPublicSSHKeysForAuthenticatedOperation,
			OperationSummary: "List public SSH keys for the authenticated user",
			OperationID:      "users/list-public-ssh-keys-for-authenticated",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "per_page",
					In:   "query",
				}: params.PerPage,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersListPublicSSHKeysForAuthenticatedParams
			Response = UsersListPublicSSHKeysForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersListPublicSSHKeysForAuthenticatedParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersListPublicSSHKeysForAuthenticated(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersListPublicSSHKeysForAuthenticated(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersListPublicSSHKeysForAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersSetPrimaryEmailVisibilityForAuthenticatedRequest handles users/set-primary-email-visibility-for-authenticated operation.
//
// Sets the visibility for your primary email addresses.
//
// PATCH /user/email/visibility
func (s *Server) handleUsersSetPrimaryEmailVisibilityForAuthenticatedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/set-primary-email-visibility-for-authenticated"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/user/email/visibility"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersSetPrimaryEmailVisibilityForAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersSetPrimaryEmailVisibilityForAuthenticatedOperation,
			ID:   "users/set-primary-email-visibility-for-authenticated",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeUsersSetPrimaryEmailVisibilityForAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersSetPrimaryEmailVisibilityForAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersSetPrimaryEmailVisibilityForAuthenticatedOperation,
			OperationSummary: "Set primary email visibility for the authenticated user",
			OperationID:      "users/set-primary-email-visibility-for-authenticated",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *UsersSetPrimaryEmailVisibilityForAuthenticatedReq
			Params   = struct{}
			Response = UsersSetPrimaryEmailVisibilityForAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersSetPrimaryEmailVisibilityForAuthenticated(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersSetPrimaryEmailVisibilityForAuthenticated(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersSetPrimaryEmailVisibilityForAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersUnblockRequest handles users/unblock operation.
//
// Unblock a user.
//
// DELETE /user/blocks/{username}
func (s *Server) handleUsersUnblockRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/unblock"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/blocks/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersUnblockOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersUnblockOperation,
			ID:   "users/unblock",
		}
	)
	params, err := decodeUsersUnblockParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersUnblockRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersUnblockOperation,
			OperationSummary: "Unblock a user",
			OperationID:      "users/unblock",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersUnblockParams
			Response = UsersUnblockRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersUnblockParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersUnblock(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersUnblock(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersUnblockResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersUnfollowRequest handles users/unfollow operation.
//
// Unfollowing a user requires the user to be logged in and authenticated with basic auth or OAuth
// with the `user:follow` scope.
//
// DELETE /user/following/{username}
func (s *Server) handleUsersUnfollowRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/unfollow"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/user/following/{username}"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersUnfollowOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersUnfollowOperation,
			ID:   "users/unfollow",
		}
	)
	params, err := decodeUsersUnfollowParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UsersUnfollowRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersUnfollowOperation,
			OperationSummary: "Unfollow a user",
			OperationID:      "users/unfollow",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "username",
					In:   "path",
				}: params.Username,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UsersUnfollowParams
			Response = UsersUnfollowRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUsersUnfollowParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersUnfollow(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersUnfollow(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersUnfollowResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUsersUpdateAuthenticatedRequest handles users/update-authenticated operation.
//
// **Note:** If your email is set to private and you send an `email` parameter as part of this
// request to update your profile, your privacy settings are still enforced: the email address will
// not be displayed on your public profile or via the API.
//
// PATCH /user
func (s *Server) handleUsersUpdateAuthenticatedRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("users/update-authenticated"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/user"),
	}

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), UsersUpdateAuthenticatedOperation,
		trace.WithAttributes(otelAttrs...),
		serverSpanKind,
	)
	defer span.End()

	// Add Labeler to context.
	labeler := &Labeler{attrs: otelAttrs}
	ctx = contextWithLabeler(ctx, labeler)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)

		attrSet := labeler.AttributeSet()
		attrs := attrSet.ToSlice()
		code := statusWriter.status
		if code != 0 {
			codeAttr := semconv.HTTPResponseStatusCode(code)
			attrs = append(attrs, codeAttr)
			span.SetAttributes(codeAttr)
		}
		attrOpt := metric.WithAttributes(attrs...)

		// Increment request counter.
		s.requests.Add(ctx, 1, attrOpt)

		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), attrOpt)
	}()

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)

			// https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
			// Span Status MUST be left unset if HTTP status code was in the 1xx, 2xx or 3xx ranges,
			// unless there was another error (e.g., network error receiving the response body; or 3xx codes with
			// max redirects exceeded), in which case status MUST be set to Error.
			code := statusWriter.status
			if code < 100 || code >= 500 {
				span.SetStatus(codes.Error, stage)
			}

			attrSet := labeler.AttributeSet()
			attrs := attrSet.ToSlice()
			if code != 0 {
				attrs = append(attrs, semconv.HTTPResponseStatusCode(code))
			}

			s.errors.Add(ctx, 1, metric.WithAttributes(attrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UsersUpdateAuthenticatedOperation,
			ID:   "users/update-authenticated",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeUsersUpdateAuthenticatedRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UsersUpdateAuthenticatedRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UsersUpdateAuthenticatedOperation,
			OperationSummary: "Update the authenticated user",
			OperationID:      "users/update-authenticated",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = OptUsersUpdateAuthenticatedReq
			Params   = struct{}
			Response = UsersUpdateAuthenticatedRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UsersUpdateAuthenticated(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UsersUpdateAuthenticated(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUsersUpdateAuthenticatedResponse(response, w, span); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}
