// Code generated by ogen, DO NOT EDIT.

package api

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAPIOverview_EncodeDecode(t *testing.T) {
	var typ APIOverview
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 APIOverview
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAPIOverview_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"actions\":[\"13.64.0.0/16\",\"13.65.0.0/16\"],\"api\":[\"192.30.252.0/22\",\"185.199.108.0/22\"],\"dependabot\":[\"54.158.161.132\"],\"git\":[\"192.30.252.0/22\"],\"hooks\":[\"192.30.252.0/22\"],\"importer\":[\"54.158.161.132\",\"54.226.70.38\"],\"packages\":[\"192.30.252.0/22\"],\"pages\":[\"192.30.252.153/32\",\"192.30.252.154/32\"],\"ssh_key_fingerprints\":{\"SHA256_DSA\":\"br9IjFspm1vxR3iA35FWE+4VTyz1hYVLIE2t1/CeyWQ\",\"SHA256_ECDSA\":\"p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM\",\"SHA256_ED25519\":\"+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU\",\"SHA256_RSA\":\"nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8\"},\"verifiable_password_authentication\":true,\"web\":[\"192.30.252.0/22\",\"185.199.108.0/22\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ APIOverview

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 APIOverview
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestAPIOverviewSSHKeyFingerprints_EncodeDecode(t *testing.T) {
	var typ APIOverviewSSHKeyFingerprints
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 APIOverviewSSHKeyFingerprints
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAccepted_EncodeDecode(t *testing.T) {
	var typ Accepted
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Accepted
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionsApproveWorkflowRunForbidden_EncodeDecode(t *testing.T) {
	var typ ActionsApproveWorkflowRunForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsApproveWorkflowRunForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionsApproveWorkflowRunNotFound_EncodeDecode(t *testing.T) {
	var typ ActionsApproveWorkflowRunNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsApproveWorkflowRunNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionsBillingUsage_EncodeDecode(t *testing.T) {
	var typ ActionsBillingUsage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsBillingUsage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsBillingUsage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"included_minutes\":3000,\"minutes_used_breakdown\":{\"MACOS\":10,\"UBUNTU\":205,\"WINDOWS\":90},\"total_minutes_used\":305,\"total_paid_minutes_used\":0}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsBillingUsage

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsBillingUsage
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsBillingUsageMinutesUsedBreakdown_EncodeDecode(t *testing.T) {
	var typ ActionsBillingUsageMinutesUsedBreakdown
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsBillingUsageMinutesUsedBreakdown
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionsCancelWorkflowRunAccepted_EncodeDecode(t *testing.T) {
	var typ ActionsCancelWorkflowRunAccepted
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsCancelWorkflowRunAccepted
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionsCreateOrUpdateEnvironmentSecretReq_EncodeDecode(t *testing.T) {
	var typ ActionsCreateOrUpdateEnvironmentSecretReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsCreateOrUpdateEnvironmentSecretReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsCreateOrUpdateEnvironmentSecretReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"encrypted_value\":\"c2VjcmV0\",\"key_id\":\"012345678912345678\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsCreateOrUpdateEnvironmentSecretReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsCreateOrUpdateEnvironmentSecretReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsCreateOrUpdateOrgSecretReq_EncodeDecode(t *testing.T) {
	var typ ActionsCreateOrUpdateOrgSecretReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsCreateOrUpdateOrgSecretReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsCreateOrUpdateOrgSecretReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"encrypted_value\":\"c2VjcmV0\",\"key_id\":\"012345678912345678\",\"selected_repository_ids\":[\"1296269\",\"1296280\"],\"visibility\":\"selected\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsCreateOrUpdateOrgSecretReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsCreateOrUpdateOrgSecretReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsCreateOrUpdateOrgSecretReqVisibility_EncodeDecode(t *testing.T) {
	var typ ActionsCreateOrUpdateOrgSecretReqVisibility
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsCreateOrUpdateOrgSecretReqVisibility
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionsCreateOrUpdateRepoSecretCreated_EncodeDecode(t *testing.T) {
	var typ ActionsCreateOrUpdateRepoSecretCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsCreateOrUpdateRepoSecretCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionsCreateOrUpdateRepoSecretReq_EncodeDecode(t *testing.T) {
	var typ ActionsCreateOrUpdateRepoSecretReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsCreateOrUpdateRepoSecretReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsCreateOrUpdateRepoSecretReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"encrypted_value\":\"c2VjcmV0\",\"key_id\":\"012345678912345678\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsCreateOrUpdateRepoSecretReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsCreateOrUpdateRepoSecretReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsCreateSelfHostedRunnerGroupForOrgReq_EncodeDecode(t *testing.T) {
	var typ ActionsCreateSelfHostedRunnerGroupForOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsCreateSelfHostedRunnerGroupForOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsCreateSelfHostedRunnerGroupForOrgReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"name\":\"Expensive hardware runners\",\"runners\":[9,2],\"selected_repository_ids\":[32,91],\"visibility\":\"selected\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsCreateSelfHostedRunnerGroupForOrgReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsCreateSelfHostedRunnerGroupForOrgReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsCreateSelfHostedRunnerGroupForOrgReqVisibility_EncodeDecode(t *testing.T) {
	var typ ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionsEnabled_EncodeDecode(t *testing.T) {
	var typ ActionsEnabled
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsEnabled
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionsEnterprisePermissions_EncodeDecode(t *testing.T) {
	var typ ActionsEnterprisePermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsEnterprisePermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsEnterprisePermissions_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"allowed_actions\":\"selected\",\"enabled_organizations\":\"all\",\"selected_actions_url\":\"https://api.github.com/enterprises/2/actions/permissions/selected-actions\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsEnterprisePermissions

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsEnterprisePermissions
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsListArtifactsForRepoOK_EncodeDecode(t *testing.T) {
	var typ ActionsListArtifactsForRepoOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsListArtifactsForRepoOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsListArtifactsForRepoOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"artifacts\":[{\"archive_download_url\":\"https://api.github.com/repos/octo-org/octo-docs/actions/artifacts/11/zip\",\"created_at\":\"2020-01-10T14:59:22Z\",\"expired\":false,\"expires_at\":\"2020-03-21T14:59:22Z\",\"id\":11,\"name\":\"Rails\",\"node_id\":\"MDg6QXJ0aWZhY3QxMQ==\",\"size_in_bytes\":556,\"updated_at\":\"2020-02-21T14:59:22Z\",\"url\":\"https://api.github.com/repos/octo-org/octo-docs/actions/artifacts/11\"},{\"archive_download_url\":\"https://api.github.com/repos/octo-org/octo-docs/actions/artifacts/13/zip\",\"created_at\":\"2020-01-10T14:59:22Z\",\"expired\":false,\"expires_at\":\"2020-03-21T14:59:22Z\",\"id\":13,\"name\":\"\",\"node_id\":\"MDg6QXJ0aWZhY3QxMw==\",\"size_in_bytes\":453,\"updated_at\":\"2020-02-21T14:59:22Z\",\"url\":\"https://api.github.com/repos/octo-org/octo-docs/actions/artifacts/13\"}],\"total_count\":2}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsListArtifactsForRepoOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsListArtifactsForRepoOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsListEnvironmentSecretsOK_EncodeDecode(t *testing.T) {
	var typ ActionsListEnvironmentSecretsOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsListEnvironmentSecretsOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsListEnvironmentSecretsOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"secrets\":[{\"created_at\":\"2019-08-10T14:59:22Z\",\"name\":\"GH_TOKEN\",\"updated_at\":\"2020-01-10T14:59:22Z\"},{\"created_at\":\"2020-01-10T10:59:22Z\",\"name\":\"GIST_ID\",\"updated_at\":\"2020-01-11T11:59:22Z\"}],\"total_count\":2}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsListEnvironmentSecretsOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsListEnvironmentSecretsOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsListJobsForWorkflowRunOK_EncodeDecode(t *testing.T) {
	var typ ActionsListJobsForWorkflowRunOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsListJobsForWorkflowRunOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsListJobsForWorkflowRunOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"jobs\":[{\"check_run_url\":\"https://api.github.com/repos/octo-org/octo-repo/check-runs/399444496\",\"completed_at\":\"2020-01-20T17:44:39Z\",\"conclusion\":\"success\",\"head_sha\":\"f83a356604ae3c5d03e1b46ef4d1ca77d64a90b0\",\"html_url\":\"https://github.com/octo-org/octo-repo/runs/399444496\",\"id\":399444496,\"name\":\"build\",\"node_id\":\"MDEyOldvcmtmbG93IEpvYjM5OTQ0NDQ5Ng==\",\"run_id\":29679449,\"run_url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/runs/29679449\",\"started_at\":\"2020-01-20T17:42:40Z\",\"status\":\"completed\",\"steps\":[{\"completed_at\":\"2020-01-20T09:42:41.000-08:00\",\"conclusion\":\"success\",\"name\":\"Set up job\",\"number\":1,\"started_at\":\"2020-01-20T09:42:40.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:42:45.000-08:00\",\"conclusion\":\"success\",\"name\":\"Run actions/checkout@v2\",\"number\":2,\"started_at\":\"2020-01-20T09:42:41.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:42:45.000-08:00\",\"conclusion\":\"success\",\"name\":\"Set up Ruby\",\"number\":3,\"started_at\":\"2020-01-20T09:42:45.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:42:48.000-08:00\",\"conclusion\":\"success\",\"name\":\"Run actions/cache@v2\",\"number\":4,\"started_at\":\"2020-01-20T09:42:45.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:42:52.000-08:00\",\"conclusion\":\"success\",\"name\":\"Install Bundler\",\"number\":5,\"started_at\":\"2020-01-20T09:42:48.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:42:53.000-08:00\",\"conclusion\":\"success\",\"name\":\"Install Gems\",\"number\":6,\"started_at\":\"2020-01-20T09:42:52.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:42:59.000-08:00\",\"conclusion\":\"success\",\"name\":\"Run Tests\",\"number\":7,\"started_at\":\"2020-01-20T09:42:53.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:44:39.000-08:00\",\"conclusion\":\"success\",\"name\":\"Deploy to Heroku\",\"number\":8,\"started_at\":\"2020-01-20T09:42:59.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:44:39.000-08:00\",\"conclusion\":\"success\",\"name\":\"Post actions/cache@v2\",\"number\":16,\"started_at\":\"2020-01-20T09:44:39.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:44:39.000-08:00\",\"conclusion\":\"success\",\"name\":\"Complete job\",\"number\":17,\"started_at\":\"2020-01-20T09:44:39.000-08:00\",\"status\":\"completed\"}],\"url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/jobs/399444496\"}],\"total_count\":1}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsListJobsForWorkflowRunOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsListJobsForWorkflowRunOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsListOrgSecretsOK_EncodeDecode(t *testing.T) {
	var typ ActionsListOrgSecretsOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsListOrgSecretsOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsListOrgSecretsOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"secrets\":[{\"created_at\":\"2019-08-10T14:59:22Z\",\"name\":\"GIST_ID\",\"updated_at\":\"2020-01-10T14:59:22Z\",\"visibility\":\"private\"},{\"created_at\":\"2019-08-10T14:59:22Z\",\"name\":\"DEPLOY_TOKEN\",\"updated_at\":\"2020-01-10T14:59:22Z\",\"visibility\":\"all\"},{\"created_at\":\"2019-08-10T14:59:22Z\",\"name\":\"GH_TOKEN\",\"selected_repositories_url\":\"https://api.github.com/orgs/octo-org/actions/secrets/SUPER_SECRET/repositories\",\"updated_at\":\"2020-01-10T14:59:22Z\",\"visibility\":\"selected\"}],\"total_count\":3}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsListOrgSecretsOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsListOrgSecretsOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK_EncodeDecode(t *testing.T) {
	var typ ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"repositories\":[{\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":1,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":9,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":0,\"open_issues_count\":0,\"organization\":null,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":null,\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":80,\"watchers_count\":80},\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":1,\"watchers_count\":80}],\"total_count\":1}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsListRepoSecretsOK_EncodeDecode(t *testing.T) {
	var typ ActionsListRepoSecretsOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsListRepoSecretsOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsListRepoSecretsOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"secrets\":[{\"created_at\":\"2019-08-10T14:59:22Z\",\"name\":\"GH_TOKEN\",\"updated_at\":\"2020-01-10T14:59:22Z\"},{\"created_at\":\"2020-01-10T10:59:22Z\",\"name\":\"GIST_ID\",\"updated_at\":\"2020-01-11T11:59:22Z\"}],\"total_count\":2}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsListRepoSecretsOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsListRepoSecretsOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsListRepoWorkflowsOK_EncodeDecode(t *testing.T) {
	var typ ActionsListRepoWorkflowsOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsListRepoWorkflowsOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsListRepoWorkflowsOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"total_count\":2,\"workflows\":[{\"badge_url\":\"https://github.com/octo-org/octo-repo/workflows/CI/badge.svg\",\"created_at\":\"2020-01-08T23:48:37.000-08:00\",\"html_url\":\"https://github.com/octo-org/octo-repo/blob/master/.github/workflows/161335\",\"id\":161335,\"name\":\"CI\",\"node_id\":\"MDg6V29ya2Zsb3cxNjEzMzU=\",\"path\":\".github/workflows/blank.yaml\",\"state\":\"active\",\"updated_at\":\"2020-01-08T23:50:21.000-08:00\",\"url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/workflows/161335\"},{\"badge_url\":\"https://github.com/octo-org/octo-repo/workflows/Linter/badge.svg\",\"created_at\":\"2020-01-08T23:48:37.000-08:00\",\"html_url\":\"https://github.com/octo-org/octo-repo/blob/master/.github/workflows/269289\",\"id\":269289,\"name\":\"Linter\",\"node_id\":\"MDE4OldvcmtmbG93IFNlY29uZGFyeTI2OTI4OQ==\",\"path\":\".github/workflows/linter.yaml\",\"state\":\"active\",\"updated_at\":\"2020-01-08T23:50:21.000-08:00\",\"url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/workflows/269289\"}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsListRepoWorkflowsOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsListRepoWorkflowsOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsListSelectedReposForOrgSecretOK_EncodeDecode(t *testing.T) {
	var typ ActionsListSelectedReposForOrgSecretOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsListSelectedReposForOrgSecretOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsListSelectedReposForOrgSecretOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"repositories\":[{\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"hooks_url\":\"http://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"name\":\"Hello-World\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\"}],\"total_count\":1}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsListSelectedReposForOrgSecretOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsListSelectedReposForOrgSecretOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK_EncodeDecode(t *testing.T) {
	var typ ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"repositories\":[{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":1,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":null,\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":1,\"watchers_count\":80}],\"total_count\":1}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsListSelfHostedRunnerGroupsForOrgOK_EncodeDecode(t *testing.T) {
	var typ ActionsListSelfHostedRunnerGroupsForOrgOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsListSelfHostedRunnerGroupsForOrgOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsListSelfHostedRunnerGroupsForOrgOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"runner_groups\":[{\"allows_public_repositories\":true,\"default\":true,\"id\":1,\"inherited\":false,\"name\":\"Default\",\"runners_url\":\"https://api.github.com/orgs/octo-org/actions/runner_groups/1/runners\",\"visibility\":\"all\"},{\"allows_public_repositories\":true,\"default\":false,\"id\":2,\"inherited\":true,\"name\":\"octo-runner-group\",\"runners_url\":\"https://api.github.com/orgs/octo-org/actions/runner_groups/2/runners\",\"selected_repositories_url\":\"https://api.github.com/orgs/octo-org/actions/runner_groups/2/repositories\",\"visibility\":\"selected\"},{\"allows_public_repositories\":true,\"default\":false,\"id\":3,\"inherited\":false,\"name\":\"expensive-hardware\",\"runners_url\":\"https://api.github.com/orgs/octo-org/actions/runner_groups/3/runners\",\"visibility\":\"private\"}],\"total_count\":3}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsListSelfHostedRunnerGroupsForOrgOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsListSelfHostedRunnerGroupsForOrgOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsListSelfHostedRunnersForOrgOK_EncodeDecode(t *testing.T) {
	var typ ActionsListSelfHostedRunnersForOrgOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsListSelfHostedRunnersForOrgOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsListSelfHostedRunnersForOrgOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"runners\":[{\"busy\":true,\"id\":23,\"labels\":[{\"id\":5,\"name\":\"self-hosted\",\"type\":\"read-only\"},{\"id\":7,\"name\":\"X64\",\"type\":\"read-only\"},{\"id\":11,\"name\":\"Linux\",\"type\":\"read-only\"}],\"name\":\"linux_runner\",\"os\":\"linux\",\"status\":\"online\"},{\"busy\":false,\"id\":24,\"labels\":[{\"id\":5,\"name\":\"self-hosted\",\"type\":\"read-only\"},{\"id\":7,\"name\":\"X64\",\"type\":\"read-only\"},{\"id\":20,\"name\":\"macOS\",\"type\":\"read-only\"},{\"id\":21,\"name\":\"no-gpu\",\"type\":\"custom\"}],\"name\":\"mac_runner\",\"os\":\"macos\",\"status\":\"offline\"}],\"total_count\":2}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsListSelfHostedRunnersForOrgOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsListSelfHostedRunnersForOrgOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsListSelfHostedRunnersForRepoOK_EncodeDecode(t *testing.T) {
	var typ ActionsListSelfHostedRunnersForRepoOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsListSelfHostedRunnersForRepoOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsListSelfHostedRunnersForRepoOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"runners\":[{\"busy\":true,\"id\":23,\"labels\":[{\"id\":5,\"name\":\"self-hosted\",\"type\":\"read-only\"},{\"id\":7,\"name\":\"X64\",\"type\":\"read-only\"},{\"id\":11,\"name\":\"Linux\",\"type\":\"read-only\"}],\"name\":\"linux_runner\",\"os\":\"linux\",\"status\":\"online\"},{\"busy\":false,\"id\":24,\"labels\":[{\"id\":5,\"name\":\"self-hosted\",\"type\":\"read-only\"},{\"id\":7,\"name\":\"X64\",\"type\":\"read-only\"},{\"id\":20,\"name\":\"macOS\",\"type\":\"read-only\"},{\"id\":21,\"name\":\"no-gpu\",\"type\":\"custom\"}],\"name\":\"mac_runner\",\"os\":\"macos\",\"status\":\"offline\"}],\"total_count\":2}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsListSelfHostedRunnersForRepoOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsListSelfHostedRunnersForRepoOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsListSelfHostedRunnersInGroupForOrgOK_EncodeDecode(t *testing.T) {
	var typ ActionsListSelfHostedRunnersInGroupForOrgOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsListSelfHostedRunnersInGroupForOrgOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsListSelfHostedRunnersInGroupForOrgOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"runners\":[{\"busy\":true,\"id\":23,\"labels\":[{\"id\":5,\"name\":\"self-hosted\",\"type\":\"read-only\"},{\"id\":7,\"name\":\"X64\",\"type\":\"read-only\"},{\"id\":11,\"name\":\"Linux\",\"type\":\"read-only\"}],\"name\":\"linux_runner\",\"os\":\"linux\",\"status\":\"online\"},{\"busy\":false,\"id\":24,\"labels\":[{\"id\":5,\"name\":\"self-hosted\",\"type\":\"read-only\"},{\"id\":7,\"name\":\"X64\",\"type\":\"read-only\"},{\"id\":20,\"name\":\"macOS\",\"type\":\"read-only\"},{\"id\":21,\"name\":\"no-gpu\",\"type\":\"custom\"}],\"name\":\"mac_runner\",\"os\":\"macos\",\"status\":\"offline\"}],\"total_count\":2}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsListSelfHostedRunnersInGroupForOrgOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsListSelfHostedRunnersInGroupForOrgOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsListWorkflowRunArtifactsOK_EncodeDecode(t *testing.T) {
	var typ ActionsListWorkflowRunArtifactsOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsListWorkflowRunArtifactsOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsListWorkflowRunArtifactsOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"artifacts\":[{\"archive_download_url\":\"https://api.github.com/repos/octo-org/octo-docs/actions/artifacts/11/zip\",\"created_at\":\"2020-01-10T14:59:22Z\",\"expired\":false,\"expires_at\":\"2020-03-21T14:59:22Z\",\"id\":11,\"name\":\"Rails\",\"node_id\":\"MDg6QXJ0aWZhY3QxMQ==\",\"size_in_bytes\":556,\"updated_at\":\"2020-02-21T14:59:22Z\",\"url\":\"https://api.github.com/repos/octo-org/octo-docs/actions/artifacts/11\"},{\"archive_download_url\":\"https://api.github.com/repos/octo-org/octo-docs/actions/artifacts/13/zip\",\"created_at\":\"2020-01-10T14:59:22Z\",\"expired\":false,\"expires_at\":\"2020-03-21T14:59:22Z\",\"id\":13,\"name\":\"\",\"node_id\":\"MDg6QXJ0aWZhY3QxMw==\",\"size_in_bytes\":453,\"updated_at\":\"2020-02-21T14:59:22Z\",\"url\":\"https://api.github.com/repos/octo-org/octo-docs/actions/artifacts/13\"}],\"total_count\":2}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsListWorkflowRunArtifactsOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsListWorkflowRunArtifactsOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsListWorkflowRunsForRepoOK_EncodeDecode(t *testing.T) {
	var typ ActionsListWorkflowRunsForRepoOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsListWorkflowRunsForRepoOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsListWorkflowRunsForRepoOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"total_count\":1,\"workflow_runs\":[{\"artifacts_url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642/artifacts\",\"cancel_url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642/cancel\",\"check_suite_url\":\"https://api.github.com/repos/octo-org/octo-repo/check-suites/414944374\",\"conclusion\":null,\"created_at\":\"2020-01-22T19:33:08Z\",\"event\":\"push\",\"head_branch\":\"master\",\"head_commit\":{\"author\":{\"email\":\"octocat@github.com\",\"name\":\"Octo Cat\"},\"committer\":{\"email\":\"noreply@github.com\",\"name\":\"GitHub\"},\"id\":\"acb5820ced9479c074f688cc328bf03f341a511d\",\"message\":\"Create linter.yaml\",\"timestamp\":\"2020-01-22T19:33:05Z\",\"tree_id\":\"d23f6eedb1e1b9610bbc754ddb5197bfe7271223\"},\"head_repository\":{\"archive_url\":\"https://api.github.com/repos/octo-org/octo-repo/{archive_format}{/ref}\",\"assignees_url\":\"https://api.github.com/repos/octo-org/octo-repo/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octo-org/octo-repo/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octo-org/octo-repo/branches{/branch}\",\"collaborators_url\":\"https://api.github.com/repos/octo-org/octo-repo/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octo-org/octo-repo/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octo-org/octo-repo/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octo-org/octo-repo/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octo-org/octo-repo/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octo-org/octo-repo/contributors\",\"deployments_url\":\"https://api.github.com/repos/octo-org/octo-repo/deployments\",\"description\":null,\"downloads_url\":\"https://api.github.com/repos/octo-org/octo-repo/downloads\",\"events_url\":\"https://api.github.com/repos/octo-org/octo-repo/events\",\"fork\":false,\"forks_url\":\"https://api.github.com/repos/octo-org/octo-repo/forks\",\"full_name\":\"octo-org/octo-repo\",\"git_commits_url\":\"https://api.github.com/repos/octo-org/octo-repo/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octo-org/octo-repo/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octo-org/octo-repo/git/tags{/sha}\",\"hooks_url\":\"https://api.github.com/repos/octo-org/octo-repo/hooks\",\"html_url\":\"https://github.com/octo-org/octo-repo\",\"id\":217723378,\"issue_comment_url\":\"https://api.github.com/repos/octo-org/octo-repo/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octo-org/octo-repo/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octo-org/octo-repo/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octo-org/octo-repo/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octo-org/octo-repo/labels{/name}\",\"languages_url\":\"https://api.github.com/repos/octo-org/octo-repo/languages\",\"merges_url\":\"https://api.github.com/repos/octo-org/octo-repo/merges\",\"milestones_url\":\"https://api.github.com/repos/octo-org/octo-repo/milestones{/number}\",\"name\":\"octo-repo\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkyMTc3MjMzNzg=\",\"notifications_url\":\"https://api.github.com/repos/octo-org/octo-repo/notifications{?since,all,participating}\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"private\":true,\"pulls_url\":\"https://api.github.com/repos/octo-org/octo-repo/pulls{/number}\",\"releases_url\":\"https://api.github.com/repos/octo-org/octo-repo/releases{/id}\",\"stargazers_url\":\"https://api.github.com/repos/octo-org/octo-repo/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octo-org/octo-repo/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/octo-org/octo-repo/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octo-org/octo-repo/subscription\",\"tags_url\":\"https://api.github.com/repos/octo-org/octo-repo/tags\",\"teams_url\":\"https://api.github.com/repos/octo-org/octo-repo/teams\",\"trees_url\":\"https://api.github.com/repos/octo-org/octo-repo/git/trees{/sha}\",\"url\":\"https://api.github.com/repos/octo-org/octo-repo\"},\"head_sha\":\"acb5820ced9479c074f688cc328bf03f341a511d\",\"html_url\":\"https://github.com/octo-org/octo-repo/actions/runs/30433642\",\"id\":30433642,\"jobs_url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642/jobs\",\"logs_url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642/logs\",\"name\":\"Build\",\"node_id\":\"MDEyOldvcmtmbG93IFJ1bjI2OTI4OQ==\",\"pull_requests\":[],\"repository\":{\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"hooks_url\":\"http://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"name\":\"Hello-World\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\"},\"rerun_url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642/rerun\",\"run_number\":562,\"status\":\"queued\",\"updated_at\":\"2020-01-22T19:33:08Z\",\"url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642\",\"workflow_id\":159038,\"workflow_url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/workflows/159038\"}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsListWorkflowRunsForRepoOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsListWorkflowRunsForRepoOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsOrganizationPermissions_EncodeDecode(t *testing.T) {
	var typ ActionsOrganizationPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsOrganizationPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsOrganizationPermissions_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"allowed_actions\":\"selected\",\"enabled_repositories\":\"all\",\"selected_actions_url\":\"https://api.github.com/organizations/42/actions/permissions/selected-actions\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsOrganizationPermissions

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsOrganizationPermissions
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsPublicKey_EncodeDecode(t *testing.T) {
	var typ ActionsPublicKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsPublicKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsPublicKey_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"key\":\"2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvv1234\",\"key_id\":\"012345678912345678\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsPublicKey

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsPublicKey
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsReRunWorkflowCreated_EncodeDecode(t *testing.T) {
	var typ ActionsReRunWorkflowCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsReRunWorkflowCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionsRepositoryPermissions_EncodeDecode(t *testing.T) {
	var typ ActionsRepositoryPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsRepositoryPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsRepositoryPermissions_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"allowed_actions\":\"selected\",\"enabled\":true,\"selected_actions_url\":\"https://api.github.com/repositories/42/actions/permissions/selected-actions\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsRepositoryPermissions

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsRepositoryPermissions
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsRetryWorkflowCreated_EncodeDecode(t *testing.T) {
	var typ ActionsRetryWorkflowCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsRetryWorkflowCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionsReviewPendingDeploymentsForRunReq_EncodeDecode(t *testing.T) {
	var typ ActionsReviewPendingDeploymentsForRunReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsReviewPendingDeploymentsForRunReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionsReviewPendingDeploymentsForRunReqState_EncodeDecode(t *testing.T) {
	var typ ActionsReviewPendingDeploymentsForRunReqState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsReviewPendingDeploymentsForRunReqState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsReviewPendingDeploymentsForRunReqState_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"approved\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsReviewPendingDeploymentsForRunReqState

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsReviewPendingDeploymentsForRunReqState
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsSecret_EncodeDecode(t *testing.T) {
	var typ ActionsSecret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsSecret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsSecret_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2019-08-10T14:59:22Z\",\"name\":\"GH_TOKEN\",\"updated_at\":\"2020-01-10T14:59:22Z\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsSecret

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsSecret
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsSetGithubActionsPermissionsOrganizationReq_EncodeDecode(t *testing.T) {
	var typ ActionsSetGithubActionsPermissionsOrganizationReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsSetGithubActionsPermissionsOrganizationReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsSetGithubActionsPermissionsOrganizationReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"allowed_actions\":\"selected\",\"enabled_repositories\":\"all\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsSetGithubActionsPermissionsOrganizationReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsSetGithubActionsPermissionsOrganizationReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsSetGithubActionsPermissionsRepositoryReq_EncodeDecode(t *testing.T) {
	var typ ActionsSetGithubActionsPermissionsRepositoryReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsSetGithubActionsPermissionsRepositoryReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsSetGithubActionsPermissionsRepositoryReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"allowed_actions\":\"selected\",\"enabled\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsSetGithubActionsPermissionsRepositoryReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsSetGithubActionsPermissionsRepositoryReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq_EncodeDecode(t *testing.T) {
	var typ ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"selected_repository_ids\":[32,91]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsSetSelectedReposForOrgSecretReq_EncodeDecode(t *testing.T) {
	var typ ActionsSetSelectedReposForOrgSecretReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsSetSelectedReposForOrgSecretReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsSetSelectedReposForOrgSecretReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"selected_repository_ids\":[64780797]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsSetSelectedReposForOrgSecretReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsSetSelectedReposForOrgSecretReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq_EncodeDecode(t *testing.T) {
	var typ ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"selected_repository_ids\":[32,42]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsSetSelfHostedRunnersInGroupForOrgReq_EncodeDecode(t *testing.T) {
	var typ ActionsSetSelfHostedRunnersInGroupForOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsSetSelfHostedRunnersInGroupForOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsSetSelfHostedRunnersInGroupForOrgReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"runners\":[9,2]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsSetSelfHostedRunnersInGroupForOrgReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsSetSelfHostedRunnersInGroupForOrgReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsUpdateSelfHostedRunnerGroupForOrgReq_EncodeDecode(t *testing.T) {
	var typ ActionsUpdateSelfHostedRunnerGroupForOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsUpdateSelfHostedRunnerGroupForOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestActionsUpdateSelfHostedRunnerGroupForOrgReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"name\":\"Expensive hardware runners\",\"visibility\":\"selected\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ActionsUpdateSelfHostedRunnerGroupForOrgReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ActionsUpdateSelfHostedRunnerGroupForOrgReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility_EncodeDecode(t *testing.T) {
	var typ ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityCheckRepoIsStarredByAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ ActivityCheckRepoIsStarredByAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityCheckRepoIsStarredByAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityCheckRepoIsStarredByAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ ActivityCheckRepoIsStarredByAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityCheckRepoIsStarredByAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityCheckRepoIsStarredByAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ ActivityCheckRepoIsStarredByAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityCheckRepoIsStarredByAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityDeleteThreadSubscriptionForbidden_EncodeDecode(t *testing.T) {
	var typ ActivityDeleteThreadSubscriptionForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityDeleteThreadSubscriptionForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityDeleteThreadSubscriptionUnauthorized_EncodeDecode(t *testing.T) {
	var typ ActivityDeleteThreadSubscriptionUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityDeleteThreadSubscriptionUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityGetThreadForbidden_EncodeDecode(t *testing.T) {
	var typ ActivityGetThreadForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityGetThreadForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityGetThreadSubscriptionForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ ActivityGetThreadSubscriptionForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityGetThreadSubscriptionForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityGetThreadSubscriptionForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ ActivityGetThreadSubscriptionForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityGetThreadSubscriptionForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityGetThreadUnauthorized_EncodeDecode(t *testing.T) {
	var typ ActivityGetThreadUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityGetThreadUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityListNotificationsForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ ActivityListNotificationsForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityListNotificationsForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityListNotificationsForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ ActivityListNotificationsForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityListNotificationsForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityListPublicEventsForRepoNetworkForbidden_EncodeDecode(t *testing.T) {
	var typ ActivityListPublicEventsForRepoNetworkForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityListPublicEventsForRepoNetworkForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityListPublicEventsForRepoNetworkMovedPermanently_EncodeDecode(t *testing.T) {
	var typ ActivityListPublicEventsForRepoNetworkMovedPermanently
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityListPublicEventsForRepoNetworkMovedPermanently
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityListPublicEventsForRepoNetworkNotFound_EncodeDecode(t *testing.T) {
	var typ ActivityListPublicEventsForRepoNetworkNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityListPublicEventsForRepoNetworkNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityListPublicEventsForRepoNetworkOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ActivityListPublicEventsForRepoNetworkOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityListPublicEventsForRepoNetworkOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityListPublicEventsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ActivityListPublicEventsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityListPublicEventsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityListReposStarredByAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ ActivityListReposStarredByAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityListReposStarredByAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityListReposStarredByAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ ActivityListReposStarredByAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityListReposStarredByAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityListWatchedReposForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ ActivityListWatchedReposForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityListWatchedReposForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityListWatchedReposForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ ActivityListWatchedReposForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityListWatchedReposForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityMarkNotificationsAsReadAccepted_EncodeDecode(t *testing.T) {
	var typ ActivityMarkNotificationsAsReadAccepted
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityMarkNotificationsAsReadAccepted
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityMarkNotificationsAsReadForbidden_EncodeDecode(t *testing.T) {
	var typ ActivityMarkNotificationsAsReadForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityMarkNotificationsAsReadForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityMarkNotificationsAsReadReq_EncodeDecode(t *testing.T) {
	var typ ActivityMarkNotificationsAsReadReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityMarkNotificationsAsReadReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityMarkNotificationsAsReadUnauthorized_EncodeDecode(t *testing.T) {
	var typ ActivityMarkNotificationsAsReadUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityMarkNotificationsAsReadUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityMarkRepoNotificationsAsReadAccepted_EncodeDecode(t *testing.T) {
	var typ ActivityMarkRepoNotificationsAsReadAccepted
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityMarkRepoNotificationsAsReadAccepted
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityMarkRepoNotificationsAsReadReq_EncodeDecode(t *testing.T) {
	var typ ActivityMarkRepoNotificationsAsReadReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityMarkRepoNotificationsAsReadReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivitySetRepoSubscriptionReq_EncodeDecode(t *testing.T) {
	var typ ActivitySetRepoSubscriptionReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivitySetRepoSubscriptionReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivitySetThreadSubscriptionForbidden_EncodeDecode(t *testing.T) {
	var typ ActivitySetThreadSubscriptionForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivitySetThreadSubscriptionForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivitySetThreadSubscriptionReq_EncodeDecode(t *testing.T) {
	var typ ActivitySetThreadSubscriptionReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivitySetThreadSubscriptionReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivitySetThreadSubscriptionUnauthorized_EncodeDecode(t *testing.T) {
	var typ ActivitySetThreadSubscriptionUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivitySetThreadSubscriptionUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityStarRepoForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ ActivityStarRepoForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityStarRepoForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityStarRepoForAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ ActivityStarRepoForAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityStarRepoForAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityStarRepoForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ ActivityStarRepoForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityStarRepoForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityUnstarRepoForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ ActivityUnstarRepoForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityUnstarRepoForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityUnstarRepoForAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ ActivityUnstarRepoForAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityUnstarRepoForAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivityUnstarRepoForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ ActivityUnstarRepoForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivityUnstarRepoForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActor_EncodeDecode(t *testing.T) {
	var typ Actor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Actor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAlertCreatedAt_EncodeDecode(t *testing.T) {
	var typ AlertCreatedAt
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AlertCreatedAt
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAlertHTMLURL_EncodeDecode(t *testing.T) {
	var typ AlertHTMLURL
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AlertHTMLURL
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAlertInstancesURL_EncodeDecode(t *testing.T) {
	var typ AlertInstancesURL
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AlertInstancesURL
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAlertNumber_EncodeDecode(t *testing.T) {
	var typ AlertNumber
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AlertNumber
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAlertURL_EncodeDecode(t *testing.T) {
	var typ AlertURL
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AlertURL
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAllowedActions_EncodeDecode(t *testing.T) {
	var typ AllowedActions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AllowedActions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissions_EncodeDecode(t *testing.T) {
	var typ AppPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAppPermissions_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"contents\":\"read\",\"deployments\":\"write\",\"issues\":\"read\",\"single_file\":\"read\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AppPermissions

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AppPermissions
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestAppPermissionsActions_EncodeDecode(t *testing.T) {
	var typ AppPermissionsActions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsActions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsAdministration_EncodeDecode(t *testing.T) {
	var typ AppPermissionsAdministration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsAdministration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsChecks_EncodeDecode(t *testing.T) {
	var typ AppPermissionsChecks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsChecks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsContentReferences_EncodeDecode(t *testing.T) {
	var typ AppPermissionsContentReferences
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsContentReferences
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsContents_EncodeDecode(t *testing.T) {
	var typ AppPermissionsContents
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsContents
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsDeployments_EncodeDecode(t *testing.T) {
	var typ AppPermissionsDeployments
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsDeployments
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsEnvironments_EncodeDecode(t *testing.T) {
	var typ AppPermissionsEnvironments
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsEnvironments
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsIssues_EncodeDecode(t *testing.T) {
	var typ AppPermissionsIssues
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsIssues
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsMembers_EncodeDecode(t *testing.T) {
	var typ AppPermissionsMembers
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsMembers
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsMetadata_EncodeDecode(t *testing.T) {
	var typ AppPermissionsMetadata
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsMetadata
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsOrganizationAdministration_EncodeDecode(t *testing.T) {
	var typ AppPermissionsOrganizationAdministration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsOrganizationAdministration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsOrganizationHooks_EncodeDecode(t *testing.T) {
	var typ AppPermissionsOrganizationHooks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsOrganizationHooks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsOrganizationPackages_EncodeDecode(t *testing.T) {
	var typ AppPermissionsOrganizationPackages
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsOrganizationPackages
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsOrganizationPlan_EncodeDecode(t *testing.T) {
	var typ AppPermissionsOrganizationPlan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsOrganizationPlan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsOrganizationProjects_EncodeDecode(t *testing.T) {
	var typ AppPermissionsOrganizationProjects
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsOrganizationProjects
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsOrganizationSecrets_EncodeDecode(t *testing.T) {
	var typ AppPermissionsOrganizationSecrets
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsOrganizationSecrets
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsOrganizationSelfHostedRunners_EncodeDecode(t *testing.T) {
	var typ AppPermissionsOrganizationSelfHostedRunners
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsOrganizationSelfHostedRunners
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsOrganizationUserBlocking_EncodeDecode(t *testing.T) {
	var typ AppPermissionsOrganizationUserBlocking
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsOrganizationUserBlocking
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsPackages_EncodeDecode(t *testing.T) {
	var typ AppPermissionsPackages
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsPackages
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsPages_EncodeDecode(t *testing.T) {
	var typ AppPermissionsPages
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsPages
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsPullRequests_EncodeDecode(t *testing.T) {
	var typ AppPermissionsPullRequests
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsPullRequests
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsRepositoryHooks_EncodeDecode(t *testing.T) {
	var typ AppPermissionsRepositoryHooks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsRepositoryHooks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsRepositoryProjects_EncodeDecode(t *testing.T) {
	var typ AppPermissionsRepositoryProjects
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsRepositoryProjects
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsSecretScanningAlerts_EncodeDecode(t *testing.T) {
	var typ AppPermissionsSecretScanningAlerts
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsSecretScanningAlerts
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsSecrets_EncodeDecode(t *testing.T) {
	var typ AppPermissionsSecrets
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsSecrets
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsSecurityEvents_EncodeDecode(t *testing.T) {
	var typ AppPermissionsSecurityEvents
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsSecurityEvents
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsSingleFile_EncodeDecode(t *testing.T) {
	var typ AppPermissionsSingleFile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsSingleFile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsStatuses_EncodeDecode(t *testing.T) {
	var typ AppPermissionsStatuses
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsStatuses
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsTeamDiscussions_EncodeDecode(t *testing.T) {
	var typ AppPermissionsTeamDiscussions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsTeamDiscussions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsVulnerabilityAlerts_EncodeDecode(t *testing.T) {
	var typ AppPermissionsVulnerabilityAlerts
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsVulnerabilityAlerts
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppPermissionsWorkflows_EncodeDecode(t *testing.T) {
	var typ AppPermissionsWorkflows
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppPermissionsWorkflows
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestApplicationGrant_EncodeDecode(t *testing.T) {
	var typ ApplicationGrant
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ApplicationGrant
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestApplicationGrant_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"app\":{\"client_id\":\"abcde12345fghij67890\",\"name\":\"my github app\",\"url\":\"http://my-github-app.com\"},\"created_at\":\"2011-09-06T17:26:27Z\",\"id\":1,\"scopes\":[\"public_repo\"],\"updated_at\":\"2011-09-06T20:39:23Z\",\"url\":\"https://api.github.com/applications/grants/1\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ApplicationGrant

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ApplicationGrant
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestApplicationGrantApp_EncodeDecode(t *testing.T) {
	var typ ApplicationGrantApp
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ApplicationGrantApp
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsAddRepoToInstallationForbidden_EncodeDecode(t *testing.T) {
	var typ AppsAddRepoToInstallationForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsAddRepoToInstallationForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsAddRepoToInstallationNotFound_EncodeDecode(t *testing.T) {
	var typ AppsAddRepoToInstallationNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsAddRepoToInstallationNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsCheckTokenReq_EncodeDecode(t *testing.T) {
	var typ AppsCheckTokenReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsCheckTokenReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsCreateContentAttachmentForbidden_EncodeDecode(t *testing.T) {
	var typ AppsCreateContentAttachmentForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsCreateContentAttachmentForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsCreateContentAttachmentGone_EncodeDecode(t *testing.T) {
	var typ AppsCreateContentAttachmentGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsCreateContentAttachmentGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsCreateContentAttachmentNotFound_EncodeDecode(t *testing.T) {
	var typ AppsCreateContentAttachmentNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsCreateContentAttachmentNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsCreateContentAttachmentReq_EncodeDecode(t *testing.T) {
	var typ AppsCreateContentAttachmentReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsCreateContentAttachmentReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsCreateFromManifestCreated_EncodeDecode(t *testing.T) {
	var typ AppsCreateFromManifestCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsCreateFromManifestCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsCreateFromManifestCreatedAdditional_EncodeDecode(t *testing.T) {
	var typ AppsCreateFromManifestCreatedAdditional
	typ = make(AppsCreateFromManifestCreatedAdditional)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsCreateFromManifestCreatedAdditional
	typ2 = make(AppsCreateFromManifestCreatedAdditional)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsCreateFromManifestCreatedPermissions_EncodeDecode(t *testing.T) {
	var typ AppsCreateFromManifestCreatedPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsCreateFromManifestCreatedPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAppsCreateFromManifestCreatedPermissions_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"deployments\":\"write\",\"issues\":\"read\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AppsCreateFromManifestCreatedPermissions

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AppsCreateFromManifestCreatedPermissions
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestAppsCreateFromManifestCreatedPermissionsAdditional_EncodeDecode(t *testing.T) {
	var typ AppsCreateFromManifestCreatedPermissionsAdditional
	typ = make(AppsCreateFromManifestCreatedPermissionsAdditional)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsCreateFromManifestCreatedPermissionsAdditional
	typ2 = make(AppsCreateFromManifestCreatedPermissionsAdditional)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsCreateFromManifestReq_EncodeDecode(t *testing.T) {
	var typ AppsCreateFromManifestReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsCreateFromManifestReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsCreateInstallationAccessTokenForbidden_EncodeDecode(t *testing.T) {
	var typ AppsCreateInstallationAccessTokenForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsCreateInstallationAccessTokenForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsCreateInstallationAccessTokenNotFound_EncodeDecode(t *testing.T) {
	var typ AppsCreateInstallationAccessTokenNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsCreateInstallationAccessTokenNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsCreateInstallationAccessTokenReq_EncodeDecode(t *testing.T) {
	var typ AppsCreateInstallationAccessTokenReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsCreateInstallationAccessTokenReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsCreateInstallationAccessTokenUnauthorized_EncodeDecode(t *testing.T) {
	var typ AppsCreateInstallationAccessTokenUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsCreateInstallationAccessTokenUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsDeleteAuthorizationReq_EncodeDecode(t *testing.T) {
	var typ AppsDeleteAuthorizationReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsDeleteAuthorizationReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAppsDeleteAuthorizationReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"access_token\":\"e72e16c7e42f292c6912e7710c838347ae178b4a\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AppsDeleteAuthorizationReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AppsDeleteAuthorizationReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestAppsDeleteTokenReq_EncodeDecode(t *testing.T) {
	var typ AppsDeleteTokenReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsDeleteTokenReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAppsDeleteTokenReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"access_token\":\"e72e16c7e42f292c6912e7710c838347ae178b4a\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AppsDeleteTokenReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AppsDeleteTokenReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestAppsGetBySlugForbidden_EncodeDecode(t *testing.T) {
	var typ AppsGetBySlugForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsGetBySlugForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsGetBySlugNotFound_EncodeDecode(t *testing.T) {
	var typ AppsGetBySlugNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsGetBySlugNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsGetSubscriptionPlanForAccountNotFound_EncodeDecode(t *testing.T) {
	var typ AppsGetSubscriptionPlanForAccountNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsGetSubscriptionPlanForAccountNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsGetSubscriptionPlanForAccountUnauthorized_EncodeDecode(t *testing.T) {
	var typ AppsGetSubscriptionPlanForAccountUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsGetSubscriptionPlanForAccountUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsListAccountsForPlanNotFound_EncodeDecode(t *testing.T) {
	var typ AppsListAccountsForPlanNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsListAccountsForPlanNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsListAccountsForPlanUnauthorized_EncodeDecode(t *testing.T) {
	var typ AppsListAccountsForPlanUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsListAccountsForPlanUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsListInstallationReposForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ AppsListInstallationReposForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsListInstallationReposForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsListInstallationReposForAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ AppsListInstallationReposForAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsListInstallationReposForAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsListInstallationReposForAuthenticatedUserOK_EncodeDecode(t *testing.T) {
	var typ AppsListInstallationReposForAuthenticatedUserOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsListInstallationReposForAuthenticatedUserOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAppsListInstallationReposForAuthenticatedUserOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"repositories\":[{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":1,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":null,\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":1,\"watchers_count\":80}],\"total_count\":1}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AppsListInstallationReposForAuthenticatedUserOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AppsListInstallationReposForAuthenticatedUserOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestAppsListPlansNotFound_EncodeDecode(t *testing.T) {
	var typ AppsListPlansNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsListPlansNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsListPlansUnauthorized_EncodeDecode(t *testing.T) {
	var typ AppsListPlansUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsListPlansUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsListReposAccessibleToInstallationForbidden_EncodeDecode(t *testing.T) {
	var typ AppsListReposAccessibleToInstallationForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsListReposAccessibleToInstallationForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsListReposAccessibleToInstallationOK_EncodeDecode(t *testing.T) {
	var typ AppsListReposAccessibleToInstallationOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsListReposAccessibleToInstallationOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAppsListReposAccessibleToInstallationOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"repositories\":[{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":1,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":null,\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":1,\"watchers_count\":80}],\"total_count\":1}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AppsListReposAccessibleToInstallationOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AppsListReposAccessibleToInstallationOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestAppsListReposAccessibleToInstallationUnauthorized_EncodeDecode(t *testing.T) {
	var typ AppsListReposAccessibleToInstallationUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsListReposAccessibleToInstallationUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsListSubscriptionsForAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ AppsListSubscriptionsForAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsListSubscriptionsForAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsListSubscriptionsForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ AppsListSubscriptionsForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsListSubscriptionsForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsListWebhookDeliveriesOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ AppsListWebhookDeliveriesOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsListWebhookDeliveriesOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsRemoveRepoFromInstallationForbidden_EncodeDecode(t *testing.T) {
	var typ AppsRemoveRepoFromInstallationForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsRemoveRepoFromInstallationForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsRemoveRepoFromInstallationNotFound_EncodeDecode(t *testing.T) {
	var typ AppsRemoveRepoFromInstallationNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsRemoveRepoFromInstallationNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsResetTokenReq_EncodeDecode(t *testing.T) {
	var typ AppsResetTokenReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsResetTokenReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsScopeTokenForbidden_EncodeDecode(t *testing.T) {
	var typ AppsScopeTokenForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsScopeTokenForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsScopeTokenNotFound_EncodeDecode(t *testing.T) {
	var typ AppsScopeTokenNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsScopeTokenNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsScopeTokenReq_EncodeDecode(t *testing.T) {
	var typ AppsScopeTokenReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsScopeTokenReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsScopeTokenUnauthorized_EncodeDecode(t *testing.T) {
	var typ AppsScopeTokenUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsScopeTokenUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAppsUpdateWebhookConfigForAppReq_EncodeDecode(t *testing.T) {
	var typ AppsUpdateWebhookConfigForAppReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AppsUpdateWebhookConfigForAppReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAppsUpdateWebhookConfigForAppReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content_type\":\"json\",\"insecure_ssl\":\"0\",\"secret\":\"********\",\"url\":\"https://example.com/webhook\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AppsUpdateWebhookConfigForAppReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AppsUpdateWebhookConfigForAppReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestArtifact_EncodeDecode(t *testing.T) {
	var typ Artifact
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Artifact
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestArtifact_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"archive_download_url\":\"https://api.github.com/repos/octo-org/octo-docs/actions/artifacts/11/zip\",\"created_at\":\"2020-01-10T14:59:22Z\",\"expired\":false,\"expires_at\":\"2020-01-21T14:59:22Z\",\"id\":11,\"name\":\"Rails\",\"node_id\":\"MDg6QXJ0aWZhY3QxMQ==\",\"size_in_bytes\":556,\"updated_at\":\"2020-01-21T14:59:22Z\",\"url\":\"https://api.github.com/repos/octo-org/octo-docs/actions/artifacts/11\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Artifact

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Artifact
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestAuditLogEvent_EncodeDecode(t *testing.T) {
	var typ AuditLogEvent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuditLogEvent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuditLogEventActorLocation_EncodeDecode(t *testing.T) {
	var typ AuditLogEventActorLocation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuditLogEventActorLocation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuditLogEventData_EncodeDecode(t *testing.T) {
	var typ AuditLogEventData
	typ = make(AuditLogEventData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuditLogEventData
	typ2 = make(AuditLogEventData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthenticationToken_EncodeDecode(t *testing.T) {
	var typ AuthenticationToken
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthenticationToken
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAuthenticationToken_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"expires_at\":\"2020-01-22T12:13:35.123-08:00\",\"token\":\"LLBF3JGZDX3P5PMEXLND6TS6FCWO6\"}"},
		{Input: "{\"expires_at\":\"2020-01-29T12:13:35.123-08:00\",\"token\":\"AABF3JGZDX3P5PMEXLND6TS6FCWO6\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AuthenticationToken

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AuthenticationToken
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestAuthenticationTokenPermissions_EncodeDecode(t *testing.T) {
	var typ AuthenticationTokenPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthenticationTokenPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAuthenticationTokenPermissions_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"deployments\":\"write\",\"issues\":\"read\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AuthenticationTokenPermissions

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AuthenticationTokenPermissions
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestAuthenticationTokenRepositorySelection_EncodeDecode(t *testing.T) {
	var typ AuthenticationTokenRepositorySelection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthenticationTokenRepositorySelection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthorAssociation_EncodeDecode(t *testing.T) {
	var typ AuthorAssociation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthorAssociation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAuthorAssociation_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"OWNER\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AuthorAssociation

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AuthorAssociation
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestAuthorization_EncodeDecode(t *testing.T) {
	var typ Authorization
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Authorization
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAuthorization_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"app\":{\"client_id\":\"abcde12345fghij67890\",\"name\":\"my github app\",\"url\":\"http://my-github-app.com\"},\"created_at\":\"2011-09-06T17:26:27Z\",\"expires_at\":\"2011-09-08T17:26:27Z\",\"fingerprint\":\"jklmnop12345678\",\"hashed_token\":\"25f94a2a5c7fbaf499c665bc73d67c1c87e496da8985131633ee0a95819db2e8\",\"id\":1,\"installation\":{\"account\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"has_multiple_single_files\":false,\"permissions\":{\"contents\":\"read\",\"issues\":\"write\",\"metadata\":\"read\"},\"repositories_url\":\"https://api.github.com/user/repos\",\"repository_selection\":\"selected\",\"single_file_name\":\".github/workflow.yml\",\"single_file_paths\":[]},\"note\":\"optional note\",\"note_url\":\"http://optional/note/url\",\"scopes\":[],\"token\":\"ghu_16C7e42F292c6912E7710c838347Ae178B4a\",\"token_last_eight\":\"Ae178B4a\",\"updated_at\":\"2011-09-06T20:39:23Z\",\"url\":\"https://api.github.com/authorizations/1\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
		{Input: "{\"app\":{\"client_id\":\"abcde12345fghij67890\",\"name\":\"my github app\",\"url\":\"http://my-github-app.com\"},\"created_at\":\"2011-09-06T17:26:27Z\",\"expires_at\":\"2011-09-08T17:26:27Z\",\"fingerprint\":\"jklmnop12345678\",\"hashed_token\":\"25f94a2a5c7fbaf499c665bc73d67c1c87e496da8985131633ee0a95819db2e8\",\"id\":1,\"note\":\"optional note\",\"note_url\":\"http://optional/note/url\",\"scopes\":[\"public_repo\",\"user\"],\"token\":\"ghu_16C7e42F292c6912E7710c838347Ae178B4a\",\"token_last_eight\":\"Ae178B4a\",\"updated_at\":\"2011-09-06T20:39:23Z\",\"url\":\"https://api.github.com/authorizations/1\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
		{Input: "{\"app\":{\"client_id\":\"abcde12345fghij67890\",\"name\":\"my github app\",\"url\":\"http://my-github-app.com\"},\"created_at\":\"2011-09-06T17:26:27Z\",\"expires_at\":\"2011-10-06T17:26:27Z\",\"fingerprint\":\"\",\"hashed_token\":\"25f94a2a5c7fbaf499c665bc73d67c1c87e496da8985131633ee0a95819db2e8\",\"id\":1,\"note\":\"optional note\",\"note_url\":\"http://optional/note/url\",\"scopes\":[\"public_repo\"],\"token\":\"ghu_16C7e42F292c6912E7710c838347Ae178B4a\",\"token_last_eight\":\"Ae178B4a\",\"updated_at\":\"2011-09-06T20:39:23Z\",\"url\":\"https://api.github.com/authorizations/1\"}"},
		{Input: "{\"app\":{\"client_id\":\"abcde12345fghij67890\",\"name\":\"my github app\",\"url\":\"http://my-github-app.com\"},\"created_at\":\"2011-09-06T17:26:27Z\",\"expires_at\":\"2011-10-06T17:26:27Z\",\"fingerprint\":\"jklmnop12345678\",\"hashed_token\":\"25f94a2a5c7fbaf499c665bc73d67c1c87e496da8985131633ee0a95819db2e8\",\"id\":1,\"note\":\"optional note\",\"note_url\":\"http://optional/note/url\",\"scopes\":[\"public_repo\"],\"token\":\"ghu_16C7e42F292c6912E7710c838347Ae178B4a\",\"token_last_eight\":\"Ae178B4a\",\"updated_at\":\"2011-09-06T20:39:23Z\",\"url\":\"https://api.github.com/authorizations/1\"}"},
		{Input: "{\"app\":{\"client_id\":\"abcde12345fghij67890\",\"name\":\"my github app\",\"url\":\"http://my-github-app.com\"},\"created_at\":\"2011-09-06T17:26:27Z\",\"expires_at\":\"2012-10-06T17:26:27Z\",\"fingerprint\":\"jklmnop12345678\",\"hashed_token\":\"25f94a2a5c7fbaf499c665bc73d67c1c87e496da8985131633ee0a95819db2e8\",\"id\":1,\"note\":\"optional note\",\"note_url\":\"http://optional/note/url\",\"scopes\":[\"public_repo\"],\"token\":\"ghu_16C7e42F292c6912E7710c838347Ae178B4a\",\"token_last_eight\":\"Ae178B4a\",\"updated_at\":\"2011-09-06T20:39:23Z\",\"url\":\"https://api.github.com/authorizations/1\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Authorization

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Authorization
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestAuthorizationApp_EncodeDecode(t *testing.T) {
	var typ AuthorizationApp
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthorizationApp
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutoMerge_EncodeDecode(t *testing.T) {
	var typ AutoMerge
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutoMerge
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutoMergeMergeMethod_EncodeDecode(t *testing.T) {
	var typ AutoMergeMergeMethod
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutoMergeMergeMethod
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutolink_EncodeDecode(t *testing.T) {
	var typ Autolink
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Autolink
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAutolink_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":1,\"key_prefix\":\"TICKET-\",\"url_template\":\"https://example.com/TICKET?query=\\u003cnum\\u003e\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Autolink

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Autolink
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestBaseGist_EncodeDecode(t *testing.T) {
	var typ BaseGist
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BaseGist
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestBaseGist_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"comments\":0,\"comments_url\":\"https://api.github.com/gists/aa5a315d61ae9438b18d/comments/\",\"commits_url\":\"https://api.github.com/gists/aa5a315d61ae9438b18d/commits\",\"created_at\":\"2010-04-14T02:15:15Z\",\"description\":\"Hello World Examples\",\"files\":{\"hello_world.rb\":{\"filename\":\"hello_world.rb\",\"language\":\"Ruby\",\"raw_url\":\"https://gist.githubusercontent.com/octocat/6cad326836d38bd3a7ae/raw/db9c55113504e46fa076e7df3a04ce592e2e86d8/hello_world.rb\",\"size\":167,\"type\":\"application/x-ruby\"}},\"forks_url\":\"https://api.github.com/gists/aa5a315d61ae9438b18d/forks\",\"git_pull_url\":\"https://gist.github.com/aa5a315d61ae9438b18d.git\",\"git_push_url\":\"https://gist.github.com/aa5a315d61ae9438b18d.git\",\"html_url\":\"https://gist.github.com/aa5a315d61ae9438b18d\",\"id\":\"aa5a315d61ae9438b18d\",\"node_id\":\"MDQ6R2lzdGFhNWEzMTVkNjFhZTk0MzhiMThk\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"public\":true,\"truncated\":false,\"updated_at\":\"2011-06-20T11:34:15Z\",\"url\":\"https://api.github.com/gists/aa5a315d61ae9438b18d\",\"user\":null}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ BaseGist

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 BaseGist
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestBaseGistFiles_EncodeDecode(t *testing.T) {
	var typ BaseGistFiles
	typ = make(BaseGistFiles)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BaseGistFiles
	typ2 = make(BaseGistFiles)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBaseGistFilesItem_EncodeDecode(t *testing.T) {
	var typ BaseGistFilesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BaseGistFilesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBasicError_EncodeDecode(t *testing.T) {
	var typ BasicError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BasicError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBlob_EncodeDecode(t *testing.T) {
	var typ Blob
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Blob
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestBlob_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content\":\"Q29udGVudCBvZiB0aGUgYmxvYg==\",\"encoding\":\"base64\",\"node_id\":\"Q29udGVudCBvZiB0aGUgYmxvYg==\",\"sha\":\"3a0f86fb8db8eea7ccbb9a95f325ddbedfb25e15\",\"size\":19,\"url\":\"https://api.github.com/repos/octocat/example/git/blobs/3a0f86fb8db8eea7ccbb9a95f325ddbedfb25e15\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Blob

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Blob
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestBranchProtection_EncodeDecode(t *testing.T) {
	var typ BranchProtection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchProtection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestBranchProtection_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"allow_deletions\":{\"enabled\":true},\"allow_force_pushes\":{\"enabled\":true},\"enforce_admins\":{\"enabled\":true,\"url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/enforce_admins\"},\"required_conversation_resolution\":{\"enabled\":true},\"required_linear_history\":{\"enabled\":true},\"required_pull_request_reviews\":{\"dismiss_stale_reviews\":true,\"dismissal_restrictions\":{\"teams\":[{\"description\":\"A great team.\",\"html_url\":\"https://github.com/orgs/github/teams/justice-league\",\"id\":1,\"members_url\":\"https://api.github.com/teams/1/members{/member}\",\"name\":\"Justice League\",\"node_id\":\"MDQ6VGVhbTE=\",\"parent\":null,\"permission\":\"admin\",\"privacy\":\"closed\",\"repositories_url\":\"https://api.github.com/teams/1/repos\",\"slug\":\"justice-league\",\"url\":\"https://api.github.com/teams/1\"}],\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/dismissal_restrictions/teams\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/dismissal_restrictions\",\"users\":[{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}],\"users_url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/dismissal_restrictions/users\"},\"require_code_owner_reviews\":true,\"required_approving_review_count\":2,\"url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/required_pull_request_reviews\"},\"required_status_checks\":{\"contexts\":[\"continuous-integration/travis-ci\"],\"contexts_url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/required_status_checks/contexts\",\"enforcement_level\":\"non_admins\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/required_status_checks\"},\"restrictions\":{\"apps\":[{\"created_at\":\"2017-07-08T16:18:44-04:00\",\"description\":\"\",\"events\":[\"push\",\"pull_request\"],\"external_url\":\"https://example.com\",\"html_url\":\"https://github.com/apps/octoapp\",\"id\":1,\"name\":\"Octocat App\",\"node_id\":\"MDExOkludGVncmF0aW9uMQ==\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"description\":\"A great organization\",\"events_url\":\"https://api.github.com/orgs/github/events\",\"hooks_url\":\"https://api.github.com/orgs/github/hooks\",\"id\":1,\"issues_url\":\"https://api.github.com/orgs/github/issues\",\"login\":\"github\",\"members_url\":\"https://api.github.com/orgs/github/members{/member}\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"public_members_url\":\"https://api.github.com/orgs/github/public_members{/member}\",\"repos_url\":\"https://api.github.com/orgs/github/repos\",\"url\":\"https://api.github.com/orgs/github\"},\"permissions\":{\"contents\":\"read\",\"issues\":\"write\",\"metadata\":\"read\",\"single_file\":\"write\"},\"slug\":\"octoapp\",\"updated_at\":\"2017-07-08T16:18:44-04:00\"}],\"apps_url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/restrictions/teams\",\"teams\":[{\"description\":\"A great team.\",\"html_url\":\"https://github.com/orgs/github/teams/justice-league\",\"id\":1,\"members_url\":\"https://api.github.com/teams/1/members{/member}\",\"name\":\"Justice League\",\"node_id\":\"MDQ6VGVhbTE=\",\"parent\":null,\"permission\":\"admin\",\"privacy\":\"closed\",\"repositories_url\":\"https://api.github.com/teams/1/repos\",\"slug\":\"justice-league\",\"url\":\"https://api.github.com/teams/1\"}],\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/restrictions/teams\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/restrictions\",\"users\":[{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}],\"users_url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/restrictions/users\"},\"url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ BranchProtection

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 BranchProtection
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestBranchProtectionAllowDeletions_EncodeDecode(t *testing.T) {
	var typ BranchProtectionAllowDeletions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchProtectionAllowDeletions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBranchProtectionAllowForcePushes_EncodeDecode(t *testing.T) {
	var typ BranchProtectionAllowForcePushes
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchProtectionAllowForcePushes
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBranchProtectionRequiredConversationResolution_EncodeDecode(t *testing.T) {
	var typ BranchProtectionRequiredConversationResolution
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchProtectionRequiredConversationResolution
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBranchProtectionRequiredLinearHistory_EncodeDecode(t *testing.T) {
	var typ BranchProtectionRequiredLinearHistory
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchProtectionRequiredLinearHistory
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBranchProtectionRequiredSignatures_EncodeDecode(t *testing.T) {
	var typ BranchProtectionRequiredSignatures
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchProtectionRequiredSignatures
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBranchProtectionRequiredStatusChecks_EncodeDecode(t *testing.T) {
	var typ BranchProtectionRequiredStatusChecks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchProtectionRequiredStatusChecks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBranchRestrictionPolicy_EncodeDecode(t *testing.T) {
	var typ BranchRestrictionPolicy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchRestrictionPolicy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestBranchRestrictionPolicy_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"apps\":[{\"created_at\":\"2017-07-08T16:18:44-04:00\",\"description\":\"\",\"events\":[\"push\",\"pull_request\"],\"external_url\":\"https://example.com\",\"html_url\":\"https://github.com/apps/octoapp\",\"id\":1,\"name\":\"Octocat App\",\"node_id\":\"MDExOkludGVncmF0aW9uMQ==\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"description\":\"A great organization\",\"events_url\":\"https://api.github.com/orgs/github/events\",\"hooks_url\":\"https://api.github.com/orgs/github/hooks\",\"id\":1,\"issues_url\":\"https://api.github.com/orgs/github/issues\",\"login\":\"github\",\"members_url\":\"https://api.github.com/orgs/github/members{/member}\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"public_members_url\":\"https://api.github.com/orgs/github/public_members{/member}\",\"repos_url\":\"https://api.github.com/orgs/github/repos\",\"url\":\"https://api.github.com/orgs/github\"},\"permissions\":{\"contents\":\"read\",\"issues\":\"write\",\"metadata\":\"read\",\"single_file\":\"write\"},\"slug\":\"octoapp\",\"updated_at\":\"2017-07-08T16:18:44-04:00\"}],\"apps_url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/restrictions/teams\",\"teams\":[{\"description\":\"A great team.\",\"html_url\":\"https://github.com/orgs/github/teams/justice-league\",\"id\":1,\"members_url\":\"https://api.github.com/teams/1/members{/member}\",\"name\":\"Justice League\",\"node_id\":\"MDQ6VGVhbTE=\",\"parent\":null,\"permission\":\"admin\",\"privacy\":\"closed\",\"repositories_url\":\"https://api.github.com/teams/1/repos\",\"slug\":\"justice-league\",\"url\":\"https://api.github.com/teams/1\"}],\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/restrictions/teams\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/restrictions\",\"users\":[{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}],\"users_url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/restrictions/users\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ BranchRestrictionPolicy

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 BranchRestrictionPolicy
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestBranchRestrictionPolicyAppsItem_EncodeDecode(t *testing.T) {
	var typ BranchRestrictionPolicyAppsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchRestrictionPolicyAppsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBranchRestrictionPolicyAppsItemOwner_EncodeDecode(t *testing.T) {
	var typ BranchRestrictionPolicyAppsItemOwner
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchRestrictionPolicyAppsItemOwner
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBranchRestrictionPolicyAppsItemPermissions_EncodeDecode(t *testing.T) {
	var typ BranchRestrictionPolicyAppsItemPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchRestrictionPolicyAppsItemPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBranchRestrictionPolicyTeamsItem_EncodeDecode(t *testing.T) {
	var typ BranchRestrictionPolicyTeamsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchRestrictionPolicyTeamsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBranchRestrictionPolicyUsersItem_EncodeDecode(t *testing.T) {
	var typ BranchRestrictionPolicyUsersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchRestrictionPolicyUsersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBranchShort_EncodeDecode(t *testing.T) {
	var typ BranchShort
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchShort
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBranchShortCommit_EncodeDecode(t *testing.T) {
	var typ BranchShortCommit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchShortCommit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBranchWithProtection_EncodeDecode(t *testing.T) {
	var typ BranchWithProtection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchWithProtection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestBranchWithProtection_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"_links\":{\"html\":\"https://github.com/octocat/Hello-World/tree/master\",\"self\":\"https://api.github.com/repos/octocat/Hello-World/branches/master\"},\"commit\":{\"author\":{\"avatar_url\":\"https://secure.gravatar.com/avatar/7ad39074b0584bc555d0417ae3e7d974?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-140.png\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":583231,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e/comments\",\"commit\":{\"author\":{\"date\":\"2012-03-06T15:06:50-08:00\",\"email\":\"octocat@nowhere.com\",\"name\":\"The Octocat\"},\"comment_count\":0,\"committer\":{\"date\":\"2012-03-06T15:06:50-08:00\",\"email\":\"octocat@nowhere.com\",\"name\":\"The Octocat\"},\"message\":\"Merge pull request #6 from Spaceghost/patch-1\\n\\nNew line at end of file.\",\"tree\":{\"sha\":\"b4eecafa9be2f2006ce1b709d6857b07069b4608\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees/b4eecafa9be2f2006ce1b709d6857b07069b4608\"},\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/7fd1a60b01f91b314f59955a4e4d4e80d8edf11d\",\"verification\":{\"payload\":null,\"reason\":\"unsigned\",\"signature\":null,\"verified\":false}},\"committer\":{\"avatar_url\":\"https://secure.gravatar.com/avatar/7ad39074b0584bc555d0417ae3e7d974?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-140.png\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":583231,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"html_url\":\"https://github.com/octocat/Hello-World/commit/6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"node_id\":\"MDY6Q29tbWl0N2ZkMWE2MGIwMWY5MWIzMTRmNTk5NTVhNGU0ZDRlODBkOGVkZjExZA==\",\"parents\":[{\"sha\":\"553c2077f0edc3d5dc5d17262f6aa498e69d6f8e\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/commits/553c2077f0edc3d5dc5d17262f6aa498e69d6f8e\"},{\"sha\":\"762941318ee16e59dabbacb1b4049eec22f0d303\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/commits/762941318ee16e59dabbacb1b4049eec22f0d303\"}],\"sha\":\"7fd1a60b01f91b314f59955a4e4d4e80d8edf11d\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/commits/7fd1a60b01f91b314f59955a4e4d4e80d8edf11d\"},\"name\":\"master\",\"protected\":true,\"protection\":{\"required_status_checks\":{\"contexts\":[\"ci-test\",\"linter\"],\"enforcement_level\":\"non_admins\"}},\"protection_url\":\"https://api.github.com/repos/octocat/hello-world/branches/master/protection\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ BranchWithProtection

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 BranchWithProtection
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestBranchWithProtectionLinks_EncodeDecode(t *testing.T) {
	var typ BranchWithProtectionLinks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BranchWithProtectionLinks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCheckAnnotation_EncodeDecode(t *testing.T) {
	var typ CheckAnnotation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CheckAnnotation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCheckRun_EncodeDecode(t *testing.T) {
	var typ CheckRun
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CheckRun
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCheckRun_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"app\":{\"created_at\":\"2017-07-08T16:18:44-04:00\",\"description\":\"\",\"events\":[\"push\",\"pull_request\"],\"external_url\":\"https://example.com\",\"html_url\":\"https://github.com/apps/octoapp\",\"id\":1,\"name\":\"Octocat App\",\"node_id\":\"MDExOkludGVncmF0aW9uMQ==\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/orgs/github/events\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"github\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/orgs/github/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/orgs/github\"},\"permissions\":{\"contents\":\"read\",\"issues\":\"write\",\"metadata\":\"read\",\"single_file\":\"write\"},\"slug\":\"octoapp\",\"updated_at\":\"2017-07-08T16:18:44-04:00\"},\"check_suite\":{\"id\":5},\"completed_at\":\"2018-05-04T01:14:52Z\",\"conclusion\":\"neutral\",\"details_url\":\"https://example.com\",\"external_id\":\"\",\"head_sha\":\"ce587453ced02b1526dfb4cb910479d431683101\",\"html_url\":\"https://github.com/github/hello-world/runs/4\",\"id\":4,\"name\":\"mighty_readme\",\"node_id\":\"MDg6Q2hlY2tSdW40\",\"output\":{\"annotations_count\":2,\"annotations_url\":\"https://api.github.com/repos/github/hello-world/check-runs/4/annotations\",\"summary\":\"There are 0 failures, 2 warnings, and 1 notice.\",\"text\":\"You may have some misspelled words on lines 2 and 4. You also may want to add a section in your README about how to install your app.\",\"title\":\"Mighty Readme report\"},\"pull_requests\":[{\"base\":{\"ref\":\"master\",\"repo\":{\"id\":526,\"name\":\"hello-world\",\"url\":\"https://api.github.com/repos/github/hello-world\"},\"sha\":\"e7fdf7640066d71ad16a86fbcbb9c6a10a18af4f\"},\"head\":{\"ref\":\"say-hello\",\"repo\":{\"id\":526,\"name\":\"hello-world\",\"url\":\"https://api.github.com/repos/github/hello-world\"},\"sha\":\"3dca65fa3e8d4b3da3f3d056c59aee1c50f41390\"},\"id\":1934,\"number\":3956,\"url\":\"https://api.github.com/repos/github/hello-world/pulls/1\"}],\"started_at\":\"2018-05-04T01:14:52Z\",\"status\":\"completed\",\"url\":\"https://api.github.com/repos/github/hello-world/check-runs/4\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CheckRun

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CheckRun
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCheckRunCheckSuite_EncodeDecode(t *testing.T) {
	var typ CheckRunCheckSuite
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CheckRunCheckSuite
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCheckRunConclusion_EncodeDecode(t *testing.T) {
	var typ CheckRunConclusion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CheckRunConclusion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCheckRunConclusion_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"neutral\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CheckRunConclusion

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CheckRunConclusion
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCheckRunOutput_EncodeDecode(t *testing.T) {
	var typ CheckRunOutput
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CheckRunOutput
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCheckRunStatus_EncodeDecode(t *testing.T) {
	var typ CheckRunStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CheckRunStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCheckRunStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"queued\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CheckRunStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CheckRunStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCheckSuite_EncodeDecode(t *testing.T) {
	var typ CheckSuite
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CheckSuite
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCheckSuite_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"after\":\"d6fde92930d4715a2b49857d24b940956b26d2d3\",\"app\":{\"created_at\":\"2017-07-08T16:18:44-04:00\",\"description\":\"\",\"events\":[\"push\",\"pull_request\"],\"external_url\":\"https://example.com\",\"html_url\":\"https://github.com/apps/octoapp\",\"id\":1,\"name\":\"Octocat App\",\"node_id\":\"MDExOkludGVncmF0aW9uMQ==\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/orgs/github/events\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"github\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/orgs/github/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/orgs/github\"},\"permissions\":{\"contents\":\"read\",\"issues\":\"write\",\"metadata\":\"read\",\"single_file\":\"write\"},\"slug\":\"octoapp\",\"updated_at\":\"2017-07-08T16:18:44-04:00\"},\"before\":\"146e867f55c26428e5f9fade55a9bbf5e95a7912\",\"check_runs_url\":\"https://api.github.com/repos/octocat/Hello-World/check-suites/5/check-runs\",\"conclusion\":\"neutral\",\"created_at\":\"2017-07-08T16:18:44-04:00\",\"head_branch\":\"master\",\"head_commit\":{\"author\":{\"email\":\"octocat@nowhere.com\",\"name\":\"The Octocat\"},\"committer\":{\"email\":\"octocat@nowhere.com\",\"name\":\"The Octocat\"},\"id\":\"7fd1a60b01f91b314f59955a4e4d4e80d8edf11d\",\"message\":\"Merge pull request #6 from Spaceghost/patch-1\\n\\nNew line at end of file.\",\"timestamp\":\"2016-10-10T00:00:00Z\",\"tree_id\":\"7fd1a60b01f91b314f59955a4e4d4e80d8edf11d\"},\"head_sha\":\"d6fde92930d4715a2b49857d24b940956b26d2d3\",\"id\":5,\"latest_check_runs_count\":1,\"node_id\":\"MDEwOkNoZWNrU3VpdGU1\",\"pull_requests\":[],\"repository\":{\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":false,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World-Template.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/events\",\"fork\":false,\"forks\":9,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/forks\",\"full_name\":\"octocat/Hello-World-Template\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World-Template.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World-Template\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World-Template\",\"name\":\"Hello-World-Template\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/notifications{?since,all,participating}\",\"open_issues\":0,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World-Template.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World-Template\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World-Template\",\"visibility\":\"public\",\"watchers\":80,\"watchers_count\":80},\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers_count\":80},\"status\":\"completed\",\"updated_at\":\"2017-07-08T16:18:44-04:00\",\"url\":\"https://api.github.com/repos/github/hello-world/check-suites/5\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CheckSuite

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CheckSuite
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCheckSuiteConclusion_EncodeDecode(t *testing.T) {
	var typ CheckSuiteConclusion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CheckSuiteConclusion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCheckSuiteConclusion_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"neutral\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CheckSuiteConclusion

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CheckSuiteConclusion
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCheckSuitePreference_EncodeDecode(t *testing.T) {
	var typ CheckSuitePreference
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CheckSuitePreference
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCheckSuitePreference_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"preferences\":{\"auto_trigger_checks\":[{\"app_id\":2,\"setting\":true},{\"app_id\":4,\"setting\":false}]},\"repository\":{\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":false,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"template_repository\":{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World-Template.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/events\",\"fork\":false,\"forks\":9,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/forks\",\"full_name\":\"octocat/Hello-World-Template\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World-Template.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World-Template\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World-Template\",\"name\":\"Hello-World-Template\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/notifications{?since,all,participating}\",\"open_issues\":0,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World-Template.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World-Template\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World-Template\",\"visibility\":\"public\",\"watchers\":80,\"watchers_count\":80},\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers_count\":80}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CheckSuitePreference

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CheckSuitePreference
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCheckSuitePreferencePreferences_EncodeDecode(t *testing.T) {
	var typ CheckSuitePreferencePreferences
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CheckSuitePreferencePreferences
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCheckSuitePreferencePreferencesAutoTriggerChecksItem_EncodeDecode(t *testing.T) {
	var typ CheckSuitePreferencePreferencesAutoTriggerChecksItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CheckSuitePreferencePreferencesAutoTriggerChecksItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCheckSuiteStatus_EncodeDecode(t *testing.T) {
	var typ CheckSuiteStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CheckSuiteStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCheckSuiteStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"completed\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CheckSuiteStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CheckSuiteStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestChecksCreateSuiteCreated_EncodeDecode(t *testing.T) {
	var typ ChecksCreateSuiteCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChecksCreateSuiteCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChecksCreateSuiteOK_EncodeDecode(t *testing.T) {
	var typ ChecksCreateSuiteOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChecksCreateSuiteOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChecksCreateSuiteReq_EncodeDecode(t *testing.T) {
	var typ ChecksCreateSuiteReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChecksCreateSuiteReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestChecksCreateSuiteReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"head_sha\":\"d6fde92930d4715a2b49857d24b940956b26d2d3\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ChecksCreateSuiteReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ChecksCreateSuiteReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestChecksListForRefOK_EncodeDecode(t *testing.T) {
	var typ ChecksListForRefOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChecksListForRefOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestChecksListForRefOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"check_runs\":[{\"app\":{\"created_at\":\"2017-07-08T16:18:44-04:00\",\"description\":\"\",\"events\":[\"push\",\"pull_request\"],\"external_url\":\"https://example.com\",\"html_url\":\"https://github.com/apps/octoapp\",\"id\":1,\"name\":\"Octocat App\",\"node_id\":\"MDExOkludGVncmF0aW9uMQ==\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/orgs/github/events\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"github\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/orgs/github/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/orgs/github\"},\"permissions\":{\"contents\":\"read\",\"issues\":\"write\",\"metadata\":\"read\",\"single_file\":\"write\"},\"slug\":\"octoapp\",\"updated_at\":\"2017-07-08T16:18:44-04:00\"},\"check_suite\":{\"id\":5},\"completed_at\":\"2018-05-04T01:14:52Z\",\"conclusion\":\"neutral\",\"details_url\":\"https://example.com\",\"external_id\":\"\",\"head_sha\":\"ce587453ced02b1526dfb4cb910479d431683101\",\"html_url\":\"https://github.com/github/hello-world/runs/4\",\"id\":4,\"name\":\"mighty_readme\",\"node_id\":\"MDg6Q2hlY2tSdW40\",\"output\":{\"annotations_count\":2,\"annotations_url\":\"https://api.github.com/repos/github/hello-world/check-runs/4/annotations\",\"summary\":\"There are 0 failures, 2 warnings, and 1 notice.\",\"text\":\"You may have some misspelled words on lines 2 and 4. You also may want to add a section in your README about how to install your app.\",\"title\":\"Mighty Readme report\"},\"pull_requests\":[{\"base\":{\"ref\":\"master\",\"repo\":{\"id\":526,\"name\":\"hello-world\",\"url\":\"https://api.github.com/repos/github/hello-world\"},\"sha\":\"e7fdf7640066d71ad16a86fbcbb9c6a10a18af4f\"},\"head\":{\"ref\":\"say-hello\",\"repo\":{\"id\":526,\"name\":\"hello-world\",\"url\":\"https://api.github.com/repos/github/hello-world\"},\"sha\":\"3dca65fa3e8d4b3da3f3d056c59aee1c50f41390\"},\"id\":1934,\"number\":3956,\"url\":\"https://api.github.com/repos/github/hello-world/pulls/1\"}],\"started_at\":\"2018-05-04T01:14:52Z\",\"status\":\"completed\",\"url\":\"https://api.github.com/repos/github/hello-world/check-runs/4\"}],\"total_count\":1}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ChecksListForRefOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ChecksListForRefOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestChecksListForSuiteOK_EncodeDecode(t *testing.T) {
	var typ ChecksListForSuiteOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChecksListForSuiteOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestChecksListForSuiteOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"check_runs\":[{\"app\":{\"created_at\":\"2017-07-08T16:18:44-04:00\",\"description\":\"\",\"events\":[\"push\",\"pull_request\"],\"external_url\":\"https://example.com\",\"html_url\":\"https://github.com/apps/octoapp\",\"id\":1,\"name\":\"Octocat App\",\"node_id\":\"MDExOkludGVncmF0aW9uMQ==\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/orgs/github/events\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"github\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/orgs/github/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/orgs/github\"},\"permissions\":{\"contents\":\"read\",\"issues\":\"write\",\"metadata\":\"read\",\"single_file\":\"write\"},\"slug\":\"octoapp\",\"updated_at\":\"2017-07-08T16:18:44-04:00\"},\"check_suite\":{\"id\":5},\"completed_at\":\"2018-05-04T01:14:52Z\",\"conclusion\":\"neutral\",\"details_url\":\"https://example.com\",\"external_id\":\"\",\"head_sha\":\"ce587453ced02b1526dfb4cb910479d431683101\",\"html_url\":\"https://github.com/github/hello-world/runs/4\",\"id\":4,\"name\":\"mighty_readme\",\"node_id\":\"MDg6Q2hlY2tSdW40\",\"output\":{\"annotations_count\":2,\"annotations_url\":\"https://api.github.com/repos/github/hello-world/check-runs/4/annotations\",\"summary\":\"There are 0 failures, 2 warnings, and 1 notice.\",\"text\":\"You may have some misspelled words on lines 2 and 4. You also may want to add a section in your README about how to install your app.\",\"title\":\"Mighty Readme report\"},\"pull_requests\":[{\"base\":{\"ref\":\"master\",\"repo\":{\"id\":526,\"name\":\"hello-world\",\"url\":\"https://api.github.com/repos/github/hello-world\"},\"sha\":\"e7fdf7640066d71ad16a86fbcbb9c6a10a18af4f\"},\"head\":{\"ref\":\"say-hello\",\"repo\":{\"id\":526,\"name\":\"hello-world\",\"url\":\"https://api.github.com/repos/github/hello-world\"},\"sha\":\"3dca65fa3e8d4b3da3f3d056c59aee1c50f41390\"},\"id\":1934,\"number\":3956,\"url\":\"https://api.github.com/repos/github/hello-world/pulls/1\"}],\"started_at\":\"2018-05-04T01:14:52Z\",\"status\":\"completed\",\"url\":\"https://api.github.com/repos/github/hello-world/check-runs/4\"}],\"total_count\":1}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ChecksListForSuiteOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ChecksListForSuiteOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestChecksListSuitesForRefOK_EncodeDecode(t *testing.T) {
	var typ ChecksListSuitesForRefOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChecksListSuitesForRefOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestChecksListSuitesForRefOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"check_suites\":[{\"after\":\"d6fde92930d4715a2b49857d24b940956b26d2d3\",\"app\":{\"created_at\":\"2017-07-08T16:18:44-04:00\",\"description\":\"\",\"events\":[\"push\",\"pull_request\"],\"external_url\":\"https://example.com\",\"html_url\":\"https://github.com/apps/octoapp\",\"id\":1,\"name\":\"Octocat App\",\"node_id\":\"MDExOkludGVncmF0aW9uMQ==\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/orgs/github/events\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"github\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/orgs/github/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/orgs/github\"},\"permissions\":{\"contents\":\"read\",\"issues\":\"write\",\"metadata\":\"read\",\"single_file\":\"write\"},\"slug\":\"octoapp\",\"updated_at\":\"2017-07-08T16:18:44-04:00\"},\"before\":\"146e867f55c26428e5f9fade55a9bbf5e95a7912\",\"check_runs_url\":\"https://api.github.com/repos/octocat/Hello-World/check-suites/5/check-runs\",\"conclusion\":\"neutral\",\"created_at\":\"2011-01-26T19:01:12Z\",\"head_branch\":\"master\",\"head_commit\":{\"author\":{\"email\":\"octocat@nowhere.com\",\"name\":\"The Octocat\"},\"committer\":{\"email\":\"octocat@nowhere.com\",\"name\":\"The Octocat\"},\"id\":\"7fd1a60b01f91b314f59955a4e4d4e80d8edf11d\",\"message\":\"Merge pull request #6 from Spaceghost/patch-1\\n\\nNew line at end of file.\",\"timestamp\":\"2016-10-10T00:00:00Z\",\"tree_id\":\"7fd1a60b01f91b314f59955a4e4d4e80d8edf11d\"},\"head_sha\":\"d6fde92930d4715a2b49857d24b940956b26d2d3\",\"id\":5,\"latest_check_runs_count\":1,\"node_id\":\"MDEwOkNoZWNrU3VpdGU1\",\"pull_requests\":[],\"repository\":{\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers_count\":80},\"status\":\"completed\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/github/hello-world/check-suites/5\"}],\"total_count\":1}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ChecksListSuitesForRefOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ChecksListSuitesForRefOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestChecksRerequestSuiteCreated_EncodeDecode(t *testing.T) {
	var typ ChecksRerequestSuiteCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChecksRerequestSuiteCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestChecksSetSuitesPreferencesReq_EncodeDecode(t *testing.T) {
	var typ ChecksSetSuitesPreferencesReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChecksSetSuitesPreferencesReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestChecksSetSuitesPreferencesReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"auto_trigger_checks\":[{\"app_id\":4,\"setting\":false}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ChecksSetSuitesPreferencesReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ChecksSetSuitesPreferencesReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestChecksSetSuitesPreferencesReqAutoTriggerChecksItem_EncodeDecode(t *testing.T) {
	var typ ChecksSetSuitesPreferencesReqAutoTriggerChecksItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ChecksSetSuitesPreferencesReqAutoTriggerChecksItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCloneTraffic_EncodeDecode(t *testing.T) {
	var typ CloneTraffic
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CloneTraffic
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCloneTraffic_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"clones\":[{\"count\":2,\"timestamp\":\"2016-10-10T00:00:00Z\",\"uniques\":1},{\"count\":17,\"timestamp\":\"2016-10-11T00:00:00Z\",\"uniques\":16},{\"count\":21,\"timestamp\":\"2016-10-12T00:00:00Z\",\"uniques\":15},{\"count\":8,\"timestamp\":\"2016-10-13T00:00:00Z\",\"uniques\":7},{\"count\":5,\"timestamp\":\"2016-10-14T00:00:00Z\",\"uniques\":5},{\"count\":2,\"timestamp\":\"2016-10-15T00:00:00Z\",\"uniques\":2},{\"count\":8,\"timestamp\":\"2016-10-16T00:00:00Z\",\"uniques\":7},{\"count\":26,\"timestamp\":\"2016-10-17T00:00:00Z\",\"uniques\":15},{\"count\":19,\"timestamp\":\"2016-10-18T00:00:00Z\",\"uniques\":17},{\"count\":19,\"timestamp\":\"2016-10-19T00:00:00Z\",\"uniques\":14},{\"count\":19,\"timestamp\":\"2016-10-20T00:00:00Z\",\"uniques\":15},{\"count\":9,\"timestamp\":\"2016-10-21T00:00:00Z\",\"uniques\":7},{\"count\":5,\"timestamp\":\"2016-10-22T00:00:00Z\",\"uniques\":5},{\"count\":6,\"timestamp\":\"2016-10-23T00:00:00Z\",\"uniques\":5},{\"count\":7,\"timestamp\":\"2016-10-24T00:00:00Z\",\"uniques\":5}],\"count\":173,\"uniques\":128}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CloneTraffic

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CloneTraffic
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCodeFrequencyStat_EncodeDecode(t *testing.T) {
	var typ CodeFrequencyStat
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeFrequencyStat
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeOfConduct_EncodeDecode(t *testing.T) {
	var typ CodeOfConduct
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeOfConduct
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCodeOfConduct_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"# Contributor Covenant Code of Conduct\\n\\n## Our Pledge\\n\\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\\n\\n## Our Standards\\n\\nExamples of behavior that contributes to creating a positive environment include:\\n\\n* Using welcoming and inclusive language\\n* Being respectful of differing viewpoints and experiences\\n* Gracefully accepting constructive criticism\\n* Focusing on what is best for the community\\n* Showing empathy towards other community members\\n\\nExamples of unacceptable behavior by participants include:\\n\\n* The use of sexualized language or imagery and unwelcome sexual attention or advances\\n* Trolling, insulting/derogatory comments, and personal or political attacks\\n* Public or private harassment\\n* Publishing others' private information, such as a physical or electronic address, without explicit permission\\n* Other conduct which could reasonably be considered inappropriate in a professional setting\\n\\n## Our Responsibilities\\n\\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response\\n                  to any instances of unacceptable behavior.\\n\\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\\n\\n## Scope\\n\\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address,\\n                  posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\\n\\n## Enforcement\\n\\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [EMAIL]. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\\n\\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.\\n\\n## Attribution\\n\\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]\\n\\n[homepage]: http://contributor-covenant.org\\n[version]: http://contributor-covenant.org/version/1/4/\\n\",\"html_url\":\"http://contributor-covenant.org/version/1/4/\",\"key\":\"contributor_covenant\",\"name\":\"Contributor Covenant\",\"url\":\"https://api.github.com/codes_of_conduct/contributor_covenant\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CodeOfConduct

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CodeOfConduct
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCodeOfConductSimple_EncodeDecode(t *testing.T) {
	var typ CodeOfConductSimple
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeOfConductSimple
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAlert_EncodeDecode(t *testing.T) {
	var typ CodeScanningAlert
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAlert
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCodeScanningAlert_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2020-06-19T11:21:34Z\",\"dismissed_at\":\"2020-02-14T12:29:18Z\",\"dismissed_by\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":54933897,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"dismissed_reason\":\"false positive\",\"html_url\":\"https://github.com/octocat/hello-world/code-scanning/42\",\"instances\":null,\"instances_url\":\"https://api.github.com/repos/octocat/hello-world/code-scanning/alerts/42/instances\",\"most_recent_instance\":{\"analysis_key\":\".github/workflows/codeql-analysis.yml:CodeQL-Build\",\"classifications\":[\"test\"],\"commit_sha\":\"39406e42cb832f683daa691dd652a8dc36ee8930\",\"environment\":\"{}\",\"location\":{\"end_column\":18,\"end_line\":917,\"path\":\"spec-main/api-session-spec.ts\",\"start_column\":7,\"start_line\":917},\"message\":{\"text\":\"This path depends on a user-provided value.\"},\"ref\":\"refs/heads/main\",\"state\":\"dismissed\"},\"number\":42,\"rule\":{\"description\":\"Arbitrary file write during zip extraction (\\\"Zip Slip\\\")\",\"full_description\":\"Extracting files from a malicious zip archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten.\",\"help\":\"# Arbitrary file write during zip extraction (\\\"Zip Slip\\\")\\\\nExtracting files from a malicious zip archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten ...\",\"id\":\"js/zipslip\",\"name\":\"js/zipslip\",\"security_severity_level\":\"high\",\"severity\":\"error\",\"tags\":[\"security\",\"external/cwe/cwe-022\"]},\"state\":\"dismissed\",\"tool\":{\"guid\":null,\"name\":\"CodeQL\",\"version\":\"2.4.0\"},\"url\":\"https://api.github.com/repos/octocat/hello-world/code-scanning/alerts/42\"}"},
		{Input: "{\"created_at\":\"2020-08-25T21:28:36Z\",\"dismissed_at\":\"2020-09-02T22:34:56Z\",\"dismissed_by\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"dismissed_reason\":\"false positive\",\"html_url\":\"https://github.com/octocat/hello-world/code-scanning/42\",\"instances_url\":\"https://api.github.com/repos/octocat/hello-world/code-scanning/alerts/42/instances\",\"most_recent_instance\":{\"analysis_key\":\".github/workflows/codeql-analysis.yml:CodeQL-Build\",\"classifications\":[\"test\"],\"commit_sha\":\"39406e42cb832f683daa691dd652a8dc36ee8930\",\"environment\":\"{}\",\"location\":{\"end_column\":18,\"end_line\":917,\"path\":\"spec-main/api-session-spec.ts\",\"start_column\":7,\"start_line\":917},\"message\":{\"text\":\"This path depends on a user-provided value.\"},\"ref\":\"refs/heads/main\",\"state\":\"dismissed\"},\"number\":42,\"rule\":{\"description\":\"Arbitrary file write during zip extraction (\\\"Zip Slip\\\")\",\"full_description\":\"Extracting files from a malicious zip archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten.\",\"help\":\"# Arbitrary file write during zip extraction (\\\"Zip Slip\\\")\\\\nExtracting files from a malicious zip archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten ...\",\"id\":\"js/zipslip\",\"name\":\"js/zipslip\",\"security_severity_level\":\"high\",\"severity\":\"error\",\"tags\":[\"security\",\"external/cwe/cwe-022\"]},\"state\":\"dismissed\",\"tool\":{\"guid\":null,\"name\":\"CodeQL\",\"version\":\"2.4.0\"},\"url\":\"https://api.github.com/repos/octocat/hello-world/code-scanning/alerts/42\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CodeScanningAlert

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CodeScanningAlert
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCodeScanningAlertClassification_EncodeDecode(t *testing.T) {
	var typ CodeScanningAlertClassification
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAlertClassification
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAlertDismissedAt_EncodeDecode(t *testing.T) {
	var typ CodeScanningAlertDismissedAt
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAlertDismissedAt
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAlertDismissedReason_EncodeDecode(t *testing.T) {
	var typ CodeScanningAlertDismissedReason
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAlertDismissedReason
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAlertEnvironment_EncodeDecode(t *testing.T) {
	var typ CodeScanningAlertEnvironment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAlertEnvironment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAlertInstance_EncodeDecode(t *testing.T) {
	var typ CodeScanningAlertInstance
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAlertInstance
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAlertInstanceMessage_EncodeDecode(t *testing.T) {
	var typ CodeScanningAlertInstanceMessage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAlertInstanceMessage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAlertItems_EncodeDecode(t *testing.T) {
	var typ CodeScanningAlertItems
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAlertItems
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAlertLocation_EncodeDecode(t *testing.T) {
	var typ CodeScanningAlertLocation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAlertLocation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAlertRule_EncodeDecode(t *testing.T) {
	var typ CodeScanningAlertRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAlertRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAlertRuleSecuritySeverityLevel_EncodeDecode(t *testing.T) {
	var typ CodeScanningAlertRuleSecuritySeverityLevel
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAlertRuleSecuritySeverityLevel
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAlertRuleSeverity_EncodeDecode(t *testing.T) {
	var typ CodeScanningAlertRuleSeverity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAlertRuleSeverity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAlertRuleSummary_EncodeDecode(t *testing.T) {
	var typ CodeScanningAlertRuleSummary
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAlertRuleSummary
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAlertRuleSummarySeverity_EncodeDecode(t *testing.T) {
	var typ CodeScanningAlertRuleSummarySeverity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAlertRuleSummarySeverity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAlertSetState_EncodeDecode(t *testing.T) {
	var typ CodeScanningAlertSetState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAlertSetState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAlertState_EncodeDecode(t *testing.T) {
	var typ CodeScanningAlertState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAlertState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAnalysis_EncodeDecode(t *testing.T) {
	var typ CodeScanningAnalysis
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAnalysis
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCodeScanningAnalysis_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"analysis_key\":\".github/workflows/codeql-analysis.yml:analyze\",\"category\":\".github/workflows/codeql-analysis.yml:analyze/language:javascript\",\"commit_sha\":\"c18c69115654ff0166991962832dc2bd7756e655\",\"created_at\":\"2021-01-13T11:55:49Z\",\"deletable\":true,\"environment\":\"{\\\"language\\\":\\\"javascript\\\"}\",\"error\":\"\",\"id\":3602840,\"ref\":\"refs/heads/main\",\"results_count\":3,\"rules_count\":67,\"sarif_id\":\"47177e22-5596-11eb-80a1-c1e54ef945c6\",\"tool\":{\"guid\":null,\"name\":\"CodeQL\",\"version\":\"2.4.0\"},\"url\":\"https://api.github.com/repos/octocat/hello-world/code-scanning/analyses/201\",\"warning\":\"\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CodeScanningAnalysis

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CodeScanningAnalysis
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCodeScanningAnalysisAnalysisKey_EncodeDecode(t *testing.T) {
	var typ CodeScanningAnalysisAnalysisKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAnalysisAnalysisKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAnalysisCategory_EncodeDecode(t *testing.T) {
	var typ CodeScanningAnalysisCategory
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAnalysisCategory
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAnalysisCommitSha_EncodeDecode(t *testing.T) {
	var typ CodeScanningAnalysisCommitSha
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAnalysisCommitSha
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAnalysisCreatedAt_EncodeDecode(t *testing.T) {
	var typ CodeScanningAnalysisCreatedAt
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAnalysisCreatedAt
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAnalysisDeletion_EncodeDecode(t *testing.T) {
	var typ CodeScanningAnalysisDeletion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAnalysisDeletion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCodeScanningAnalysisDeletion_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"confirm_delete_url\":\"https://api.github.com/repos/octocat/hello-world/code-scanning/analyses/41?confirm_delete\",\"next_analysis_url\":\"https://api.github.com/repos/octocat/hello-world/code-scanning/analyses/41\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CodeScanningAnalysisDeletion

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CodeScanningAnalysisDeletion
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCodeScanningAnalysisEnvironment_EncodeDecode(t *testing.T) {
	var typ CodeScanningAnalysisEnvironment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAnalysisEnvironment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAnalysisSarifFile_EncodeDecode(t *testing.T) {
	var typ CodeScanningAnalysisSarifFile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAnalysisSarifFile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAnalysisSarifID_EncodeDecode(t *testing.T) {
	var typ CodeScanningAnalysisSarifID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAnalysisSarifID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAnalysisTool_EncodeDecode(t *testing.T) {
	var typ CodeScanningAnalysisTool
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAnalysisTool
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAnalysisToolGUID_EncodeDecode(t *testing.T) {
	var typ CodeScanningAnalysisToolGUID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAnalysisToolGUID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAnalysisToolName_EncodeDecode(t *testing.T) {
	var typ CodeScanningAnalysisToolName
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAnalysisToolName
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAnalysisToolVersion_EncodeDecode(t *testing.T) {
	var typ CodeScanningAnalysisToolVersion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAnalysisToolVersion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningAnalysisURL_EncodeDecode(t *testing.T) {
	var typ CodeScanningAnalysisURL
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningAnalysisURL
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningDeleteAnalysisBadRequest_EncodeDecode(t *testing.T) {
	var typ CodeScanningDeleteAnalysisBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningDeleteAnalysisBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningDeleteAnalysisForbidden_EncodeDecode(t *testing.T) {
	var typ CodeScanningDeleteAnalysisForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningDeleteAnalysisForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningDeleteAnalysisNotFound_EncodeDecode(t *testing.T) {
	var typ CodeScanningDeleteAnalysisNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningDeleteAnalysisNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningGetAlertForbidden_EncodeDecode(t *testing.T) {
	var typ CodeScanningGetAlertForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningGetAlertForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningGetAlertNotFound_EncodeDecode(t *testing.T) {
	var typ CodeScanningGetAlertNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningGetAlertNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningGetAnalysisForbidden_EncodeDecode(t *testing.T) {
	var typ CodeScanningGetAnalysisForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningGetAnalysisForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningGetAnalysisNotFound_EncodeDecode(t *testing.T) {
	var typ CodeScanningGetAnalysisNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningGetAnalysisNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningListAlertInstancesForbidden_EncodeDecode(t *testing.T) {
	var typ CodeScanningListAlertInstancesForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningListAlertInstancesForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningListAlertInstancesNotFound_EncodeDecode(t *testing.T) {
	var typ CodeScanningListAlertInstancesNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningListAlertInstancesNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningListAlertInstancesOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ CodeScanningListAlertInstancesOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningListAlertInstancesOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningListAlertsForRepoForbidden_EncodeDecode(t *testing.T) {
	var typ CodeScanningListAlertsForRepoForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningListAlertsForRepoForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningListAlertsForRepoNotFound_EncodeDecode(t *testing.T) {
	var typ CodeScanningListAlertsForRepoNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningListAlertsForRepoNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningListAlertsForRepoOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ CodeScanningListAlertsForRepoOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningListAlertsForRepoOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningListRecentAnalysesForbidden_EncodeDecode(t *testing.T) {
	var typ CodeScanningListRecentAnalysesForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningListRecentAnalysesForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningListRecentAnalysesNotFound_EncodeDecode(t *testing.T) {
	var typ CodeScanningListRecentAnalysesNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningListRecentAnalysesNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningListRecentAnalysesOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ CodeScanningListRecentAnalysesOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningListRecentAnalysesOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningRef_EncodeDecode(t *testing.T) {
	var typ CodeScanningRef
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningRef
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningSarifsReceipt_EncodeDecode(t *testing.T) {
	var typ CodeScanningSarifsReceipt
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningSarifsReceipt
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCodeScanningSarifsReceipt_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":\"47177e22-5596-11eb-80a1-c1e54ef945c6\",\"url\":\"https://api.github.com/repos/octocat/hello-world/code-scanning/sarifs/47177e22-5596-11eb-80a1-c1e54ef945c6\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CodeScanningSarifsReceipt

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CodeScanningSarifsReceipt
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCodeScanningSarifsStatus_EncodeDecode(t *testing.T) {
	var typ CodeScanningSarifsStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningSarifsStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCodeScanningSarifsStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"analyses_url\":\"https://api.github.com/repos/octocat/hello-world/code-scanning/analyses?sarif_id=47177e22-5596-11eb-80a1-c1e54ef945c6\",\"processing_status\":\"complete\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CodeScanningSarifsStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CodeScanningSarifsStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCodeScanningSarifsStatusProcessingStatus_EncodeDecode(t *testing.T) {
	var typ CodeScanningSarifsStatusProcessingStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningSarifsStatusProcessingStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningUpdateAlertForbidden_EncodeDecode(t *testing.T) {
	var typ CodeScanningUpdateAlertForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningUpdateAlertForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningUpdateAlertNotFound_EncodeDecode(t *testing.T) {
	var typ CodeScanningUpdateAlertNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningUpdateAlertNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningUpdateAlertReq_EncodeDecode(t *testing.T) {
	var typ CodeScanningUpdateAlertReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningUpdateAlertReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCodeScanningUpdateAlertReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"dismissed_reason\":\"false positive\",\"state\":\"dismissed\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CodeScanningUpdateAlertReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CodeScanningUpdateAlertReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCodeScanningUploadSarifForbidden_EncodeDecode(t *testing.T) {
	var typ CodeScanningUploadSarifForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningUploadSarifForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningUploadSarifNotFound_EncodeDecode(t *testing.T) {
	var typ CodeScanningUploadSarifNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningUploadSarifNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeScanningUploadSarifReq_EncodeDecode(t *testing.T) {
	var typ CodeScanningUploadSarifReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeScanningUploadSarifReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodeSearchResultItem_EncodeDecode(t *testing.T) {
	var typ CodeSearchResultItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodeSearchResultItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCodesOfConductGetAllCodesOfConductOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ CodesOfConductGetAllCodesOfConductOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CodesOfConductGetAllCodesOfConductOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCollaborator_EncodeDecode(t *testing.T) {
	var typ Collaborator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Collaborator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCollaboratorPermissions_EncodeDecode(t *testing.T) {
	var typ CollaboratorPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CollaboratorPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCombinedBillingUsage_EncodeDecode(t *testing.T) {
	var typ CombinedBillingUsage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CombinedBillingUsage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCombinedBillingUsage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"days_left_in_billing_cycle\":20,\"estimated_paid_storage_for_month\":15,\"estimated_storage_for_month\":40}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CombinedBillingUsage

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CombinedBillingUsage
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCombinedCommitStatus_EncodeDecode(t *testing.T) {
	var typ CombinedCommitStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CombinedCommitStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCombinedCommitStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"commit_url\":\"https://api.github.com/repos/octocat/Hello-World/6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"repository\":{\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"hooks_url\":\"http://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"name\":\"Hello-World\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\"},\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"state\":\"success\",\"statuses\":[{\"avatar_url\":\"https://github.com/images/error/hubot_happy.gif\",\"context\":\"continuous-integration/jenkins\",\"created_at\":\"2012-07-20T01:19:13Z\",\"description\":\"Build has completed successfully\",\"id\":1,\"node_id\":\"MDY6U3RhdHVzMQ==\",\"state\":\"success\",\"target_url\":\"https://ci.example.com/1000/output\",\"updated_at\":\"2012-07-20T01:19:13Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/6dcb09b5b57875f334f61aebed695e2e4193db5e\"},{\"avatar_url\":\"https://github.com/images/error/other_user_happy.gif\",\"context\":\"security/brakeman\",\"created_at\":\"2012-08-20T01:19:13Z\",\"description\":\"Testing has completed successfully\",\"id\":2,\"node_id\":\"MDY6U3RhdHVzMg==\",\"state\":\"success\",\"target_url\":\"https://ci.example.com/2000/output\",\"updated_at\":\"2012-08-20T01:19:13Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/6dcb09b5b57875f334f61aebed695e2e4193db5e\"}],\"total_count\":2,\"url\":\"https://api.github.com/repos/octocat/Hello-World/6dcb09b5b57875f334f61aebed695e2e4193db5e/status\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CombinedCommitStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CombinedCommitStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCommit_EncodeDecode(t *testing.T) {
	var typ Commit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Commit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCommit_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"author\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e/comments\",\"commit\":{\"author\":{\"date\":\"2011-04-14T16:00:49Z\",\"email\":\"mona@github.com\",\"name\":\"Monalisa Octocat\"},\"comment_count\":0,\"committer\":{\"date\":\"2011-04-14T16:00:49Z\",\"email\":\"mona@github.com\",\"name\":\"Monalisa Octocat\"},\"message\":\"Fix all the bugs\",\"tree\":{\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/tree/6dcb09b5b57875f334f61aebed695e2e4193db5e\"},\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"verification\":{\"payload\":null,\"reason\":\"unsigned\",\"signature\":null,\"verified\":false}},\"committer\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"files\":[{\"additions\":10,\"blob_url\":\"https://github.com/octocat/Hello-World/blob/7ca483543807a51b6079e54ac4cc392bc29ae284/file1.txt\",\"changes\":12,\"deletions\":2,\"filename\":\"file1.txt\",\"patch\":\"@@ -29,7 +29,7 @@\\n.....\",\"raw_url\":\"https://github.com/octocat/Hello-World/raw/7ca483543807a51b6079e54ac4cc392bc29ae284/file1.txt\",\"status\":\"modified\"}],\"html_url\":\"https://github.com/octocat/Hello-World/commit/6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"node_id\":\"MDY6Q29tbWl0NmRjYjA5YjViNTc4NzVmMzM0ZjYxYWViZWQ2OTVlMmU0MTkzZGI1ZQ==\",\"parents\":[{\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e\"}],\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"stats\":{\"additions\":104,\"deletions\":4,\"total\":108},\"url\":\"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Commit

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Commit
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCommitActivity_EncodeDecode(t *testing.T) {
	var typ CommitActivity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommitActivity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCommitComment_EncodeDecode(t *testing.T) {
	var typ CommitComment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommitComment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCommitComment_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"author_association\":\"COLLABORATOR\",\"body\":\"Great stuff\",\"commit_id\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"created_at\":\"2011-04-14T16:00:49Z\",\"html_url\":\"https://github.com/octocat/Hello-World/commit/6dcb09b5b57875f334f61aebed695e2e4193db5e#commitcomment-1\",\"id\":1,\"line\":14,\"node_id\":\"MDEzOkNvbW1pdENvbW1lbnQx\",\"path\":\"file1.txt\",\"position\":4,\"updated_at\":\"2011-04-14T16:00:49Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/comments/1\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
		{Input: "{\"author_association\":\"COLLABORATOR\",\"body\":\"Nice change\",\"commit_id\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"created_at\":\"2011-04-14T16:00:49Z\",\"html_url\":\"https://github.com/octocat/Hello-World/commit/6dcb09b5b57875f334f61aebed695e2e4193db5e#commitcomment-1\",\"id\":1,\"line\":14,\"node_id\":\"MDEzOkNvbW1pdENvbW1lbnQx\",\"path\":\"file1.txt\",\"position\":4,\"updated_at\":\"2011-04-14T16:00:49Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/comments/1\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CommitComment

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CommitComment
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCommitCommit_EncodeDecode(t *testing.T) {
	var typ CommitCommit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommitCommit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCommitCommitTree_EncodeDecode(t *testing.T) {
	var typ CommitCommitTree
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommitCommitTree
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCommitComparison_EncodeDecode(t *testing.T) {
	var typ CommitComparison
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommitComparison
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCommitComparison_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"ahead_by\":1,\"base_commit\":{\"author\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e/comments\",\"commit\":{\"author\":{\"date\":\"2011-04-14T16:00:49Z\",\"email\":\"mona@github.com\",\"name\":\"Monalisa Octocat\"},\"comment_count\":0,\"committer\":{\"date\":\"2011-04-14T16:00:49Z\",\"email\":\"mona@github.com\",\"name\":\"Monalisa Octocat\"},\"message\":\"Fix all the bugs\",\"tree\":{\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/tree/6dcb09b5b57875f334f61aebed695e2e4193db5e\"},\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"verification\":{\"payload\":null,\"reason\":\"unsigned\",\"signature\":null,\"verified\":false}},\"committer\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"html_url\":\"https://github.com/octocat/Hello-World/commit/6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"node_id\":\"MDY6Q29tbWl0NmRjYjA5YjViNTc4NzVmMzM0ZjYxYWViZWQ2OTVlMmU0MTkzZGI1ZQ==\",\"parents\":[{\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e\"}],\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e\"},\"behind_by\":2,\"commits\":[{\"author\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e/comments\",\"commit\":{\"author\":{\"date\":\"2011-04-14T16:00:49Z\",\"email\":\"mona@github.com\",\"name\":\"Monalisa Octocat\"},\"comment_count\":0,\"committer\":{\"date\":\"2011-04-14T16:00:49Z\",\"email\":\"mona@github.com\",\"name\":\"Monalisa Octocat\"},\"message\":\"Fix all the bugs\",\"tree\":{\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/tree/6dcb09b5b57875f334f61aebed695e2e4193db5e\"},\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"verification\":{\"payload\":null,\"reason\":\"unsigned\",\"signature\":null,\"verified\":false}},\"committer\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"html_url\":\"https://github.com/octocat/Hello-World/commit/6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"node_id\":\"MDY6Q29tbWl0NmRjYjA5YjViNTc4NzVmMzM0ZjYxYWViZWQ2OTVlMmU0MTkzZGI1ZQ==\",\"parents\":[{\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e\"}],\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e\"}],\"diff_url\":\"https://github.com/octocat/Hello-World/compare/master...topic.diff\",\"files\":[{\"additions\":103,\"blob_url\":\"https://github.com/octocat/Hello-World/blob/6dcb09b5b57875f334f61aebed695e2e4193db5e/file1.txt\",\"changes\":124,\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/file1.txt?ref=6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"deletions\":21,\"filename\":\"file1.txt\",\"patch\":\"@@ -132,7 +132,7 @@ module Test @@ -1000,7 +1000,7 @@ module Test\",\"raw_url\":\"https://github.com/octocat/Hello-World/raw/6dcb09b5b57875f334f61aebed695e2e4193db5e/file1.txt\",\"sha\":\"bbcd538c8e72b8c175046e27cc8f907076331401\",\"status\":\"added\"}],\"html_url\":\"https://github.com/octocat/Hello-World/compare/master...topic\",\"merge_base_commit\":{\"author\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e/comments\",\"commit\":{\"author\":{\"date\":\"2011-04-14T16:00:49Z\",\"email\":\"mona@github.com\",\"name\":\"Monalisa Octocat\"},\"comment_count\":0,\"committer\":{\"date\":\"2011-04-14T16:00:49Z\",\"email\":\"mona@github.com\",\"name\":\"Monalisa Octocat\"},\"message\":\"Fix all the bugs\",\"tree\":{\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/tree/6dcb09b5b57875f334f61aebed695e2e4193db5e\"},\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"verification\":{\"payload\":null,\"reason\":\"unsigned\",\"signature\":null,\"verified\":false}},\"committer\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"html_url\":\"https://github.com/octocat/Hello-World/commit/6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"node_id\":\"MDY6Q29tbWl0NmRjYjA5YjViNTc4NzVmMzM0ZjYxYWViZWQ2OTVlMmU0MTkzZGI1ZQ==\",\"parents\":[{\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e\"}],\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e\"},\"patch_url\":\"https://github.com/octocat/Hello-World/compare/master...topic.patch\",\"permalink_url\":\"https://github.com/octocat/Hello-World/compare/octocat:bbcd538c8e72b8c175046e27cc8f907076331401...octocat:0328041d1152db8ae77652d1618a02e57f745f17\",\"status\":\"behind\",\"total_commits\":1,\"url\":\"https://api.github.com/repos/octocat/Hello-World/compare/master...topic\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CommitComparison

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CommitComparison
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCommitComparisonStatus_EncodeDecode(t *testing.T) {
	var typ CommitComparisonStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommitComparisonStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCommitComparisonStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"ahead\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CommitComparisonStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CommitComparisonStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCommitFilesItem_EncodeDecode(t *testing.T) {
	var typ CommitFilesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommitFilesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCommitParentsItem_EncodeDecode(t *testing.T) {
	var typ CommitParentsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommitParentsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCommitSearchResultItem_EncodeDecode(t *testing.T) {
	var typ CommitSearchResultItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommitSearchResultItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCommitSearchResultItemCommit_EncodeDecode(t *testing.T) {
	var typ CommitSearchResultItemCommit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommitSearchResultItemCommit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCommitSearchResultItemCommitAuthor_EncodeDecode(t *testing.T) {
	var typ CommitSearchResultItemCommitAuthor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommitSearchResultItemCommitAuthor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCommitSearchResultItemCommitTree_EncodeDecode(t *testing.T) {
	var typ CommitSearchResultItemCommitTree
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommitSearchResultItemCommitTree
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCommitSearchResultItemParentsItem_EncodeDecode(t *testing.T) {
	var typ CommitSearchResultItemParentsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommitSearchResultItemParentsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCommitStats_EncodeDecode(t *testing.T) {
	var typ CommitStats
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommitStats
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCommunityProfile_EncodeDecode(t *testing.T) {
	var typ CommunityProfile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommunityProfile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCommunityProfile_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content_reports_enabled\":true,\"description\":\"My first repository on GitHub!\",\"documentation\":null,\"files\":{\"code_of_conduct\":{\"html_url\":\"https://github.com/octocat/Hello-World/blob/master/CODE_OF_CONDUCT.md\",\"key\":\"contributor_covenant\",\"name\":\"Contributor Covenant\",\"url\":\"https://api.github.com/codes_of_conduct/contributor_covenant\"},\"code_of_conduct_file\":{\"html_url\":\"https://github.com/octocat/Hello-World/blob/master/CODE_OF_CONDUCT.md\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/contents/CODE_OF_CONDUCT.md\"},\"contributing\":{\"html_url\":\"https://github.com/octocat/Hello-World/blob/master/CONTRIBUTING\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/contents/CONTRIBUTING\"},\"issue_template\":{\"html_url\":\"https://github.com/octocat/Hello-World/blob/master/ISSUE_TEMPLATE\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/contents/ISSUE_TEMPLATE\"},\"license\":{\"html_url\":\"https://github.com/octocat/Hello-World/blob/master/LICENSE\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"pull_request_template\":{\"html_url\":\"https://github.com/octocat/Hello-World/blob/master/PULL_REQUEST_TEMPLATE\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/contents/PULL_REQUEST_TEMPLATE\"},\"readme\":{\"html_url\":\"https://github.com/octocat/Hello-World/blob/master/README.md\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/contents/README.md\"}},\"health_percentage\":100,\"updated_at\":\"2017-02-28T19:09:29Z\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CommunityProfile

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CommunityProfile
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCommunityProfileFiles_EncodeDecode(t *testing.T) {
	var typ CommunityProfileFiles
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CommunityProfileFiles
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestContentFile_EncodeDecode(t *testing.T) {
	var typ ContentFile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ContentFile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestContentFile_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"_links\":{\"git\":\"https://api.github.com/repos/octokit/octokit.rb/git/blobs/3d21ec53a331a6f037a91c368710b99387d012c1\",\"html\":\"https://github.com/octokit/octokit.rb/blob/master/README.md\",\"self\":\"https://api.github.com/repos/octokit/octokit.rb/contents/README.md\"},\"content\":\"encoded content ...\",\"download_url\":\"https://raw.githubusercontent.com/octokit/octokit.rb/master/README.md\",\"encoding\":\"base64\",\"git_url\":\"https://api.github.com/repos/octokit/octokit.rb/git/blobs/3d21ec53a331a6f037a91c368710b99387d012c1\",\"html_url\":\"https://github.com/octokit/octokit.rb/blob/master/README.md\",\"name\":\"README.md\",\"path\":\"README.md\",\"sha\":\"3d21ec53a331a6f037a91c368710b99387d012c1\",\"size\":5362,\"type\":\"file\",\"url\":\"https://api.github.com/repos/octokit/octokit.rb/contents/README.md\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ContentFile

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ContentFile
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestContentFileLinks_EncodeDecode(t *testing.T) {
	var typ ContentFileLinks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ContentFileLinks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestContentReferenceAttachment_EncodeDecode(t *testing.T) {
	var typ ContentReferenceAttachment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ContentReferenceAttachment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestContentReferenceAttachment_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"You have used an email that already exists for the user_email_uniq field.\\n ## DETAILS:\\n\\nThe (email)=(Octocat@github.com) already exists.\\n\\n The error was found in core/models.py in get_or_create_user at line 62.\\n\\n self.save()\",\"id\":101,\"title\":\"[A-1234] Error found in core/models.py file'\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ContentReferenceAttachment

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ContentReferenceAttachment
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestContentTraffic_EncodeDecode(t *testing.T) {
	var typ ContentTraffic
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ContentTraffic
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestContributor_EncodeDecode(t *testing.T) {
	var typ Contributor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Contributor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestContributorActivity_EncodeDecode(t *testing.T) {
	var typ ContributorActivity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ContributorActivity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestContributorActivityWeeksItem_EncodeDecode(t *testing.T) {
	var typ ContributorActivityWeeksItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ContributorActivityWeeksItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCredentialAuthorization_EncodeDecode(t *testing.T) {
	var typ CredentialAuthorization
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CredentialAuthorization
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeployKey_EncodeDecode(t *testing.T) {
	var typ DeployKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeployKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeployKey_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2014-12-10T15:53:42Z\",\"id\":1,\"key\":\"ssh-rsa AAA...\",\"read_only\":true,\"title\":\"octocat@octomac\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/keys/1\",\"verified\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeployKey

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeployKey
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeployment_EncodeDecode(t *testing.T) {
	var typ Deployment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Deployment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeployment_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2012-07-20T01:19:13Z\",\"creator\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"description\":\"Deploy request from hubot\",\"environment\":\"production\",\"id\":1,\"node_id\":\"MDEwOkRlcGxveW1lbnQx\",\"original_environment\":\"staging\",\"payload\":{},\"production_environment\":true,\"ref\":\"topic-branch\",\"repository_url\":\"https://api.github.com/repos/octocat/example\",\"sha\":\"a84d88e7554fc1fa21bcbc4efae3c782a70d2b9d\",\"statuses_url\":\"https://api.github.com/repos/octocat/example/deployments/1/statuses\",\"task\":\"deploy\",\"transient_environment\":false,\"updated_at\":\"2012-07-20T01:19:13Z\",\"url\":\"https://api.github.com/repos/octocat/example/deployments/1\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Deployment

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Deployment
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeploymentPayload_EncodeDecode(t *testing.T) {
	var typ DeploymentPayload
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeploymentPayload
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeploymentPayload0_EncodeDecode(t *testing.T) {
	var typ DeploymentPayload0
	typ = make(DeploymentPayload0)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeploymentPayload0
	typ2 = make(DeploymentPayload0)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeploymentSimple_EncodeDecode(t *testing.T) {
	var typ DeploymentSimple
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeploymentSimple
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeploymentStatus_EncodeDecode(t *testing.T) {
	var typ DeploymentStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeploymentStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeploymentStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2012-07-20T01:19:13Z\",\"creator\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"deployment_url\":\"https://api.github.com/repos/octocat/example/deployments/42\",\"description\":\"Deployment finished successfully.\",\"environment\":\"production\",\"environment_url\":\"https://test-branch.lab.acme.com\",\"id\":1,\"log_url\":\"https://example.com/deployment/42/output\",\"node_id\":\"MDE2OkRlcGxveW1lbnRTdGF0dXMx\",\"repository_url\":\"https://api.github.com/repos/octocat/example\",\"state\":\"success\",\"target_url\":\"https://example.com/deployment/42/output\",\"updated_at\":\"2012-07-20T01:19:13Z\",\"url\":\"https://api.github.com/repos/octocat/example/deployments/42/statuses/1\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeploymentStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeploymentStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDeploymentStatusState_EncodeDecode(t *testing.T) {
	var typ DeploymentStatusState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeploymentStatusState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDeploymentStatusState_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"success\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DeploymentStatusState

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DeploymentStatusState
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDiffEntry_EncodeDecode(t *testing.T) {
	var typ DiffEntry
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DiffEntry
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDiffEntryStatus_EncodeDecode(t *testing.T) {
	var typ DiffEntryStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DiffEntryStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDiffEntryStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"added\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DiffEntryStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DiffEntryStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEmail_EncodeDecode(t *testing.T) {
	var typ Email
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Email
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEmojisGetOK_EncodeDecode(t *testing.T) {
	var typ EmojisGetOK
	typ = make(EmojisGetOK)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EmojisGetOK
	typ2 = make(EmojisGetOK)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEmptyObject_EncodeDecode(t *testing.T) {
	var typ EmptyObject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EmptyObject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnabledOrganizations_EncodeDecode(t *testing.T) {
	var typ EnabledOrganizations
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnabledOrganizations
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnabledRepositories_EncodeDecode(t *testing.T) {
	var typ EnabledRepositories
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnabledRepositories
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"name\":\"Expensive hardware runners\",\"runners\":[9,2],\"selected_organization_ids\":[32,91],\"visibility\":\"selected\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"organizations\":[{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"description\":\"A great organization\",\"events_url\":\"https://api.github.com/orgs/octo-org/events\",\"hooks_url\":\"https://api.github.com/orgs/octo-org/hooks\",\"id\":161335,\"issues_url\":\"https://api.github.com/orgs/octo-org/issues\",\"login\":\"octocat\",\"members_url\":\"https://api.github.com/orgs/octo-org/members{/member}\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"public_members_url\":\"https://api.github.com/orgs/octo-org/public_members{/member}\",\"repos_url\":\"https://api.github.com/orgs/octo-org/repos\",\"url\":\"https://api.github.com/orgs/octo-org\"}],\"total_count\":1}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"organizations\":[{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"description\":\"A great organization\",\"events_url\":\"https://api.github.com/orgs/octo-org/events\",\"hooks_url\":\"https://api.github.com/orgs/octo-org/hooks\",\"id\":161335,\"issues_url\":\"https://api.github.com/orgs/octo-org/issues\",\"login\":\"octocat\",\"members_url\":\"https://api.github.com/orgs/octo-org/members{/member}\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"public_members_url\":\"https://api.github.com/orgs/octo-org/public_members{/member}\",\"repos_url\":\"https://api.github.com/orgs/octo-org/repos\",\"url\":\"https://api.github.com/orgs/octo-org\"}],\"total_count\":1}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"runner_groups\":[{\"allows_public_repositories\":false,\"default\":true,\"id\":1,\"name\":\"Default\",\"runners_url\":\"https://api.github.com/enterprises/octo-corp/actions/runner_groups/1/runners\",\"visibility\":\"all\"},{\"allows_public_repositories\":true,\"default\":false,\"id\":2,\"name\":\"octo-runner-group\",\"runners_url\":\"https://api.github.com/enterprises/octo-corp/actions/runner_groups/2/runners\",\"selected_organizations_url\":\"https://api.github.com/enterprises/octo-corp/actions/runner_groups/2/organizations\",\"visibility\":\"selected\"},{\"allows_public_repositories\":true,\"default\":false,\"id\":3,\"name\":\"expensive-hardware\",\"runners_url\":\"https://api.github.com/enterprises/octo-corp/actions/runner_groups/3/runners\",\"visibility\":\"private\"}],\"total_count\":3}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminListSelfHostedRunnersForEnterpriseOK_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminListSelfHostedRunnersForEnterpriseOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminListSelfHostedRunnersForEnterpriseOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminListSelfHostedRunnersForEnterpriseOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"runners\":[{\"busy\":true,\"id\":23,\"labels\":[{\"id\":5,\"name\":\"self-hosted\",\"type\":\"read-only\"},{\"id\":7,\"name\":\"X64\",\"type\":\"read-only\"},{\"id\":11,\"name\":\"Linux\",\"type\":\"read-only\"}],\"name\":\"linux_runner\",\"os\":\"linux\",\"status\":\"online\"},{\"busy\":false,\"id\":24,\"labels\":[{\"id\":5,\"name\":\"self-hosted\",\"type\":\"read-only\"},{\"id\":7,\"name\":\"X64\",\"type\":\"read-only\"},{\"id\":20,\"name\":\"macOS\",\"type\":\"read-only\"},{\"id\":21,\"name\":\"no-gpu\",\"type\":\"custom\"}],\"name\":\"mac_runner\",\"os\":\"macos\",\"status\":\"offline\"}],\"total_count\":2}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminListSelfHostedRunnersForEnterpriseOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminListSelfHostedRunnersForEnterpriseOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"runners\":[{\"busy\":true,\"id\":23,\"labels\":[{\"id\":5,\"name\":\"self-hosted\",\"type\":\"read-only\"},{\"id\":7,\"name\":\"X64\",\"type\":\"read-only\"},{\"id\":11,\"name\":\"Linux\",\"type\":\"read-only\"}],\"name\":\"linux_runner\",\"os\":\"linux\",\"status\":\"online\"},{\"busy\":false,\"id\":24,\"labels\":[{\"id\":5,\"name\":\"self-hosted\",\"type\":\"read-only\"},{\"id\":7,\"name\":\"X64\",\"type\":\"read-only\"},{\"id\":20,\"name\":\"macOS\",\"type\":\"read-only\"},{\"id\":21,\"name\":\"no-gpu\",\"type\":\"custom\"}],\"name\":\"mac_runner\",\"os\":\"macos\",\"status\":\"offline\"}],\"total_count\":2}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminProvisionAndInviteEnterpriseGroupReq_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminProvisionAndInviteEnterpriseGroupReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminProvisionAndInviteEnterpriseGroupReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminProvisionAndInviteEnterpriseGroupReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"displayName\":\"octo-org\",\"members\":[{\"value\":\"92b58aaa-a1d6-11ea-8227-b9ce9e023ccc\"},{\"value\":\"aaaa8c34-a6b2-11ea-9d70-bbbbbd1c8fd5\"}],\"schemas\":[\"urn:ietf:params:scim:schemas:core:2.0:Group\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminProvisionAndInviteEnterpriseGroupReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminProvisionAndInviteEnterpriseGroupReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnterpriseAdminProvisionAndInviteEnterpriseUserReq_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminProvisionAndInviteEnterpriseUserReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminProvisionAndInviteEnterpriseUserReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminProvisionAndInviteEnterpriseUserReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"emails\":[{\"primary\":true,\"type\":\"work\",\"value\":\"mona.octocat@okta.example.com\"}],\"groups\":[{\"value\":\"468dd3fa-a1d6-11ea-9031-15a1f0d7811d\"}],\"name\":{\"familyName\":\"Octocat\",\"givenName\":\"Mona\"},\"schemas\":[\"urn:ietf:params:scim:schemas:core:2.0:User\"],\"userName\":\"mona.octocat@okta.example.com\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminProvisionAndInviteEnterpriseUserReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminProvisionAndInviteEnterpriseUserReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnterpriseAdminProvisionAndInviteEnterpriseUserReqName_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminProvisionAndInviteEnterpriseUserReqName
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminProvisionAndInviteEnterpriseUserReqName
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnterpriseAdminSetGithubActionsPermissionsEnterpriseReq_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminSetGithubActionsPermissionsEnterpriseReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"allowed_actions\":\"selected\",\"enabled_organizations\":\"all\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"displayName\":\"octo-org\",\"members\":[{\"value\":\"92b58aaa-a1d6-11ea-8227-b9ce9e023ccc\"},{\"value\":\"aaaa8c34-a6b2-11ea-9d70-bbbbbd1c8fd5\"}],\"schemas\":[\"urn:ietf:params:scim:schemas:core:2.0:Group\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnterpriseAdminSetInformationForProvisionedEnterpriseUserReq_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminSetInformationForProvisionedEnterpriseUserReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"emails\":[{\"primary\":true,\"type\":\"work\",\"value\":\"mona.octocat@okta.example.com\"}],\"groups\":[{\"value\":\"468dd3fa-a1d6-11ea-9031-15a1f0d7811d\"}],\"name\":{\"familyName\":\"Octocat\",\"givenName\":\"Mona\"},\"schemas\":[\"urn:ietf:params:scim:schemas:core:2.0:User\"],\"userName\":\"mona.octocat@okta.example.com\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"selected_organization_ids\":[32,91]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"selected_organization_ids\":[32,91]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"runners\":[9,2]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminUpdateAttributeForEnterpriseGroupReq_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminUpdateAttributeForEnterpriseGroupReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminUpdateAttributeForEnterpriseGroupReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminUpdateAttributeForEnterpriseGroupReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Operations\":[{\"op\":\"remove\",\"path\":\"members\",\"value\":[{\"value\":\"aaaa8c34-a6b2-11ea-9d70-bbbbbd1c8fd5\"}]}],\"schemas\":[\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminUpdateAttributeForEnterpriseGroupReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminUpdateAttributeForEnterpriseGroupReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemOp
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminUpdateAttributeForEnterpriseGroupReqOperationsItemValue1
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnterpriseAdminUpdateAttributeForEnterpriseUserReq_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminUpdateAttributeForEnterpriseUserReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminUpdateAttributeForEnterpriseUserReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminUpdateAttributeForEnterpriseUserReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Operations\":[{\"op\":\"add\",\"path\":\"emails\",\"value\":[{\"type\":\"home\",\"value\":\"monalisa@octocat.github.com\"}]},{\"op\":\"replace\",\"path\":\"name.givenName\",\"value\":\"Monalisa\"}],\"schemas\":[\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminUpdateAttributeForEnterpriseUserReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminUpdateAttributeForEnterpriseUserReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"name\":\"Expensive hardware runners\",\"visibility\":\"selected\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility_EncodeDecode(t *testing.T) {
	var typ EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnvironmentApprovals_EncodeDecode(t *testing.T) {
	var typ EnvironmentApprovals
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnvironmentApprovals
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnvironmentApprovalsEnvironmentsItem_EncodeDecode(t *testing.T) {
	var typ EnvironmentApprovalsEnvironmentsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnvironmentApprovalsEnvironmentsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEnvironmentApprovalsState_EncodeDecode(t *testing.T) {
	var typ EnvironmentApprovalsState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EnvironmentApprovalsState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEnvironmentApprovalsState_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"approved\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ EnvironmentApprovalsState

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 EnvironmentApprovalsState
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEvent_EncodeDecode(t *testing.T) {
	var typ Event
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Event
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventPayload_EncodeDecode(t *testing.T) {
	var typ EventPayload
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventPayload
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventPayloadPagesItem_EncodeDecode(t *testing.T) {
	var typ EventPayloadPagesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventPayloadPagesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventRepo_EncodeDecode(t *testing.T) {
	var typ EventRepo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventRepo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFeed_EncodeDecode(t *testing.T) {
	var typ Feed
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Feed
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestFeed_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"_links\":{\"current_user\":{\"href\":\"https://github.com/octocat.private?token=abc123\",\"type\":\"application/atom+xml\"},\"current_user_actor\":{\"href\":\"https://github.com/octocat.private.actor?token=abc123\",\"type\":\"application/atom+xml\"},\"current_user_organization\":{\"href\":\"\",\"type\":\"\"},\"current_user_organizations\":[{\"href\":\"https://github.com/organizations/github/octocat.private.atom?token=abc123\",\"type\":\"application/atom+xml\"}],\"current_user_public\":{\"href\":\"https://github.com/octocat\",\"type\":\"application/atom+xml\"},\"security_advisories\":{\"href\":\"https://github.com/security-advisories\",\"type\":\"application/atom+xml\"},\"timeline\":{\"href\":\"https://github.com/timeline\",\"type\":\"application/atom+xml\"},\"user\":{\"href\":\"https://github.com/{user}\",\"type\":\"application/atom+xml\"}},\"current_user_actor_url\":\"https://github.com/octocat.private.actor?token=abc123\",\"current_user_organization_url\":\"\",\"current_user_organization_urls\":[\"https://github.com/organizations/github/octocat.private.atom?token=abc123\"],\"current_user_public_url\":\"https://github.com/octocat\",\"current_user_url\":\"https://github.com/octocat.private?token=abc123\",\"security_advisories_url\":\"https://github.com/security-advisories\",\"timeline_url\":\"https://github.com/timeline\",\"user_url\":\"https://github.com/{user}\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Feed

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Feed
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestFeedLinks_EncodeDecode(t *testing.T) {
	var typ FeedLinks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FeedLinks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFileCommit_EncodeDecode(t *testing.T) {
	var typ FileCommit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FileCommit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestFileCommit_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"commit\":{\"author\":{\"date\":\"2014-11-07T22:01:45Z\",\"email\":\"octocat@github.com\",\"name\":\"Monalisa Octocat\"},\"committer\":{\"date\":\"2014-11-07T22:01:45Z\",\"email\":\"octocat@github.com\",\"name\":\"Monalisa Octocat\"},\"html_url\":\"https://github.com/octocat/Hello-World/git/commit/18a43cd8e1e3a79c786e3d808a73d23b6d212b16\",\"message\":\"my commit message\",\"node_id\":\"MDY6Q29tbWl0MThhNDNjZDhlMWUzYTc5Yzc4NmUzZDgwOGE3M2QyM2I2ZDIxMmIxNg==\",\"parents\":[{\"html_url\":\"https://github.com/octocat/Hello-World/git/commit/da5a433788da5c255edad7979b328b67d79f53f6\",\"sha\":\"da5a433788da5c255edad7979b328b67d79f53f6\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/da5a433788da5c255edad7979b328b67d79f53f6\"}],\"sha\":\"18a43cd8e1e3a79c786e3d808a73d23b6d212b16\",\"tree\":{\"sha\":\"9a21f8e2018f42ffcf369b24d2cd20bc25c9e66f\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees/9a21f8e2018f42ffcf369b24d2cd20bc25c9e66f\"},\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/18a43cd8e1e3a79c786e3d808a73d23b6d212b16\",\"verification\":{\"payload\":null,\"reason\":\"unsigned\",\"signature\":null,\"verified\":false}},\"content\":{\"_links\":{\"git\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs/a56507ed892d05a37c6d6128c260937ea4d287bd\",\"html\":\"https://github.com/octocat/Hello-World/blob/master/notes/hello.txt\",\"self\":\"https://api.github.com/repos/octocat/Hello-World/contents/notes/hello.txt\"},\"download_url\":\"https://raw.githubusercontent.com/octocat/HelloWorld/master/notes/hello.txt\",\"git_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs/a56507ed892d05a37c6d6128c260937ea4d287bd\",\"html_url\":\"https://github.com/octocat/Hello-World/blob/master/notes/hello.txt\",\"name\":\"hello.txt\",\"path\":\"notes/hello.txt\",\"sha\":\"a56507ed892d05a37c6d6128c260937ea4d287bd\",\"size\":9,\"type\":\"file\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/contents/notes/hello.txt\"}}"},
		{Input: "{\"commit\":{\"author\":{\"date\":\"2014-11-07T22:01:45Z\",\"email\":\"octocat@github.com\",\"name\":\"Monalisa Octocat\"},\"committer\":{\"date\":\"2014-11-07T22:01:45Z\",\"email\":\"octocat@github.com\",\"name\":\"Monalisa Octocat\"},\"html_url\":\"https://github.com/octocat/Hello-World/git/commit/7638417db6d59f3c431d3e1f261cc637155684cd\",\"message\":\"my commit message\",\"node_id\":\"MDY6Q29tbWl0NzYzODQxN2RiNmQ1OWYzYzQzMWQzZTFmMjYxY2M2MzcxNTU2ODRjZA==\",\"parents\":[{\"html_url\":\"https://github.com/octocat/Hello-World/git/commit/1acc419d4d6a9ce985db7be48c6349a0475975b5\",\"sha\":\"1acc419d4d6a9ce985db7be48c6349a0475975b5\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/1acc419d4d6a9ce985db7be48c6349a0475975b5\"}],\"sha\":\"7638417db6d59f3c431d3e1f261cc637155684cd\",\"tree\":{\"sha\":\"691272480426f78a0138979dd3ce63b77f706feb\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees/691272480426f78a0138979dd3ce63b77f706feb\"},\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/7638417db6d59f3c431d3e1f261cc637155684cd\",\"verification\":{\"payload\":null,\"reason\":\"unsigned\",\"signature\":null,\"verified\":false}},\"content\":null}"},
		{Input: "{\"commit\":{\"author\":{\"date\":\"2014-11-07T22:01:45Z\",\"email\":\"octocat@github.com\",\"name\":\"Monalisa Octocat\"},\"committer\":{\"date\":\"2014-11-07T22:01:45Z\",\"email\":\"octocat@github.com\",\"name\":\"Monalisa Octocat\"},\"html_url\":\"https://github.com/octocat/Hello-World/git/commit/7638417db6d59f3c431d3e1f261cc637155684cd\",\"message\":\"my commit message\",\"node_id\":\"MDY6Q29tbWl0NzYzODQxN2RiNmQ1OWYzYzQzMWQzZTFmMjYxY2M2MzcxNTU2ODRjZA==\",\"parents\":[{\"html_url\":\"https://github.com/octocat/Hello-World/git/commit/1acc419d4d6a9ce985db7be48c6349a0475975b5\",\"sha\":\"1acc419d4d6a9ce985db7be48c6349a0475975b5\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/1acc419d4d6a9ce985db7be48c6349a0475975b5\"}],\"sha\":\"7638417db6d59f3c431d3e1f261cc637155684cd\",\"tree\":{\"sha\":\"691272480426f78a0138979dd3ce63b77f706feb\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees/691272480426f78a0138979dd3ce63b77f706feb\"},\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/7638417db6d59f3c431d3e1f261cc637155684cd\",\"verification\":{\"payload\":null,\"reason\":\"unsigned\",\"signature\":null,\"verified\":false}},\"content\":{\"_links\":{\"git\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs/95b966ae1c166bd92f8ae7d1c313e738c731dfc3\",\"html\":\"https://github.com/octocat/Hello-World/blob/master/notes/hello.txt\",\"self\":\"https://api.github.com/repos/octocat/Hello-World/contents/notes/hello.txt\"},\"download_url\":\"https://raw.githubusercontent.com/octocat/HelloWorld/master/notes/hello.txt\",\"git_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs/95b966ae1c166bd92f8ae7d1c313e738c731dfc3\",\"html_url\":\"https://github.com/octocat/Hello-World/blob/master/notes/hello.txt\",\"name\":\"hello.txt\",\"path\":\"notes/hello.txt\",\"sha\":\"95b966ae1c166bd92f8ae7d1c313e738c731dfc3\",\"size\":9,\"type\":\"file\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/contents/notes/hello.txt\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ FileCommit

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 FileCommit
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestFileCommitCommit_EncodeDecode(t *testing.T) {
	var typ FileCommitCommit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FileCommitCommit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFileCommitCommitAuthor_EncodeDecode(t *testing.T) {
	var typ FileCommitCommitAuthor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FileCommitCommitAuthor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFileCommitCommitCommitter_EncodeDecode(t *testing.T) {
	var typ FileCommitCommitCommitter
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FileCommitCommitCommitter
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFileCommitCommitParentsItem_EncodeDecode(t *testing.T) {
	var typ FileCommitCommitParentsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FileCommitCommitParentsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFileCommitCommitTree_EncodeDecode(t *testing.T) {
	var typ FileCommitCommitTree
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FileCommitCommitTree
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFileCommitCommitVerification_EncodeDecode(t *testing.T) {
	var typ FileCommitCommitVerification
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FileCommitCommitVerification
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFileCommitContent_EncodeDecode(t *testing.T) {
	var typ FileCommitContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FileCommitContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFileCommitContentLinks_EncodeDecode(t *testing.T) {
	var typ FileCommitContentLinks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FileCommitContentLinks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestForbiddenGist_EncodeDecode(t *testing.T) {
	var typ ForbiddenGist
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ForbiddenGist
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestForbiddenGistBlock_EncodeDecode(t *testing.T) {
	var typ ForbiddenGistBlock
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ForbiddenGistBlock
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFullRepository_EncodeDecode(t *testing.T) {
	var typ FullRepository
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FullRepository
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestFullRepository_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"allow_auto_merge\":false,\"allow_forking\":true,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":9,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":false,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":0,\"open_issues_count\":0,\"organization\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"Organization\",\"url\":\"https://api.github.com/users/octocat\"},\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"parent\":{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":1,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":1,\"watchers_count\":80},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"source\":{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":1,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":1,\"watchers_count\":80},\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World-Template.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/events\",\"fork\":false,\"forks\":9,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/forks\",\"full_name\":\"octocat/Hello-World-Template\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World-Template.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World-Template\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World-Template\",\"name\":\"Hello-World-Template\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/notifications{?since,all,participating}\",\"open_issues\":0,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World-Template.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World-Template\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World-Template\",\"visibility\":\"public\",\"watchers\":80,\"watchers_count\":80},\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":80,\"watchers_count\":80}"},
		{Input: "{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":9,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":false,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":0,\"open_issues_count\":0,\"organization\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"Organization\",\"url\":\"https://api.github.com/users/octocat\"},\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"parent\":{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":1,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":1,\"watchers_count\":80},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"source\":{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":1,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":1,\"watchers_count\":80},\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World-Template.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/events\",\"fork\":false,\"forks\":9,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/forks\",\"full_name\":\"octocat/Hello-World-Template\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World-Template.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World-Template\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World-Template\",\"name\":\"Hello-World-Template\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/notifications{?since,all,participating}\",\"open_issues\":0,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World-Template.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World-Template\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World-Template\",\"visibility\":\"public\",\"watchers\":80,\"watchers_count\":80},\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":80,\"watchers_count\":80}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ FullRepository

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 FullRepository
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestFullRepositoryPermissions_EncodeDecode(t *testing.T) {
	var typ FullRepositoryPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FullRepositoryPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFullRepositorySecurityAndAnalysis_EncodeDecode(t *testing.T) {
	var typ FullRepositorySecurityAndAnalysis
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FullRepositorySecurityAndAnalysis
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFullRepositorySecurityAndAnalysisAdvancedSecurity_EncodeDecode(t *testing.T) {
	var typ FullRepositorySecurityAndAnalysisAdvancedSecurity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FullRepositorySecurityAndAnalysisAdvancedSecurity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFullRepositorySecurityAndAnalysisAdvancedSecurityStatus_EncodeDecode(t *testing.T) {
	var typ FullRepositorySecurityAndAnalysisAdvancedSecurityStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FullRepositorySecurityAndAnalysisAdvancedSecurityStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFullRepositorySecurityAndAnalysisSecretScanning_EncodeDecode(t *testing.T) {
	var typ FullRepositorySecurityAndAnalysisSecretScanning
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FullRepositorySecurityAndAnalysisSecretScanning
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFullRepositorySecurityAndAnalysisSecretScanningStatus_EncodeDecode(t *testing.T) {
	var typ FullRepositorySecurityAndAnalysisSecretScanningStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FullRepositorySecurityAndAnalysisSecretScanningStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistComment_EncodeDecode(t *testing.T) {
	var typ GistComment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistComment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGistComment_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"author_association\":\"COLLABORATOR\",\"body\":\"Just commenting for the sake of commenting\",\"created_at\":\"2011-04-18T23:23:56Z\",\"id\":1,\"node_id\":\"MDExOkdpc3RDb21tZW50MQ==\",\"updated_at\":\"2011-04-18T23:23:56Z\",\"url\":\"https://api.github.com/gists/a6db0bec360bb87e9418/comments/1\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GistComment

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GistComment
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGistCommit_EncodeDecode(t *testing.T) {
	var typ GistCommit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistCommit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistCommitChangeStatus_EncodeDecode(t *testing.T) {
	var typ GistCommitChangeStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistCommitChangeStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistHistory_EncodeDecode(t *testing.T) {
	var typ GistHistory
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistHistory
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistHistoryChangeStatus_EncodeDecode(t *testing.T) {
	var typ GistHistoryChangeStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistHistoryChangeStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistSimple_EncodeDecode(t *testing.T) {
	var typ GistSimple
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistSimple
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGistSimple_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"comments\":0,\"comments_url\":\"https://api.github.com/gists/aa5a315d61ae9438b18d/comments/\",\"commits_url\":\"https://api.github.com/gists/aa5a315d61ae9438b18d/commits\",\"created_at\":\"2010-04-14T02:15:15Z\",\"description\":\"Hello World Examples\",\"forks_url\":\"https://api.github.com/gists/aa5a315d61ae9438b18d/forks\",\"git_pull_url\":\"https://gist.github.com/aa5a315d61ae9438b18d.git\",\"git_push_url\":\"https://gist.github.com/aa5a315d61ae9438b18d.git\",\"html_url\":\"https://gist.github.com/aa5a315d61ae9438b18d\",\"id\":\"aa5a315d61ae9438b18d\",\"node_id\":\"MDQ6R2lzdGFhNWEzMTVkNjFhZTk0MzhiMThk\",\"updated_at\":\"2011-06-20T11:34:15Z\",\"url\":\"https://api.github.com/gists/aa5a315d61ae9438b18d\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GistSimple

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GistSimple
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGistSimpleFiles_EncodeDecode(t *testing.T) {
	var typ GistSimpleFiles
	typ = make(GistSimpleFiles)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistSimpleFiles
	typ2 = make(GistSimpleFiles)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistSimpleFilesItem_EncodeDecode(t *testing.T) {
	var typ GistSimpleFilesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistSimpleFilesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistSimpleForkOf_EncodeDecode(t *testing.T) {
	var typ GistSimpleForkOf
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistSimpleForkOf
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistSimpleForkOfFiles_EncodeDecode(t *testing.T) {
	var typ GistSimpleForkOfFiles
	typ = make(GistSimpleForkOfFiles)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistSimpleForkOfFiles
	typ2 = make(GistSimpleForkOfFiles)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistSimpleForkOfFilesItem_EncodeDecode(t *testing.T) {
	var typ GistSimpleForkOfFilesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistSimpleForkOfFilesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistSimpleForksItem_EncodeDecode(t *testing.T) {
	var typ GistSimpleForksItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistSimpleForksItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsCheckIsStarredNotFound_EncodeDecode(t *testing.T) {
	var typ GistsCheckIsStarredNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsCheckIsStarredNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsCreateCommentForbidden_EncodeDecode(t *testing.T) {
	var typ GistsCreateCommentForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsCreateCommentForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsCreateCommentNotFound_EncodeDecode(t *testing.T) {
	var typ GistsCreateCommentNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsCreateCommentNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsCreateCommentReq_EncodeDecode(t *testing.T) {
	var typ GistsCreateCommentReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsCreateCommentReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsCreateForbidden_EncodeDecode(t *testing.T) {
	var typ GistsCreateForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsCreateForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsCreateNotFound_EncodeDecode(t *testing.T) {
	var typ GistsCreateNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsCreateNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsCreateReq_EncodeDecode(t *testing.T) {
	var typ GistsCreateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsCreateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsCreateReqFiles_EncodeDecode(t *testing.T) {
	var typ GistsCreateReqFiles
	typ = make(GistsCreateReqFiles)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsCreateReqFiles
	typ2 = make(GistsCreateReqFiles)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGistsCreateReqFiles_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"hello.rb\":{\"content\":\"puts \\\"Hello, World!\\\"\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GistsCreateReqFiles
			typ = make(GistsCreateReqFiles)

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GistsCreateReqFiles
			typ2 = make(GistsCreateReqFiles)
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGistsCreateReqFilesItem_EncodeDecode(t *testing.T) {
	var typ GistsCreateReqFilesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsCreateReqFilesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsCreateReqPublic_EncodeDecode(t *testing.T) {
	var typ GistsCreateReqPublic
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsCreateReqPublic
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsCreateReqPublic1_EncodeDecode(t *testing.T) {
	var typ GistsCreateReqPublic1
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsCreateReqPublic1
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGistsCreateReqPublic1_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"true\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GistsCreateReqPublic1

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GistsCreateReqPublic1
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGistsDeleteCommentForbidden_EncodeDecode(t *testing.T) {
	var typ GistsDeleteCommentForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsDeleteCommentForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsDeleteCommentNotFound_EncodeDecode(t *testing.T) {
	var typ GistsDeleteCommentNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsDeleteCommentNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsDeleteForbidden_EncodeDecode(t *testing.T) {
	var typ GistsDeleteForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsDeleteForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsDeleteNotFound_EncodeDecode(t *testing.T) {
	var typ GistsDeleteNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsDeleteNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsForkForbidden_EncodeDecode(t *testing.T) {
	var typ GistsForkForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsForkForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsForkNotFound_EncodeDecode(t *testing.T) {
	var typ GistsForkNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsForkNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsGetRevisionForbidden_EncodeDecode(t *testing.T) {
	var typ GistsGetRevisionForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsGetRevisionForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsGetRevisionNotFound_EncodeDecode(t *testing.T) {
	var typ GistsGetRevisionNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsGetRevisionNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsListCommentsForbidden_EncodeDecode(t *testing.T) {
	var typ GistsListCommentsForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsListCommentsForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsListCommentsNotFound_EncodeDecode(t *testing.T) {
	var typ GistsListCommentsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsListCommentsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsListCommitsForbidden_EncodeDecode(t *testing.T) {
	var typ GistsListCommitsForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsListCommitsForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsListCommitsNotFound_EncodeDecode(t *testing.T) {
	var typ GistsListCommitsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsListCommitsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsListForksForbidden_EncodeDecode(t *testing.T) {
	var typ GistsListForksForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsListForksForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsListForksNotFound_EncodeDecode(t *testing.T) {
	var typ GistsListForksNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsListForksNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsListStarredForbidden_EncodeDecode(t *testing.T) {
	var typ GistsListStarredForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsListStarredForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsListStarredUnauthorized_EncodeDecode(t *testing.T) {
	var typ GistsListStarredUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsListStarredUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsStarForbidden_EncodeDecode(t *testing.T) {
	var typ GistsStarForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsStarForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsStarNotFound_EncodeDecode(t *testing.T) {
	var typ GistsStarNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsStarNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsUnstarForbidden_EncodeDecode(t *testing.T) {
	var typ GistsUnstarForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsUnstarForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsUnstarNotFound_EncodeDecode(t *testing.T) {
	var typ GistsUnstarNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsUnstarNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGistsUpdateCommentReq_EncodeDecode(t *testing.T) {
	var typ GistsUpdateCommentReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GistsUpdateCommentReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCommit_EncodeDecode(t *testing.T) {
	var typ GitCommit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCommit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGitCommit_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"author\":{\"date\":\"2014-11-07T22:01:45Z\",\"email\":\"octocat@github.com\",\"name\":\"Monalisa Octocat\"},\"committer\":{\"date\":\"2014-11-07T22:01:45Z\",\"email\":\"octocat@github.com\",\"name\":\"Monalisa Octocat\"},\"html_url\":\"https://github.com/octocat/Hello-World/commit/7638417db6d59f3c431d3e1f261cc637155684cd\",\"message\":\"added readme, because im a good github citizen\",\"node_id\":\"MDY6Q29tbWl0NmRjYjA5YjViNTc4NzVmMzM0ZjYxYWViZWQ2OTVlMmU0MTkzZGI1ZQ==\",\"parents\":[{\"html_url\":\"https://github.com/octocat/Hello-World/commit/7638417db6d59f3c431d3e1f261cc637155684cd\",\"sha\":\"1acc419d4d6a9ce985db7be48c6349a0475975b5\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/1acc419d4d6a9ce985db7be48c6349a0475975b5\"}],\"sha\":\"7638417db6d59f3c431d3e1f261cc637155684cd\",\"tree\":{\"sha\":\"691272480426f78a0138979dd3ce63b77f706feb\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees/691272480426f78a0138979dd3ce63b77f706feb\"},\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/7638417db6d59f3c431d3e1f261cc637155684cd\",\"verification\":{\"payload\":null,\"reason\":\"unsigned\",\"signature\":null,\"verified\":false}}"},
		{Input: "{\"author\":{\"date\":\"2014-11-07T22:01:45Z\",\"email\":\"octocat@github.com\",\"name\":\"Monalisa Octocat\"},\"committer\":{\"date\":\"2014-11-07T22:01:45Z\",\"email\":\"octocat@github.com\",\"name\":\"Monalisa Octocat\"},\"html_url\":\"https://github.com/octocat/Hello-World/commit/7638417db6d59f3c431d3e1f261cc637155684cd\",\"message\":\"my commit message\",\"node_id\":\"MDY6Q29tbWl0NzYzODQxN2RiNmQ1OWYzYzQzMWQzZTFmMjYxY2M2MzcxNTU2ODRjZA==\",\"parents\":[{\"html_url\":\"https://github.com/octocat/Hello-World/commit/7d1b31e74ee336d15cbd21741bc88a537ed063a0\",\"sha\":\"7d1b31e74ee336d15cbd21741bc88a537ed063a0\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/7d1b31e74ee336d15cbd21741bc88a537ed063a0\"}],\"sha\":\"7638417db6d59f3c431d3e1f261cc637155684cd\",\"tree\":{\"sha\":\"827efc6d56897b048c772eb4087f854f46256132\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees/827efc6d56897b048c772eb4087f854f46256132\"},\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/7638417db6d59f3c431d3e1f261cc637155684cd\",\"verification\":{\"payload\":null,\"reason\":\"unsigned\",\"signature\":null,\"verified\":false}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GitCommit

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GitCommit
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGitCommitAuthor_EncodeDecode(t *testing.T) {
	var typ GitCommitAuthor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCommitAuthor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCommitCommitter_EncodeDecode(t *testing.T) {
	var typ GitCommitCommitter
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCommitCommitter
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCommitParentsItem_EncodeDecode(t *testing.T) {
	var typ GitCommitParentsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCommitParentsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCommitTree_EncodeDecode(t *testing.T) {
	var typ GitCommitTree
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCommitTree
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCommitVerification_EncodeDecode(t *testing.T) {
	var typ GitCommitVerification
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCommitVerification
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCreateBlobConflict_EncodeDecode(t *testing.T) {
	var typ GitCreateBlobConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateBlobConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCreateBlobForbidden_EncodeDecode(t *testing.T) {
	var typ GitCreateBlobForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateBlobForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCreateBlobNotFound_EncodeDecode(t *testing.T) {
	var typ GitCreateBlobNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateBlobNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCreateBlobReq_EncodeDecode(t *testing.T) {
	var typ GitCreateBlobReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateBlobReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGitCreateBlobReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content\":\"Content of the blob\",\"encoding\":\"utf-8\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GitCreateBlobReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GitCreateBlobReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGitCreateCommitReq_EncodeDecode(t *testing.T) {
	var typ GitCreateCommitReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateCommitReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGitCreateCommitReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"author\":{\"date\":\"2008-07-09T16:13:30+12:00\",\"email\":\"octocat@github.com\",\"name\":\"Mona Octocat\"},\"message\":\"my commit message\",\"parents\":[\"7d1b31e74ee336d15cbd21741bc88a537ed063a0\"],\"signature\":\"-----BEGIN PGP SIGNATURE-----\\n\\niQIzBAABAQAdFiEESn/54jMNIrGSE6Tp6cQjvhfv7nAFAlnT71cACgkQ6cQjvhfv\\n7nCWwA//XVqBKWO0zF+bZl6pggvky3Oc2j1pNFuRWZ29LXpNuD5WUGXGG209B0hI\\nDkmcGk19ZKUTnEUJV2Xd0R7AW01S/YSub7OYcgBkI7qUE13FVHN5ln1KvH2all2n\\n2+JCV1HcJLEoTjqIFZSSu/sMdhkLQ9/NsmMAzpf/iIM0nQOyU4YRex9eD1bYj6nA\\nOQPIDdAuaTQj1gFPHYLzM4zJnCqGdRlg0sOM/zC5apBNzIwlgREatOYQSCfCKV7k\\nnrU34X8b9BzQaUx48Qa+Dmfn5KQ8dl27RNeWAqlkuWyv3pUauH9UeYW+KyuJeMkU\\n+NyHgAsWFaCFl23kCHThbLStMZOYEnGagrd0hnm1TPS4GJkV4wfYMwnI4KuSlHKB\\njHl3Js9vNzEUQipQJbgCgTiWvRJoK3ENwBTMVkKHaqT4x9U4Jk/XZB6Q8MA09ezJ\\n3QgiTjTAGcum9E9QiJqMYdWQPWkaBIRRz5cET6HPB48YNXAAUsfmuYsGrnVLYbG+\\nUpC6I97VybYHTy2O9XSGoaLeMI9CsFn38ycAxxbWagk5mhclNTP5mezIq6wKSwmr\\nX11FW3n1J23fWZn5HJMBsRnUCgzqzX3871IqLYHqRJ/bpZ4h20RhTyPj5c/z7QXp\\neSakNQMfbbMcljkha+ZMuVQX1K9aRlVqbmv3ZMWh+OijLYVU2bc=\\n=5Io4\\n-----END PGP SIGNATURE-----\\n\",\"tree\":\"827efc6d56897b048c772eb4087f854f46256132\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GitCreateCommitReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GitCreateCommitReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGitCreateCommitReqAuthor_EncodeDecode(t *testing.T) {
	var typ GitCreateCommitReqAuthor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateCommitReqAuthor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCreateCommitReqCommitter_EncodeDecode(t *testing.T) {
	var typ GitCreateCommitReqCommitter
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateCommitReqCommitter
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCreateRefReq_EncodeDecode(t *testing.T) {
	var typ GitCreateRefReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateRefReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGitCreateRefReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"ref\":\"refs/heads/featureA\",\"sha\":\"aa218f56b14c9653891f9e74264a383fa43fefbd\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GitCreateRefReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GitCreateRefReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGitCreateTagReq_EncodeDecode(t *testing.T) {
	var typ GitCreateTagReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateTagReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGitCreateTagReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"message\":\"initial version\",\"object\":\"c3d0be41ecbe669545ee3e94d31ed9a4bc91ee3c\",\"tag\":\"v0.0.1\",\"tagger\":{\"date\":\"2011-06-17T14:53:35-07:00\",\"email\":\"octocat@github.com\",\"name\":\"Monalisa Octocat\"},\"type\":\"commit\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GitCreateTagReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GitCreateTagReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGitCreateTagReqTagger_EncodeDecode(t *testing.T) {
	var typ GitCreateTagReqTagger
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateTagReqTagger
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCreateTagReqType_EncodeDecode(t *testing.T) {
	var typ GitCreateTagReqType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateTagReqType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCreateTreeForbidden_EncodeDecode(t *testing.T) {
	var typ GitCreateTreeForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateTreeForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCreateTreeNotFound_EncodeDecode(t *testing.T) {
	var typ GitCreateTreeNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateTreeNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCreateTreeReq_EncodeDecode(t *testing.T) {
	var typ GitCreateTreeReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateTreeReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGitCreateTreeReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"base_tree\":\"9fb037999f264ba9a7fc6274d15fa3ae2ab98312\",\"tree\":[{\"mode\":\"100644\",\"path\":\"file.rb\",\"sha\":\"44b4fc6d56897b048c772eb4087f854f46256132\",\"type\":\"blob\"}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GitCreateTreeReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GitCreateTreeReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGitCreateTreeReqTreeItem_EncodeDecode(t *testing.T) {
	var typ GitCreateTreeReqTreeItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateTreeReqTreeItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCreateTreeReqTreeItemMode_EncodeDecode(t *testing.T) {
	var typ GitCreateTreeReqTreeItemMode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateTreeReqTreeItemMode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitCreateTreeReqTreeItemType_EncodeDecode(t *testing.T) {
	var typ GitCreateTreeReqTreeItemType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitCreateTreeReqTreeItemType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitGetBlobForbidden_EncodeDecode(t *testing.T) {
	var typ GitGetBlobForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitGetBlobForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitGetBlobNotFound_EncodeDecode(t *testing.T) {
	var typ GitGetBlobNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitGetBlobNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitRef_EncodeDecode(t *testing.T) {
	var typ GitRef
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitRef
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGitRef_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"node_id\":\"MDM6UmVmcmVmcy9oZWFkcy9mZWF0dXJlQQ==\",\"object\":{\"sha\":\"aa218f56b14c9653891f9e74264a383fa43fefbd\",\"type\":\"commit\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/aa218f56b14c9653891f9e74264a383fa43fefbd\"},\"ref\":\"refs/heads/featureA\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs/heads/featureA\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GitRef

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GitRef
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGitRefObject_EncodeDecode(t *testing.T) {
	var typ GitRefObject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitRefObject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitTag_EncodeDecode(t *testing.T) {
	var typ GitTag
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitTag
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGitTag_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"message\":\"initial version\",\"node_id\":\"MDM6VGFnOTQwYmQzMzYyNDhlZmFlMGY5ZWU1YmM3YjJkNWM5ODU4ODdiMTZhYw==\",\"object\":{\"sha\":\"c3d0be41ecbe669545ee3e94d31ed9a4bc91ee3c\",\"type\":\"commit\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits/c3d0be41ecbe669545ee3e94d31ed9a4bc91ee3c\"},\"sha\":\"940bd336248efae0f9ee5bc7b2d5c985887b16ac\",\"tag\":\"v0.0.1\",\"tagger\":{\"date\":\"2014-11-07T22:01:45Z\",\"email\":\"octocat@github.com\",\"name\":\"Monalisa Octocat\"},\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags/940bd336248efae0f9ee5bc7b2d5c985887b16ac\",\"verification\":{\"payload\":null,\"reason\":\"unsigned\",\"signature\":null,\"verified\":false}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GitTag

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GitTag
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGitTagObject_EncodeDecode(t *testing.T) {
	var typ GitTagObject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitTagObject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitTagTagger_EncodeDecode(t *testing.T) {
	var typ GitTagTagger
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitTagTagger
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitTree_EncodeDecode(t *testing.T) {
	var typ GitTree
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitTree
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGitTree_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"sha\":\"9fb037999f264ba9a7fc6274d15fa3ae2ab98312\",\"tree\":[{\"mode\":\"100644\",\"path\":\"file.rb\",\"sha\":\"44b4fc6d56897b048c772eb4087f854f46256132\",\"size\":30,\"type\":\"blob\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs/44b4fc6d56897b048c772eb4087f854f46256132\"},{\"mode\":\"040000\",\"path\":\"subdir\",\"sha\":\"f484d249c660418515fb01c2b9662073663c242e\",\"type\":\"tree\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs/f484d249c660418515fb01c2b9662073663c242e\"},{\"mode\":\"100755\",\"path\":\"exec_file\",\"sha\":\"45b983be36b73c0788dc9cbcb76cbb80fc7bb057\",\"size\":75,\"type\":\"blob\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs/45b983be36b73c0788dc9cbcb76cbb80fc7bb057\"}],\"truncated\":false,\"url\":\"https://api.github.com/repos/octocat/Hello-World/trees/9fb037999f264ba9a7fc6274d15fa3ae2ab98312\"}"},
		{Input: "{\"sha\":\"cd8274d15fa3ae2ab983129fb037999f264ba9a7\",\"tree\":[{\"mode\":\"100644\",\"path\":\"file.rb\",\"sha\":\"7c258a9869f33c1e1e1f74fbb32f07c86cb5a75b\",\"size\":132,\"type\":\"blob\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs/7c258a9869f33c1e1e1f74fbb32f07c86cb5a75b\"}],\"truncated\":true,\"url\":\"https://api.github.com/repos/octocat/Hello-World/trees/cd8274d15fa3ae2ab983129fb037999f264ba9a7\"}"},
		{Input: "{\"sha\":\"fc6274d15fa3ae2ab983129fb037999f264ba9a7\",\"tree\":[{\"mode\":\"100644\",\"path\":\"subdir/file.txt\",\"sha\":\"7c258a9869f33c1e1e1f74fbb32f07c86cb5a75b\",\"size\":132,\"type\":\"blob\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/git/7c258a9869f33c1e1e1f74fbb32f07c86cb5a75b\"}],\"truncated\":false,\"url\":\"https://api.github.com/repos/octocat/Hello-World/trees/fc6274d15fa3ae2ab983129fb037999f264ba9a7\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GitTree

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GitTree
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGitTreeTreeItem_EncodeDecode(t *testing.T) {
	var typ GitTreeTreeItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitTreeTreeItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitUpdateRefReq_EncodeDecode(t *testing.T) {
	var typ GitUpdateRefReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitUpdateRefReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGitUpdateRefReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"force\":true,\"sha\":\"aa218f56b14c9653891f9e74264a383fa43fefbd\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GitUpdateRefReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GitUpdateRefReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGitignoreGetAllTemplatesOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ GitignoreGetAllTemplatesOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitignoreGetAllTemplatesOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGitignoreTemplate_EncodeDecode(t *testing.T) {
	var typ GitignoreTemplate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GitignoreTemplate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGitignoreTemplate_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"name\":\"C\",\"source\":\"# Object files\\n*.o\\n\\n# Libraries\\n*.lib\\n*.a\\n\\n# Shared objects (inc. Windows DLLs)\\n*.dll\\n*.so\\n*.so.*\\n*.dylib\\n\\n# Executables\\n*.exe\\n*.out\\n*.app\\n\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GitignoreTemplate

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GitignoreTemplate
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGpgKey_EncodeDecode(t *testing.T) {
	var typ GpgKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GpgKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGpgKey_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"can_certify\":true,\"can_encrypt_comms\":false,\"can_encrypt_storage\":false,\"can_sign\":true,\"created_at\":\"2016-03-24T11:31:04-06:00\",\"emails\":[{\"email\":\"mastahyeti@users.noreply.github.com\",\"verified\":true}],\"expires_at\":\"2016-03-24T11:31:04-07:00\",\"id\":3,\"key_id\":\"3262EFF25BA0D270\",\"primary_key_id\":2,\"public_key\":\"xsBNBFayYZ...\",\"raw_key\":\"\\\"-----BEGIN PGP PUBLIC KEY BLOCK-----\\\\nVersion: GnuPG v2\\\\n\\\\nmQENBFayYZ0BCAC4hScoJXXpyR+MXGcrBxElqw3FzCVvkViuyeko+Jp76QJhg8kr\\\\nucRTxbnOoHfda/FmilEa/wxf9ch5/PSrrL26FxEoPHhJolp8fnIDLQeITn94NYdB\\\\nZtnnEKslpPrG97qSUWIchvyqCPtvOb8+8fWvGx9K/ZWcEEdh1X8+WFR2jMENMeoX\\\\nwxHWQoPnS7LpX/85/M7VUcJxvDVfv+eHsnQupmE5bGarKNih0oMe3LbdN3qA5PTz\\\\nSCm6Iudar1VsQ+xTz08ymL7t4pnEtLguQ7EyatFHCjxNblv5RzxoL0tDgN3HqoDz\\\\nc7TEA+q4RtDQl9amcvQ95emnXmZ974u7UkYdABEBAAG0HlNvbWUgVXNlciA8c29t\\\\nZXVzZXJAZ21haWwuY29tPokBOAQTAQIAIgUCVrJhnQIbAwYLCQgHAwIGFQgCCQoL\\\\nBBYCAwECHgECF4AACgkQMmLv8lug0nAViQgArWjI55+7p48URr2z9Jvak+yrBTx1\\\\nzkufltQAnHTJkq+Kl9dySSmTnOop8o3rE4++IOpYV5Y36PkKf9EZMk4n1RQiDPKE\\\\nAFtRVTkRaoWzOir9KQXJPfhKrl01j/QzY+utfiMvUoBJZ9ybq8Pa885SljW9lbaX\\\\nIYw+hl8ZdJ2KStvGrEyfQvRyq3aN5c9TV//4BdGnwx7Qabq/U+G18lizG6f/yq15\\\\ned7t0KELaCfeKPvytp4VE9/z/Ksah/h3+Qilx07/oG2Ae5kC1bEC9coD/ogPUhbv\\\\nb2bsBIoY9E9YwsLoif2lU+o1t76zLgUktuNscRRUKobW028H1zuFS/XQhrkBDQRW\\\\nsmGdAQgApnyyv3i144OLYy0O4UKQxd3e10Y3WpDwfnGIBefAI1m7RxnUxBag/DsU\\\\n7gi9qLEC4VHSfq4eiNfr1LJOyCL2edTgCWFgBhVjbXjZe6YAOrAnhxwCErnN0Y7N\\\\n6s8wVh9fObSOyf8ZE6G7JeKpcq9Q6gd/KxagfD48a1v+fyRHpyQc6J9pUEmtrDJ7\\\\nBjmsd2VWzLBvNWdHyxDNtZweIaqIO9VUYYpr1mtTliNBOZLUelmgrt7HBRcJpWMA\\\\nS8muVVbuP5MK0trLBq/JB8qUH3zRzB/PhMgzmkIfjEK1VYDWm4E8DYyTWEJcHqkb\\\\neqFsNjrIlwPaA122BWC6gUOPwwH+oQARAQABiQEfBBgBAgAJBQJWsmGdAhsMAAoJ\\\\nEDJi7/JboNJwAyAIALd4xcdmGbZD98gScJzqwzkOMcO8zFHqHNvJ42xIFvGny7c0\\\\n1Rx7iyrdypOby5AxE+viQcjG4rpLZW/xKYBNGrCfDyQO7511I0v8x20EICMlMfD/\\\\nNrWQCzesEPcUlKTP07d+sFyP8AyseOidbzY/92CpskTgdSBjY/ntLSaoknl/fjJE\\\\nQM8OkPqU7IraO1Jzzdnm20d5PZL9+PIwIWdSTedU/vBMTJyNcoqvSfKf1wNC66XP\\\\nhqfYgXJE564AdWZKA3C0IyCqiv+LHwxLnUHio1a4/r91C8KPzxs6tGxRDjXLd7ms\\\\nuYFGWymiUGOE/giHlcxdYcHzwLnPDliMQOLiTkK5AQ0EVuxMygEIAOD+bW1cDTmE\\\\nBxh5JECoqeHuwgl6DlLhnubWPkQ4ZeRzBRAsFcEJQlwlJjrzFDicL+lnm6Qq4tt0\\\\n560TwHdf15/AKTZIZu7H25axvGNzgeaUkJEJdYAq9zTKWwX7wKyzBszi485nQg97\\\\nMfAqwhMpDW0Qqf8+7Ug+WEmfBSGv9uL3aQC6WEeIsHfri0n0n8v4XgwhfShXguxO\\\\nCsOztEsuW7WWKW9P4TngKKv4lCHdPlV6FwxeMzODBJvc2fkHVHnqc0PqszJ5xcF8\\\\n6gZCpMM027SbpeYWCAD5zwJyYP9ntfO1p2HjnQ1dZaP9FeNcO7uIV1Lnd1eGCu6I\\\\nsrVp5k1f3isAEQEAAYkCPgQYAQIACQUCVuxMygIbAgEpCRAyYu/yW6DScMBdIAQZ\\\\nAQIABgUCVuxMygAKCRCKohN4dhq2b4tcCACHxmOHVXNpu47OvUGYQydLgMACUlXN\\\\nlj+HfE0VReqShxdDmpasAY9IRpuMB2RsGK8GbNP+4SlOlAiPf5SMhS7nZNkNDgQQ\\\\naZ3HFpgrFmFwmE10BKT4iQtoxELLM57z0qGOAfTsEjWFQa4sF+6IHAQR/ptkdkkI\\\\nBUEXiMnAwVwBysLIJiLO8qdjB6qp52QkT074JVrwywT/P+DkMfC2k4r/AfEbf6eF\\\\ndmPDuPk6KD87+hJZsSa5MaMUBQVvRO/mgEkhJRITVu58eWGaBOcQJ8gqurhCqM5P\\\\nDfUA4TJ7wiqM6sS764vV1rOioTTXkszzhClQqET7hPVnVQjenYgv0EZHNyQH/1f1\\\\n/CYqvV1vFjM9vJjMbxXsATCkZe6wvBVKD8vLsJAr8N+onKQz+4OPc3kmKq7aESu3\\\\nCi/iuie5KKVwnuNhr9AzT61vEkKxwHcVFEvHB77F6ZAAInhRvjzmQbD2dlPLLQCC\\\\nqDj71ODSSAPTEmUy6969bgD9PfWei7kNkBIx7s3eBv8yzytSc2EcuUgopqFazquw\\\\nFs1+tqGHjBvQfTo6bqbJjp/9Ci2pvde3ElV2rAgUlb3lqXyXjRDqrXosh5GcRPQj\\\\nK8Nhj1BNhnrCVskE4BP0LYbOHuzgm86uXwGCFsY+w2VOsSm16Jx5GHyG5S5WU3+D\\\\nIts/HFYRLiFgDLmTlxo=\\\\n=+OzK\\\\n-----END PGP PUBLIC KEY BLOCK-----\\\"\",\"subkeys\":[{\"can_certify\":false,\"can_encrypt_comms\":true,\"can_encrypt_storage\":true,\"can_sign\":false,\"created_at\":\"2016-03-24T11:31:04-06:00\",\"emails\":[],\"expires_at\":\"2016-03-24T11:31:04-07:00\",\"id\":4,\"key_id\":\"4A595D4C72EE49C7\",\"primary_key_id\":3,\"public_key\":\"zsBNBFayYZ...\",\"subkeys\":[]}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GpgKey

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GpgKey
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGpgKeyEmailsItem_EncodeDecode(t *testing.T) {
	var typ GpgKeyEmailsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GpgKeyEmailsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGpgKeySubkeysItem_EncodeDecode(t *testing.T) {
	var typ GpgKeySubkeysItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GpgKeySubkeysItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGroupMapping_EncodeDecode(t *testing.T) {
	var typ GroupMapping
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GroupMapping
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGroupMapping_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"groups\":[{\"group_description\":\"The people who configure your octoworld.\",\"group_id\":\"123\",\"group_name\":\"Octocat admins\"},{\"group_description\":\"The people who make your octoworld come to life.\",\"group_id\":\"456\",\"group_name\":\"Octocat docs members\"}]}"},
		{Input: "{\"groups\":[{\"group_description\":\"The people who configure your octoworld.\",\"group_id\":\"123\",\"group_name\":\"Octocat admins\"}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GroupMapping

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GroupMapping
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGroupMappingGroupsItem_EncodeDecode(t *testing.T) {
	var typ GroupMappingGroupsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GroupMappingGroupsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHook_EncodeDecode(t *testing.T) {
	var typ Hook
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Hook
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestHook_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"active\":true,\"config\":{\"content_type\":\"json\",\"insecure_ssl\":\"0\",\"url\":\"https://example.com/webhook\"},\"created_at\":\"2019-06-03T00:57:16Z\",\"deliveries_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks/12345678/deliveries\",\"events\":[\"push\",\"pull_request\"],\"id\":12345678,\"last_response\":{\"code\":null,\"message\":null,\"status\":\"unused\"},\"name\":\"web\",\"ping_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks/12345678/pings\",\"test_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks/12345678/test\",\"type\":\"Repository\",\"updated_at\":\"2019-06-03T00:57:16Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/hooks/12345678\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Hook

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Hook
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestHookConfig_EncodeDecode(t *testing.T) {
	var typ HookConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HookConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHookDelivery_EncodeDecode(t *testing.T) {
	var typ HookDelivery
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HookDelivery
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestHookDelivery_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"action\":\"opened\",\"delivered_at\":\"2019-06-03T00:57:16Z\",\"duration\":0.27,\"event\":\"issues\",\"guid\":\"0b989ba4-242f-11e5-81e1-c7b6966d2516\",\"id\":12345678,\"installation_id\":123,\"redelivery\":false,\"repository_id\":456,\"request\":{\"headers\":{\"Accept\":\"*/*\",\"User-Agent\":\"GitHub-Hookshot/b8c71d8\",\"X-GitHub-Delivery\":\"0b989ba4-242f-11e5-81e1-c7b6966d2516\",\"X-GitHub-Event\":\"issues\",\"X-GitHub-Hook-ID\":\"42\",\"X-GitHub-Hook-Installation-Target-ID\":\"123\",\"X-GitHub-Hook-Installation-Target-Type\":\"repository\",\"X-Hub-Signature\":\"sha1=a84d88e7554fc1fa21bcbc4efae3c782a70d2b9d\",\"X-Hub-Signature-256\":\"sha256=6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"content-type\":\"application/json\"},\"payload\":{\"action\":\"opened\",\"issue\":{\"body\":\"foo\"},\"repository\":{\"id\":123}}},\"response\":{\"headers\":{\"Content-Type\":\"text/html;charset=utf-8\"},\"payload\":\"ok\"},\"status\":\"OK\",\"status_code\":200,\"url\":\"https://www.example.com\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ HookDelivery

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 HookDelivery
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestHookDeliveryItem_EncodeDecode(t *testing.T) {
	var typ HookDeliveryItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HookDeliveryItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHookDeliveryRequest_EncodeDecode(t *testing.T) {
	var typ HookDeliveryRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HookDeliveryRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHookDeliveryRequestHeaders_EncodeDecode(t *testing.T) {
	var typ HookDeliveryRequestHeaders
	typ = make(HookDeliveryRequestHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HookDeliveryRequestHeaders
	typ2 = make(HookDeliveryRequestHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHookDeliveryRequestPayload_EncodeDecode(t *testing.T) {
	var typ HookDeliveryRequestPayload
	typ = make(HookDeliveryRequestPayload)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HookDeliveryRequestPayload
	typ2 = make(HookDeliveryRequestPayload)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHookDeliveryResponse_EncodeDecode(t *testing.T) {
	var typ HookDeliveryResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HookDeliveryResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHookDeliveryResponseHeaders_EncodeDecode(t *testing.T) {
	var typ HookDeliveryResponseHeaders
	typ = make(HookDeliveryResponseHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HookDeliveryResponseHeaders
	typ2 = make(HookDeliveryResponseHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHookResponse_EncodeDecode(t *testing.T) {
	var typ HookResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HookResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHovercard_EncodeDecode(t *testing.T) {
	var typ Hovercard
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Hovercard
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestHovercard_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"contexts\":[{\"message\":\"Owns this repository\",\"octicon\":\"repo\"}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Hovercard

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Hovercard
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestHovercardContextsItem_EncodeDecode(t *testing.T) {
	var typ HovercardContextsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HovercardContextsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestImport_EncodeDecode(t *testing.T) {
	var typ Import
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Import
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestImport_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"authors_count\":0,\"authors_url\":\"https://api.github.com/repos/octocat/socm/import/authors\",\"commit_count\":1042,\"has_large_files\":false,\"html_url\":\"https://import.github.com/octocat/socm/import\",\"large_files_count\":0,\"large_files_size\":0,\"repository_url\":\"https://api.github.com/repos/octocat/socm\",\"status\":\"importing\",\"status_text\":\"Importing...\",\"tfvc_project\":\"project1\",\"url\":\"https://api.github.com/repos/octocat/socm/import\",\"use_lfs\":true,\"vcs\":\"tfvc\",\"vcs_url\":\"http://tfs.mycompany.com/tfs/myproject\"}"},
		{Input: "{\"authors_count\":0,\"authors_url\":\"https://api.github.com/repos/octocat/socm/import/authors\",\"commit_count\":1042,\"has_large_files\":false,\"html_url\":\"https://import.github.com/octocat/socm/import\",\"large_files_count\":0,\"large_files_size\":0,\"repository_url\":\"https://api.github.com/repos/octocat/socm\",\"status\":\"importing\",\"status_text\":\"Importing...\",\"url\":\"https://api.github.com/repos/octocat/socm/import\",\"use_lfs\":true,\"vcs\":\"subversion\",\"vcs_url\":\"http://svn.mycompany.com/svn/myproject\"}"},
		{Input: "{\"authors_count\":4,\"authors_url\":\"https://api.github.com/repos/octocat/socm/import/authors\",\"has_large_files\":true,\"html_url\":\"https://import.github.com/octocat/socm/import\",\"large_files_count\":1,\"large_files_size\":132331036,\"repository_url\":\"https://api.github.com/repos/octocat/socm\",\"status\":\"complete\",\"status_text\":\"Done\",\"url\":\"https://api.github.com/repos/octocat/socm/import\",\"use_lfs\":true,\"vcs\":\"subversion\",\"vcs_url\":\"http://svn.mycompany.com/svn/myproject\"}"},
		{Input: "{\"authors_url\":\"https://api.github.com/repos/octocat/socm/import/authors\",\"html_url\":\"https://import.github.com/octocat/socm/import\",\"repository_url\":\"https://api.github.com/repos/octocat/socm\",\"status\":\"detecting\",\"url\":\"https://api.github.com/repos/octocat/socm/import\",\"use_lfs\":true,\"vcs\":\"subversion\",\"vcs_url\":\"http://svn.mycompany.com/svn/myproject\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Import

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Import
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestImportProjectChoicesItem_EncodeDecode(t *testing.T) {
	var typ ImportProjectChoicesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ImportProjectChoicesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestImportStatus_EncodeDecode(t *testing.T) {
	var typ ImportStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ImportStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInstallationToken_EncodeDecode(t *testing.T) {
	var typ InstallationToken
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InstallationToken
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestInstallationToken_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"expires_at\":\"2016-07-11T22:14:10Z\",\"permissions\":{\"contents\":\"read\",\"issues\":\"write\"},\"repositories\":[{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":1,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":null,\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":1,\"watchers_count\":80}],\"repository_selection\":\"selected\",\"token\":\"ghs_16C7e42F292c6912E7710c838347Ae178B4a\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ InstallationToken

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 InstallationToken
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestInstallationTokenRepositorySelection_EncodeDecode(t *testing.T) {
	var typ InstallationTokenRepositorySelection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InstallationTokenRepositorySelection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIntegration_EncodeDecode(t *testing.T) {
	var typ Integration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Integration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestIntegration_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2017-07-08T16:18:44-04:00\",\"description\":\"\",\"events\":[\"push\",\"pull_request\"],\"external_url\":\"https://example.com\",\"html_url\":\"https://github.com/apps/octoapp\",\"id\":1,\"name\":\"Octocat App\",\"node_id\":\"MDExOkludGVncmF0aW9uMQ==\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/orgs/github/events\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"github\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/orgs/github/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/orgs/github\"},\"permissions\":{\"contents\":\"read\",\"issues\":\"write\",\"metadata\":\"read\",\"single_file\":\"write\"},\"slug\":\"octoapp\",\"updated_at\":\"2017-07-08T16:18:44-04:00\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Integration

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Integration
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIntegrationPermissions_EncodeDecode(t *testing.T) {
	var typ IntegrationPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IntegrationPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestIntegrationPermissions_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"deployments\":\"write\",\"issues\":\"read\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ IntegrationPermissions

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 IntegrationPermissions
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIntegrationPermissionsAdditional_EncodeDecode(t *testing.T) {
	var typ IntegrationPermissionsAdditional
	typ = make(IntegrationPermissionsAdditional)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IntegrationPermissionsAdditional
	typ2 = make(IntegrationPermissionsAdditional)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInteractionExpiry_EncodeDecode(t *testing.T) {
	var typ InteractionExpiry
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InteractionExpiry
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestInteractionExpiry_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"one_month\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ InteractionExpiry

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 InteractionExpiry
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestInteractionGroup_EncodeDecode(t *testing.T) {
	var typ InteractionGroup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InteractionGroup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestInteractionGroup_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"collaborators_only\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ InteractionGroup

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 InteractionGroup
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestInteractionLimit_EncodeDecode(t *testing.T) {
	var typ InteractionLimit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InteractionLimit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInteractionLimitResponse_EncodeDecode(t *testing.T) {
	var typ InteractionLimitResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InteractionLimitResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestInteractionLimitResponse_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"expires_at\":\"2018-08-17T04:18:39Z\",\"limit\":\"collaborators_only\",\"origin\":\"organization\"}"},
		{Input: "{\"expires_at\":\"2018-08-17T04:18:39Z\",\"limit\":\"collaborators_only\",\"origin\":\"repository\"}"},
		{Input: "{\"expires_at\":\"2018-08-17T04:18:39Z\",\"limit\":\"collaborators_only\",\"origin\":\"user\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ InteractionLimitResponse

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 InteractionLimitResponse
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIssue_EncodeDecode(t *testing.T) {
	var typ Issue
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Issue
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestIssue_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"active_lock_reason\":\"too heated\",\"assignee\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"assignees\":[{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}],\"author_association\":\"COLLABORATOR\",\"body\":\"I'm having a problem with this.\",\"closed_at\":null,\"closed_by\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"comments\":0,\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347/comments\",\"created_at\":\"2011-04-22T13:33:48Z\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347/events\",\"html_url\":\"https://github.com/octocat/Hello-World/issues/1347\",\"id\":1,\"labels\":[{\"color\":\"f29513\",\"default\":true,\"description\":\"Something isn't working\",\"id\":208045946,\"name\":\"bug\",\"node_id\":\"MDU6TGFiZWwyMDgwNDU5NDY=\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/labels/bug\"}],\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347/labels{/name}\",\"locked\":true,\"milestone\":{\"closed_at\":\"2013-02-12T13:22:01Z\",\"closed_issues\":8,\"created_at\":\"2011-04-10T20:09:31Z\",\"creator\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"description\":\"Tracking milestone for version 1.0\",\"due_on\":\"2012-10-09T23:39:01Z\",\"html_url\":\"https://github.com/octocat/Hello-World/milestones/v1.0\",\"id\":1002604,\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones/1/labels\",\"node_id\":\"MDk6TWlsZXN0b25lMTAwMjYwNA==\",\"number\":1,\"open_issues\":4,\"state\":\"open\",\"title\":\"v1.0\",\"updated_at\":\"2014-03-03T18:58:10Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/milestones/1\"},\"node_id\":\"MDU6SXNzdWUx\",\"number\":1347,\"pull_request\":{\"diff_url\":\"https://github.com/octocat/Hello-World/pull/1347.diff\",\"html_url\":\"https://github.com/octocat/Hello-World/pull/1347\",\"patch_url\":\"https://github.com/octocat/Hello-World/pull/1347.patch\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1347\"},\"repository_url\":\"https://api.github.com/repos/octocat/Hello-World\",\"state\":\"open\",\"title\":\"Found a bug\",\"updated_at\":\"2011-04-22T13:33:48Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Issue

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Issue
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIssueComment_EncodeDecode(t *testing.T) {
	var typ IssueComment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssueComment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestIssueComment_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"author_association\":\"COLLABORATOR\",\"body\":\"Me too\",\"created_at\":\"2011-04-14T16:00:49Z\",\"html_url\":\"https://github.com/octocat/Hello-World/issues/1347#issuecomment-1\",\"id\":1,\"issue_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347\",\"node_id\":\"MDEyOklzc3VlQ29tbWVudDE=\",\"updated_at\":\"2011-04-14T16:00:49Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments/1\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ IssueComment

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 IssueComment
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIssueEvent_EncodeDecode(t *testing.T) {
	var typ IssueEvent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssueEvent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestIssueEvent_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"actor\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"commit_id\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"commit_url\":\"https://api.github.com/repos/octocat/Hello-World/commits/6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"created_at\":\"2011-04-14T16:00:49Z\",\"event\":\"closed\",\"id\":1,\"issue\":{\"assignee\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"assignees\":[{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}],\"author_association\":\"COLLABORATOR\",\"body\":\"I'm having a problem with this.\",\"closed_at\":null,\"comments\":0,\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347/comments\",\"created_at\":\"2011-04-22T13:33:48Z\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347/events\",\"html_url\":\"https://github.com/octocat/Hello-World/issues/1347\",\"id\":1,\"labels\":[{\"color\":\"f29513\",\"default\":true,\"description\":\"Something isn't working\",\"id\":208045946,\"name\":\"bug\",\"node_id\":\"MDU6TGFiZWwyMDgwNDU5NDY=\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/labels/bug\"}],\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347/labels{/name}\",\"locked\":true,\"milestone\":{\"closed_at\":\"2013-02-12T13:22:01Z\",\"closed_issues\":8,\"created_at\":\"2011-04-10T20:09:31Z\",\"creator\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"description\":\"Tracking milestone for version 1.0\",\"due_on\":\"2012-10-09T23:39:01Z\",\"html_url\":\"https://github.com/octocat/Hello-World/milestones/v1.0\",\"id\":1002604,\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones/1/labels\",\"node_id\":\"MDk6TWlsZXN0b25lMTAwMjYwNA==\",\"number\":1,\"open_issues\":4,\"state\":\"open\",\"title\":\"v1.0\",\"updated_at\":\"2014-03-03T18:58:10Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/milestones/1\"},\"node_id\":\"MDU6SXNzdWUx\",\"number\":1347,\"performed_via_github_app\":{\"created_at\":\"2017-07-08T16:18:44-04:00\",\"description\":\"\",\"events\":[\"push\",\"pull_request\"],\"external_url\":\"https://example.com\",\"html_url\":\"https://github.com/apps/octoapp\",\"id\":1,\"name\":\"Octocat App\",\"node_id\":\"MDExOkludGVncmF0aW9uMQ==\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/orgs/github/events\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"github\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/orgs/github/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/orgs/github\"},\"permissions\":{\"contents\":\"read\",\"issues\":\"write\",\"metadata\":\"read\",\"single_file\":\"write\"},\"slug\":\"octoapp\",\"updated_at\":\"2017-07-08T16:18:44-04:00\"},\"pull_request\":{\"diff_url\":\"https://github.com/octocat/Hello-World/pull/1347.diff\",\"html_url\":\"https://github.com/octocat/Hello-World/pull/1347\",\"patch_url\":\"https://github.com/octocat/Hello-World/pull/1347.patch\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1347\"},\"repository_url\":\"https://api.github.com/repos/octocat/Hello-World\",\"state\":\"open\",\"title\":\"Found a bug\",\"updated_at\":\"2011-04-22T13:33:48Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}},\"node_id\":\"MDEwOklzc3VlRXZlbnQx\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events/1\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ IssueEvent

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 IssueEvent
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIssueEventDismissedReview_EncodeDecode(t *testing.T) {
	var typ IssueEventDismissedReview
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssueEventDismissedReview
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssueEventLabel_EncodeDecode(t *testing.T) {
	var typ IssueEventLabel
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssueEventLabel
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssueEventMilestone_EncodeDecode(t *testing.T) {
	var typ IssueEventMilestone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssueEventMilestone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssueEventProjectCard_EncodeDecode(t *testing.T) {
	var typ IssueEventProjectCard
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssueEventProjectCard
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssueEventRename_EncodeDecode(t *testing.T) {
	var typ IssueEventRename
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssueEventRename
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssueLabelsItem_EncodeDecode(t *testing.T) {
	var typ IssueLabelsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssueLabelsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssueLabelsItem1_EncodeDecode(t *testing.T) {
	var typ IssueLabelsItem1
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssueLabelsItem1
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuePullRequest_EncodeDecode(t *testing.T) {
	var typ IssuePullRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuePullRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssueSearchResultItem_EncodeDecode(t *testing.T) {
	var typ IssueSearchResultItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssueSearchResultItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssueSearchResultItemLabelsItem_EncodeDecode(t *testing.T) {
	var typ IssueSearchResultItemLabelsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssueSearchResultItemLabelsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssueSearchResultItemPullRequest_EncodeDecode(t *testing.T) {
	var typ IssueSearchResultItemPullRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssueSearchResultItemPullRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssueSimple_EncodeDecode(t *testing.T) {
	var typ IssueSimple
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssueSimple
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestIssueSimple_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"active_lock_reason\":\"too heated\",\"assignee\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"assignees\":[{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},{\"avatar_url\":\"https://github.com/images/error/hubot_happy.gif\",\"events_url\":\"https://api.github.com/users/hubot/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/hubot/followers\",\"following_url\":\"https://api.github.com/users/hubot/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/hubot/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/hubot\",\"id\":1,\"login\":\"hubot\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/hubot/orgs\",\"received_events_url\":\"https://api.github.com/users/hubot/received_events\",\"repos_url\":\"https://api.github.com/users/hubot/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/hubot/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/hubot/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/hubot\"},{\"avatar_url\":\"https://github.com/images/error/other_user_happy.gif\",\"events_url\":\"https://api.github.com/users/other_user/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/other_user/followers\",\"following_url\":\"https://api.github.com/users/other_user/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/other_user/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/other_user\",\"id\":1,\"login\":\"other_user\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/other_user/orgs\",\"received_events_url\":\"https://api.github.com/users/other_user/received_events\",\"repos_url\":\"https://api.github.com/users/other_user/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/other_user/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/other_user/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/other_user\"}],\"author_association\":\"COLLABORATOR\",\"body\":\"I'm having a problem with this.\",\"closed_at\":null,\"comments\":0,\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347/comments\",\"created_at\":\"2011-04-22T13:33:48Z\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347/events\",\"html_url\":\"https://github.com/octocat/Hello-World/issues/1347\",\"id\":1,\"labels\":[{\"color\":\"f29513\",\"default\":true,\"description\":\"Something isn't working\",\"id\":208045946,\"name\":\"bug\",\"node_id\":\"MDU6TGFiZWwyMDgwNDU5NDY=\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/labels/bug\"}],\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347/labels{/name}\",\"locked\":true,\"milestone\":{\"closed_at\":\"2013-02-12T13:22:01Z\",\"closed_issues\":8,\"created_at\":\"2011-04-10T20:09:31Z\",\"creator\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"description\":\"Tracking milestone for version 1.0\",\"due_on\":\"2012-10-09T23:39:01Z\",\"html_url\":\"https://github.com/octocat/Hello-World/milestones/v1.0\",\"id\":1002604,\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones/1/labels\",\"node_id\":\"MDk6TWlsZXN0b25lMTAwMjYwNA==\",\"number\":1,\"open_issues\":4,\"state\":\"open\",\"title\":\"v1.0\",\"updated_at\":\"2014-03-03T18:58:10Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/milestones/1\"},\"node_id\":\"MDU6SXNzdWUx\",\"number\":1347,\"pull_request\":{\"diff_url\":\"https://github.com/octocat/Hello-World/pull/1347.diff\",\"html_url\":\"https://github.com/octocat/Hello-World/pull/1347\",\"patch_url\":\"https://github.com/octocat/Hello-World/pull/1347.patch\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1347\"},\"repository_url\":\"https://api.github.com/repos/octocat/Hello-World\",\"state\":\"open\",\"title\":\"Found a bug\",\"updated_at\":\"2011-04-22T13:33:48Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ IssueSimple

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 IssueSimple
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIssueSimplePullRequest_EncodeDecode(t *testing.T) {
	var typ IssueSimplePullRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssueSimplePullRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesAddAssigneesReq_EncodeDecode(t *testing.T) {
	var typ IssuesAddAssigneesReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesAddAssigneesReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestIssuesAddAssigneesReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"assignees\":[\"hubot\",\"other_user\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ IssuesAddAssigneesReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 IssuesAddAssigneesReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIssuesCreateCommentForbidden_EncodeDecode(t *testing.T) {
	var typ IssuesCreateCommentForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesCreateCommentForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesCreateCommentGone_EncodeDecode(t *testing.T) {
	var typ IssuesCreateCommentGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesCreateCommentGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesCreateCommentNotFound_EncodeDecode(t *testing.T) {
	var typ IssuesCreateCommentNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesCreateCommentNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesCreateCommentReq_EncodeDecode(t *testing.T) {
	var typ IssuesCreateCommentReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesCreateCommentReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestIssuesCreateCommentReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"Me too\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ IssuesCreateCommentReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 IssuesCreateCommentReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIssuesCreateForbidden_EncodeDecode(t *testing.T) {
	var typ IssuesCreateForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesCreateForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesCreateGone_EncodeDecode(t *testing.T) {
	var typ IssuesCreateGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesCreateGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesCreateLabelReq_EncodeDecode(t *testing.T) {
	var typ IssuesCreateLabelReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesCreateLabelReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestIssuesCreateLabelReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"color\":\"f29513\",\"description\":\"Something isn't working\",\"name\":\"bug\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ IssuesCreateLabelReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 IssuesCreateLabelReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIssuesCreateMilestoneReq_EncodeDecode(t *testing.T) {
	var typ IssuesCreateMilestoneReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesCreateMilestoneReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestIssuesCreateMilestoneReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"Tracking milestone for version 1.0\",\"due_on\":\"2012-10-09T23:39:01Z\",\"state\":\"open\",\"title\":\"v1.0\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ IssuesCreateMilestoneReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 IssuesCreateMilestoneReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIssuesCreateMilestoneReqState_EncodeDecode(t *testing.T) {
	var typ IssuesCreateMilestoneReqState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesCreateMilestoneReqState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesCreateNotFound_EncodeDecode(t *testing.T) {
	var typ IssuesCreateNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesCreateNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesCreateReq_EncodeDecode(t *testing.T) {
	var typ IssuesCreateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesCreateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestIssuesCreateReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"assignees\":[\"octocat\"],\"body\":\"I'm having a problem with this.\",\"labels\":[\"bug\"],\"milestone\":1,\"title\":\"Found a bug\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ IssuesCreateReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 IssuesCreateReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIssuesCreateReqLabelsItem_EncodeDecode(t *testing.T) {
	var typ IssuesCreateReqLabelsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesCreateReqLabelsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesCreateReqLabelsItem1_EncodeDecode(t *testing.T) {
	var typ IssuesCreateReqLabelsItem1
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesCreateReqLabelsItem1
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesCreateReqMilestone_EncodeDecode(t *testing.T) {
	var typ IssuesCreateReqMilestone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesCreateReqMilestone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesCreateReqTitle_EncodeDecode(t *testing.T) {
	var typ IssuesCreateReqTitle
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesCreateReqTitle
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesGetEventForbidden_EncodeDecode(t *testing.T) {
	var typ IssuesGetEventForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesGetEventForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesGetEventGone_EncodeDecode(t *testing.T) {
	var typ IssuesGetEventGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesGetEventGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesGetEventNotFound_EncodeDecode(t *testing.T) {
	var typ IssuesGetEventNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesGetEventNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesGetGone_EncodeDecode(t *testing.T) {
	var typ IssuesGetGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesGetGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesGetMovedPermanently_EncodeDecode(t *testing.T) {
	var typ IssuesGetMovedPermanently
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesGetMovedPermanently
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesGetNotFound_EncodeDecode(t *testing.T) {
	var typ IssuesGetNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesGetNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesListCommentsGone_EncodeDecode(t *testing.T) {
	var typ IssuesListCommentsGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesListCommentsGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesListCommentsNotFound_EncodeDecode(t *testing.T) {
	var typ IssuesListCommentsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesListCommentsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesListForRepoMovedPermanently_EncodeDecode(t *testing.T) {
	var typ IssuesListForRepoMovedPermanently
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesListForRepoMovedPermanently
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesListForRepoNotFound_EncodeDecode(t *testing.T) {
	var typ IssuesListForRepoNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesListForRepoNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesLockForbidden_EncodeDecode(t *testing.T) {
	var typ IssuesLockForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesLockForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesLockGone_EncodeDecode(t *testing.T) {
	var typ IssuesLockGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesLockGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesLockNotFound_EncodeDecode(t *testing.T) {
	var typ IssuesLockNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesLockNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesLockReq_EncodeDecode(t *testing.T) {
	var typ IssuesLockReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesLockReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesLockReqLockReason_EncodeDecode(t *testing.T) {
	var typ IssuesLockReqLockReason
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesLockReqLockReason
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesRemoveAssigneesReq_EncodeDecode(t *testing.T) {
	var typ IssuesRemoveAssigneesReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesRemoveAssigneesReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestIssuesRemoveAssigneesReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"assignees\":[\"hubot\",\"other_user\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ IssuesRemoveAssigneesReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 IssuesRemoveAssigneesReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIssuesRemoveLabelGone_EncodeDecode(t *testing.T) {
	var typ IssuesRemoveLabelGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesRemoveLabelGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesRemoveLabelNotFound_EncodeDecode(t *testing.T) {
	var typ IssuesRemoveLabelNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesRemoveLabelNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesRemoveLabelOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ IssuesRemoveLabelOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesRemoveLabelOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesUnlockForbidden_EncodeDecode(t *testing.T) {
	var typ IssuesUnlockForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesUnlockForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesUnlockNotFound_EncodeDecode(t *testing.T) {
	var typ IssuesUnlockNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesUnlockNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesUpdateCommentReq_EncodeDecode(t *testing.T) {
	var typ IssuesUpdateCommentReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesUpdateCommentReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestIssuesUpdateCommentReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"Me too\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ IssuesUpdateCommentReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 IssuesUpdateCommentReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIssuesUpdateForbidden_EncodeDecode(t *testing.T) {
	var typ IssuesUpdateForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesUpdateForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesUpdateGone_EncodeDecode(t *testing.T) {
	var typ IssuesUpdateGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesUpdateGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesUpdateLabelReq_EncodeDecode(t *testing.T) {
	var typ IssuesUpdateLabelReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesUpdateLabelReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestIssuesUpdateLabelReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"color\":\"b01f26\",\"description\":\"Small bug fix required\",\"new_name\":\"bug :bug:\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ IssuesUpdateLabelReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 IssuesUpdateLabelReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIssuesUpdateMilestoneReq_EncodeDecode(t *testing.T) {
	var typ IssuesUpdateMilestoneReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesUpdateMilestoneReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestIssuesUpdateMilestoneReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"Tracking milestone for version 1.0\",\"due_on\":\"2012-10-09T23:39:01Z\",\"state\":\"open\",\"title\":\"v1.0\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ IssuesUpdateMilestoneReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 IssuesUpdateMilestoneReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIssuesUpdateMilestoneReqState_EncodeDecode(t *testing.T) {
	var typ IssuesUpdateMilestoneReqState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesUpdateMilestoneReqState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesUpdateMovedPermanently_EncodeDecode(t *testing.T) {
	var typ IssuesUpdateMovedPermanently
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesUpdateMovedPermanently
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesUpdateNotFound_EncodeDecode(t *testing.T) {
	var typ IssuesUpdateNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesUpdateNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesUpdateReq_EncodeDecode(t *testing.T) {
	var typ IssuesUpdateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesUpdateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestIssuesUpdateReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"assignees\":[\"octocat\"],\"body\":\"I'm having a problem with this.\",\"labels\":[\"bug\"],\"milestone\":1,\"state\":\"open\",\"title\":\"Found a bug\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ IssuesUpdateReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 IssuesUpdateReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestIssuesUpdateReqLabelsItem_EncodeDecode(t *testing.T) {
	var typ IssuesUpdateReqLabelsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesUpdateReqLabelsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesUpdateReqLabelsItem1_EncodeDecode(t *testing.T) {
	var typ IssuesUpdateReqLabelsItem1
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesUpdateReqLabelsItem1
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesUpdateReqMilestone_EncodeDecode(t *testing.T) {
	var typ IssuesUpdateReqMilestone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesUpdateReqMilestone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesUpdateReqState_EncodeDecode(t *testing.T) {
	var typ IssuesUpdateReqState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesUpdateReqState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIssuesUpdateReqTitle_EncodeDecode(t *testing.T) {
	var typ IssuesUpdateReqTitle
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IssuesUpdateReqTitle
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJob_EncodeDecode(t *testing.T) {
	var typ Job
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Job
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestJob_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"check_run_url\":\"https://api.github.com/repos/octo-org/octo-repo/check-runs/399444496\",\"completed_at\":\"2020-01-20T17:44:39Z\",\"conclusion\":\"success\",\"head_sha\":\"f83a356604ae3c5d03e1b46ef4d1ca77d64a90b0\",\"html_url\":\"https://github.com/octo-org/octo-repo/runs/399444496\",\"id\":399444496,\"name\":\"build\",\"node_id\":\"MDEyOldvcmtmbG93IEpvYjM5OTQ0NDQ5Ng==\",\"run_id\":29679449,\"run_url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/runs/29679449\",\"started_at\":\"2020-01-20T17:42:40Z\",\"status\":\"completed\",\"steps\":[{\"completed_at\":\"2020-01-20T09:42:41.000-08:00\",\"conclusion\":\"success\",\"name\":\"Set up job\",\"number\":1,\"started_at\":\"2020-01-20T09:42:40.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:42:45.000-08:00\",\"conclusion\":\"success\",\"name\":\"Run actions/checkout@v2\",\"number\":2,\"started_at\":\"2020-01-20T09:42:41.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:42:45.000-08:00\",\"conclusion\":\"success\",\"name\":\"Set up Ruby\",\"number\":3,\"started_at\":\"2020-01-20T09:42:45.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:42:48.000-08:00\",\"conclusion\":\"success\",\"name\":\"Run actions/cache@v2\",\"number\":4,\"started_at\":\"2020-01-20T09:42:45.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:42:52.000-08:00\",\"conclusion\":\"success\",\"name\":\"Install Bundler\",\"number\":5,\"started_at\":\"2020-01-20T09:42:48.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:42:53.000-08:00\",\"conclusion\":\"success\",\"name\":\"Install Gems\",\"number\":6,\"started_at\":\"2020-01-20T09:42:52.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:42:59.000-08:00\",\"conclusion\":\"success\",\"name\":\"Run Tests\",\"number\":7,\"started_at\":\"2020-01-20T09:42:53.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:44:39.000-08:00\",\"conclusion\":\"success\",\"name\":\"Deploy to Heroku\",\"number\":8,\"started_at\":\"2020-01-20T09:42:59.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:44:39.000-08:00\",\"conclusion\":\"success\",\"name\":\"Post actions/cache@v2\",\"number\":16,\"started_at\":\"2020-01-20T09:44:39.000-08:00\",\"status\":\"completed\"},{\"completed_at\":\"2020-01-20T09:44:39.000-08:00\",\"conclusion\":\"success\",\"name\":\"Complete job\",\"number\":17,\"started_at\":\"2020-01-20T09:44:39.000-08:00\",\"status\":\"completed\"}],\"url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/jobs/399444496\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Job

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Job
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestJobStatus_EncodeDecode(t *testing.T) {
	var typ JobStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JobStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestJobStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"queued\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ JobStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 JobStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestJobStepsItem_EncodeDecode(t *testing.T) {
	var typ JobStepsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JobStepsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJobStepsItemStatus_EncodeDecode(t *testing.T) {
	var typ JobStepsItemStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JobStepsItemStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestJobStepsItemStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"queued\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ JobStepsItemStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 JobStepsItemStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestKey_EncodeDecode(t *testing.T) {
	var typ Key
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Key
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestKey_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2020-06-11T21:31:57Z\",\"id\":2,\"key\":\"2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvv1234\",\"read_only\":false,\"title\":\"ssh-rsa AAAAB3NzaC1yc2EAAA\",\"url\":\"https://api.github.com/user/keys/2\",\"verified\":false}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Key

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Key
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestKeySimple_EncodeDecode(t *testing.T) {
	var typ KeySimple
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 KeySimple
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLabel_EncodeDecode(t *testing.T) {
	var typ Label
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Label
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestLabel_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"color\":\"b01f26\",\"default\":true,\"description\":\"Small bug fix required\",\"id\":208045946,\"name\":\"bug :bug:\",\"node_id\":\"MDU6TGFiZWwyMDgwNDU5NDY=\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/labels/bug%20:bug:\"}"},
		{Input: "{\"color\":\"f29513\",\"default\":true,\"description\":\"Something isn't working\",\"id\":208045946,\"name\":\"bug\",\"node_id\":\"MDU6TGFiZWwyMDgwNDU5NDY=\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/labels/bug\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Label

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Label
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestLabelSearchResultItem_EncodeDecode(t *testing.T) {
	var typ LabelSearchResultItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LabelSearchResultItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLanguage_EncodeDecode(t *testing.T) {
	var typ Language
	typ = make(Language)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Language
	typ2 = make(Language)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestLanguage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"C\":78769,\"Python\":7769}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Language
			typ = make(Language)

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Language
			typ2 = make(Language)
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestLicense_EncodeDecode(t *testing.T) {
	var typ License
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 License
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestLicense_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"\\n\\nThe MIT License (MIT)\\n\\nCopyright (c) [year] [fullname]\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all\\ncopies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\nSOFTWARE.\\n\",\"conditions\":[\"include-copyright\"],\"description\":\"A permissive license that is short and to the point. It lets people do anything with your code with proper attribution and without warranty.\",\"featured\":true,\"html_url\":\"http://choosealicense.com/licenses/mit/\",\"implementation\":\"Create a text file (typically named LICENSE or LICENSE.txt) in the root of your source code and copy the text of the license into the file. Replace [year] with the current year and [fullname] with the name (or names) of the copyright holders.\",\"key\":\"mit\",\"limitations\":[\"no-liability\"],\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"permissions\":[\"commercial-use\",\"modifications\",\"distribution\",\"sublicense\",\"private-use\"],\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ License

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 License
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestLicenseContent_EncodeDecode(t *testing.T) {
	var typ LicenseContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LicenseContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestLicenseContent_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"_links\":{\"git\":\"https://api.github.com/repos/benbalter/gman/git/blobs/401c59dcc4570b954dd6d345e76199e1f4e76266\",\"html\":\"https://github.com/benbalter/gman/blob/master/LICENSE\",\"self\":\"https://api.github.com/repos/benbalter/gman/contents/LICENSE?ref=master\"},\"content\":\"VGhlIE1JVCBMaWNlbnNlIChNSVQpCgpDb3B5cmlnaHQgKGMpIDIwMTMgQmVu\\nIEJhbHRlcgoKUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBv\\nZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZgp0\\naGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmls\\nZXMgKHRoZSAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbgp0aGUgU29mdHdhcmUg\\nd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRh\\ndGlvbiB0aGUgcmlnaHRzIHRvCnVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwg\\ncHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwg\\nY29waWVzIG9mCnRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25z\\nIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywK\\nc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6CgpUaGUgYWJv\\ndmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGlj\\nZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwKY29waWVzIG9yIHN1YnN0YW50\\naWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KClRIRSBTT0ZUV0FSRSBJ\\nUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBL\\nSU5ELCBFWFBSRVNTIE9SCklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJ\\nTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBG\\nSVRORVNTCkZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklO\\nR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUgpDT1BZ\\nUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdF\\nUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIKSU4gQU4gQUNUSU9OIE9G\\nIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBP\\nVVQgT0YgT1IgSU4KQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBU\\nSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4K\\n\",\"download_url\":\"https://raw.githubusercontent.com/benbalter/gman/master/LICENSE?lab=true\",\"encoding\":\"base64\",\"git_url\":\"https://api.github.com/repos/benbalter/gman/git/blobs/401c59dcc4570b954dd6d345e76199e1f4e76266\",\"html_url\":\"https://github.com/benbalter/gman/blob/master/LICENSE\",\"license\":{\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"name\":\"LICENSE\",\"path\":\"LICENSE\",\"sha\":\"401c59dcc4570b954dd6d345e76199e1f4e76266\",\"size\":1077,\"type\":\"file\",\"url\":\"https://api.github.com/repos/benbalter/gman/contents/LICENSE?ref=master\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ LicenseContent

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 LicenseContent
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestLicenseContentLinks_EncodeDecode(t *testing.T) {
	var typ LicenseContentLinks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LicenseContentLinks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLicenseSimple_EncodeDecode(t *testing.T) {
	var typ LicenseSimple
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LicenseSimple
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLicensesGetAllCommonlyUsedOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ LicensesGetAllCommonlyUsedOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LicensesGetAllCommonlyUsedOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLicensesGetForbidden_EncodeDecode(t *testing.T) {
	var typ LicensesGetForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LicensesGetForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLicensesGetNotFound_EncodeDecode(t *testing.T) {
	var typ LicensesGetNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LicensesGetNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLink_EncodeDecode(t *testing.T) {
	var typ Link
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Link
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLinkWithType_EncodeDecode(t *testing.T) {
	var typ LinkWithType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LinkWithType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMarkdownRenderReq_EncodeDecode(t *testing.T) {
	var typ MarkdownRenderReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MarkdownRenderReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMarkdownRenderReqMode_EncodeDecode(t *testing.T) {
	var typ MarkdownRenderReqMode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MarkdownRenderReqMode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestMarkdownRenderReqMode_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"markdown\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ MarkdownRenderReqMode

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 MarkdownRenderReqMode
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestMarketplaceAccount_EncodeDecode(t *testing.T) {
	var typ MarketplaceAccount
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MarketplaceAccount
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMarketplaceListingPlan_EncodeDecode(t *testing.T) {
	var typ MarketplaceListingPlan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MarketplaceListingPlan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMarketplacePurchase_EncodeDecode(t *testing.T) {
	var typ MarketplacePurchase
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MarketplacePurchase
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestMarketplacePurchase_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"email\":\"billing@github.com\",\"id\":4,\"login\":\"github\",\"marketplace_pending_change\":{\"effective_date\":\"2017-11-11T00:00:00Z\",\"id\":77,\"plan\":{\"accounts_url\":\"https://api.github.com/marketplace_listing/plans/1111/accounts\",\"bullets\":[\"Up to 10 private repositories\",\"3 concurrent builds\"],\"description\":\"A professional-grade CI solution\",\"has_free_trial\":true,\"id\":1111,\"monthly_price_in_cents\":699,\"name\":\"Startup\",\"number\":2,\"price_model\":\"flat-rate\",\"state\":\"published\",\"unit_name\":null,\"url\":\"https://api.github.com/marketplace_listing/plans/1111\",\"yearly_price_in_cents\":7870},\"unit_count\":null},\"marketplace_purchase\":{\"billing_cycle\":\"monthly\",\"free_trial_ends_on\":\"2017-11-11T00:00:00Z\",\"next_billing_date\":\"2017-11-11T00:00:00Z\",\"on_free_trial\":true,\"plan\":{\"accounts_url\":\"https://api.github.com/marketplace_listing/plans/1313/accounts\",\"bullets\":[\"Up to 25 private repositories\",\"11 concurrent builds\"],\"description\":\"A professional-grade CI solution\",\"has_free_trial\":true,\"id\":1313,\"monthly_price_in_cents\":1099,\"name\":\"Pro\",\"number\":3,\"price_model\":\"flat-rate\",\"state\":\"published\",\"unit_name\":null,\"url\":\"https://api.github.com/marketplace_listing/plans/1313\",\"yearly_price_in_cents\":11870},\"unit_count\":null,\"updated_at\":\"2017-11-02T01:12:12Z\"},\"organization_billing_email\":\"billing@github.com\",\"type\":\"Organization\",\"url\":\"https://api.github.com/orgs/github\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ MarketplacePurchase

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 MarketplacePurchase
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestMarketplacePurchaseMarketplacePendingChange_EncodeDecode(t *testing.T) {
	var typ MarketplacePurchaseMarketplacePendingChange
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MarketplacePurchaseMarketplacePendingChange
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMarketplacePurchaseMarketplacePurchase_EncodeDecode(t *testing.T) {
	var typ MarketplacePurchaseMarketplacePurchase
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MarketplacePurchaseMarketplacePurchase
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMergedUpstream_EncodeDecode(t *testing.T) {
	var typ MergedUpstream
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MergedUpstream
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestMergedUpstream_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"base_branch\":\"defunkt:main\",\"merge_type\":\"fast-forward\",\"message\":\"Successfully fetched and fast-forwarded from upstream defunkt:main\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ MergedUpstream

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 MergedUpstream
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestMergedUpstreamMergeType_EncodeDecode(t *testing.T) {
	var typ MergedUpstreamMergeType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MergedUpstreamMergeType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMetaRootOK_EncodeDecode(t *testing.T) {
	var typ MetaRootOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MetaRootOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigration_EncodeDecode(t *testing.T) {
	var typ Migration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Migration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestMigration_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2015-07-06T15:33:38-07:00\",\"exclude_attachments\":false,\"exclude_owner_projects\":false,\"exclude_releases\":false,\"guid\":\"0b989ba4-242f-11e5-81e1-c7b6966d2516\",\"id\":79,\"lock_repositories\":true,\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/orgs/github/events\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"github\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/orgs/github/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/orgs/github\"},\"repositories\":[{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":1,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":null,\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":1,\"watchers_count\":80}],\"state\":\"exported\",\"updated_at\":\"2015-07-06T15:33:38-07:00\",\"url\":\"https://api.github.com/orgs/octo-org/migrations/79\"}"},
		{Input: "{\"created_at\":\"2015-07-06T15:33:38-07:00\",\"exclude_attachments\":false,\"exclude_owner_projects\":false,\"exclude_releases\":false,\"guid\":\"0b989ba4-242f-11e5-81e1-c7b6966d2516\",\"id\":79,\"lock_repositories\":true,\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/orgs/github/events\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"github\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/orgs/github/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/orgs/github\"},\"repositories\":[{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":1,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":null,\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":1,\"watchers_count\":80}],\"state\":\"pending\",\"updated_at\":\"2015-07-06T15:33:38-07:00\",\"url\":\"https://api.github.com/orgs/octo-org/migrations/79\"}"},
		{Input: "{\"created_at\":\"2015-07-06T15:33:38-07:00\",\"exclude_attachments\":false,\"exclude_owner_projects\":false,\"exclude_releases\":false,\"guid\":\"0b989ba4-242f-11e5-81e1-c7b6966d2516\",\"id\":79,\"lock_repositories\":true,\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"repositories\":[{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":1,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":null,\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":1,\"watchers_count\":80}],\"state\":\"exported\",\"updated_at\":\"2015-07-06T15:33:38-07:00\",\"url\":\"https://api.github.com/orgs/octo-org/migrations/79\"}"},
		{Input: "{\"created_at\":\"2015-07-06T15:33:38-07:00\",\"exclude_attachments\":false,\"exclude_owner_projects\":false,\"exclude_releases\":false,\"guid\":\"0b989ba4-242f-11e5-81e1-c7b6966d2516\",\"id\":79,\"lock_repositories\":true,\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"repositories\":[{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":1,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":null,\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":1,\"watchers_count\":80}],\"state\":\"pending\",\"updated_at\":\"2015-07-06T15:33:38-07:00\",\"url\":\"https://api.github.com/orgs/octo-org/migrations/79\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Migration

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Migration
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestMigrationsDeleteArchiveForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ MigrationsDeleteArchiveForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsDeleteArchiveForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsDeleteArchiveForAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ MigrationsDeleteArchiveForAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsDeleteArchiveForAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsDeleteArchiveForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ MigrationsDeleteArchiveForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsDeleteArchiveForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsGetArchiveForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ MigrationsGetArchiveForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsGetArchiveForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsGetArchiveForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ MigrationsGetArchiveForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsGetArchiveForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsGetCommitAuthorsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ MigrationsGetCommitAuthorsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsGetCommitAuthorsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsGetStatusForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ MigrationsGetStatusForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsGetStatusForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsGetStatusForAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ MigrationsGetStatusForAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsGetStatusForAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsGetStatusForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ MigrationsGetStatusForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsGetStatusForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsListForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ MigrationsListForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsListForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsListForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ MigrationsListForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsListForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsMapCommitAuthorReq_EncodeDecode(t *testing.T) {
	var typ MigrationsMapCommitAuthorReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsMapCommitAuthorReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestMigrationsMapCommitAuthorReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"email\":\"hubot@github.com\",\"name\":\"Hubot the Robot\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ MigrationsMapCommitAuthorReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 MigrationsMapCommitAuthorReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestMigrationsSetLfsPreferenceReq_EncodeDecode(t *testing.T) {
	var typ MigrationsSetLfsPreferenceReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsSetLfsPreferenceReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestMigrationsSetLfsPreferenceReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"use_lfs\":\"opt_in\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ MigrationsSetLfsPreferenceReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 MigrationsSetLfsPreferenceReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestMigrationsSetLfsPreferenceReqUseLfs_EncodeDecode(t *testing.T) {
	var typ MigrationsSetLfsPreferenceReqUseLfs
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsSetLfsPreferenceReqUseLfs
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsStartForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ MigrationsStartForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsStartForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsStartForAuthenticatedUserReq_EncodeDecode(t *testing.T) {
	var typ MigrationsStartForAuthenticatedUserReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsStartForAuthenticatedUserReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsStartForAuthenticatedUserReqExcludeItem_EncodeDecode(t *testing.T) {
	var typ MigrationsStartForAuthenticatedUserReqExcludeItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsStartForAuthenticatedUserReqExcludeItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestMigrationsStartForAuthenticatedUserReqExcludeItem_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"repositories\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ MigrationsStartForAuthenticatedUserReqExcludeItem

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 MigrationsStartForAuthenticatedUserReqExcludeItem
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestMigrationsStartForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ MigrationsStartForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsStartForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsStartForOrgReq_EncodeDecode(t *testing.T) {
	var typ MigrationsStartForOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsStartForOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestMigrationsStartForOrgReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"lock_repositories\":true,\"repositories\":[\"github/Hello-World\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ MigrationsStartForOrgReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 MigrationsStartForOrgReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestMigrationsStartForOrgReqExcludeItem_EncodeDecode(t *testing.T) {
	var typ MigrationsStartForOrgReqExcludeItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsStartForOrgReqExcludeItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsStartImportReq_EncodeDecode(t *testing.T) {
	var typ MigrationsStartImportReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsStartImportReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestMigrationsStartImportReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"vcs\":\"subversion\",\"vcs_password\":\"secret\",\"vcs_url\":\"http://svn.mycompany.com/svn/myproject\",\"vcs_username\":\"octocat\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ MigrationsStartImportReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 MigrationsStartImportReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestMigrationsStartImportReqVcs_EncodeDecode(t *testing.T) {
	var typ MigrationsStartImportReqVcs
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsStartImportReqVcs
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsUnlockRepoForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ MigrationsUnlockRepoForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsUnlockRepoForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsUnlockRepoForAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ MigrationsUnlockRepoForAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsUnlockRepoForAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsUnlockRepoForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ MigrationsUnlockRepoForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsUnlockRepoForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMigrationsUpdateImportReq_EncodeDecode(t *testing.T) {
	var typ MigrationsUpdateImportReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MigrationsUpdateImportReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestMigrationsUpdateImportReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"vcs_password\":\"secret\",\"vcs_username\":\"octocat\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ MigrationsUpdateImportReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 MigrationsUpdateImportReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestMilestone_EncodeDecode(t *testing.T) {
	var typ Milestone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Milestone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestMilestone_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"closed_at\":\"2013-02-12T13:22:01Z\",\"closed_issues\":8,\"created_at\":\"2011-04-10T20:09:31Z\",\"creator\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"description\":\"Tracking milestone for version 1.0\",\"due_on\":\"2012-10-09T23:39:01Z\",\"html_url\":\"https://github.com/octocat/Hello-World/milestones/v1.0\",\"id\":1002604,\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones/1/labels\",\"node_id\":\"MDk6TWlsZXN0b25lMTAwMjYwNA==\",\"number\":1,\"open_issues\":4,\"state\":\"open\",\"title\":\"v1.0\",\"updated_at\":\"2014-03-03T18:58:10Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/milestones/1\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Milestone

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Milestone
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestMilestoneState_EncodeDecode(t *testing.T) {
	var typ MilestoneState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MilestoneState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestMilestoneState_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"open\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ MilestoneState

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 MilestoneState
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestMinimalRepository_EncodeDecode(t *testing.T) {
	var typ MinimalRepository
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MinimalRepository
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestMinimalRepository_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":false,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"template_repository\":{\"allow_auto_merge\":false,\"allow_forking\":true,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World-Template.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/events\",\"fork\":false,\"forks\":9,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/forks\",\"full_name\":\"octocat/Hello-World-Template\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World-Template.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World-Template\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World-Template\",\"name\":\"Hello-World-Template\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/notifications{?since,all,participating}\",\"open_issues\":0,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World-Template.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World-Template\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World-Template\",\"visibility\":\"public\",\"watchers\":80,\"watchers_count\":80},\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers_count\":80}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ MinimalRepository

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 MinimalRepository
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestMinimalRepositoryLicense_EncodeDecode(t *testing.T) {
	var typ MinimalRepositoryLicense
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MinimalRepositoryLicense
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMinimalRepositoryPermissions_EncodeDecode(t *testing.T) {
	var typ MinimalRepositoryPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MinimalRepositoryPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableCodeOfConductSimple_EncodeDecode(t *testing.T) {
	var typ NullableCodeOfConductSimple
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableCodeOfConductSimple
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableCommunityHealthFile_EncodeDecode(t *testing.T) {
	var typ NullableCommunityHealthFile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableCommunityHealthFile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableGitUser_EncodeDecode(t *testing.T) {
	var typ NullableGitUser
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableGitUser
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableIntegration_EncodeDecode(t *testing.T) {
	var typ NullableIntegration
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableIntegration
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableIntegrationPermissions_EncodeDecode(t *testing.T) {
	var typ NullableIntegrationPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableIntegrationPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNullableIntegrationPermissions_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"deployments\":\"write\",\"issues\":\"read\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NullableIntegrationPermissions

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NullableIntegrationPermissions
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNullableIntegrationPermissionsAdditional_EncodeDecode(t *testing.T) {
	var typ NullableIntegrationPermissionsAdditional
	typ = make(NullableIntegrationPermissionsAdditional)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableIntegrationPermissionsAdditional
	typ2 = make(NullableIntegrationPermissionsAdditional)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableLicenseSimple_EncodeDecode(t *testing.T) {
	var typ NullableLicenseSimple
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableLicenseSimple
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableMilestone_EncodeDecode(t *testing.T) {
	var typ NullableMilestone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableMilestone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableMilestoneState_EncodeDecode(t *testing.T) {
	var typ NullableMilestoneState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableMilestoneState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestNullableMilestoneState_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"open\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ NullableMilestoneState

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 NullableMilestoneState
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestNullableMinimalRepository_EncodeDecode(t *testing.T) {
	var typ NullableMinimalRepository
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableMinimalRepository
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableMinimalRepositoryLicense_EncodeDecode(t *testing.T) {
	var typ NullableMinimalRepositoryLicense
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableMinimalRepositoryLicense
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableMinimalRepositoryPermissions_EncodeDecode(t *testing.T) {
	var typ NullableMinimalRepositoryPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableMinimalRepositoryPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableRepository_EncodeDecode(t *testing.T) {
	var typ NullableRepository
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableRepository
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableRepositoryPermissions_EncodeDecode(t *testing.T) {
	var typ NullableRepositoryPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableRepositoryPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableRepositoryTemplateRepository_EncodeDecode(t *testing.T) {
	var typ NullableRepositoryTemplateRepository
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableRepositoryTemplateRepository
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableRepositoryTemplateRepositoryOwner_EncodeDecode(t *testing.T) {
	var typ NullableRepositoryTemplateRepositoryOwner
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableRepositoryTemplateRepositoryOwner
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableRepositoryTemplateRepositoryPermissions_EncodeDecode(t *testing.T) {
	var typ NullableRepositoryTemplateRepositoryPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableRepositoryTemplateRepositoryPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableScopedInstallation_EncodeDecode(t *testing.T) {
	var typ NullableScopedInstallation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableScopedInstallation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableScopedInstallationRepositorySelection_EncodeDecode(t *testing.T) {
	var typ NullableScopedInstallationRepositorySelection
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableScopedInstallationRepositorySelection
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableSimpleCommit_EncodeDecode(t *testing.T) {
	var typ NullableSimpleCommit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableSimpleCommit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableSimpleCommitAuthor_EncodeDecode(t *testing.T) {
	var typ NullableSimpleCommitAuthor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableSimpleCommitAuthor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableSimpleCommitCommitter_EncodeDecode(t *testing.T) {
	var typ NullableSimpleCommitCommitter
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableSimpleCommitCommitter
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableSimpleUser_EncodeDecode(t *testing.T) {
	var typ NullableSimpleUser
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableSimpleUser
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNullableTeamSimple_EncodeDecode(t *testing.T) {
	var typ NullableTeamSimple
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NullableTeamSimple
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsCreateAuthorizationForbidden_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsCreateAuthorizationForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsCreateAuthorizationForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsCreateAuthorizationGone_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsCreateAuthorizationGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsCreateAuthorizationGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsCreateAuthorizationReq_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsCreateAuthorizationReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsCreateAuthorizationReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsCreateAuthorizationUnauthorized_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsCreateAuthorizationUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsCreateAuthorizationUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsDeleteAuthorizationForbidden_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsDeleteAuthorizationForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsDeleteAuthorizationForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsDeleteAuthorizationUnauthorized_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsDeleteAuthorizationUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsDeleteAuthorizationUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsDeleteGrantForbidden_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsDeleteGrantForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsDeleteGrantForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsDeleteGrantUnauthorized_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsDeleteGrantUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsDeleteGrantUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsGetAuthorizationForbidden_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsGetAuthorizationForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsGetAuthorizationForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsGetAuthorizationUnauthorized_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsGetAuthorizationUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsGetAuthorizationUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsGetGrantForbidden_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsGetGrantForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsGetGrantForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsGetGrantUnauthorized_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsGetGrantUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsGetGrantUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsGetOrCreateAuthorizationForAppForbidden_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsGetOrCreateAuthorizationForAppForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsGetOrCreateAuthorizationForAppForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsGetOrCreateAuthorizationForAppReq_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsGetOrCreateAuthorizationForAppReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsGetOrCreateAuthorizationForAppReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsGetOrCreateAuthorizationForAppUnauthorized_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsGetOrCreateAuthorizationForAppUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsGetOrCreateAuthorizationForAppUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsListAuthorizationsForbidden_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsListAuthorizationsForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsListAuthorizationsForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsListAuthorizationsNotFound_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsListAuthorizationsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsListAuthorizationsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsListAuthorizationsUnauthorized_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsListAuthorizationsUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsListAuthorizationsUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsListGrantsForbidden_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsListGrantsForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsListGrantsForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsListGrantsNotFound_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsListGrantsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsListGrantsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsListGrantsUnauthorized_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsListGrantsUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsListGrantsUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuthAuthorizationsUpdateAuthorizationReq_EncodeDecode(t *testing.T) {
	var typ OAuthAuthorizationsUpdateAuthorizationReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuthAuthorizationsUpdateAuthorizationReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgHook_EncodeDecode(t *testing.T) {
	var typ OrgHook
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgHook
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrgHook_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"active\":true,\"config\":{\"content_type\":\"json\",\"url\":\"http://example.com\"},\"created_at\":\"2011-09-06T17:26:27Z\",\"deliveries_url\":\"https://api.github.com/orgs/octocat/hooks/1/deliveries\",\"events\":[\"push\",\"pull_request\"],\"id\":1,\"name\":\"web\",\"ping_url\":\"https://api.github.com/orgs/octocat/hooks/1/pings\",\"type\":\"Organization\",\"updated_at\":\"2011-09-06T20:39:23Z\",\"url\":\"https://api.github.com/orgs/octocat/hooks/1\"}"},
		{Input: "{\"active\":true,\"config\":{\"content_type\":\"json\",\"url\":\"http://example.com\"},\"created_at\":\"2011-09-06T17:26:27Z\",\"deliveries_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks/12345678/deliveries\",\"events\":[\"pull_request\"],\"id\":1,\"name\":\"web\",\"ping_url\":\"https://api.github.com/orgs/octocat/hooks/1/pings\",\"type\":\"Organization\",\"updated_at\":\"2011-09-06T20:39:23Z\",\"url\":\"https://api.github.com/orgs/octocat/hooks/1\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrgHook

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrgHook
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrgHookConfig_EncodeDecode(t *testing.T) {
	var typ OrgHookConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgHookConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgMembership_EncodeDecode(t *testing.T) {
	var typ OrgMembership
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgMembership
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrgMembership_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"organization\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"description\":\"A great organization\",\"events_url\":\"https://api.github.com/orgs/github/events\",\"hooks_url\":\"https://api.github.com/orgs/github/hooks\",\"id\":1,\"issues_url\":\"https://api.github.com/orgs/github/issues\",\"login\":\"github\",\"members_url\":\"https://api.github.com/orgs/github/members{/member}\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"public_members_url\":\"https://api.github.com/orgs/github/public_members{/member}\",\"repos_url\":\"https://api.github.com/orgs/github/repos\",\"url\":\"https://api.github.com/orgs/github\"},\"organization_url\":\"https://api.github.com/orgs/invitocat\",\"role\":\"admin\",\"state\":\"pending\",\"url\":\"https://api.github.com/orgs/invitocat/memberships/defunkt\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
		{Input: "{\"organization\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"description\":\"A great organization\",\"events_url\":\"https://api.github.com/orgs/github/events\",\"hooks_url\":\"https://api.github.com/orgs/github/hooks\",\"id\":1,\"issues_url\":\"https://api.github.com/orgs/github/issues\",\"login\":\"github\",\"members_url\":\"https://api.github.com/orgs/github/members{/member}\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"public_members_url\":\"https://api.github.com/orgs/github/public_members{/member}\",\"repos_url\":\"https://api.github.com/orgs/github/repos\",\"url\":\"https://api.github.com/orgs/github\"},\"organization_url\":\"https://api.github.com/orgs/octocat\",\"role\":\"admin\",\"state\":\"active\",\"url\":\"https://api.github.com/orgs/octocat/memberships/defunkt\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrgMembership

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrgMembership
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrgMembershipPermissions_EncodeDecode(t *testing.T) {
	var typ OrgMembershipPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgMembershipPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgMembershipRole_EncodeDecode(t *testing.T) {
	var typ OrgMembershipRole
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgMembershipRole
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrgMembershipRole_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"admin\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrgMembershipRole

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrgMembershipRole
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrgMembershipState_EncodeDecode(t *testing.T) {
	var typ OrgMembershipState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgMembershipState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrgMembershipState_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"active\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrgMembershipState

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrgMembershipState
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrganizationActionsSecret_EncodeDecode(t *testing.T) {
	var typ OrganizationActionsSecret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationActionsSecret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrganizationActionsSecret_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2019-08-10T14:59:22Z\",\"name\":\"GH_TOKEN\",\"selected_repositories_url\":\"https://api.github.com/orgs/octo-org/actions/secrets/SUPER_SECRET/repositories\",\"updated_at\":\"2020-01-10T14:59:22Z\",\"visibility\":\"selected\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrganizationActionsSecret

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrganizationActionsSecret
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrganizationActionsSecretVisibility_EncodeDecode(t *testing.T) {
	var typ OrganizationActionsSecretVisibility
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationActionsSecretVisibility
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrganizationFull_EncodeDecode(t *testing.T) {
	var typ OrganizationFull
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationFull
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrganizationFull_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"billing_email\":\"mona@github.com\",\"blog\":\"https://github.com/blog\",\"collaborators\":8,\"company\":\"GitHub\",\"created_at\":\"2008-01-14T04:33:35Z\",\"default_repository_permission\":\"read\",\"description\":\"A great organization\",\"disk_usage\":10000,\"email\":\"octocat@github.com\",\"events_url\":\"https://api.github.com/orgs/github/events\",\"followers\":20,\"following\":0,\"has_organization_projects\":true,\"has_repository_projects\":true,\"hooks_url\":\"https://api.github.com/orgs/github/hooks\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"is_verified\":true,\"issues_url\":\"https://api.github.com/orgs/github/issues\",\"location\":\"San Francisco\",\"login\":\"github\",\"members_allowed_repository_creation_type\":\"all\",\"members_can_create_internal_repositories\":false,\"members_can_create_pages\":true,\"members_can_create_private_pages\":true,\"members_can_create_private_repositories\":false,\"members_can_create_public_pages\":true,\"members_can_create_public_repositories\":false,\"members_can_create_repositories\":true,\"members_url\":\"https://api.github.com/orgs/github/members{/member}\",\"name\":\"github\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"owned_private_repos\":100,\"plan\":{\"name\":\"Medium\",\"private_repos\":20,\"space\":400},\"private_gists\":81,\"public_gists\":1,\"public_members_url\":\"https://api.github.com/orgs/github/public_members{/member}\",\"public_repos\":2,\"repos_url\":\"https://api.github.com/orgs/github/repos\",\"total_private_repos\":100,\"twitter_username\":\"github\",\"two_factor_requirement_enabled\":true,\"type\":\"Organization\",\"updated_at\":\"2014-03-03T18:58:10Z\",\"url\":\"https://api.github.com/orgs/github\"}"},
		{Input: "{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"billing_email\":\"mona@github.com\",\"blog\":\"https://github.com/blog\",\"collaborators\":8,\"company\":\"GitHub\",\"created_at\":\"2008-01-14T04:33:35Z\",\"default_repository_permission\":\"read\",\"description\":\"A great organization\",\"disk_usage\":10000,\"email\":\"octocat@github.com\",\"events_url\":\"https://api.github.com/orgs/github/events\",\"followers\":20,\"following\":0,\"has_organization_projects\":true,\"has_repository_projects\":true,\"hooks_url\":\"https://api.github.com/orgs/github/hooks\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"is_verified\":true,\"issues_url\":\"https://api.github.com/orgs/github/issues\",\"location\":\"San Francisco\",\"login\":\"github\",\"members_allowed_repository_creation_type\":\"all\",\"members_can_create_internal_repositories\":false,\"members_can_create_pages\":true,\"members_can_create_private_repositories\":false,\"members_can_create_public_repositories\":false,\"members_can_create_repositories\":true,\"members_url\":\"https://api.github.com/orgs/github/members{/member}\",\"name\":\"github\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"owned_private_repos\":100,\"plan\":{\"filled_seats\":4,\"name\":\"Medium\",\"private_repos\":20,\"seats\":5,\"space\":400},\"private_gists\":81,\"public_gists\":1,\"public_members_url\":\"https://api.github.com/orgs/github/public_members{/member}\",\"public_repos\":2,\"repos_url\":\"https://api.github.com/orgs/github/repos\",\"total_private_repos\":100,\"twitter_username\":\"github\",\"two_factor_requirement_enabled\":true,\"type\":\"Organization\",\"updated_at\":\"2014-03-03T18:58:10Z\",\"url\":\"https://api.github.com/orgs/github\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrganizationFull

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrganizationFull
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrganizationFullPlan_EncodeDecode(t *testing.T) {
	var typ OrganizationFullPlan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationFullPlan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrganizationInvitation_EncodeDecode(t *testing.T) {
	var typ OrganizationInvitation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationInvitation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrganizationInvitation_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2016-11-30T06:46:10-08:00\",\"email\":\"octocat@github.com\",\"id\":1,\"invitation_teams_url\":\"https://api.github.com/organizations/2/invitations/1/teams\",\"inviter\":{\"avatar_url\":\"https://github.com/images/error/other_user_happy.gif\",\"events_url\":\"https://api.github.com/users/other_user/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/other_user/followers\",\"following_url\":\"https://api.github.com/users/other_user/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/other_user/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/other_user\",\"id\":1,\"login\":\"other_user\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/other_user/orgs\",\"received_events_url\":\"https://api.github.com/users/other_user/received_events\",\"repos_url\":\"https://api.github.com/users/other_user/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/other_user/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/other_user/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/other_user\"},\"login\":\"monalisa\",\"node_id\":\"MDQ6VXNlcjE=\",\"role\":\"direct_member\",\"team_count\":2}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrganizationInvitation

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrganizationInvitation
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrganizationSecretScanningAlert_EncodeDecode(t *testing.T) {
	var typ OrganizationSecretScanningAlert
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationSecretScanningAlert
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrganizationSimple_EncodeDecode(t *testing.T) {
	var typ OrganizationSimple
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationSimple
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsConvertMemberToOutsideCollaboratorAccepted_EncodeDecode(t *testing.T) {
	var typ OrgsConvertMemberToOutsideCollaboratorAccepted
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsConvertMemberToOutsideCollaboratorAccepted
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsCreateInvitationReq_EncodeDecode(t *testing.T) {
	var typ OrgsCreateInvitationReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsCreateInvitationReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrgsCreateInvitationReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"email\":\"octocat@github.com\",\"role\":\"direct_member\",\"team_ids\":[12,26]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrgsCreateInvitationReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrgsCreateInvitationReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrgsCreateInvitationReqRole_EncodeDecode(t *testing.T) {
	var typ OrgsCreateInvitationReqRole
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsCreateInvitationReqRole
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsCreateWebhookReq_EncodeDecode(t *testing.T) {
	var typ OrgsCreateWebhookReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsCreateWebhookReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrgsCreateWebhookReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"active\":true,\"config\":{\"content_type\":\"json\",\"url\":\"http://example.com/webhook\"},\"events\":[\"push\",\"pull_request\"],\"name\":\"web\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrgsCreateWebhookReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrgsCreateWebhookReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrgsCreateWebhookReqConfig_EncodeDecode(t *testing.T) {
	var typ OrgsCreateWebhookReqConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsCreateWebhookReqConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsGetMembershipForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ OrgsGetMembershipForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsGetMembershipForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsGetMembershipForAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ OrgsGetMembershipForAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsGetMembershipForAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsGetMembershipForUserForbidden_EncodeDecode(t *testing.T) {
	var typ OrgsGetMembershipForUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsGetMembershipForUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsGetMembershipForUserNotFound_EncodeDecode(t *testing.T) {
	var typ OrgsGetMembershipForUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsGetMembershipForUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsListBlockedUsersOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ OrgsListBlockedUsersOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsListBlockedUsersOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsListForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ OrgsListForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsListForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsListForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ OrgsListForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsListForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsListMembershipsForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ OrgsListMembershipsForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsListMembershipsForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsListMembershipsForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ OrgsListMembershipsForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsListMembershipsForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsListWebhookDeliveriesOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ OrgsListWebhookDeliveriesOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsListWebhookDeliveriesOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsRemoveMembershipForUserForbidden_EncodeDecode(t *testing.T) {
	var typ OrgsRemoveMembershipForUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsRemoveMembershipForUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsRemoveMembershipForUserNotFound_EncodeDecode(t *testing.T) {
	var typ OrgsRemoveMembershipForUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsRemoveMembershipForUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsRemoveOutsideCollaboratorUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ OrgsRemoveOutsideCollaboratorUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsRemoveOutsideCollaboratorUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrgsRemoveOutsideCollaboratorUnprocessableEntity_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"documentation_url\":\"https://docs.github.com/rest/reference/orgs#remove-outside-collaborator\",\"message\":\"You cannot specify an organization member to remove as an outside collaborator.\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrgsRemoveOutsideCollaboratorUnprocessableEntity

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrgsRemoveOutsideCollaboratorUnprocessableEntity
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrgsSetMembershipForUserReq_EncodeDecode(t *testing.T) {
	var typ OrgsSetMembershipForUserReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsSetMembershipForUserReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsSetMembershipForUserReqRole_EncodeDecode(t *testing.T) {
	var typ OrgsSetMembershipForUserReqRole
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsSetMembershipForUserReqRole
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsUpdateMembershipForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ OrgsUpdateMembershipForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsUpdateMembershipForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsUpdateMembershipForAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ OrgsUpdateMembershipForAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsUpdateMembershipForAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsUpdateMembershipForAuthenticatedUserReq_EncodeDecode(t *testing.T) {
	var typ OrgsUpdateMembershipForAuthenticatedUserReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsUpdateMembershipForAuthenticatedUserReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrgsUpdateMembershipForAuthenticatedUserReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"state\":\"active\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrgsUpdateMembershipForAuthenticatedUserReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrgsUpdateMembershipForAuthenticatedUserReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrgsUpdateMembershipForAuthenticatedUserReqState_EncodeDecode(t *testing.T) {
	var typ OrgsUpdateMembershipForAuthenticatedUserReqState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsUpdateMembershipForAuthenticatedUserReqState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrgsUpdateWebhookConfigForOrgReq_EncodeDecode(t *testing.T) {
	var typ OrgsUpdateWebhookConfigForOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsUpdateWebhookConfigForOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrgsUpdateWebhookConfigForOrgReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content_type\":\"json\",\"insecure_ssl\":\"0\",\"secret\":\"********\",\"url\":\"https://example.com/webhook\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrgsUpdateWebhookConfigForOrgReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrgsUpdateWebhookConfigForOrgReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrgsUpdateWebhookReq_EncodeDecode(t *testing.T) {
	var typ OrgsUpdateWebhookReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsUpdateWebhookReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrgsUpdateWebhookReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"active\":true,\"events\":[\"pull_request\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrgsUpdateWebhookReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrgsUpdateWebhookReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrgsUpdateWebhookReqConfig_EncodeDecode(t *testing.T) {
	var typ OrgsUpdateWebhookReqConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrgsUpdateWebhookReqConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackage_EncodeDecode(t *testing.T) {
	var typ Package
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Package
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPackage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2019-10-20T14:17:14Z\",\"html_url\":\"https://github.com/octocat/octo-name-repo/packages/40201\",\"id\":40201,\"name\":\"octo-name\",\"owner\":{\"avatar_url\":\"https://avatars.githubusercontent.com/u/209477?v=4\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":209477,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjIwOTQ3Nw==\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"package_type\":\"rubygems\",\"repository\":{\"archive_url\":\"https://api.github.com/repos/octocat/octo-name-repo/{archive_format}{/ref}\",\"assignees_url\":\"https://api.github.com/repos/octocat/octo-name-repo/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/octo-name-repo/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/octo-name-repo/branches{/branch}\",\"collaborators_url\":\"https://api.github.com/repos/octocat/octo-name-repo/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/octo-name-repo/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/octo-name-repo/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/octo-name-repo/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/octo-name-repo/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/octo-name-repo/contributors\",\"deployments_url\":\"https://api.github.com/repos/octocat/octo-name-repo/deployments\",\"description\":\"Project for octocats\",\"downloads_url\":\"https://api.github.com/repos/octocat/octo-name-repo/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/octo-name-repo/events\",\"fork\":false,\"forks_url\":\"https://api.github.com/repos/octocat/octo-name-repo/forks\",\"full_name\":\"octocat/octo-name-repo\",\"git_commits_url\":\"https://api.github.com/repos/octocat/octo-name-repo/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/octo-name-repo/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/octo-name-repo/git/tags{/sha}\",\"hooks_url\":\"https://api.github.com/repos/octocat/octo-name-repo/hooks\",\"html_url\":\"https://github.com/octocat/octo-name-repo\",\"id\":216219492,\"issue_comment_url\":\"https://api.github.com/repos/octocat/octo-name-repo/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/octo-name-repo/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/octo-name-repo/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/octo-name-repo/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/octo-name-repo/labels{/name}\",\"languages_url\":\"https://api.github.com/repos/octocat/octo-name-repo/languages\",\"merges_url\":\"https://api.github.com/repos/octocat/octo-name-repo/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/octo-name-repo/milestones{/number}\",\"name\":\"octo-name-repo\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkyMTYyMTk0OTI=\",\"notifications_url\":\"https://api.github.com/repos/octocat/octo-name-repo/notifications{?since,all,participating}\",\"owner\":{\"avatar_url\":\"https://avatars.githubusercontent.com/u/209477?v=4\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":209477,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjIwOTQ3Nw==\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/octo-name-repo/pulls{/number}\",\"releases_url\":\"https://api.github.com/repos/octocat/octo-name-repo/releases{/id}\",\"stargazers_url\":\"https://api.github.com/repos/octocat/octo-name-repo/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/octo-name-repo/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/octocat/octo-name-repo/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/octo-name-repo/subscription\",\"tags_url\":\"https://api.github.com/repos/octocat/octo-name-repo/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/octo-name-repo/teams\",\"trees_url\":\"https://api.github.com/repos/octocat/octo-name-repo/git/trees{/sha}\",\"url\":\"https://api.github.com/repos/octocat/octo-name-repo\"},\"updated_at\":\"2019-10-20T14:17:14Z\",\"url\":\"https://api.github.com/users/octocat/packages/rubygems/octo-name\",\"version_count\":3,\"visibility\":\"public\"}"},
		{Input: "{\"created_at\":\"2020-05-19T22:19:11Z\",\"html_url\":\"https://github.com/orgs/github/packages/container/package/hello_docker\",\"id\":197,\"name\":\"hello_docker\",\"owner\":{\"avatar_url\":\"https://avatars.githubusercontent.com/u/9919?v=4\",\"events_url\":\"https://api.github.com/users/github/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/github/followers\",\"following_url\":\"https://api.github.com/users/github/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/github/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/github\",\"id\":9919,\"login\":\"github\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjk5MTk=\",\"organizations_url\":\"https://api.github.com/users/github/orgs\",\"received_events_url\":\"https://api.github.com/users/github/received_events\",\"repos_url\":\"https://api.github.com/users/github/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/github/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/github/subscriptions\",\"type\":\"Organization\",\"url\":\"https://api.github.com/users/github\"},\"package_type\":\"container\",\"updated_at\":\"2020-05-19T22:19:11Z\",\"url\":\"https://api.github.com/orgs/github/packages/container/hello_docker\",\"version_count\":1,\"visibility\":\"private\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Package

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Package
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPackagePackageType_EncodeDecode(t *testing.T) {
	var typ PackagePackageType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagePackageType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPackagePackageType_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"docker\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PackagePackageType

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PackagePackageType
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPackageVersion_EncodeDecode(t *testing.T) {
	var typ PackageVersion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackageVersion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPackageVersion_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2019-12-01T20:49:29Z\",\"description\":\"Octo-name client for Ruby\",\"html_url\":\"https://github.com/octocat/octo-name-repo/packages/40201?version=0.2.0\",\"id\":387039,\"license\":\"MIT\",\"metadata\":{\"package_type\":\"rubygems\"},\"name\":\"0.2.0\",\"package_html_url\":\"https://github.com/octocat/octo-name-repo/packages/40201\",\"updated_at\":\"2019-12-01T20:49:30Z\",\"url\":\"https://api.github.com/users/octocat/packages/rubygems/octo-name/versions/387039\"}"},
		{Input: "{\"created_at\":\"2020-05-15T03:46:45Z\",\"html_url\":\"https://github.com/users/octocat/packages/container/hello_docker/214\",\"id\":214,\"metadata\":{\"container\":{\"tags\":[\"1.13.6\"]},\"package_type\":\"container\"},\"name\":\"sha256:3561f0cff06caccddb99c93bd26e712fcc56a811de0f8ea7a17bb865f30b176a\",\"package_html_url\":\"https://github.com/users/octocat/packages/container/package/hello_docker\",\"updated_at\":\"2020-05-15T03:46:45Z\",\"url\":\"https://api.github.com/users/octocat/packages/container/hello_docker/versions/214\"}"},
		{Input: "{\"created_at\":\"2020-05-19T22:19:11Z\",\"html_url\":\"https://github.com/orgs/github/packages/container/hello_docker/836\",\"id\":836,\"metadata\":{\"container\":{\"tags\":[\"latest\"]},\"package_type\":\"container\"},\"name\":\"sha256:b3d3e366b55f9a54599220198b3db5da8f53592acbbb7dc7e4e9878762fc5344\",\"package_html_url\":\"https://github.com/orgs/github/packages/container/package/hello_docker\",\"updated_at\":\"2020-05-19T22:19:11Z\",\"url\":\"https://api.github.com/orgs/github/packages/container/hello_docker/versions/836\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PackageVersion

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PackageVersion
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPackageVersionMetadata_EncodeDecode(t *testing.T) {
	var typ PackageVersionMetadata
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackageVersionMetadata
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackageVersionMetadataContainer_EncodeDecode(t *testing.T) {
	var typ PackageVersionMetadataContainer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackageVersionMetadataContainer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackageVersionMetadataDocker_EncodeDecode(t *testing.T) {
	var typ PackageVersionMetadataDocker
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackageVersionMetadataDocker
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackageVersionMetadataPackageType_EncodeDecode(t *testing.T) {
	var typ PackageVersionMetadataPackageType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackageVersionMetadataPackageType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPackageVersionMetadataPackageType_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"docker\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PackageVersionMetadataPackageType

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PackageVersionMetadataPackageType
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPackageVisibility_EncodeDecode(t *testing.T) {
	var typ PackageVisibility
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackageVisibility
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPackageVisibility_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"private\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PackageVisibility

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PackageVisibility
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPackagesBillingUsage_EncodeDecode(t *testing.T) {
	var typ PackagesBillingUsage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesBillingUsage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPackagesBillingUsage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"included_gigabytes_bandwidth\":10,\"total_gigabytes_bandwidth_used\":50,\"total_paid_gigabytes_bandwidth_used\":40}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PackagesBillingUsage

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PackagesBillingUsage
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPackagesDeletePackageForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageForAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageForAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageForAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageForOrgForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageForOrgForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageForOrgForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageForOrgNotFound_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageForOrgNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageForOrgNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageForOrgUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageForOrgUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageForOrgUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageForUserForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageForUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageForUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageForUserNotFound_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageForUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageForUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageForUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageForUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageForUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageVersionForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageVersionForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageVersionForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageVersionForAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageVersionForAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageVersionForAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageVersionForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageVersionForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageVersionForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageVersionForOrgForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageVersionForOrgForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageVersionForOrgForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageVersionForOrgNotFound_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageVersionForOrgNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageVersionForOrgNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageVersionForOrgUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageVersionForOrgUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageVersionForOrgUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageVersionForUserForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageVersionForUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageVersionForUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageVersionForUserNotFound_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageVersionForUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageVersionForUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesDeletePackageVersionForUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesDeletePackageVersionForUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesDeletePackageVersionForUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesGetAllPackageVersionsForPackageOwnedByOrgForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesGetAllPackageVersionsForPackageOwnedByOrgForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesGetAllPackageVersionsForPackageOwnedByOrgForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesGetAllPackageVersionsForPackageOwnedByOrgNotFound_EncodeDecode(t *testing.T) {
	var typ PackagesGetAllPackageVersionsForPackageOwnedByOrgNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesGetAllPackageVersionsForPackageOwnedByOrgNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesGetAllPackageVersionsForPackageOwnedByOrgUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesGetAllPackageVersionsForPackageOwnedByOrgUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesGetAllPackageVersionsForPackageOwnedByOrgUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesGetAllPackageVersionsForPackageOwnedByUserForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesGetAllPackageVersionsForPackageOwnedByUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesGetAllPackageVersionsForPackageOwnedByUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesGetAllPackageVersionsForPackageOwnedByUserNotFound_EncodeDecode(t *testing.T) {
	var typ PackagesGetAllPackageVersionsForPackageOwnedByUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesGetAllPackageVersionsForPackageOwnedByUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesGetAllPackageVersionsForPackageOwnedByUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesGetAllPackageVersionsForPackageOwnedByUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesGetAllPackageVersionsForPackageOwnedByUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesListPackagesForOrganizationForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesListPackagesForOrganizationForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesListPackagesForOrganizationForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesListPackagesForOrganizationOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ PackagesListPackagesForOrganizationOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesListPackagesForOrganizationOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesListPackagesForOrganizationUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesListPackagesForOrganizationUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesListPackagesForOrganizationUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesListPackagesForUserForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesListPackagesForUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesListPackagesForUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesListPackagesForUserOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ PackagesListPackagesForUserOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesListPackagesForUserOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesListPackagesForUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesListPackagesForUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesListPackagesForUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageForAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageForAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageForAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageForOrgForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageForOrgForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageForOrgForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageForOrgNotFound_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageForOrgNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageForOrgNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageForOrgUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageForOrgUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageForOrgUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageForUserForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageForUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageForUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageForUserNotFound_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageForUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageForUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageForUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageForUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageForUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageVersionForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageVersionForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageVersionForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageVersionForAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageVersionForAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageVersionForAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageVersionForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageVersionForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageVersionForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageVersionForOrgForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageVersionForOrgForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageVersionForOrgForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageVersionForOrgNotFound_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageVersionForOrgNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageVersionForOrgNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageVersionForOrgUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageVersionForOrgUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageVersionForOrgUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageVersionForUserForbidden_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageVersionForUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageVersionForUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageVersionForUserNotFound_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageVersionForUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageVersionForUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPackagesRestorePackageVersionForUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ PackagesRestorePackageVersionForUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PackagesRestorePackageVersionForUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPage_EncodeDecode(t *testing.T) {
	var typ Page
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Page
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"cname\":\"developer.github.com\",\"custom_404\":false,\"html_url\":\"https://developer.github.com\",\"https_certificate\":{\"description\":\"Certificate is approved\",\"domains\":[\"developer.github.com\"],\"expires_at\":\"2021-05-22\",\"state\":\"approved\"},\"https_enforced\":true,\"public\":true,\"source\":{\"branch\":\"master\",\"path\":\"/\"},\"status\":\"built\",\"url\":\"https://api.github.com/repos/github/developer.github.com/pages\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Page

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Page
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPageBuild_EncodeDecode(t *testing.T) {
	var typ PageBuild
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PageBuild
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPageBuild_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"commit\":\"351391cdcb88ffae71ec3028c91f375a8036a26b\",\"created_at\":\"2014-02-10T19:00:49Z\",\"duration\":2104,\"error\":{\"message\":null},\"pusher\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"status\":\"built\",\"updated_at\":\"2014-02-10T19:00:51Z\",\"url\":\"https://api.github.com/repos/github/developer.github.com/pages/builds/5472601\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PageBuild

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PageBuild
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPageBuildError_EncodeDecode(t *testing.T) {
	var typ PageBuildError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PageBuildError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPageBuildStatus_EncodeDecode(t *testing.T) {
	var typ PageBuildStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PageBuildStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPageBuildStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"status\":\"queued\",\"url\":\"https://api.github.com/repos/github/developer.github.com/pages/builds/latest\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PageBuildStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PageBuildStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPageProtectedDomainState_EncodeDecode(t *testing.T) {
	var typ PageProtectedDomainState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PageProtectedDomainState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPageProtectedDomainState_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"pending\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PageProtectedDomainState

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PageProtectedDomainState
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPageStatus_EncodeDecode(t *testing.T) {
	var typ PageStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PageStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPageStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"built\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PageStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PageStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPagesHTTPSCertificate_EncodeDecode(t *testing.T) {
	var typ PagesHTTPSCertificate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PagesHTTPSCertificate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPagesHTTPSCertificateState_EncodeDecode(t *testing.T) {
	var typ PagesHTTPSCertificateState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PagesHTTPSCertificateState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPagesHTTPSCertificateState_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"approved\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PagesHTTPSCertificateState

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PagesHTTPSCertificateState
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPagesHealthCheck_EncodeDecode(t *testing.T) {
	var typ PagesHealthCheck
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PagesHealthCheck
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPagesHealthCheck_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"alt_domain\":{\"caa_error\":null,\"dns_resolves\":true,\"enforces_https\":true,\"has_cname_record\":false,\"has_mx_records_present\":false,\"host\":\"www.example.com\",\"https_error\":null,\"is_a_record\":true,\"is_apex_domain\":true,\"is_cloudflare_ip\":false,\"is_cname_to_fastly\":false,\"is_cname_to_github_user_domain\":false,\"is_cname_to_pages_dot_github_dot_com\":false,\"is_fastly_ip\":false,\"is_https_eligible\":true,\"is_non_github_pages_ip_present\":false,\"is_old_ip_address\":false,\"is_pages_domain\":false,\"is_pointed_to_github_pages_ip\":true,\"is_proxied\":false,\"is_served_by_pages\":true,\"is_valid\":true,\"is_valid_domain\":true,\"nameservers\":\"default\",\"reason\":null,\"responds_to_https\":true,\"should_be_a_record\":true,\"uri\":\"http://www.example.com/\"},\"domain\":{\"caa_error\":null,\"dns_resolves\":true,\"enforces_https\":true,\"has_cname_record\":false,\"has_mx_records_present\":false,\"host\":\"example.com\",\"https_error\":null,\"is_a_record\":true,\"is_apex_domain\":true,\"is_cloudflare_ip\":false,\"is_cname_to_fastly\":false,\"is_cname_to_github_user_domain\":false,\"is_cname_to_pages_dot_github_dot_com\":false,\"is_fastly_ip\":false,\"is_https_eligible\":true,\"is_non_github_pages_ip_present\":false,\"is_old_ip_address\":false,\"is_pages_domain\":false,\"is_pointed_to_github_pages_ip\":true,\"is_proxied\":false,\"is_served_by_pages\":true,\"is_valid\":true,\"is_valid_domain\":true,\"nameservers\":\"default\",\"reason\":null,\"responds_to_https\":true,\"should_be_a_record\":true,\"uri\":\"http://example.com/\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PagesHealthCheck

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PagesHealthCheck
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPagesHealthCheckAltDomain_EncodeDecode(t *testing.T) {
	var typ PagesHealthCheckAltDomain
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PagesHealthCheckAltDomain
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPagesHealthCheckDomain_EncodeDecode(t *testing.T) {
	var typ PagesHealthCheckDomain
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PagesHealthCheckDomain
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPagesSourceHash_EncodeDecode(t *testing.T) {
	var typ PagesSourceHash
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PagesSourceHash
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestParticipationStats_EncodeDecode(t *testing.T) {
	var typ ParticipationStats
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ParticipationStats
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestParticipationStats_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"all\":[11,21,15,2,8,1,8,23,17,21,11,10,33,91,38,34,22,23,32,3,43,87,71,18,13,5,13,16,66,27,12,45,110,117,13,8,18,9,19,26,39,12,20,31,46,91,45,10,24,9,29,7],\"owner\":[3,2,3,0,2,0,5,14,7,9,1,5,0,48,19,2,0,1,10,2,23,40,35,8,8,2,10,6,30,0,2,9,53,104,3,3,10,4,7,11,21,4,4,22,26,63,11,2,14,1,10,3]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ParticipationStats

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ParticipationStats
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPorterAuthor_EncodeDecode(t *testing.T) {
	var typ PorterAuthor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PorterAuthor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPorterAuthor_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"email\":\"hubot@github.com\",\"id\":2268557,\"import_url\":\"https://api.github.com/repos/octocat/socm/import\",\"name\":\"Hubot\",\"remote_id\":\"nobody@fc7da526-431c-80fe-3c8c-c148ff18d7ef\",\"remote_name\":\"nobody\",\"url\":\"https://api.github.com/repos/octocat/socm/import/authors/2268557\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PorterAuthor

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PorterAuthor
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPorterLargeFile_EncodeDecode(t *testing.T) {
	var typ PorterLargeFile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PorterLargeFile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPreviewHeaderMissing_EncodeDecode(t *testing.T) {
	var typ PreviewHeaderMissing
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PreviewHeaderMissing
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPrivateUser_EncodeDecode(t *testing.T) {
	var typ PrivateUser
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PrivateUser
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPrivateUser_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"bio\":\"There once was...\",\"blog\":\"https://github.com/blog\",\"collaborators\":8,\"company\":\"GitHub\",\"created_at\":\"2008-01-14T04:33:35Z\",\"disk_usage\":10000,\"email\":\"octocat@github.com\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers\":20,\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following\":0,\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"hireable\":false,\"html_url\":\"https://github.com/octocat\",\"id\":1,\"location\":\"San Francisco\",\"login\":\"octocat\",\"name\":\"monalisa octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"owned_private_repos\":100,\"plan\":{\"collaborators\":0,\"name\":\"Medium\",\"private_repos\":20,\"space\":400},\"private_gists\":81,\"public_gists\":1,\"public_repos\":2,\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"total_private_repos\":100,\"twitter_username\":\"monatheoctocat\",\"two_factor_authentication\":true,\"type\":\"User\",\"updated_at\":\"2008-01-14T04:33:35Z\",\"url\":\"https://api.github.com/users/octocat\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PrivateUser

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PrivateUser
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPrivateUserPlan_EncodeDecode(t *testing.T) {
	var typ PrivateUserPlan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PrivateUserPlan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProject_EncodeDecode(t *testing.T) {
	var typ Project
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Project
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestProject_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"A board to manage my personal projects.\",\"columns_url\":\"https://api.github.com/projects/1002603/columns\",\"created_at\":\"2011-04-10T20:09:31Z\",\"creator\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"html_url\":\"https://github.com/users/octocat/projects/1\",\"id\":1002603,\"name\":\"My Projects\",\"node_id\":\"MDc6UHJvamVjdDEwMDI2MDM=\",\"number\":1,\"owner_url\":\"https://api.github.com/users/octocat\",\"state\":\"open\",\"updated_at\":\"2014-03-03T18:58:10Z\",\"url\":\"https://api.github.com/projects/1002603\"}"},
		{Input: "{\"body\":\"Developer documentation project for the developer site.\",\"columns_url\":\"https://api.github.com/projects/1002604/columns\",\"created_at\":\"2011-04-10T20:09:31Z\",\"creator\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"html_url\":\"https://github.com/api-playground/projects-test/projects/1\",\"id\":1002604,\"name\":\"Projects Documentation\",\"node_id\":\"MDc6UHJvamVjdDEwMDI2MDQ=\",\"number\":1,\"owner_url\":\"https://api.github.com/repos/api-playground/projects-test\",\"state\":\"open\",\"updated_at\":\"2014-03-03T18:58:10Z\",\"url\":\"https://api.github.com/projects/1002604\"}"},
		{Input: "{\"body\":\"High-level roadmap for the upcoming year.\",\"columns_url\":\"https://api.github.com/projects/1002605/columns\",\"created_at\":\"2011-04-11T20:09:31Z\",\"creator\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"html_url\":\"https://github.com/orgs/api-playground/projects/1\",\"id\":1002605,\"name\":\"Organization Roadmap\",\"node_id\":\"MDc6UHJvamVjdDEwMDI2MDU=\",\"number\":1,\"owner_url\":\"https://api.github.com/orgs/octocat\",\"state\":\"open\",\"updated_at\":\"2014-03-04T18:58:10Z\",\"url\":\"https://api.github.com/projects/1002605\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Project

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Project
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestProjectCard_EncodeDecode(t *testing.T) {
	var typ ProjectCard
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectCard
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestProjectCard_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"archived\":false,\"column_url\":\"https://api.github.com/projects/columns/367\",\"content_url\":\"https://api.github.com/repos/api-playground/projects-test/issues/3\",\"created_at\":\"2016-09-05T14:21:06Z\",\"creator\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"id\":1478,\"node_id\":\"MDExOlByb2plY3RDYXJkMTQ3OA==\",\"note\":\"Add payload for delete Project column\",\"project_url\":\"https://api.github.com/projects/120\",\"updated_at\":\"2016-09-05T14:20:22Z\",\"url\":\"https://api.github.com/projects/columns/cards/1478\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ProjectCard

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ProjectCard
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestProjectColumn_EncodeDecode(t *testing.T) {
	var typ ProjectColumn
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectColumn
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestProjectColumn_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"cards_url\":\"https://api.github.com/projects/columns/367/cards\",\"created_at\":\"2016-09-05T14:18:44Z\",\"id\":367,\"name\":\"To Do\",\"node_id\":\"MDEzOlByb2plY3RDb2x1bW4zNjc=\",\"project_url\":\"https://api.github.com/projects/120\",\"updated_at\":\"2016-09-05T14:22:28Z\",\"url\":\"https://api.github.com/projects/columns/367\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ProjectColumn

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ProjectColumn
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestProjectOrganizationPermission_EncodeDecode(t *testing.T) {
	var typ ProjectOrganizationPermission
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectOrganizationPermission
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsAddCollaboratorForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsAddCollaboratorForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsAddCollaboratorForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsAddCollaboratorNotFound_EncodeDecode(t *testing.T) {
	var typ ProjectsAddCollaboratorNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsAddCollaboratorNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsAddCollaboratorReq_EncodeDecode(t *testing.T) {
	var typ ProjectsAddCollaboratorReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsAddCollaboratorReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsAddCollaboratorReqPermission_EncodeDecode(t *testing.T) {
	var typ ProjectsAddCollaboratorReqPermission
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsAddCollaboratorReqPermission
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestProjectsAddCollaboratorReqPermission_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"write\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ProjectsAddCollaboratorReqPermission

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ProjectsAddCollaboratorReqPermission
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestProjectsAddCollaboratorUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsAddCollaboratorUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsAddCollaboratorUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsCreateColumnForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsCreateColumnForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsCreateColumnForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsCreateColumnReq_EncodeDecode(t *testing.T) {
	var typ ProjectsCreateColumnReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsCreateColumnReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsCreateColumnUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsCreateColumnUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsCreateColumnUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsCreateForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsCreateForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsCreateForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsCreateForAuthenticatedUserReq_EncodeDecode(t *testing.T) {
	var typ ProjectsCreateForAuthenticatedUserReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsCreateForAuthenticatedUserReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsCreateForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsCreateForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsCreateForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsCreateForOrgForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsCreateForOrgForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsCreateForOrgForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsCreateForOrgGone_EncodeDecode(t *testing.T) {
	var typ ProjectsCreateForOrgGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsCreateForOrgGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsCreateForOrgNotFound_EncodeDecode(t *testing.T) {
	var typ ProjectsCreateForOrgNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsCreateForOrgNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsCreateForOrgReq_EncodeDecode(t *testing.T) {
	var typ ProjectsCreateForOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsCreateForOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestProjectsCreateForOrgReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"High-level roadmap for the upcoming year.\",\"name\":\"Organization Roadmap\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ProjectsCreateForOrgReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ProjectsCreateForOrgReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestProjectsCreateForOrgUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsCreateForOrgUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsCreateForOrgUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsCreateForRepoForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsCreateForRepoForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsCreateForRepoForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsCreateForRepoGone_EncodeDecode(t *testing.T) {
	var typ ProjectsCreateForRepoGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsCreateForRepoGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsCreateForRepoNotFound_EncodeDecode(t *testing.T) {
	var typ ProjectsCreateForRepoNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsCreateForRepoNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsCreateForRepoReq_EncodeDecode(t *testing.T) {
	var typ ProjectsCreateForRepoReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsCreateForRepoReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestProjectsCreateForRepoReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"Developer documentation project for the developer site.\",\"name\":\"Projects Documentation\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ProjectsCreateForRepoReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ProjectsCreateForRepoReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestProjectsCreateForRepoUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsCreateForRepoUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsCreateForRepoUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsDeleteCardForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsDeleteCardForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsDeleteCardForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsDeleteCardNotFound_EncodeDecode(t *testing.T) {
	var typ ProjectsDeleteCardNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsDeleteCardNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsDeleteCardUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsDeleteCardUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsDeleteCardUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsDeleteColumnForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsDeleteColumnForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsDeleteColumnForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsDeleteColumnUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsDeleteColumnUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsDeleteColumnUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsDeleteForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsDeleteForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsDeleteForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsDeleteGone_EncodeDecode(t *testing.T) {
	var typ ProjectsDeleteGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsDeleteGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsDeleteNotFound_EncodeDecode(t *testing.T) {
	var typ ProjectsDeleteNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsDeleteNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsDeleteUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsDeleteUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsDeleteUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsGetCardForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsGetCardForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsGetCardForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsGetCardNotFound_EncodeDecode(t *testing.T) {
	var typ ProjectsGetCardNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsGetCardNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsGetCardUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsGetCardUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsGetCardUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsGetColumnForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsGetColumnForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsGetColumnForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsGetColumnNotFound_EncodeDecode(t *testing.T) {
	var typ ProjectsGetColumnNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsGetColumnNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsGetColumnUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsGetColumnUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsGetColumnUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsGetForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsGetForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsGetForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsGetPermissionForUserForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsGetPermissionForUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsGetPermissionForUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsGetPermissionForUserNotFound_EncodeDecode(t *testing.T) {
	var typ ProjectsGetPermissionForUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsGetPermissionForUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsGetPermissionForUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsGetPermissionForUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsGetPermissionForUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsGetUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsGetUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsGetUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsListCardsForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsListCardsForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsListCardsForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsListCardsUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsListCardsUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsListCardsUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsListCollaboratorsForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsListCollaboratorsForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsListCollaboratorsForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsListCollaboratorsNotFound_EncodeDecode(t *testing.T) {
	var typ ProjectsListCollaboratorsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsListCollaboratorsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsListCollaboratorsUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsListCollaboratorsUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsListCollaboratorsUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsListColumnsForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsListColumnsForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsListColumnsForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsListColumnsUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsListColumnsUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsListColumnsUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsListForRepoForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsListForRepoForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsListForRepoForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsListForRepoGone_EncodeDecode(t *testing.T) {
	var typ ProjectsListForRepoGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsListForRepoGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsListForRepoNotFound_EncodeDecode(t *testing.T) {
	var typ ProjectsListForRepoNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsListForRepoNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsListForRepoUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsListForRepoUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsListForRepoUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsMoveCardCreated_EncodeDecode(t *testing.T) {
	var typ ProjectsMoveCardCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsMoveCardCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsMoveCardForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsMoveCardForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsMoveCardForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsMoveCardForbiddenErrorsItem_EncodeDecode(t *testing.T) {
	var typ ProjectsMoveCardForbiddenErrorsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsMoveCardForbiddenErrorsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsMoveCardReq_EncodeDecode(t *testing.T) {
	var typ ProjectsMoveCardReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsMoveCardReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsMoveCardServiceUnavailable_EncodeDecode(t *testing.T) {
	var typ ProjectsMoveCardServiceUnavailable
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsMoveCardServiceUnavailable
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsMoveCardServiceUnavailableErrorsItem_EncodeDecode(t *testing.T) {
	var typ ProjectsMoveCardServiceUnavailableErrorsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsMoveCardServiceUnavailableErrorsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsMoveColumnCreated_EncodeDecode(t *testing.T) {
	var typ ProjectsMoveColumnCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsMoveColumnCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsMoveColumnForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsMoveColumnForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsMoveColumnForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsMoveColumnReq_EncodeDecode(t *testing.T) {
	var typ ProjectsMoveColumnReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsMoveColumnReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsMoveColumnUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsMoveColumnUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsMoveColumnUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsRemoveCollaboratorForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsRemoveCollaboratorForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsRemoveCollaboratorForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsRemoveCollaboratorNotFound_EncodeDecode(t *testing.T) {
	var typ ProjectsRemoveCollaboratorNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsRemoveCollaboratorNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsRemoveCollaboratorUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsRemoveCollaboratorUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsRemoveCollaboratorUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsUpdateCardForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsUpdateCardForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsUpdateCardForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsUpdateCardNotFound_EncodeDecode(t *testing.T) {
	var typ ProjectsUpdateCardNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsUpdateCardNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsUpdateCardReq_EncodeDecode(t *testing.T) {
	var typ ProjectsUpdateCardReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsUpdateCardReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsUpdateCardUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsUpdateCardUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsUpdateCardUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsUpdateColumnForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsUpdateColumnForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsUpdateColumnForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsUpdateColumnReq_EncodeDecode(t *testing.T) {
	var typ ProjectsUpdateColumnReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsUpdateColumnReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsUpdateColumnUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsUpdateColumnUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsUpdateColumnUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsUpdateForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectsUpdateForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsUpdateForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsUpdateGone_EncodeDecode(t *testing.T) {
	var typ ProjectsUpdateGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsUpdateGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsUpdateReq_EncodeDecode(t *testing.T) {
	var typ ProjectsUpdateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsUpdateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsUpdateReqOrganizationPermission_EncodeDecode(t *testing.T) {
	var typ ProjectsUpdateReqOrganizationPermission
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsUpdateReqOrganizationPermission
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsUpdateUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectsUpdateUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsUpdateUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProtectedBranch_EncodeDecode(t *testing.T) {
	var typ ProtectedBranch
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProtectedBranch
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProtectedBranchAdminEnforced_EncodeDecode(t *testing.T) {
	var typ ProtectedBranchAdminEnforced
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProtectedBranchAdminEnforced
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestProtectedBranchAdminEnforced_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"enabled\":true,\"url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/enforce_admins\"}"},
		{Input: "{\"enabled\":true,\"url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/required_signatures\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ProtectedBranchAdminEnforced

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ProtectedBranchAdminEnforced
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestProtectedBranchAllowDeletions_EncodeDecode(t *testing.T) {
	var typ ProtectedBranchAllowDeletions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProtectedBranchAllowDeletions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProtectedBranchAllowForcePushes_EncodeDecode(t *testing.T) {
	var typ ProtectedBranchAllowForcePushes
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProtectedBranchAllowForcePushes
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProtectedBranchEnforceAdmins_EncodeDecode(t *testing.T) {
	var typ ProtectedBranchEnforceAdmins
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProtectedBranchEnforceAdmins
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProtectedBranchPullRequestReview_EncodeDecode(t *testing.T) {
	var typ ProtectedBranchPullRequestReview
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProtectedBranchPullRequestReview
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestProtectedBranchPullRequestReview_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"dismiss_stale_reviews\":true,\"dismissal_restrictions\":{\"teams\":[{\"description\":\"A great team.\",\"html_url\":\"https://github.com/orgs/github/teams/justice-league\",\"id\":1,\"members_url\":\"https://api.github.com/teams/1/members{/member}\",\"name\":\"Justice League\",\"node_id\":\"MDQ6VGVhbTE=\",\"parent\":null,\"permission\":\"admin\",\"privacy\":\"closed\",\"repositories_url\":\"https://api.github.com/teams/1/repos\",\"slug\":\"justice-league\",\"url\":\"https://api.github.com/teams/1\"}],\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/dismissal_restrictions/teams\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/dismissal_restrictions\",\"users\":[{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}],\"users_url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/dismissal_restrictions/users\"},\"require_code_owner_reviews\":true,\"required_approving_review_count\":2,\"url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/required_pull_request_reviews\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ProtectedBranchPullRequestReview

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ProtectedBranchPullRequestReview
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestProtectedBranchPullRequestReviewDismissalRestrictions_EncodeDecode(t *testing.T) {
	var typ ProtectedBranchPullRequestReviewDismissalRestrictions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProtectedBranchPullRequestReviewDismissalRestrictions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProtectedBranchRequiredConversationResolution_EncodeDecode(t *testing.T) {
	var typ ProtectedBranchRequiredConversationResolution
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProtectedBranchRequiredConversationResolution
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProtectedBranchRequiredLinearHistory_EncodeDecode(t *testing.T) {
	var typ ProtectedBranchRequiredLinearHistory
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProtectedBranchRequiredLinearHistory
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProtectedBranchRequiredPullRequestReviews_EncodeDecode(t *testing.T) {
	var typ ProtectedBranchRequiredPullRequestReviews
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProtectedBranchRequiredPullRequestReviews
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProtectedBranchRequiredPullRequestReviewsDismissalRestrictions_EncodeDecode(t *testing.T) {
	var typ ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProtectedBranchRequiredSignatures_EncodeDecode(t *testing.T) {
	var typ ProtectedBranchRequiredSignatures
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProtectedBranchRequiredSignatures
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPublicUser_EncodeDecode(t *testing.T) {
	var typ PublicUser
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PublicUser
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPublicUserPlan_EncodeDecode(t *testing.T) {
	var typ PublicUserPlan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PublicUserPlan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequest_EncodeDecode(t *testing.T) {
	var typ PullRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"_links\":{\"comments\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347/comments\"},\"commits\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1347/commits\"},\"html\":{\"href\":\"https://github.com/octocat/Hello-World/pull/1347\"},\"issue\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347\"},\"review_comment\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/pulls/comments{/number}\"},\"review_comments\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1347/comments\"},\"self\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1347\"},\"statuses\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/statuses/6dcb09b5b57875f334f61aebed695e2e4193db5e\"}},\"active_lock_reason\":\"too heated\",\"additions\":100,\"assignee\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"assignees\":[{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},{\"avatar_url\":\"https://github.com/images/error/hubot_happy.gif\",\"events_url\":\"https://api.github.com/users/hubot/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/hubot/followers\",\"following_url\":\"https://api.github.com/users/hubot/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/hubot/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/hubot\",\"id\":1,\"login\":\"hubot\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/hubot/orgs\",\"received_events_url\":\"https://api.github.com/users/hubot/received_events\",\"repos_url\":\"https://api.github.com/users/hubot/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/hubot/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/hubot/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/hubot\"}],\"author_association\":\"OWNER\",\"auto_merge\":null,\"base\":{\"label\":\"octocat:master\",\"ref\":\"master\",\"repo\":{\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":123,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":123,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"watchers\":123,\"watchers_count\":80},\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}},\"body\":\"Please pull these awesome changes in!\",\"changed_files\":5,\"closed_at\":\"2011-01-26T19:01:12Z\",\"comments\":10,\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347/comments\",\"commits\":3,\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1347/commits\",\"created_at\":\"2011-01-26T19:01:12Z\",\"deletions\":3,\"diff_url\":\"https://github.com/octocat/Hello-World/pull/1347.diff\",\"draft\":false,\"head\":{\"label\":\"octocat:new-topic\",\"ref\":\"new-topic\",\"repo\":{\"allow_forking\":true,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":123,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":123,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"watchers\":123,\"watchers_count\":80},\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}},\"html_url\":\"https://github.com/octocat/Hello-World/pull/1347\",\"id\":1,\"issue_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347\",\"labels\":[{\"color\":\"f29513\",\"default\":true,\"description\":\"Something isn't working\",\"id\":208045946,\"name\":\"bug\",\"node_id\":\"MDU6TGFiZWwyMDgwNDU5NDY=\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/labels/bug\"}],\"locked\":true,\"maintainer_can_modify\":true,\"merge_commit_sha\":\"e5bd3914e2e596debea16f433f57875b5b90bcd6\",\"mergeable\":true,\"mergeable_state\":\"clean\",\"merged\":false,\"merged_at\":\"2011-01-26T19:01:12Z\",\"merged_by\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"milestone\":{\"closed_at\":\"2013-02-12T13:22:01Z\",\"closed_issues\":8,\"created_at\":\"2011-04-10T20:09:31Z\",\"creator\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"description\":\"Tracking milestone for version 1.0\",\"due_on\":\"2012-10-09T23:39:01Z\",\"html_url\":\"https://github.com/octocat/Hello-World/milestones/v1.0\",\"id\":1002604,\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones/1/labels\",\"node_id\":\"MDk6TWlsZXN0b25lMTAwMjYwNA==\",\"number\":1,\"open_issues\":4,\"state\":\"open\",\"title\":\"v1.0\",\"updated_at\":\"2014-03-03T18:58:10Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/milestones/1\"},\"node_id\":\"MDExOlB1bGxSZXF1ZXN0MQ==\",\"number\":1347,\"patch_url\":\"https://github.com/octocat/Hello-World/pull/1347.patch\",\"rebaseable\":true,\"requested_reviewers\":[{\"avatar_url\":\"https://github.com/images/error/other_user_happy.gif\",\"events_url\":\"https://api.github.com/users/other_user/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/other_user/followers\",\"following_url\":\"https://api.github.com/users/other_user/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/other_user/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/other_user\",\"id\":1,\"login\":\"other_user\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/other_user/orgs\",\"received_events_url\":\"https://api.github.com/users/other_user/received_events\",\"repos_url\":\"https://api.github.com/users/other_user/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/other_user/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/other_user/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/other_user\"}],\"requested_teams\":[{\"description\":\"A great team.\",\"html_url\":\"https://github.com/orgs/github/teams/justice-league\",\"id\":1,\"members_url\":\"https://api.github.com/teams/1/members{/member}\",\"name\":\"Justice League\",\"node_id\":\"MDQ6VGVhbTE=\",\"permission\":\"admin\",\"privacy\":\"closed\",\"repositories_url\":\"https://api.github.com/teams/1/repos\",\"slug\":\"justice-league\",\"url\":\"https://api.github.com/teams/1\"}],\"review_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/comments{/number}\",\"review_comments\":0,\"review_comments_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1347/comments\",\"state\":\"open\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"title\":\"Amazing new feature\",\"updated_at\":\"2011-01-26T19:01:12Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1347\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullRequestBase_EncodeDecode(t *testing.T) {
	var typ PullRequestBase
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestBase
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestBaseRepo_EncodeDecode(t *testing.T) {
	var typ PullRequestBaseRepo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestBaseRepo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestBaseRepoOwner_EncodeDecode(t *testing.T) {
	var typ PullRequestBaseRepoOwner
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestBaseRepoOwner
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestBaseRepoPermissions_EncodeDecode(t *testing.T) {
	var typ PullRequestBaseRepoPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestBaseRepoPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestBaseUser_EncodeDecode(t *testing.T) {
	var typ PullRequestBaseUser
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestBaseUser
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestHead_EncodeDecode(t *testing.T) {
	var typ PullRequestHead
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestHead
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestHeadRepo_EncodeDecode(t *testing.T) {
	var typ PullRequestHeadRepo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestHeadRepo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestHeadRepoLicense_EncodeDecode(t *testing.T) {
	var typ PullRequestHeadRepoLicense
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestHeadRepoLicense
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestHeadRepoOwner_EncodeDecode(t *testing.T) {
	var typ PullRequestHeadRepoOwner
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestHeadRepoOwner
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestHeadRepoPermissions_EncodeDecode(t *testing.T) {
	var typ PullRequestHeadRepoPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestHeadRepoPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestHeadUser_EncodeDecode(t *testing.T) {
	var typ PullRequestHeadUser
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestHeadUser
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestLabelsItem_EncodeDecode(t *testing.T) {
	var typ PullRequestLabelsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestLabelsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestLinks_EncodeDecode(t *testing.T) {
	var typ PullRequestLinks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestLinks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestMergeResult_EncodeDecode(t *testing.T) {
	var typ PullRequestMergeResult
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestMergeResult
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullRequestMergeResult_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"merged\":true,\"message\":\"Pull Request successfully merged\",\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullRequestMergeResult

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullRequestMergeResult
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullRequestMinimal_EncodeDecode(t *testing.T) {
	var typ PullRequestMinimal
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestMinimal
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestMinimalBase_EncodeDecode(t *testing.T) {
	var typ PullRequestMinimalBase
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestMinimalBase
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestMinimalBaseRepo_EncodeDecode(t *testing.T) {
	var typ PullRequestMinimalBaseRepo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestMinimalBaseRepo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestMinimalHead_EncodeDecode(t *testing.T) {
	var typ PullRequestMinimalHead
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestMinimalHead
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestMinimalHeadRepo_EncodeDecode(t *testing.T) {
	var typ PullRequestMinimalHeadRepo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestMinimalHeadRepo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestReview_EncodeDecode(t *testing.T) {
	var typ PullRequestReview
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestReview
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullRequestReview_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"_links\":{\"html\":{\"href\":\"https://github.com/octocat/Hello-World/pull/12#pullrequestreview-80\"},\"pull_request\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/pulls/12\"}},\"author_association\":\"COLLABORATOR\",\"body\":\"Here is the body for the review.\",\"commit_id\":\"ecdd80bb57125d7ba9641ffaa4d7d2c19d3f3091\",\"html_url\":\"https://github.com/octocat/Hello-World/pull/12#pullrequestreview-80\",\"id\":80,\"node_id\":\"MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODA=\",\"pull_request_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/12\",\"state\":\"APPROVED\",\"submitted_at\":\"2019-11-17T17:43:43Z\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
		{Input: "{\"_links\":{\"html\":{\"href\":\"https://github.com/octocat/Hello-World/pull/12#pullrequestreview-80\"},\"pull_request\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/pulls/12\"}},\"author_association\":\"COLLABORATOR\",\"body\":\"Here is the body for the review.\",\"commit_id\":\"ecdd80bb57125d7ba9641ffaa4d7d2c19d3f3091\",\"html_url\":\"https://github.com/octocat/Hello-World/pull/12#pullrequestreview-80\",\"id\":80,\"node_id\":\"MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODA=\",\"pull_request_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/12\",\"state\":\"DISMISSED\",\"submitted_at\":\"2019-11-17T17:43:43Z\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
		{Input: "{\"_links\":{\"html\":{\"href\":\"https://github.com/octocat/Hello-World/pull/12#pullrequestreview-80\"},\"pull_request\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/pulls/12\"}},\"author_association\":\"COLLABORATOR\",\"body\":\"This is close to perfect! Please address the suggested inline change. And add more about this.\",\"commit_id\":\"ecdd80bb57125d7ba9641ffaa4d7d2c19d3f3091\",\"html_url\":\"https://github.com/octocat/Hello-World/pull/12#pullrequestreview-80\",\"id\":80,\"node_id\":\"MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODA=\",\"pull_request_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/12\",\"state\":\"CHANGES_REQUESTED\",\"submitted_at\":\"2019-11-17T17:43:43Z\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
		{Input: "{\"_links\":{\"html\":{\"href\":\"https://github.com/octocat/Hello-World/pull/12#pullrequestreview-80\"},\"pull_request\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/pulls/12\"}},\"author_association\":\"COLLABORATOR\",\"body\":\"This is close to perfect! Please address the suggested inline change.\",\"commit_id\":\"ecdd80bb57125d7ba9641ffaa4d7d2c19d3f3091\",\"html_url\":\"https://github.com/octocat/Hello-World/pull/12#pullrequestreview-80\",\"id\":80,\"node_id\":\"MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODA=\",\"pull_request_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/12\",\"state\":\"CHANGES_REQUESTED\",\"submitted_at\":\"2019-11-17T17:43:43Z\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullRequestReview

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullRequestReview
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullRequestReviewComment_EncodeDecode(t *testing.T) {
	var typ PullRequestReviewComment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestReviewComment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullRequestReviewComment_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"_links\":{\"html\":{\"href\":\"https://github.com/octocat/Hello-World/pull/1#discussion-diff-1\"},\"pull_request\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1\"},\"self\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/pulls/comments/1\"}},\"author_association\":\"NONE\",\"body\":\"Great stuff!\",\"commit_id\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"created_at\":\"2011-04-14T16:00:49Z\",\"diff_hunk\":\"@@ -16,33 +16,40 @@ public class Connection : IConnection...\",\"html_url\":\"https://github.com/octocat/Hello-World/pull/1#discussion-diff-1\",\"id\":10,\"in_reply_to_id\":426899381,\"line\":2,\"node_id\":\"MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEw\",\"original_commit_id\":\"9c48853fa3dc5c1c3d6f1f1cd1f2743e72652840\",\"original_line\":2,\"original_position\":4,\"original_start_line\":1,\"path\":\"file1.txt\",\"position\":1,\"pull_request_review_id\":42,\"pull_request_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1\",\"side\":\"RIGHT\",\"start_line\":1,\"start_side\":\"RIGHT\",\"updated_at\":\"2011-04-14T16:00:49Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/comments/1\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
		{Input: "{\"_links\":{\"html\":{\"href\":\"https://github.com/octocat/Hello-World/pull/1#discussion-diff-1\"},\"pull_request\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1\"},\"self\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/pulls/comments/1\"}},\"author_association\":\"NONE\",\"body\":\"Great stuff!\",\"commit_id\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"created_at\":\"2011-04-14T16:00:49Z\",\"diff_hunk\":\"@@ -16,33 +16,40 @@ public class Connection : IConnection...\",\"html_url\":\"https://github.com/octocat/Hello-World/pull/1#discussion-diff-1\",\"id\":10,\"in_reply_to_id\":8,\"line\":2,\"node_id\":\"MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEw\",\"original_commit_id\":\"9c48853fa3dc5c1c3d6f1f1cd1f2743e72652840\",\"original_line\":2,\"original_position\":4,\"original_start_line\":1,\"path\":\"file1.txt\",\"position\":1,\"pull_request_review_id\":42,\"pull_request_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1\",\"side\":\"RIGHT\",\"start_line\":1,\"start_side\":\"RIGHT\",\"updated_at\":\"2011-04-14T16:00:49Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/comments/1\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullRequestReviewComment

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullRequestReviewComment
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullRequestReviewCommentLinks_EncodeDecode(t *testing.T) {
	var typ PullRequestReviewCommentLinks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestReviewCommentLinks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestReviewCommentLinksHTML_EncodeDecode(t *testing.T) {
	var typ PullRequestReviewCommentLinksHTML
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestReviewCommentLinksHTML
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestReviewCommentLinksPullRequest_EncodeDecode(t *testing.T) {
	var typ PullRequestReviewCommentLinksPullRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestReviewCommentLinksPullRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestReviewCommentLinksSelf_EncodeDecode(t *testing.T) {
	var typ PullRequestReviewCommentLinksSelf
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestReviewCommentLinksSelf
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestReviewCommentSide_EncodeDecode(t *testing.T) {
	var typ PullRequestReviewCommentSide
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestReviewCommentSide
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestReviewCommentStartSide_EncodeDecode(t *testing.T) {
	var typ PullRequestReviewCommentStartSide
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestReviewCommentStartSide
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestReviewLinks_EncodeDecode(t *testing.T) {
	var typ PullRequestReviewLinks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestReviewLinks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestReviewLinksHTML_EncodeDecode(t *testing.T) {
	var typ PullRequestReviewLinksHTML
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestReviewLinksHTML
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestReviewLinksPullRequest_EncodeDecode(t *testing.T) {
	var typ PullRequestReviewLinksPullRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestReviewLinksPullRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestReviewRequest_EncodeDecode(t *testing.T) {
	var typ PullRequestReviewRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestReviewRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullRequestReviewRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"teams\":[{\"description\":\"A great team.\",\"html_url\":\"https://github.com/orgs/github/teams/justice-league\",\"id\":1,\"members_url\":\"https://api.github.com/teams/1/members{/member}\",\"name\":\"Justice League\",\"node_id\":\"MDQ6VGVhbTE=\",\"parent\":null,\"permission\":\"admin\",\"privacy\":\"closed\",\"repositories_url\":\"https://api.github.com/teams/1/repos\",\"slug\":\"justice-league\",\"url\":\"https://api.github.com/teams/1\"}],\"users\":[{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullRequestReviewRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullRequestReviewRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullRequestSimple_EncodeDecode(t *testing.T) {
	var typ PullRequestSimple
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestSimple
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullRequestSimple_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"_links\":{\"comments\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347/comments\"},\"commits\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1347/commits\"},\"html\":{\"href\":\"https://github.com/octocat/Hello-World/pull/1347\"},\"issue\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347\"},\"review_comment\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/pulls/comments{/number}\"},\"review_comments\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1347/comments\"},\"self\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1347\"},\"statuses\":{\"href\":\"https://api.github.com/repos/octocat/Hello-World/statuses/6dcb09b5b57875f334f61aebed695e2e4193db5e\"}},\"active_lock_reason\":\"too heated\",\"assignee\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"assignees\":[{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},{\"avatar_url\":\"https://github.com/images/error/hubot_happy.gif\",\"events_url\":\"https://api.github.com/users/hubot/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/hubot/followers\",\"following_url\":\"https://api.github.com/users/hubot/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/hubot/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/hubot\",\"id\":1,\"login\":\"hubot\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/hubot/orgs\",\"received_events_url\":\"https://api.github.com/users/hubot/received_events\",\"repos_url\":\"https://api.github.com/users/hubot/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/hubot/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/hubot/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/hubot\"}],\"author_association\":\"OWNER\",\"auto_merge\":null,\"base\":{\"label\":\"octocat:master\",\"ref\":\"master\",\"repo\":{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":1,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":null,\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":1,\"watchers_count\":80},\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}},\"body\":\"Please pull these awesome changes in!\",\"closed_at\":\"2011-01-26T19:01:12Z\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347/comments\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1347/commits\",\"created_at\":\"2011-01-26T19:01:12Z\",\"diff_url\":\"https://github.com/octocat/Hello-World/pull/1347.diff\",\"draft\":false,\"head\":{\"label\":\"octocat:new-topic\",\"ref\":\"new-topic\",\"repo\":{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":1,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":null,\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":1,\"watchers_count\":80},\"sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}},\"html_url\":\"https://github.com/octocat/Hello-World/pull/1347\",\"id\":1,\"issue_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/1347\",\"labels\":[{\"color\":\"f29513\",\"default\":true,\"description\":\"Something isn't working\",\"id\":208045946,\"name\":\"bug\",\"node_id\":\"MDU6TGFiZWwyMDgwNDU5NDY=\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/labels/bug\"}],\"locked\":true,\"merge_commit_sha\":\"e5bd3914e2e596debea16f433f57875b5b90bcd6\",\"merged_at\":\"2011-01-26T19:01:12Z\",\"milestone\":{\"closed_at\":\"2013-02-12T13:22:01Z\",\"closed_issues\":8,\"created_at\":\"2011-04-10T20:09:31Z\",\"creator\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"description\":\"Tracking milestone for version 1.0\",\"due_on\":\"2012-10-09T23:39:01Z\",\"html_url\":\"https://github.com/octocat/Hello-World/milestones/v1.0\",\"id\":1002604,\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones/1/labels\",\"node_id\":\"MDk6TWlsZXN0b25lMTAwMjYwNA==\",\"number\":1,\"open_issues\":4,\"state\":\"open\",\"title\":\"v1.0\",\"updated_at\":\"2014-03-03T18:58:10Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/milestones/1\"},\"node_id\":\"MDExOlB1bGxSZXF1ZXN0MQ==\",\"number\":1347,\"patch_url\":\"https://github.com/octocat/Hello-World/pull/1347.patch\",\"requested_reviewers\":[{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},{\"avatar_url\":\"https://github.com/images/error/hubot_happy.gif\",\"events_url\":\"https://api.github.com/users/hubot/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/hubot/followers\",\"following_url\":\"https://api.github.com/users/hubot/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/hubot/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/hubot\",\"id\":1,\"login\":\"hubot\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/hubot/orgs\",\"received_events_url\":\"https://api.github.com/users/hubot/received_events\",\"repos_url\":\"https://api.github.com/users/hubot/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/hubot/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/hubot/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/hubot\"},{\"avatar_url\":\"https://github.com/images/error/other_user_happy.gif\",\"events_url\":\"https://api.github.com/users/other_user/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/other_user/followers\",\"following_url\":\"https://api.github.com/users/other_user/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/other_user/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/other_user\",\"id\":1,\"login\":\"other_user\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/other_user/orgs\",\"received_events_url\":\"https://api.github.com/users/other_user/received_events\",\"repos_url\":\"https://api.github.com/users/other_user/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/other_user/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/other_user/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/other_user\"}],\"requested_teams\":[{\"description\":\"A great team.\",\"html_url\":\"https://github.com/orgs/github/teams/justice-league\",\"id\":1,\"members_url\":\"https://api.github.com/teams/1/members{/member}\",\"name\":\"Justice League\",\"node_id\":\"MDQ6VGVhbTE=\",\"parent\":null,\"permission\":\"admin\",\"privacy\":\"closed\",\"repositories_url\":\"https://api.github.com/teams/1/repos\",\"slug\":\"justice-league\",\"url\":\"https://api.github.com/teams/1\"}],\"review_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/comments{/number}\",\"review_comments_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1347/comments\",\"state\":\"open\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"title\":\"Amazing new feature\",\"updated_at\":\"2011-01-26T19:01:12Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1347\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullRequestSimple

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullRequestSimple
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullRequestSimpleBase_EncodeDecode(t *testing.T) {
	var typ PullRequestSimpleBase
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestSimpleBase
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestSimpleHead_EncodeDecode(t *testing.T) {
	var typ PullRequestSimpleHead
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestSimpleHead
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestSimpleLabelsItem_EncodeDecode(t *testing.T) {
	var typ PullRequestSimpleLabelsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestSimpleLabelsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestSimpleLinks_EncodeDecode(t *testing.T) {
	var typ PullRequestSimpleLinks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestSimpleLinks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullRequestState_EncodeDecode(t *testing.T) {
	var typ PullRequestState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullRequestState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullRequestState_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"open\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullRequestState

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullRequestState
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullsCreateReplyForReviewCommentReq_EncodeDecode(t *testing.T) {
	var typ PullsCreateReplyForReviewCommentReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsCreateReplyForReviewCommentReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullsCreateReplyForReviewCommentReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"Great stuff!\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullsCreateReplyForReviewCommentReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullsCreateReplyForReviewCommentReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullsCreateReq_EncodeDecode(t *testing.T) {
	var typ PullsCreateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsCreateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullsCreateReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"base\":\"master\",\"body\":\"Please pull these awesome changes in!\",\"head\":\"octocat:new-feature\",\"title\":\"Amazing new feature\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullsCreateReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullsCreateReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullsCreateReviewCommentReq_EncodeDecode(t *testing.T) {
	var typ PullsCreateReviewCommentReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsCreateReviewCommentReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullsCreateReviewCommentReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"Great stuff!\",\"commit_id\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"line\":2,\"path\":\"file1.txt\",\"side\":\"RIGHT\",\"start_line\":1,\"start_side\":\"RIGHT\"}"},
		{Input: "{\"body\":\"Let's add this deleted line back.\",\"commit_id\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\",\"line\":5,\"path\":\"file1.txt\",\"side\":\"LEFT\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullsCreateReviewCommentReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullsCreateReviewCommentReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullsCreateReviewCommentReqSide_EncodeDecode(t *testing.T) {
	var typ PullsCreateReviewCommentReqSide
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsCreateReviewCommentReqSide
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullsCreateReviewCommentReqStartSide_EncodeDecode(t *testing.T) {
	var typ PullsCreateReviewCommentReqStartSide
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsCreateReviewCommentReqStartSide
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullsCreateReviewReq_EncodeDecode(t *testing.T) {
	var typ PullsCreateReviewReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsCreateReviewReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullsCreateReviewReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"This is close to perfect! Please address the suggested inline change.\",\"comments\":[{\"body\":\"Please add more information here, and fix this typo.\",\"path\":\"file.md\",\"position\":6}],\"commit_id\":\"ecdd80bb57125d7ba9641ffaa4d7d2c19d3f3091\",\"event\":\"REQUEST_CHANGES\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullsCreateReviewReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullsCreateReviewReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullsCreateReviewReqCommentsItem_EncodeDecode(t *testing.T) {
	var typ PullsCreateReviewReqCommentsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsCreateReviewReqCommentsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullsCreateReviewReqEvent_EncodeDecode(t *testing.T) {
	var typ PullsCreateReviewReqEvent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsCreateReviewReqEvent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullsDismissReviewReq_EncodeDecode(t *testing.T) {
	var typ PullsDismissReviewReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsDismissReviewReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullsGetInternalServerError_EncodeDecode(t *testing.T) {
	var typ PullsGetInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsGetInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullsGetNotFound_EncodeDecode(t *testing.T) {
	var typ PullsGetNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsGetNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullsMergeConflict_EncodeDecode(t *testing.T) {
	var typ PullsMergeConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsMergeConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullsMergeConflict_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"message\":\"Head branch was modified. Review and try the merge again.\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullsMergeConflict

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullsMergeConflict
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullsMergeForbidden_EncodeDecode(t *testing.T) {
	var typ PullsMergeForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsMergeForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullsMergeMethodNotAllowed_EncodeDecode(t *testing.T) {
	var typ PullsMergeMethodNotAllowed
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsMergeMethodNotAllowed
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullsMergeMethodNotAllowed_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"message\":\"Pull Request is not mergeable\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullsMergeMethodNotAllowed

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullsMergeMethodNotAllowed
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullsMergeNotFound_EncodeDecode(t *testing.T) {
	var typ PullsMergeNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsMergeNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullsMergeReq_EncodeDecode(t *testing.T) {
	var typ PullsMergeReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsMergeReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullsMergeReqMergeMethod_EncodeDecode(t *testing.T) {
	var typ PullsMergeReqMergeMethod
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsMergeReqMergeMethod
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullsRemoveRequestedReviewersReq_EncodeDecode(t *testing.T) {
	var typ PullsRemoveRequestedReviewersReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsRemoveRequestedReviewersReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullsRemoveRequestedReviewersReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"reviewers\":[\"octocat\",\"hubot\",\"other_user\"],\"team_reviewers\":[\"justice-league\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullsRemoveRequestedReviewersReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullsRemoveRequestedReviewersReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullsSubmitReviewForbidden_EncodeDecode(t *testing.T) {
	var typ PullsSubmitReviewForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsSubmitReviewForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullsSubmitReviewNotFound_EncodeDecode(t *testing.T) {
	var typ PullsSubmitReviewNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsSubmitReviewNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullsSubmitReviewReq_EncodeDecode(t *testing.T) {
	var typ PullsSubmitReviewReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsSubmitReviewReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullsSubmitReviewReqEvent_EncodeDecode(t *testing.T) {
	var typ PullsSubmitReviewReqEvent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsSubmitReviewReqEvent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullsUpdateBranchAccepted_EncodeDecode(t *testing.T) {
	var typ PullsUpdateBranchAccepted
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsUpdateBranchAccepted
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullsUpdateBranchAccepted_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"message\":\"Updating pull request branch.\",\"url\":\"https://github.com/repos/octocat/Hello-World/pulls/53\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullsUpdateBranchAccepted

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullsUpdateBranchAccepted
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullsUpdateBranchReq_EncodeDecode(t *testing.T) {
	var typ PullsUpdateBranchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsUpdateBranchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullsUpdateBranchReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"expected_head_sha\":\"6dcb09b5b57875f334f61aebed695e2e4193db5e\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullsUpdateBranchReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullsUpdateBranchReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullsUpdateReq_EncodeDecode(t *testing.T) {
	var typ PullsUpdateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsUpdateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullsUpdateReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"base\":\"master\",\"body\":\"updated body\",\"state\":\"open\",\"title\":\"new title\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullsUpdateReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullsUpdateReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullsUpdateReqState_EncodeDecode(t *testing.T) {
	var typ PullsUpdateReqState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsUpdateReqState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPullsUpdateReviewCommentReq_EncodeDecode(t *testing.T) {
	var typ PullsUpdateReviewCommentReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsUpdateReviewCommentReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullsUpdateReviewCommentReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"I like this too!\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullsUpdateReviewCommentReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullsUpdateReviewCommentReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPullsUpdateReviewReq_EncodeDecode(t *testing.T) {
	var typ PullsUpdateReviewReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PullsUpdateReviewReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPullsUpdateReviewReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"This is close to perfect! Please address the suggested inline change. And add more about this.\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PullsUpdateReviewReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PullsUpdateReviewReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRateLimit_EncodeDecode(t *testing.T) {
	var typ RateLimit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RateLimit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRateLimitOverview_EncodeDecode(t *testing.T) {
	var typ RateLimitOverview
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RateLimitOverview
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRateLimitOverview_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"rate\":{\"limit\":5000,\"remaining\":4999,\"reset\":1372700873,\"used\":1},\"resources\":{\"code_scanning_upload\":{\"limit\":500,\"remaining\":499,\"reset\":1551806725,\"used\":1},\"core\":{\"limit\":5000,\"remaining\":4999,\"reset\":1372700873,\"used\":1},\"graphql\":{\"limit\":5000,\"remaining\":4993,\"reset\":1372700389,\"used\":7},\"integration_manifest\":{\"limit\":5000,\"remaining\":4999,\"reset\":1551806725,\"used\":1},\"search\":{\"limit\":30,\"remaining\":18,\"reset\":1372697452,\"used\":12}}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RateLimitOverview

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RateLimitOverview
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRateLimitOverviewResources_EncodeDecode(t *testing.T) {
	var typ RateLimitOverviewResources
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RateLimitOverviewResources
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReaction_EncodeDecode(t *testing.T) {
	var typ Reaction
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Reaction
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReaction_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content\":\"heart\",\"created_at\":\"2016-05-20T20:09:31Z\",\"id\":1,\"node_id\":\"MDg6UmVhY3Rpb24x\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Reaction

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Reaction
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReactionContent_EncodeDecode(t *testing.T) {
	var typ ReactionContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReactionContent_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"heart\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReactionContent

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReactionContent
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReactionRollup_EncodeDecode(t *testing.T) {
	var typ ReactionRollup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionRollup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForCommitCommentCreated_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForCommitCommentCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForCommitCommentCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForCommitCommentOK_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForCommitCommentOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForCommitCommentOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForCommitCommentReq_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForCommitCommentReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForCommitCommentReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReactionsCreateForCommitCommentReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content\":\"heart\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReactionsCreateForCommitCommentReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReactionsCreateForCommitCommentReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReactionsCreateForCommitCommentReqContent_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForCommitCommentReqContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForCommitCommentReqContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForIssueCommentCreated_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForIssueCommentCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForIssueCommentCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForIssueCommentOK_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForIssueCommentOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForIssueCommentOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForIssueCommentReq_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForIssueCommentReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForIssueCommentReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReactionsCreateForIssueCommentReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content\":\"heart\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReactionsCreateForIssueCommentReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReactionsCreateForIssueCommentReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReactionsCreateForIssueCommentReqContent_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForIssueCommentReqContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForIssueCommentReqContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForIssueCreated_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForIssueCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForIssueCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForIssueOK_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForIssueOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForIssueOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForIssueReq_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForIssueReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForIssueReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReactionsCreateForIssueReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content\":\"heart\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReactionsCreateForIssueReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReactionsCreateForIssueReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReactionsCreateForIssueReqContent_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForIssueReqContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForIssueReqContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForPullRequestReviewCommentCreated_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForPullRequestReviewCommentCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForPullRequestReviewCommentCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForPullRequestReviewCommentOK_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForPullRequestReviewCommentOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForPullRequestReviewCommentOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForPullRequestReviewCommentReq_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForPullRequestReviewCommentReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForPullRequestReviewCommentReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReactionsCreateForPullRequestReviewCommentReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content\":\"heart\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReactionsCreateForPullRequestReviewCommentReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReactionsCreateForPullRequestReviewCommentReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReactionsCreateForPullRequestReviewCommentReqContent_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForPullRequestReviewCommentReqContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForPullRequestReviewCommentReqContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForReleaseCreated_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForReleaseCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForReleaseCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForReleaseOK_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForReleaseOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForReleaseOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForReleaseReq_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForReleaseReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForReleaseReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReactionsCreateForReleaseReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content\":\"heart\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReactionsCreateForReleaseReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReactionsCreateForReleaseReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReactionsCreateForReleaseReqContent_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForReleaseReqContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForReleaseReqContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForTeamDiscussionCommentInOrgCreated_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForTeamDiscussionCommentInOrgCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForTeamDiscussionCommentInOrgCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForTeamDiscussionCommentInOrgOK_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForTeamDiscussionCommentInOrgOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForTeamDiscussionCommentInOrgOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForTeamDiscussionCommentInOrgReq_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForTeamDiscussionCommentInOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForTeamDiscussionCommentInOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReactionsCreateForTeamDiscussionCommentInOrgReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content\":\"heart\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReactionsCreateForTeamDiscussionCommentInOrgReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReactionsCreateForTeamDiscussionCommentInOrgReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReactionsCreateForTeamDiscussionCommentInOrgReqContent_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForTeamDiscussionCommentInOrgReqContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForTeamDiscussionCommentInOrgReqContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForTeamDiscussionCommentLegacyReq_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForTeamDiscussionCommentLegacyReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForTeamDiscussionCommentLegacyReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReactionsCreateForTeamDiscussionCommentLegacyReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content\":\"heart\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReactionsCreateForTeamDiscussionCommentLegacyReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReactionsCreateForTeamDiscussionCommentLegacyReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReactionsCreateForTeamDiscussionCommentLegacyReqContent_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForTeamDiscussionCommentLegacyReqContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForTeamDiscussionCommentLegacyReqContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForTeamDiscussionInOrgCreated_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForTeamDiscussionInOrgCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForTeamDiscussionInOrgCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForTeamDiscussionInOrgOK_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForTeamDiscussionInOrgOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForTeamDiscussionInOrgOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForTeamDiscussionInOrgReq_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForTeamDiscussionInOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForTeamDiscussionInOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReactionsCreateForTeamDiscussionInOrgReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content\":\"heart\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReactionsCreateForTeamDiscussionInOrgReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReactionsCreateForTeamDiscussionInOrgReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReactionsCreateForTeamDiscussionInOrgReqContent_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForTeamDiscussionInOrgReqContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForTeamDiscussionInOrgReqContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsCreateForTeamDiscussionLegacyReq_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForTeamDiscussionLegacyReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForTeamDiscussionLegacyReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReactionsCreateForTeamDiscussionLegacyReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content\":\"heart\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReactionsCreateForTeamDiscussionLegacyReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReactionsCreateForTeamDiscussionLegacyReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReactionsCreateForTeamDiscussionLegacyReqContent_EncodeDecode(t *testing.T) {
	var typ ReactionsCreateForTeamDiscussionLegacyReqContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsCreateForTeamDiscussionLegacyReqContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsDeleteLegacyForbidden_EncodeDecode(t *testing.T) {
	var typ ReactionsDeleteLegacyForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsDeleteLegacyForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsDeleteLegacyGone_EncodeDecode(t *testing.T) {
	var typ ReactionsDeleteLegacyGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsDeleteLegacyGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsDeleteLegacyUnauthorized_EncodeDecode(t *testing.T) {
	var typ ReactionsDeleteLegacyUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsDeleteLegacyUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsListForIssueGone_EncodeDecode(t *testing.T) {
	var typ ReactionsListForIssueGone
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsListForIssueGone
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReactionsListForIssueNotFound_EncodeDecode(t *testing.T) {
	var typ ReactionsListForIssueNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReactionsListForIssueNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReferrerTraffic_EncodeDecode(t *testing.T) {
	var typ ReferrerTraffic
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReferrerTraffic
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRelease_EncodeDecode(t *testing.T) {
	var typ Release
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Release
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRelease_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"assets\":[{\"browser_download_url\":\"https://github.com/octocat/Hello-World/releases/download/v1.0.0/example.zip\",\"content_type\":\"application/zip\",\"created_at\":\"2013-02-27T19:35:32Z\",\"download_count\":42,\"id\":1,\"label\":\"short description\",\"name\":\"example.zip\",\"node_id\":\"MDEyOlJlbGVhc2VBc3NldDE=\",\"size\":1024,\"state\":\"uploaded\",\"updated_at\":\"2013-02-27T19:35:32Z\",\"uploader\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"url\":\"https://api.github.com/repos/octocat/Hello-World/releases/assets/1\"}],\"assets_url\":\"https://api.github.com/repos/octocat/Hello-World/releases/1/assets\",\"author\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"body\":\"Description of the release\",\"created_at\":\"2013-02-27T19:35:32Z\",\"discussion_url\":\"https://github.com/octocat/Hello-World/discussions/90\",\"draft\":false,\"html_url\":\"https://github.com/octocat/Hello-World/releases/v1.0.0\",\"id\":1,\"name\":\"v1.0.0\",\"node_id\":\"MDc6UmVsZWFzZTE=\",\"prerelease\":false,\"published_at\":\"2013-02-27T19:35:32Z\",\"tag_name\":\"v1.0.0\",\"tarball_url\":\"https://api.github.com/repos/octocat/Hello-World/tarball/v1.0.0\",\"target_commitish\":\"master\",\"upload_url\":\"https://uploads.github.com/repos/octocat/Hello-World/releases/1/assets{?name,label}\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/releases/1\",\"zipball_url\":\"https://api.github.com/repos/octocat/Hello-World/zipball/v1.0.0\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Release

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Release
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReleaseAsset_EncodeDecode(t *testing.T) {
	var typ ReleaseAsset
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReleaseAsset
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReleaseAsset_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"browser_download_url\":\"https://github.com/octocat/Hello-World/releases/download/v1.0.0/example.zip\",\"content_type\":\"application/zip\",\"created_at\":\"2013-02-27T19:35:32Z\",\"download_count\":42,\"id\":1,\"label\":\"short description\",\"name\":\"example.zip\",\"node_id\":\"MDEyOlJlbGVhc2VBc3NldDE=\",\"size\":1024,\"state\":\"uploaded\",\"updated_at\":\"2013-02-27T19:35:32Z\",\"uploader\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"url\":\"https://api.github.com/repos/octocat/Hello-World/releases/assets/1\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReleaseAsset

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReleaseAsset
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReleaseAssetState_EncodeDecode(t *testing.T) {
	var typ ReleaseAssetState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReleaseAssetState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRepoSearchResultItem_EncodeDecode(t *testing.T) {
	var typ RepoSearchResultItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RepoSearchResultItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRepoSearchResultItemPermissions_EncodeDecode(t *testing.T) {
	var typ RepoSearchResultItemPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RepoSearchResultItemPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposAcceptInvitationConflict_EncodeDecode(t *testing.T) {
	var typ ReposAcceptInvitationConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAcceptInvitationConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposAcceptInvitationForbidden_EncodeDecode(t *testing.T) {
	var typ ReposAcceptInvitationForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAcceptInvitationForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposAcceptInvitationNotFound_EncodeDecode(t *testing.T) {
	var typ ReposAcceptInvitationNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAcceptInvitationNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposAddAppAccessRestrictionsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposAddAppAccessRestrictionsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAddAppAccessRestrictionsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposAddAppAccessRestrictionsReq_EncodeDecode(t *testing.T) {
	var typ ReposAddAppAccessRestrictionsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAddAppAccessRestrictionsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposAddAppAccessRestrictionsReq0_EncodeDecode(t *testing.T) {
	var typ ReposAddAppAccessRestrictionsReq0
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAddAppAccessRestrictionsReq0
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposAddAppAccessRestrictionsReq0_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"apps\":[\"my-app\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposAddAppAccessRestrictionsReq0

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposAddAppAccessRestrictionsReq0
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposAddCollaboratorReq_EncodeDecode(t *testing.T) {
	var typ ReposAddCollaboratorReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAddCollaboratorReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposAddCollaboratorReqPermission_EncodeDecode(t *testing.T) {
	var typ ReposAddCollaboratorReqPermission
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAddCollaboratorReqPermission
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposAddStatusCheckContextsForbidden_EncodeDecode(t *testing.T) {
	var typ ReposAddStatusCheckContextsForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAddStatusCheckContextsForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposAddStatusCheckContextsNotFound_EncodeDecode(t *testing.T) {
	var typ ReposAddStatusCheckContextsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAddStatusCheckContextsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposAddStatusCheckContextsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposAddStatusCheckContextsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAddStatusCheckContextsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposAddStatusCheckContextsReq_EncodeDecode(t *testing.T) {
	var typ ReposAddStatusCheckContextsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAddStatusCheckContextsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposAddStatusCheckContextsReq0_EncodeDecode(t *testing.T) {
	var typ ReposAddStatusCheckContextsReq0
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAddStatusCheckContextsReq0
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposAddStatusCheckContextsReq0_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"contexts\":[\"contexts\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposAddStatusCheckContextsReq0

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposAddStatusCheckContextsReq0
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposAddTeamAccessRestrictionsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposAddTeamAccessRestrictionsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAddTeamAccessRestrictionsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposAddTeamAccessRestrictionsReq_EncodeDecode(t *testing.T) {
	var typ ReposAddTeamAccessRestrictionsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAddTeamAccessRestrictionsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposAddTeamAccessRestrictionsReq0_EncodeDecode(t *testing.T) {
	var typ ReposAddTeamAccessRestrictionsReq0
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAddTeamAccessRestrictionsReq0
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposAddTeamAccessRestrictionsReq0_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"teams\":[\"my-team\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposAddTeamAccessRestrictionsReq0

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposAddTeamAccessRestrictionsReq0
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposAddUserAccessRestrictionsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposAddUserAccessRestrictionsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAddUserAccessRestrictionsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposAddUserAccessRestrictionsReq_EncodeDecode(t *testing.T) {
	var typ ReposAddUserAccessRestrictionsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAddUserAccessRestrictionsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposAddUserAccessRestrictionsReq0_EncodeDecode(t *testing.T) {
	var typ ReposAddUserAccessRestrictionsReq0
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposAddUserAccessRestrictionsReq0
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposAddUserAccessRestrictionsReq0_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"users\":[\"mona\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposAddUserAccessRestrictionsReq0

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposAddUserAccessRestrictionsReq0
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposCompareCommitsInternalServerError_EncodeDecode(t *testing.T) {
	var typ ReposCompareCommitsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCompareCommitsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCompareCommitsNotFound_EncodeDecode(t *testing.T) {
	var typ ReposCompareCommitsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCompareCommitsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateAutolinkReq_EncodeDecode(t *testing.T) {
	var typ ReposCreateAutolinkReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateAutolinkReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposCreateAutolinkReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"key_prefix\":\"TICKET-\",\"url_template\":\"https://example.com/TICKET?query=\\u003cnum\\u003e\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposCreateAutolinkReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposCreateAutolinkReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposCreateCommitCommentReq_EncodeDecode(t *testing.T) {
	var typ ReposCreateCommitCommentReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateCommitCommentReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposCreateCommitCommentReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"Great stuff\",\"line\":1,\"path\":\"file1.txt\",\"position\":4}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposCreateCommitCommentReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposCreateCommitCommentReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposCreateCommitStatusReq_EncodeDecode(t *testing.T) {
	var typ ReposCreateCommitStatusReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateCommitStatusReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposCreateCommitStatusReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"context\":\"continuous-integration/jenkins\",\"description\":\"The build succeeded!\",\"state\":\"success\",\"target_url\":\"https://example.com/build/status\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposCreateCommitStatusReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposCreateCommitStatusReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposCreateCommitStatusReqState_EncodeDecode(t *testing.T) {
	var typ ReposCreateCommitStatusReqState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateCommitStatusReqState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateDeployKeyReq_EncodeDecode(t *testing.T) {
	var typ ReposCreateDeployKeyReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateDeployKeyReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposCreateDeployKeyReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"key\":\"ssh-rsa AAA...\",\"read_only\":true,\"title\":\"octocat@octomac\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposCreateDeployKeyReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposCreateDeployKeyReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposCreateDeploymentAccepted_EncodeDecode(t *testing.T) {
	var typ ReposCreateDeploymentAccepted
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateDeploymentAccepted
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposCreateDeploymentAccepted_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"message\":\"Auto-merged master into topic-branch on deployment.\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposCreateDeploymentAccepted

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposCreateDeploymentAccepted
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposCreateDeploymentReq_EncodeDecode(t *testing.T) {
	var typ ReposCreateDeploymentReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateDeploymentReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposCreateDeploymentReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"auto_merge\":false,\"description\":\"Deploy request from hubot\",\"payload\":\"{ \\\"deploy\\\": \\\"migrate\\\" }\",\"ref\":\"topic-branch\",\"required_contexts\":[\"ci/janky\",\"security/brakeman\"]}"},
		{Input: "{\"description\":\"Deploy request from hubot\",\"payload\":\"{ \\\"deploy\\\": \\\"migrate\\\" }\",\"ref\":\"topic-branch\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposCreateDeploymentReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposCreateDeploymentReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposCreateDeploymentReqPayload_EncodeDecode(t *testing.T) {
	var typ ReposCreateDeploymentReqPayload
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateDeploymentReqPayload
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateDeploymentReqPayload0_EncodeDecode(t *testing.T) {
	var typ ReposCreateDeploymentReqPayload0
	typ = make(ReposCreateDeploymentReqPayload0)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateDeploymentReqPayload0
	typ2 = make(ReposCreateDeploymentReqPayload0)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateDeploymentStatusReq_EncodeDecode(t *testing.T) {
	var typ ReposCreateDeploymentStatusReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateDeploymentStatusReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposCreateDeploymentStatusReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"Deployment finished successfully.\",\"environment\":\"production\",\"log_url\":\"https://example.com/deployment/42/output\",\"state\":\"success\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposCreateDeploymentStatusReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposCreateDeploymentStatusReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposCreateDeploymentStatusReqEnvironment_EncodeDecode(t *testing.T) {
	var typ ReposCreateDeploymentStatusReqEnvironment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateDeploymentStatusReqEnvironment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateDeploymentStatusReqState_EncodeDecode(t *testing.T) {
	var typ ReposCreateDeploymentStatusReqState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateDeploymentStatusReqState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateDispatchEventReq_EncodeDecode(t *testing.T) {
	var typ ReposCreateDispatchEventReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateDispatchEventReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposCreateDispatchEventReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"client_payload\":{\"integration\":true,\"unit\":false},\"event_type\":\"on-demand-test\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposCreateDispatchEventReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposCreateDispatchEventReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposCreateDispatchEventReqClientPayload_EncodeDecode(t *testing.T) {
	var typ ReposCreateDispatchEventReqClientPayload
	typ = make(ReposCreateDispatchEventReqClientPayload)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateDispatchEventReqClientPayload
	typ2 = make(ReposCreateDispatchEventReqClientPayload)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateForAuthenticatedUserBadRequest_EncodeDecode(t *testing.T) {
	var typ ReposCreateForAuthenticatedUserBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateForAuthenticatedUserBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ ReposCreateForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateForAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ ReposCreateForAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateForAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateForAuthenticatedUserReq_EncodeDecode(t *testing.T) {
	var typ ReposCreateForAuthenticatedUserReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateForAuthenticatedUserReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ ReposCreateForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateForkBadRequest_EncodeDecode(t *testing.T) {
	var typ ReposCreateForkBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateForkBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateForkForbidden_EncodeDecode(t *testing.T) {
	var typ ReposCreateForkForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateForkForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateForkNotFound_EncodeDecode(t *testing.T) {
	var typ ReposCreateForkNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateForkNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateForkReq_EncodeDecode(t *testing.T) {
	var typ ReposCreateForkReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateForkReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateInOrgReq_EncodeDecode(t *testing.T) {
	var typ ReposCreateInOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateInOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposCreateInOrgReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"This is your first repository\",\"has_issues\":true,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"name\":\"Hello-World\",\"private\":false}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposCreateInOrgReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposCreateInOrgReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposCreateInOrgReqVisibility_EncodeDecode(t *testing.T) {
	var typ ReposCreateInOrgReqVisibility
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateInOrgReqVisibility
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateOrUpdateFileContentsConflict_EncodeDecode(t *testing.T) {
	var typ ReposCreateOrUpdateFileContentsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateOrUpdateFileContentsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateOrUpdateFileContentsCreated_EncodeDecode(t *testing.T) {
	var typ ReposCreateOrUpdateFileContentsCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateOrUpdateFileContentsCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateOrUpdateFileContentsNotFound_EncodeDecode(t *testing.T) {
	var typ ReposCreateOrUpdateFileContentsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateOrUpdateFileContentsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateOrUpdateFileContentsOK_EncodeDecode(t *testing.T) {
	var typ ReposCreateOrUpdateFileContentsOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateOrUpdateFileContentsOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateOrUpdateFileContentsReq_EncodeDecode(t *testing.T) {
	var typ ReposCreateOrUpdateFileContentsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateOrUpdateFileContentsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposCreateOrUpdateFileContentsReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"committer\":{\"email\":\"octocat@github.com\",\"name\":\"Monalisa Octocat\"},\"content\":\"bXkgbmV3IGZpbGUgY29udGVudHM=\",\"message\":\"my commit message\"}"},
		{Input: "{\"committer\":{\"email\":\"octocat@github.com\",\"name\":\"Monalisa Octocat\"},\"content\":\"bXkgdXBkYXRlZCBmaWxlIGNvbnRlbnRz\",\"message\":\"a new commit message\",\"sha\":\"95b966ae1c166bd92f8ae7d1c313e738c731dfc3\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposCreateOrUpdateFileContentsReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposCreateOrUpdateFileContentsReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposCreateOrUpdateFileContentsReqAuthor_EncodeDecode(t *testing.T) {
	var typ ReposCreateOrUpdateFileContentsReqAuthor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateOrUpdateFileContentsReqAuthor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateOrUpdateFileContentsReqCommitter_EncodeDecode(t *testing.T) {
	var typ ReposCreateOrUpdateFileContentsReqCommitter
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateOrUpdateFileContentsReqCommitter
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreatePagesSiteReq_EncodeDecode(t *testing.T) {
	var typ ReposCreatePagesSiteReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreatePagesSiteReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposCreatePagesSiteReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"source\":{\"branch\":\"main\",\"path\":\"/docs\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposCreatePagesSiteReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposCreatePagesSiteReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposCreatePagesSiteReqSource_EncodeDecode(t *testing.T) {
	var typ ReposCreatePagesSiteReqSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreatePagesSiteReqSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreatePagesSiteReqSourcePath_EncodeDecode(t *testing.T) {
	var typ ReposCreatePagesSiteReqSourcePath
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreatePagesSiteReqSourcePath
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateReleaseReq_EncodeDecode(t *testing.T) {
	var typ ReposCreateReleaseReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateReleaseReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposCreateReleaseReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"Description of the release\",\"draft\":false,\"name\":\"v1.0.0\",\"prerelease\":false,\"tag_name\":\"v1.0.0\",\"target_commitish\":\"master\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposCreateReleaseReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposCreateReleaseReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposCreateUsingTemplateReq_EncodeDecode(t *testing.T) {
	var typ ReposCreateUsingTemplateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateUsingTemplateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposCreateUsingTemplateReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"This is your first repository\",\"include_all_branches\":false,\"name\":\"Hello-World\",\"owner\":\"octocat\",\"private\":false}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposCreateUsingTemplateReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposCreateUsingTemplateReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposCreateWebhookForbidden_EncodeDecode(t *testing.T) {
	var typ ReposCreateWebhookForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateWebhookForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateWebhookNotFound_EncodeDecode(t *testing.T) {
	var typ ReposCreateWebhookNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateWebhookNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposCreateWebhookReq_EncodeDecode(t *testing.T) {
	var typ ReposCreateWebhookReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateWebhookReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposCreateWebhookReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"active\":true,\"config\":{\"content_type\":\"json\",\"insecure_ssl\":\"0\",\"url\":\"https://example.com/webhook\"},\"events\":[\"push\",\"pull_request\"],\"name\":\"web\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposCreateWebhookReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposCreateWebhookReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposCreateWebhookReqConfig_EncodeDecode(t *testing.T) {
	var typ ReposCreateWebhookReqConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposCreateWebhookReqConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposDeclineInvitationConflict_EncodeDecode(t *testing.T) {
	var typ ReposDeclineInvitationConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposDeclineInvitationConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposDeclineInvitationForbidden_EncodeDecode(t *testing.T) {
	var typ ReposDeclineInvitationForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposDeclineInvitationForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposDeclineInvitationNotFound_EncodeDecode(t *testing.T) {
	var typ ReposDeclineInvitationNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposDeclineInvitationNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposDeleteFileConflict_EncodeDecode(t *testing.T) {
	var typ ReposDeleteFileConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposDeleteFileConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposDeleteFileNotFound_EncodeDecode(t *testing.T) {
	var typ ReposDeleteFileNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposDeleteFileNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposDeleteFileReq_EncodeDecode(t *testing.T) {
	var typ ReposDeleteFileReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposDeleteFileReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposDeleteFileReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"committer\":{\"email\":\"octocat@github.com\",\"name\":\"Monalisa Octocat\"},\"message\":\"my commit message\",\"sha\":\"329688480d39049927147c162b9d2deaf885005f\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposDeleteFileReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposDeleteFileReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposDeleteFileReqAuthor_EncodeDecode(t *testing.T) {
	var typ ReposDeleteFileReqAuthor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposDeleteFileReqAuthor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposDeleteFileReqCommitter_EncodeDecode(t *testing.T) {
	var typ ReposDeleteFileReqCommitter
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposDeleteFileReqCommitter
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposDeleteForbidden_EncodeDecode(t *testing.T) {
	var typ ReposDeleteForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposDeleteForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposDeleteForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"documentation_url\":\"https://docs.github.com/rest/reference/repos#delete-a-repository\",\"message\":\"Organization members cannot delete repositories.\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposDeleteForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposDeleteForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposDeleteNotFound_EncodeDecode(t *testing.T) {
	var typ ReposDeleteNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposDeleteNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposDeleteTemporaryRedirect_EncodeDecode(t *testing.T) {
	var typ ReposDeleteTemporaryRedirect
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposDeleteTemporaryRedirect
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetAllStatusCheckContextsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposGetAllStatusCheckContextsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetAllStatusCheckContextsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetAppsWithAccessToProtectedBranchOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetBranchMovedPermanently_EncodeDecode(t *testing.T) {
	var typ ReposGetBranchMovedPermanently
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetBranchMovedPermanently
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetBranchNotFound_EncodeDecode(t *testing.T) {
	var typ ReposGetBranchNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetBranchNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetCodeFrequencyStatsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposGetCodeFrequencyStatsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetCodeFrequencyStatsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetCommitActivityStatsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposGetCommitActivityStatsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetCommitActivityStatsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetCommitInternalServerError_EncodeDecode(t *testing.T) {
	var typ ReposGetCommitInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetCommitInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetCommitNotFound_EncodeDecode(t *testing.T) {
	var typ ReposGetCommitNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetCommitNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetContributorsStatsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposGetContributorsStatsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetContributorsStatsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetForbidden_EncodeDecode(t *testing.T) {
	var typ ReposGetForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetMovedPermanently_EncodeDecode(t *testing.T) {
	var typ ReposGetMovedPermanently
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetMovedPermanently
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetNotFound_EncodeDecode(t *testing.T) {
	var typ ReposGetNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetPunchCardStatsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposGetPunchCardStatsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetPunchCardStatsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetTopPathsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposGetTopPathsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetTopPathsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetTopReferrersOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposGetTopReferrersOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetTopReferrersOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposGetUsersWithAccessToProtectedBranchOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposListBranchesForHeadCommitOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposListBranchesForHeadCommitOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposListBranchesForHeadCommitOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposListCommitsBadRequest_EncodeDecode(t *testing.T) {
	var typ ReposListCommitsBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposListCommitsBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposListCommitsConflict_EncodeDecode(t *testing.T) {
	var typ ReposListCommitsConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposListCommitsConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposListCommitsInternalServerError_EncodeDecode(t *testing.T) {
	var typ ReposListCommitsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposListCommitsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposListCommitsNotFound_EncodeDecode(t *testing.T) {
	var typ ReposListCommitsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposListCommitsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposListContributorsForbidden_EncodeDecode(t *testing.T) {
	var typ ReposListContributorsForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposListContributorsForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposListContributorsNotFound_EncodeDecode(t *testing.T) {
	var typ ReposListContributorsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposListContributorsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposListForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ ReposListForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposListForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposListForAuthenticatedUserOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposListForAuthenticatedUserOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposListForAuthenticatedUserOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposListForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ ReposListForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposListForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposListInvitationsForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ ReposListInvitationsForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposListInvitationsForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposListInvitationsForAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ ReposListInvitationsForAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposListInvitationsForAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposListInvitationsForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ ReposListInvitationsForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposListInvitationsForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposListWebhookDeliveriesOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposListWebhookDeliveriesOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposListWebhookDeliveriesOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposMergeReq_EncodeDecode(t *testing.T) {
	var typ ReposMergeReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposMergeReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposMergeReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"base\":\"master\",\"commit_message\":\"Shipped cool_feature!\",\"head\":\"cool_feature\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposMergeReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposMergeReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposMergeUpstreamReq_EncodeDecode(t *testing.T) {
	var typ ReposMergeUpstreamReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposMergeUpstreamReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposMergeUpstreamReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"branch\":\"main\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposMergeUpstreamReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposMergeUpstreamReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposRemoveAppAccessRestrictionsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposRemoveAppAccessRestrictionsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposRemoveAppAccessRestrictionsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposRemoveAppAccessRestrictionsReq_EncodeDecode(t *testing.T) {
	var typ ReposRemoveAppAccessRestrictionsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposRemoveAppAccessRestrictionsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposRemoveAppAccessRestrictionsReq0_EncodeDecode(t *testing.T) {
	var typ ReposRemoveAppAccessRestrictionsReq0
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposRemoveAppAccessRestrictionsReq0
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposRemoveAppAccessRestrictionsReq0_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"apps\":[\"my-app\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposRemoveAppAccessRestrictionsReq0

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposRemoveAppAccessRestrictionsReq0
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposRemoveStatusCheckContextsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposRemoveStatusCheckContextsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposRemoveStatusCheckContextsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposRemoveStatusCheckContextsReq_EncodeDecode(t *testing.T) {
	var typ ReposRemoveStatusCheckContextsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposRemoveStatusCheckContextsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposRemoveStatusCheckContextsReq0_EncodeDecode(t *testing.T) {
	var typ ReposRemoveStatusCheckContextsReq0
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposRemoveStatusCheckContextsReq0
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposRemoveStatusCheckContextsReq0_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"contexts\":[\"contexts\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposRemoveStatusCheckContextsReq0

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposRemoveStatusCheckContextsReq0
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposRemoveTeamAccessRestrictionsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposRemoveTeamAccessRestrictionsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposRemoveTeamAccessRestrictionsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposRemoveTeamAccessRestrictionsReq_EncodeDecode(t *testing.T) {
	var typ ReposRemoveTeamAccessRestrictionsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposRemoveTeamAccessRestrictionsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposRemoveTeamAccessRestrictionsReq0_EncodeDecode(t *testing.T) {
	var typ ReposRemoveTeamAccessRestrictionsReq0
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposRemoveTeamAccessRestrictionsReq0
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposRemoveTeamAccessRestrictionsReq0_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"teams\":[\"my-team\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposRemoveTeamAccessRestrictionsReq0

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposRemoveTeamAccessRestrictionsReq0
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposRemoveUserAccessRestrictionsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposRemoveUserAccessRestrictionsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposRemoveUserAccessRestrictionsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposRemoveUserAccessRestrictionsReq_EncodeDecode(t *testing.T) {
	var typ ReposRemoveUserAccessRestrictionsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposRemoveUserAccessRestrictionsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposRemoveUserAccessRestrictionsReq0_EncodeDecode(t *testing.T) {
	var typ ReposRemoveUserAccessRestrictionsReq0
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposRemoveUserAccessRestrictionsReq0
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposRemoveUserAccessRestrictionsReq0_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"users\":[\"mona\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposRemoveUserAccessRestrictionsReq0

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposRemoveUserAccessRestrictionsReq0
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposRenameBranchForbidden_EncodeDecode(t *testing.T) {
	var typ ReposRenameBranchForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposRenameBranchForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposRenameBranchNotFound_EncodeDecode(t *testing.T) {
	var typ ReposRenameBranchNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposRenameBranchNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposRenameBranchReq_EncodeDecode(t *testing.T) {
	var typ ReposRenameBranchReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposRenameBranchReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposRenameBranchReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"new_name\":\"my_renamed_branch\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposRenameBranchReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposRenameBranchReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposReplaceAllTopicsReq_EncodeDecode(t *testing.T) {
	var typ ReposReplaceAllTopicsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposReplaceAllTopicsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposReplaceAllTopicsReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"names\":[\"octocat\",\"atom\",\"electron\",\"api\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposReplaceAllTopicsReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposReplaceAllTopicsReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposSetAppAccessRestrictionsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposSetAppAccessRestrictionsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposSetAppAccessRestrictionsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposSetAppAccessRestrictionsReq_EncodeDecode(t *testing.T) {
	var typ ReposSetAppAccessRestrictionsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposSetAppAccessRestrictionsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposSetAppAccessRestrictionsReq0_EncodeDecode(t *testing.T) {
	var typ ReposSetAppAccessRestrictionsReq0
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposSetAppAccessRestrictionsReq0
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposSetAppAccessRestrictionsReq0_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"apps\":[\"my-app\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposSetAppAccessRestrictionsReq0

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposSetAppAccessRestrictionsReq0
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposSetStatusCheckContextsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposSetStatusCheckContextsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposSetStatusCheckContextsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposSetStatusCheckContextsReq_EncodeDecode(t *testing.T) {
	var typ ReposSetStatusCheckContextsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposSetStatusCheckContextsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposSetStatusCheckContextsReq0_EncodeDecode(t *testing.T) {
	var typ ReposSetStatusCheckContextsReq0
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposSetStatusCheckContextsReq0
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposSetStatusCheckContextsReq0_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"contexts\":[\"contexts\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposSetStatusCheckContextsReq0

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposSetStatusCheckContextsReq0
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposSetTeamAccessRestrictionsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposSetTeamAccessRestrictionsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposSetTeamAccessRestrictionsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposSetTeamAccessRestrictionsReq_EncodeDecode(t *testing.T) {
	var typ ReposSetTeamAccessRestrictionsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposSetTeamAccessRestrictionsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposSetTeamAccessRestrictionsReq0_EncodeDecode(t *testing.T) {
	var typ ReposSetTeamAccessRestrictionsReq0
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposSetTeamAccessRestrictionsReq0
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposSetTeamAccessRestrictionsReq0_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"teams\":[\"my-team\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposSetTeamAccessRestrictionsReq0

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposSetTeamAccessRestrictionsReq0
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposSetUserAccessRestrictionsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ReposSetUserAccessRestrictionsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposSetUserAccessRestrictionsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposSetUserAccessRestrictionsReq_EncodeDecode(t *testing.T) {
	var typ ReposSetUserAccessRestrictionsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposSetUserAccessRestrictionsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposSetUserAccessRestrictionsReq0_EncodeDecode(t *testing.T) {
	var typ ReposSetUserAccessRestrictionsReq0
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposSetUserAccessRestrictionsReq0
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposSetUserAccessRestrictionsReq0_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"users\":[\"mona\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposSetUserAccessRestrictionsReq0

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposSetUserAccessRestrictionsReq0
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposTransferReq_EncodeDecode(t *testing.T) {
	var typ ReposTransferReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposTransferReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposTransferReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"new_owner\":\"github\",\"team_ids\":[12,345]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposTransferReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposTransferReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposUpdateBranchProtectionForbidden_EncodeDecode(t *testing.T) {
	var typ ReposUpdateBranchProtectionForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateBranchProtectionForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposUpdateBranchProtectionNotFound_EncodeDecode(t *testing.T) {
	var typ ReposUpdateBranchProtectionNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateBranchProtectionNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposUpdateBranchProtectionReq_EncodeDecode(t *testing.T) {
	var typ ReposUpdateBranchProtectionReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateBranchProtectionReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposUpdateBranchProtectionReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"allow_deletions\":true,\"allow_force_pushes\":true,\"enforce_admins\":true,\"required_conversation_resolution\":true,\"required_linear_history\":true,\"required_pull_request_reviews\":{\"dismiss_stale_reviews\":true,\"dismissal_restrictions\":{\"teams\":[\"justice-league\"],\"users\":[\"octocat\"]},\"require_code_owner_reviews\":true,\"required_approving_review_count\":2},\"required_status_checks\":{\"contexts\":[\"continuous-integration/travis-ci\"],\"strict\":true},\"restrictions\":{\"apps\":[\"super-ci\"],\"teams\":[\"justice-league\"],\"users\":[\"octocat\"]}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposUpdateBranchProtectionReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposUpdateBranchProtectionReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposUpdateBranchProtectionReqRequiredPullRequestReviews_EncodeDecode(t *testing.T) {
	var typ ReposUpdateBranchProtectionReqRequiredPullRequestReviews
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateBranchProtectionReqRequiredPullRequestReviews
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions_EncodeDecode(t *testing.T) {
	var typ ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposUpdateBranchProtectionReqRequiredStatusChecks_EncodeDecode(t *testing.T) {
	var typ ReposUpdateBranchProtectionReqRequiredStatusChecks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateBranchProtectionReqRequiredStatusChecks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposUpdateBranchProtectionReqRestrictions_EncodeDecode(t *testing.T) {
	var typ ReposUpdateBranchProtectionReqRestrictions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateBranchProtectionReqRestrictions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposUpdateCommitCommentReq_EncodeDecode(t *testing.T) {
	var typ ReposUpdateCommitCommentReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateCommitCommentReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposUpdateCommitCommentReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"Nice change\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposUpdateCommitCommentReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposUpdateCommitCommentReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposUpdateForbidden_EncodeDecode(t *testing.T) {
	var typ ReposUpdateForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposUpdateInvitationReq_EncodeDecode(t *testing.T) {
	var typ ReposUpdateInvitationReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateInvitationReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposUpdateInvitationReqPermissions_EncodeDecode(t *testing.T) {
	var typ ReposUpdateInvitationReqPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateInvitationReqPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposUpdateNotFound_EncodeDecode(t *testing.T) {
	var typ ReposUpdateNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposUpdatePullRequestReviewProtectionReq_EncodeDecode(t *testing.T) {
	var typ ReposUpdatePullRequestReviewProtectionReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdatePullRequestReviewProtectionReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposUpdatePullRequestReviewProtectionReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"dismiss_stale_reviews\":true,\"dismissal_restrictions\":{\"teams\":[\"justice-league\"],\"users\":[\"octocat\"]},\"require_code_owner_reviews\":true,\"required_approving_review_count\":2}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposUpdatePullRequestReviewProtectionReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposUpdatePullRequestReviewProtectionReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposUpdatePullRequestReviewProtectionReqDismissalRestrictions_EncodeDecode(t *testing.T) {
	var typ ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposUpdateReleaseAssetReq_EncodeDecode(t *testing.T) {
	var typ ReposUpdateReleaseAssetReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateReleaseAssetReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposUpdateReleaseAssetReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"label\":\"Mac binary\",\"name\":\"foo-1.0.0-osx.zip\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposUpdateReleaseAssetReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposUpdateReleaseAssetReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposUpdateReleaseReq_EncodeDecode(t *testing.T) {
	var typ ReposUpdateReleaseReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateReleaseReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposUpdateReleaseReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"Description of the release\",\"draft\":false,\"name\":\"v1.0.0\",\"prerelease\":false,\"tag_name\":\"v1.0.0\",\"target_commitish\":\"master\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposUpdateReleaseReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposUpdateReleaseReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposUpdateReq_EncodeDecode(t *testing.T) {
	var typ ReposUpdateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposUpdateReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"This is your first repository\",\"has_issues\":true,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"name\":\"Hello-World\",\"private\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposUpdateReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposUpdateReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposUpdateReqSecurityAndAnalysis_EncodeDecode(t *testing.T) {
	var typ ReposUpdateReqSecurityAndAnalysis
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateReqSecurityAndAnalysis
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposUpdateReqSecurityAndAnalysisAdvancedSecurity_EncodeDecode(t *testing.T) {
	var typ ReposUpdateReqSecurityAndAnalysisAdvancedSecurity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateReqSecurityAndAnalysisAdvancedSecurity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposUpdateReqSecurityAndAnalysisSecretScanning_EncodeDecode(t *testing.T) {
	var typ ReposUpdateReqSecurityAndAnalysisSecretScanning
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateReqSecurityAndAnalysisSecretScanning
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposUpdateReqVisibility_EncodeDecode(t *testing.T) {
	var typ ReposUpdateReqVisibility
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateReqVisibility
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposUpdateStatusCheckProtectionReq_EncodeDecode(t *testing.T) {
	var typ ReposUpdateStatusCheckProtectionReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateStatusCheckProtectionReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposUpdateStatusCheckProtectionReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"contexts\":[\"continuous-integration/travis-ci\"],\"strict\":true}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposUpdateStatusCheckProtectionReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposUpdateStatusCheckProtectionReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposUpdateTemporaryRedirect_EncodeDecode(t *testing.T) {
	var typ ReposUpdateTemporaryRedirect
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateTemporaryRedirect
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReposUpdateWebhookConfigForRepoReq_EncodeDecode(t *testing.T) {
	var typ ReposUpdateWebhookConfigForRepoReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateWebhookConfigForRepoReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposUpdateWebhookConfigForRepoReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content_type\":\"json\",\"insecure_ssl\":\"0\",\"secret\":\"********\",\"url\":\"https://example.com/webhook\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposUpdateWebhookConfigForRepoReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposUpdateWebhookConfigForRepoReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposUpdateWebhookReq_EncodeDecode(t *testing.T) {
	var typ ReposUpdateWebhookReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateWebhookReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestReposUpdateWebhookReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"active\":true,\"add_events\":[\"pull_request\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ReposUpdateWebhookReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ReposUpdateWebhookReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestReposUpdateWebhookReqConfig_EncodeDecode(t *testing.T) {
	var typ ReposUpdateWebhookReqConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReposUpdateWebhookReqConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRepository_EncodeDecode(t *testing.T) {
	var typ Repository
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Repository
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRepository_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":9,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":0,\"open_issues_count\":0,\"organization\":null,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":null,\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":80,\"watchers_count\":80}"},
		{Input: "{\"allow_auto_merge\":false,\"allow_rebase_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":9,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":false,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":0,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":80,\"watchers_count\":80}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Repository

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Repository
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRepositoryCollaboratorPermission_EncodeDecode(t *testing.T) {
	var typ RepositoryCollaboratorPermission
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RepositoryCollaboratorPermission
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRepositoryCollaboratorPermission_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"permission\":\"admin\",\"user\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RepositoryCollaboratorPermission

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RepositoryCollaboratorPermission
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRepositoryInvitation_EncodeDecode(t *testing.T) {
	var typ RepositoryInvitation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RepositoryInvitation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRepositoryInvitation_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2016-06-13T14:52:50-05:00\",\"expired\":false,\"html_url\":\"https://github.com/octocat/Hello-World/invitations\",\"id\":1,\"invitee\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"inviter\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"permissions\":\"write\",\"repository\":{\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"hooks_url\":\"http://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"name\":\"Hello-World\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\"},\"url\":\"https://api.github.com/user/repository_invitations/1296269\"}"},
		{Input: "{\"created_at\":\"2016-06-13T14:52:50-05:00\",\"html_url\":\"https://github.com/octocat/Hello-World/invitations\",\"id\":1,\"invitee\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"inviter\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"permissions\":\"write\",\"repository\":{\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"hooks_url\":\"http://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"name\":\"Hello-World\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\"},\"url\":\"https://api.github.com/user/repository_invitations/1296269\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RepositoryInvitation

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RepositoryInvitation
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRepositoryInvitationPermissions_EncodeDecode(t *testing.T) {
	var typ RepositoryInvitationPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RepositoryInvitationPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRepositoryInvitationPermissions_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"read\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RepositoryInvitationPermissions

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RepositoryInvitationPermissions
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRepositoryPermissions_EncodeDecode(t *testing.T) {
	var typ RepositoryPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RepositoryPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRepositorySubscription_EncodeDecode(t *testing.T) {
	var typ RepositorySubscription
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RepositorySubscription
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRepositorySubscription_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2012-10-06T21:34:12Z\",\"ignored\":false,\"reason\":null,\"repository_url\":\"https://api.github.com/repos/octocat/example\",\"subscribed\":true,\"url\":\"https://api.github.com/repos/octocat/example/subscription\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RepositorySubscription

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RepositorySubscription
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRepositoryTemplateRepository_EncodeDecode(t *testing.T) {
	var typ RepositoryTemplateRepository
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RepositoryTemplateRepository
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRepositoryTemplateRepositoryOwner_EncodeDecode(t *testing.T) {
	var typ RepositoryTemplateRepositoryOwner
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RepositoryTemplateRepositoryOwner
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRepositoryTemplateRepositoryPermissions_EncodeDecode(t *testing.T) {
	var typ RepositoryTemplateRepositoryPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RepositoryTemplateRepositoryPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReviewComment_EncodeDecode(t *testing.T) {
	var typ ReviewComment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReviewComment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReviewCommentLinks_EncodeDecode(t *testing.T) {
	var typ ReviewCommentLinks
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReviewCommentLinks
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReviewCommentSide_EncodeDecode(t *testing.T) {
	var typ ReviewCommentSide
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReviewCommentSide
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReviewCommentStartSide_EncodeDecode(t *testing.T) {
	var typ ReviewCommentStartSide
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReviewCommentStartSide
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRunner_EncodeDecode(t *testing.T) {
	var typ Runner
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Runner
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRunner_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"busy\":true,\"id\":23,\"labels\":[{\"id\":5,\"name\":\"self-hosted\",\"type\":\"read-only\"},{\"id\":7,\"name\":\"X64\",\"type\":\"read-only\"},{\"id\":20,\"name\":\"macOS\",\"type\":\"read-only\"},{\"id\":21,\"name\":\"no-gpu\",\"type\":\"custom\"}],\"name\":\"MBP\",\"os\":\"macos\",\"status\":\"online\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Runner

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Runner
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRunnerApplication_EncodeDecode(t *testing.T) {
	var typ RunnerApplication
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RunnerApplication
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRunnerGroupsEnterprise_EncodeDecode(t *testing.T) {
	var typ RunnerGroupsEnterprise
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RunnerGroupsEnterprise
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRunnerGroupsEnterprise_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"allows_public_repositories\":false,\"default\":false,\"id\":2,\"name\":\"octo-runner-group\",\"runners_url\":\"https://api.github.com/enterprises/octo-corp/actions/runner-groups/2/runners\",\"selected_organizations_url\":\"https://api.github.com/enterprises/octo-corp/actions/runner-groups/2/organizations\",\"visibility\":\"selected\"}"},
		{Input: "{\"allows_public_repositories\":true,\"default\":false,\"id\":2,\"name\":\"Expensive hardware runners\",\"runners_url\":\"https://api.github.com/enterprises/octo-corp/actions/runner-groups/2/runners\",\"selected_organizations_url\":\"https://api.github.com/enterprises/octo-corp/actions/runner-groups/2/organizations\",\"visibility\":\"selected\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RunnerGroupsEnterprise

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RunnerGroupsEnterprise
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRunnerGroupsOrg_EncodeDecode(t *testing.T) {
	var typ RunnerGroupsOrg
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RunnerGroupsOrg
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRunnerGroupsOrg_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"allows_public_repositories\":true,\"default\":false,\"id\":2,\"inherited\":false,\"name\":\"octo-runner-group\",\"runners_url\":\"https://api.github.com/orgs/octo-org/actions/runner_groups/2/runners\",\"selected_repositories_url\":\"https://api.github.com/orgs/octo-org/actions/runner-groups/2/repositories\",\"visibility\":\"selected\"}"},
		{Input: "{\"allows_public_repositories\":true,\"default\":false,\"id\":2,\"inherited\":false,\"name\":\"octo-runner-group\",\"runners_url\":\"https://api.github.com/orgs/octo-org/actions/runner_groups/2/runners\",\"selected_repositories_url\":\"https://api.github.com/orgs/octo-org/actions/runner_groups/2/repositories\",\"visibility\":\"selected\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RunnerGroupsOrg

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RunnerGroupsOrg
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRunnerLabelsItem_EncodeDecode(t *testing.T) {
	var typ RunnerLabelsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RunnerLabelsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRunnerLabelsItemType_EncodeDecode(t *testing.T) {
	var typ RunnerLabelsItemType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RunnerLabelsItemType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimDeleteUserFromOrgForbidden_EncodeDecode(t *testing.T) {
	var typ ScimDeleteUserFromOrgForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimDeleteUserFromOrgForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimDeleteUserFromOrgNotFound_EncodeDecode(t *testing.T) {
	var typ ScimDeleteUserFromOrgNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimDeleteUserFromOrgNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimEnterpriseGroup_EncodeDecode(t *testing.T) {
	var typ ScimEnterpriseGroup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimEnterpriseGroup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestScimEnterpriseGroup_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"displayName\":\"octo-org\",\"externalId\":null,\"id\":\"abcd27f8-a9aa-11ea-8221-f59b2be9cccc\",\"members\":[{\"$ref\":\"https://api.github.com/scim/v2/enterprises/octo-corp/Users/92b58aaa-a1d6-11ea-8227-b9ce9e023ccc\",\"display\":\"octocat@github.com\",\"value\":\"92b58aaa-a1d6-11ea-8227-b9ce9e023ccc\"},{\"$ref\":\"https://api.github.com/scim/v2/enterprises/octo-corp/Users/aaaa8c34-a6b2-11ea-9d70-bbbbbd1c8fd5\",\"display\":\"hubot@example.com\",\"value\":\"aaaa8c34-a6b2-11ea-9d70-bbbbbd1c8fd5\"}],\"meta\":{\"created\":\"2020-06-09T03:10:17.000+10:0\",\"lastModified\":\"2020-06-09T03:10:17.000+10:00\",\"location\":\"https://api.github.com/scim/v2/enterprises/octo-corp/Groups/abcd27f8-a9aa-11ea-8221-f59b2be9cccc\",\"resourceType\":\"Group\"},\"schemas\":[\"urn:ietf:params:scim:schemas:core:2.0:Group\"]}"},
		{Input: "{\"displayName\":\"octo-org\",\"externalId\":null,\"id\":\"abcd27f8-a9aa-11ea-8221-f59b2be9cccc\",\"members\":[{\"$ref\":\"https://api.github.com/scim/v2/enterprises/octo-corp/Users/92b58aaa-a1d6-11ea-8227-b9ce9e023ccc\",\"display\":\"octocat@github.com\",\"value\":\"92b58aaa-a1d6-11ea-8227-b9ce9e023ccc\"}],\"meta\":{\"created\":\"2020-06-09T03:10:17.000+10:00\",\"lastModified\":\"2020-06-09T03:10:17.000+10:00\",\"location\":\"https://api.github.com/scim/v2/enterprises/octo-corp/Groups/abcd27f8-a9aa-11ea-8221-f59b2be9cccc\",\"resourceType\":\"Group\"},\"schemas\":[\"urn:ietf:params:scim:schemas:core:2.0:Group\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ScimEnterpriseGroup

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ScimEnterpriseGroup
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestScimEnterpriseGroupMembersItem_EncodeDecode(t *testing.T) {
	var typ ScimEnterpriseGroupMembersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimEnterpriseGroupMembersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimEnterpriseGroupMeta_EncodeDecode(t *testing.T) {
	var typ ScimEnterpriseGroupMeta
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimEnterpriseGroupMeta
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimEnterpriseUser_EncodeDecode(t *testing.T) {
	var typ ScimEnterpriseUser
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimEnterpriseUser
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestScimEnterpriseUser_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"active\":true,\"emails\":[{\"primary\":true,\"type\":\"work\",\"value\":\"mona.octocat@okta.example.com\"},{\"type\":\"home\",\"value\":\"monalisa@octocat.github.com\"}],\"externalId\":\"00dowz5dr9oSfDFRA0h7\",\"groups\":[{\"value\":\"468dd3fa-a1d6-11ea-9031-15a1f0d7811d\"}],\"id\":\"92b58aaa-a1d6-11ea-8227-b9ce9e023ccc\",\"meta\":{\"created\":\"2017-03-09T16:11:13-05:00\",\"lastModified\":\"2017-03-09T16:11:13-05:00\",\"location\":\"https://api.github.com/scim/v2/enterprises/octo-corp/Users/92b58aaa-a1d6-11ea-8227-b9ce9e023ccc\",\"resourceType\":\"User\"},\"name\":{\"familyName\":\"Octocat\",\"givenName\":\"Monalisa\"},\"schemas\":[\"urn:ietf:params:scim:schemas:core:2.0:User\"],\"userName\":\"mona.octocat@okta.example.com\"}"},
		{Input: "{\"active\":true,\"emails\":[{\"primary\":true,\"type\":\"work\",\"value\":\"mona.octocat@okta.example.com\"}],\"externalId\":\"00dowz5dr9oSfDFRA0h7\",\"groups\":[{\"value\":\"468dd3fa-a1d6-11ea-9031-15a1f0d7811d\"}],\"id\":\"92b58aaa-a1d6-11ea-8227-b9ce9e023ccc\",\"meta\":{\"created\":\"2017-03-09T16:11:13-05:00\",\"lastModified\":\"2017-03-09T16:11:13-05:00\",\"location\":\"https://api.github.com/scim/v2/enterprises/octo-corp/Users/92b58aaa-a1d6-11ea-8227-b9ce9e023ccc\",\"resourceType\":\"User\"},\"name\":{\"familyName\":\"Octocat\",\"givenName\":\"Mona\"},\"schemas\":[\"urn:ietf:params:scim:schemas:core:2.0:User\"],\"userName\":\"mona.octocat@okta.example.com\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ScimEnterpriseUser

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ScimEnterpriseUser
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestScimEnterpriseUserEmailsItem_EncodeDecode(t *testing.T) {
	var typ ScimEnterpriseUserEmailsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimEnterpriseUserEmailsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimEnterpriseUserGroupsItem_EncodeDecode(t *testing.T) {
	var typ ScimEnterpriseUserGroupsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimEnterpriseUserGroupsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimEnterpriseUserMeta_EncodeDecode(t *testing.T) {
	var typ ScimEnterpriseUserMeta
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimEnterpriseUserMeta
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimEnterpriseUserName_EncodeDecode(t *testing.T) {
	var typ ScimEnterpriseUserName
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimEnterpriseUserName
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimError_EncodeDecode(t *testing.T) {
	var typ ScimError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimGroupListEnterprise_EncodeDecode(t *testing.T) {
	var typ ScimGroupListEnterprise
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimGroupListEnterprise
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestScimGroupListEnterprise_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Resources\":[{\"displayName\":\"octo-org\",\"externalId\":null,\"id\":\"abcd27f8-a9aa-11ea-8221-f59b2be9cccc\",\"members\":[{\"$ref\":\"https://api.github.com/scim/v2/enterprises/octo-corp/Users/92b58aaa-a1d6-11ea-8227-b9ce9e023ccc\",\"display\":\"octocat@github.com\",\"value\":\"92b58aaa-a1d6-11ea-8227-b9ce9e023ccc\"},{\"$ref\":\"https://api.github.com/scim/v2/enterprises/octo-corp/Users/aaaa8c34-a6b2-11ea-9d70-bbbbbd1c8fd5\",\"display\":\"hubot@example.com\",\"value\":\"aaaa8c34-a6b2-11ea-9d70-bbbbbd1c8fd5\"}],\"meta\":{\"created\":\"2020-06-09T03:10:17.000+10:00\",\"lastModified\":\"2020-06-09T03:10:17.000+10:00\",\"location\":\"https://api.github.com/scim/v2/enterprises/octo-corp/Groups/abcd27f8-a9aa-11ea-8221-f59b2be9cccc\",\"resourceType\":\"Group\"},\"schemas\":[\"urn:ietf:params:scim:schemas:core:2.0:Group\"]},{\"displayName\":\"octo-docs-org\",\"externalId\":null,\"id\":\"5e75bbbb-aa1a-11ea-8644-75ff655cdddd\",\"members\":[{\"$ref\":\"https://api.github.com/scim/v2/enterprises/octo-corp/Users/92b58aaa-a1d6-11ea-8227-b9ce9e023ccc\",\"display\":\"octocat@github.com\",\"value\":\"92b58aaa-a1d6-11ea-8227-b9ce9e023ccc\"}],\"meta\":{\"created\":\"2020-06-09T16:28:01.000+10:00\",\"lastModified\":\"2020-06-09T16:28:01.000+10:00\",\"location\":\"https://api.github.com/scim/v2/enterprises/octo-corp/Groups/5e75bbbb-aa1a-11ea-8644-75ff655cdddd\",\"resourceType\":\"Group\"},\"schemas\":[\"urn:ietf:params:scim:schemas:core:2.0:Group\"]}],\"itemsPerPage\":2,\"schemas\":[\"urn:ietf:params:scim:api:messages:2.0:ListResponse\"],\"startIndex\":1,\"totalResults\":2}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ScimGroupListEnterprise

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ScimGroupListEnterprise
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestScimGroupListEnterpriseResourcesItem_EncodeDecode(t *testing.T) {
	var typ ScimGroupListEnterpriseResourcesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimGroupListEnterpriseResourcesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimGroupListEnterpriseResourcesItemMembersItem_EncodeDecode(t *testing.T) {
	var typ ScimGroupListEnterpriseResourcesItemMembersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimGroupListEnterpriseResourcesItemMembersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimGroupListEnterpriseResourcesItemMeta_EncodeDecode(t *testing.T) {
	var typ ScimGroupListEnterpriseResourcesItemMeta
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimGroupListEnterpriseResourcesItemMeta
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimUserListEnterprise_EncodeDecode(t *testing.T) {
	var typ ScimUserListEnterprise
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimUserListEnterprise
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestScimUserListEnterprise_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"Resources\":[{\"active\":true,\"emails\":[{\"primary\":true,\"type\":\"work\",\"value\":\"octocat@github.com\"}],\"externalId\":\"00dowz5dr9oSfDFRA0h7\",\"groups\":[{\"value\":\"468dd3fa-a1d6-11ea-9031-15a1f0d7811d\"}],\"id\":\"92b58aaa-a1d6-11ea-8227-b9ce9e023ccc\",\"meta\":{\"created\":\"2020-05-30T04:02:34.000+10:00\",\"lastModified\":\"2020-05-30T04:05:04.000+10:00\",\"location\":\"https://api.github.com/scim/v2/enterprises/octo-corp/Users/92b58aaa-a1d6-11ea-8227-b9ce9e023ccc\",\"resourceType\":\"User\"},\"name\":{\"familyName\":\"Octocat\",\"givenName\":\"Mona\"},\"schemas\":[\"urn:ietf:params:scim:schemas:core:2.0:User\"],\"userName\":\"octocat@github.com\"},{\"active\":true,\"emails\":[{\"primary\":true,\"type\":\"work\",\"value\":\"hubot@example.com\"}],\"externalId\":\"sdfoiausdofiua\",\"groups\":[],\"id\":\"e18b8c34-a6b2-11ea-9d70-54abbd1c8fd5\",\"meta\":{\"created\":\"2020-06-05T08:29:40.000+10:00\",\"lastModified\":\"2020-06-05T08:30:19.000+10:00\",\"location\":\"https://api.github.com/scim/v2/enterprises/octo-corp/Users/e18b8c34-a6b2-11ea-9d70-54abbd1c8fd5\",\"resourceType\":\"User\"},\"name\":{\"familyName\":\"bot\",\"givenName\":\"hu\"},\"schemas\":[\"urn:ietf:params:scim:schemas:core:2.0:User\"],\"userName\":\"hubot@example.com\"}],\"itemsPerPage\":2,\"schemas\":[\"urn:ietf:params:scim:api:messages:2.0:ListResponse\"],\"startIndex\":1,\"totalResults\":2}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ScimUserListEnterprise

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ScimUserListEnterprise
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestScimUserListEnterpriseResourcesItem_EncodeDecode(t *testing.T) {
	var typ ScimUserListEnterpriseResourcesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimUserListEnterpriseResourcesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimUserListEnterpriseResourcesItemEmailsItem_EncodeDecode(t *testing.T) {
	var typ ScimUserListEnterpriseResourcesItemEmailsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimUserListEnterpriseResourcesItemEmailsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimUserListEnterpriseResourcesItemGroupsItem_EncodeDecode(t *testing.T) {
	var typ ScimUserListEnterpriseResourcesItemGroupsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimUserListEnterpriseResourcesItemGroupsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimUserListEnterpriseResourcesItemMeta_EncodeDecode(t *testing.T) {
	var typ ScimUserListEnterpriseResourcesItemMeta
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimUserListEnterpriseResourcesItemMeta
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScimUserListEnterpriseResourcesItemName_EncodeDecode(t *testing.T) {
	var typ ScimUserListEnterpriseResourcesItemName
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ScimUserListEnterpriseResourcesItemName
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSearchCodeOK_EncodeDecode(t *testing.T) {
	var typ SearchCodeOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchCodeOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSearchCodeOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"incomplete_results\":false,\"items\":[{\"git_url\":\"https://api.github.com/repositories/167174/git/blobs/d7212f9dee2dcc18f084d7df8f417b80846ded5a\",\"html_url\":\"https://github.com/jquery/jquery/blob/825ac3773694e0cd23ee74895fd5aeb535b27da4/src/attributes/classes.js\",\"name\":\"classes.js\",\"path\":\"src/attributes/classes.js\",\"repository\":{\"archive_url\":\"https://api.github.com/repos/jquery/jquery/{archive_format}{/ref}\",\"assignees_url\":\"https://api.github.com/repos/jquery/jquery/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/jquery/jquery/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/jquery/jquery/branches{/branch}\",\"collaborators_url\":\"https://api.github.com/repos/jquery/jquery/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/jquery/jquery/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/jquery/jquery/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/jquery/jquery/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/jquery/jquery/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/jquery/jquery/contributors\",\"deployments_url\":\"http://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"jQuery JavaScript Library\",\"downloads_url\":\"https://api.github.com/repos/jquery/jquery/downloads\",\"events_url\":\"https://api.github.com/repos/jquery/jquery/events\",\"fork\":false,\"forks_url\":\"https://api.github.com/repos/jquery/jquery/forks\",\"full_name\":\"jquery/jquery\",\"git_commits_url\":\"https://api.github.com/repos/jquery/jquery/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/jquery/jquery/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/jquery/jquery/git/tags{/sha}\",\"hooks_url\":\"https://api.github.com/repos/jquery/jquery/hooks\",\"html_url\":\"https://github.com/jquery/jquery\",\"id\":167174,\"issue_comment_url\":\"https://api.github.com/repos/jquery/jquery/issues/comments/{number}\",\"issue_events_url\":\"https://api.github.com/repos/jquery/jquery/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/jquery/jquery/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/jquery/jquery/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/jquery/jquery/labels{/name}\",\"languages_url\":\"https://api.github.com/repos/jquery/jquery/languages\",\"merges_url\":\"https://api.github.com/repos/jquery/jquery/merges\",\"milestones_url\":\"https://api.github.com/repos/jquery/jquery/milestones{/number}\",\"name\":\"jquery\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkxNjcxNzQ=\",\"notifications_url\":\"https://api.github.com/repos/jquery/jquery/notifications{?since,all,participating}\",\"owner\":{\"avatar_url\":\"https://0.gravatar.com/avatar/6906f317a4733f4379b06c32229ef02f?d=https%3A%2F%2Fidenticons.github.com%2Ff426f04f2f9813718fb806b30e0093de.png\",\"events_url\":\"https://api.github.com/users/jquery/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/jquery/followers\",\"following_url\":\"https://api.github.com/users/jquery/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/jquery/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/jquery\",\"id\":70142,\"login\":\"jquery\",\"node_id\":\"MDQ6VXNlcjcwMTQy\",\"organizations_url\":\"https://api.github.com/users/jquery/orgs\",\"received_events_url\":\"https://api.github.com/users/jquery/received_events\",\"repos_url\":\"https://api.github.com/users/jquery/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/jquery/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/jquery/subscriptions\",\"type\":\"Organization\",\"url\":\"https://api.github.com/users/jquery\"},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/jquery/jquery/pulls{/number}\",\"releases_url\":\"http://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"stargazers_url\":\"https://api.github.com/repos/jquery/jquery/stargazers\",\"statuses_url\":\"https://api.github.com/repos/jquery/jquery/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/jquery/jquery/subscribers\",\"subscription_url\":\"https://api.github.com/repos/jquery/jquery/subscription\",\"tags_url\":\"https://api.github.com/repos/jquery/jquery/tags\",\"teams_url\":\"https://api.github.com/repos/jquery/jquery/teams\",\"trees_url\":\"https://api.github.com/repos/jquery/jquery/git/trees{/sha}\",\"url\":\"https://api.github.com/repos/jquery/jquery\"},\"score\":1,\"sha\":\"d7212f9dee2dcc18f084d7df8f417b80846ded5a\",\"url\":\"https://api.github.com/repositories/167174/contents/src/attributes/classes.js?ref=825ac3773694e0cd23ee74895fd5aeb535b27da4\"}],\"total_count\":7}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ SearchCodeOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 SearchCodeOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSearchCommitsOK_EncodeDecode(t *testing.T) {
	var typ SearchCommitsOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchCommitsOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSearchCommitsOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"incomplete_results\":false,\"items\":[{\"author\":{\"avatar_url\":\"https://avatars.githubusercontent.com/u/583231?v=3\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":583231,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjU4MzIzMQ==\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"comments_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/commits/bb4cc8d3b2e14b3af5df699876dd4ff3acd00b7f/comments\",\"commit\":{\"author\":{\"date\":\"2014-02-04T14:38:36-08:00\",\"email\":\"octocat@nowhere.com\",\"name\":\"The Octocat\"},\"comment_count\":8,\"committer\":{\"date\":\"2014-02-12T15:18:55-08:00\",\"email\":\"octocat@nowhere.com\",\"name\":\"The Octocat\"},\"message\":\"Create styles.css and updated README\",\"tree\":{\"sha\":\"a639e96f9038797fba6e0469f94a4b0cc459fa68\",\"url\":\"https://api.github.com/repos/octocat/Spoon-Knife/git/trees/a639e96f9038797fba6e0469f94a4b0cc459fa68\"},\"url\":\"https://api.github.com/repos/octocat/Spoon-Knife/git/commits/bb4cc8d3b2e14b3af5df699876dd4ff3acd00b7f\"},\"committer\":{},\"html_url\":\"https://github.com/octocat/Spoon-Knife/commit/bb4cc8d3b2e14b3af5df699876dd4ff3acd00b7f\",\"node_id\":\"MDQ6VXNlcjU4MzIzMQ==\",\"parents\":[{\"html_url\":\"https://github.com/octocat/Spoon-Knife/commit/a30c19e3f13765a3b48829788bc1cb8b4e95cee4\",\"sha\":\"a30c19e3f13765a3b48829788bc1cb8b4e95cee4\",\"url\":\"https://api.github.com/repos/octocat/Spoon-Knife/commits/a30c19e3f13765a3b48829788bc1cb8b4e95cee4\"}],\"repository\":{\"archive_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/{archive_format}{/ref}\",\"assignees_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/branches{/branch}\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/contributors\",\"deployments_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/deployments\",\"description\":\"This repo is for demonstration purposes only.\",\"downloads_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/events\",\"fork\":false,\"forks_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/forks\",\"full_name\":\"octocat/Spoon-Knife\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/git/tags{/sha}\",\"hooks_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/hooks\",\"html_url\":\"https://github.com/octocat/Spoon-Knife\",\"id\":1300192,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/labels{/name}\",\"languages_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/languages\",\"merges_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/milestones{/number}\",\"name\":\"Spoon-Knife\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMzAwMTky\",\"notifications_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/notifications{?since,all,participating}\",\"owner\":{\"avatar_url\":\"https://avatars.githubusercontent.com/u/583231?v=3\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":583231,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjU4MzIzMQ==\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/pulls{/number}\",\"releases_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/releases{/id}\",\"stargazers_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/subscription\",\"tags_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/teams\",\"trees_url\":\"https://api.github.com/repos/octocat/Spoon-Knife/git/trees{/sha}\",\"url\":\"https://api.github.com/repos/octocat/Spoon-Knife\"},\"score\":1,\"sha\":\"bb4cc8d3b2e14b3af5df699876dd4ff3acd00b7f\",\"url\":\"https://api.github.com/repos/octocat/Spoon-Knife/commits/bb4cc8d3b2e14b3af5df699876dd4ff3acd00b7f\"}],\"total_count\":1}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ SearchCommitsOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 SearchCommitsOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSearchIssuesAndPullRequestsOK_EncodeDecode(t *testing.T) {
	var typ SearchIssuesAndPullRequestsOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchIssuesAndPullRequestsOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSearchIssuesAndPullRequestsOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"incomplete_results\":false,\"items\":[{\"assignee\":null,\"author_association\":\"COLLABORATOR\",\"body\":\"...\",\"closed_at\":null,\"comments\":15,\"comments_url\":\"https://api.github.com/repos/batterseapower/pinyin-toolkit/issues/132/comments\",\"created_at\":\"2009-07-12T20:10:41Z\",\"events_url\":\"https://api.github.com/repos/batterseapower/pinyin-toolkit/issues/132/events\",\"html_url\":\"https://github.com/batterseapower/pinyin-toolkit/issues/132\",\"id\":35802,\"labels\":[{\"color\":\"ff0000\",\"id\":4,\"name\":\"bug\",\"node_id\":\"MDU6TGFiZWw0\",\"url\":\"https://api.github.com/repos/batterseapower/pinyin-toolkit/labels/bug\"}],\"labels_url\":\"https://api.github.com/repos/batterseapower/pinyin-toolkit/issues/132/labels{/name}\",\"locked\":true,\"milestone\":{\"closed_at\":\"2013-02-12T13:22:01Z\",\"closed_issues\":8,\"created_at\":\"2011-04-10T20:09:31Z\",\"creator\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"description\":\"Tracking milestone for version 1.0\",\"due_on\":\"2012-10-09T23:39:01Z\",\"html_url\":\"https://github.com/octocat/Hello-World/milestones/v1.0\",\"id\":1002604,\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones/1/labels\",\"node_id\":\"MDk6TWlsZXN0b25lMTAwMjYwNA==\",\"number\":1,\"open_issues\":4,\"state\":\"open\",\"title\":\"v1.0\",\"updated_at\":\"2014-03-03T18:58:10Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/milestones/1\"},\"node_id\":\"MDU6SXNzdWUzNTgwMg==\",\"number\":132,\"pull_request\":{\"diff_url\":\"https://github.com/octocat/Hello-World/pull/1347.diff\",\"html_url\":\"https://github.com/octocat/Hello-World/pull/1347\",\"patch_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls/1347\",\"url\":\"https://api/github.com/repos/octocat/Hello-World/pull/1347\"},\"repository_url\":\"https://api.github.com/repos/batterseapower/pinyin-toolkit\",\"score\":1,\"state\":\"open\",\"title\":\"Line Number Indexes Beyond 20 Not Displayed\",\"updated_at\":\"2009-07-19T09:23:43Z\",\"url\":\"https://api.github.com/repos/batterseapower/pinyin-toolkit/issues/132\",\"user\":{\"avatar_url\":\"https://secure.gravatar.com/avatar/934442aadfe3b2f4630510de416c5718?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png\",\"events_url\":\"https://api.github.com/users/Nick3C/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/Nick3C/followers\",\"following_url\":\"https://api.github.com/users/Nick3C/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/Nick3C/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/Nick3C\",\"id\":90254,\"login\":\"Nick3C\",\"node_id\":\"MDQ6VXNlcjkwMjU0\",\"organizations_url\":\"https://api.github.com/users/Nick3C/orgs\",\"received_events_url\":\"https://api.github.com/users/Nick3C/received_events\",\"repos_url\":\"https://api.github.com/users/Nick3C/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/Nick3C/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/Nick3C/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/Nick3C\"}}],\"total_count\":280}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ SearchIssuesAndPullRequestsOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 SearchIssuesAndPullRequestsOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSearchLabelsForbidden_EncodeDecode(t *testing.T) {
	var typ SearchLabelsForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchLabelsForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSearchLabelsNotFound_EncodeDecode(t *testing.T) {
	var typ SearchLabelsNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchLabelsNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSearchLabelsOK_EncodeDecode(t *testing.T) {
	var typ SearchLabelsOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchLabelsOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSearchLabelsOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"incomplete_results\":false,\"items\":[{\"color\":\"84b6eb\",\"default\":true,\"description\":\"New feature or request.\",\"id\":418327088,\"name\":\"enhancement\",\"node_id\":\"MDU6TGFiZWw0MTgzMjcwODg=\",\"score\":1,\"url\":\"https://api.github.com/repos/octocat/linguist/labels/enhancement\"},{\"color\":\"ee0701\",\"default\":true,\"description\":\"Something isn't working.\",\"id\":418327086,\"name\":\"bug\",\"node_id\":\"MDU6TGFiZWw0MTgzMjcwODY=\",\"score\":1,\"url\":\"https://api.github.com/repos/octocat/linguist/labels/bug\"}],\"total_count\":2}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ SearchLabelsOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 SearchLabelsOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSearchReposOK_EncodeDecode(t *testing.T) {
	var typ SearchReposOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchReposOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSearchReposOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"incomplete_results\":false,\"items\":[{\"archive_url\":\"https://api.github.com/repos/dtrupenn/Tetris/{archive_format}{/ref}\",\"archived\":true,\"assignees_url\":\"https://api.github.com/repos/dtrupenn/Tetris/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/dtrupenn/Tetris/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/dtrupenn/Tetris/branches{/branch}\",\"clone_url\":\"https://github.com/dtrupenn/Tetris.git\",\"collaborators_url\":\"https://api.github.com/repos/dtrupenn/Tetris/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/dtrupenn/Tetris/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/dtrupenn/Tetris/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/dtrupenn/Tetris/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/dtrupenn/Tetris/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/dtrupenn/Tetris/contributors\",\"created_at\":\"2012-01-01T00:31:50Z\",\"default_branch\":\"master\",\"deployments_url\":\"https://api.github.com/repos/dtrupenn/Tetris/deployments\",\"description\":\"A C implementation of Tetris using Pennsim through LC4\",\"disabled\":true,\"downloads_url\":\"https://api.github.com/repos/dtrupenn/Tetris/downloads\",\"events_url\":\"https://api.github.com/repos/dtrupenn/Tetris/events\",\"fork\":false,\"forks\":1,\"forks_count\":0,\"forks_url\":\"https://api.github.com/repos/dtrupenn/Tetris/forks\",\"full_name\":\"dtrupenn/Tetris\",\"git_commits_url\":\"https://api.github.com/repos/dtrupenn/Tetris/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/dtrupenn/Tetris/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/dtrupenn/Tetris/git/tags{/sha}\",\"git_url\":\"git:github.com/dtrupenn/Tetris.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":true,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/dtrupenn/Tetris/hooks\",\"html_url\":\"https://github.com/dtrupenn/Tetris\",\"id\":3081286,\"issue_comment_url\":\"https://api.github.com/repos/dtrupenn/Tetris/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/dtrupenn/Tetris/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/dtrupenn/Tetris/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/dtrupenn/Tetris/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/dtrupenn/Tetris/labels{/name}\",\"language\":\"Assembly\",\"languages_url\":\"https://api.github.com/repos/dtrupenn/Tetris/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"master_branch\":\"master\",\"merges_url\":\"https://api.github.com/repos/dtrupenn/Tetris/merges\",\"milestones_url\":\"https://api.github.com/repos/dtrupenn/Tetris/milestones{/number}\",\"mirror_url\":\"git:git.example.com/dtrupenn/Tetris\",\"name\":\"Tetris\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkzMDgxMjg2\",\"notifications_url\":\"https://api.github.com/repos/dtrupenn/Tetris/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://secure.gravatar.com/avatar/e7956084e75f239de85d3a31bc172ace?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":872147,\"login\":\"dtrupenn\",\"node_id\":\"MDQ6VXNlcjg3MjE0Nw==\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/dtrupenn/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/dtrupenn\"},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/dtrupenn/Tetris/pulls{/number}\",\"pushed_at\":\"2012-01-01T00:37:02Z\",\"releases_url\":\"https://api.github.com/repos/dtrupenn/Tetris/releases{/id}\",\"score\":1,\"size\":524,\"ssh_url\":\"git@github.com:dtrupenn/Tetris.git\",\"stargazers_count\":1,\"stargazers_url\":\"https://api.github.com/repos/dtrupenn/Tetris/stargazers\",\"statuses_url\":\"https://api.github.com/repos/dtrupenn/Tetris/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/dtrupenn/Tetris/subscribers\",\"subscription_url\":\"https://api.github.com/repos/dtrupenn/Tetris/subscription\",\"svn_url\":\"https://svn.github.com/dtrupenn/Tetris\",\"tags_url\":\"https://api.github.com/repos/dtrupenn/Tetris/tags\",\"teams_url\":\"https://api.github.com/repos/dtrupenn/Tetris/teams\",\"trees_url\":\"https://api.github.com/repos/dtrupenn/Tetris/git/trees{/sha}\",\"updated_at\":\"2013-01-05T17:58:47Z\",\"url\":\"https://api.github.com/repos/dtrupenn/Tetris\",\"watchers\":1,\"watchers_count\":1}],\"total_count\":40}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ SearchReposOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 SearchReposOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSearchResultTextMatches_EncodeDecode(t *testing.T) {
	var typ SearchResultTextMatches
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchResultTextMatches
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSearchResultTextMatchesItem_EncodeDecode(t *testing.T) {
	var typ SearchResultTextMatchesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchResultTextMatchesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSearchResultTextMatchesItemMatchesItem_EncodeDecode(t *testing.T) {
	var typ SearchResultTextMatchesItemMatchesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchResultTextMatchesItemMatchesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSearchTopicsOK_EncodeDecode(t *testing.T) {
	var typ SearchTopicsOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchTopicsOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSearchTopicsOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"incomplete_results\":false,\"items\":[{\"created_at\":\"2016-11-28T22:03:59Z\",\"created_by\":\"Yukihiro Matsumoto\",\"curated\":true,\"description\":\"Ruby was developed by\u00a0Yukihiro \\\"Matz\\\" Matsumoto\u00a0in 1995 with the intent of having an easily readable programming language. It is integrated with the Rails framework to create dynamic web-applications. Ruby's syntax is similar to that of Perl and Python.\",\"display_name\":\"Ruby\",\"featured\":true,\"name\":\"ruby\",\"released\":\"December 21, 1995\",\"score\":1,\"short_description\":\"Ruby is a scripting language designed for simplified object-oriented programming.\",\"updated_at\":\"2017-10-30T18:16:32Z\"},{\"created_at\":\"2016-12-09T17:03:50Z\",\"created_by\":\"David Heinemeier Hansson\",\"curated\":true,\"description\":\"Ruby on Rails (Rails) is a web application framework written in Ruby. It is meant to help simplify the building of complex websites.\",\"display_name\":\"Rails\",\"featured\":true,\"name\":\"rails\",\"released\":\"December 13 2005\",\"score\":1,\"short_description\":\"Ruby on Rails (Rails) is a web application framework written in Ruby.\",\"updated_at\":\"2017-10-30T16:20:19Z\"},{\"created_at\":\"2016-12-07T00:07:02Z\",\"created_by\":\"Guido van Rossum\",\"curated\":true,\"description\":\"Python is a dynamically typed programming language designed by Guido Van Rossum. Much like the programming language Ruby, Python was designed to be easily read by programmers. Because of its large following and many libraries, Python can be implemented and used to do anything from webpages to scientific research.\",\"display_name\":\"Python\",\"featured\":true,\"name\":\"python\",\"released\":\"February 20, 1991\",\"score\":1,\"short_description\":\"Python is a dynamically typed programming language.\",\"updated_at\":\"2017-10-27T22:45:43Z\"},{\"created_at\":\"2016-12-16T21:53:08Z\",\"created_by\":\"Tom Preston-Werner\",\"curated\":true,\"description\":\"Jekyll is a blog-aware, site generator written in Ruby. It takes raw text files, runs it through a renderer and produces a publishable static website.\",\"display_name\":\"Jekyll\",\"featured\":true,\"name\":\"jekyll\",\"released\":\"2008\",\"score\":1,\"short_description\":\"Jekyll is a simple, blog-aware static site generator.\",\"updated_at\":\"2017-10-27T19:00:24Z\"},{\"created_at\":\"2016-12-16T21:53:45Z\",\"created_by\":\"Hampton Catlin, Natalie Weizenbaum, Chris Eppstein\",\"curated\":true,\"description\":\"Sass is a stylesheet language with a main implementation in Ruby. It is an extension of CSS that makes improvements to the old stylesheet format, such as being able to declare variables and using a cleaner nesting syntax.\",\"display_name\":\"Sass\",\"featured\":true,\"name\":\"sass\",\"released\":\"November 28, 2006\",\"score\":1,\"short_description\":\"Sass is a stable extension to classic CSS.\",\"updated_at\":\"2018-01-16T16:30:40Z\"},{\"created_at\":\"2016-12-17T20:30:44Z\",\"created_by\":\"Max Howell\",\"curated\":true,\"description\":\"Homebrew is a package manager for Apple's macOS operating system. It simplifies the installation of software and is popular in the Ruby on Rails community.\",\"display_name\":\"Homebrew\",\"featured\":true,\"name\":\"homebrew\",\"released\":\"2009\",\"score\":1,\"short_description\":\"Homebrew is a package manager for macOS.\",\"updated_at\":\"2018-02-06T16:14:56Z\"}],\"total_count\":6}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ SearchTopicsOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 SearchTopicsOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSearchUsersOK_EncodeDecode(t *testing.T) {
	var typ SearchUsersOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SearchUsersOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSearchUsersOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"incomplete_results\":false,\"items\":[{\"avatar_url\":\"https://secure.gravatar.com/avatar/25c7c18223fb42a4c6ae1c8db6f50f9b?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png\",\"events_url\":\"https://api.github.com/users/mojombo/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/mojombo/followers\",\"following_url\":\"https://api.github.com/users/mojombo/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/mojombo/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/mojombo\",\"id\":1,\"login\":\"mojombo\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/mojombo/orgs\",\"received_events_url\":\"https://api.github.com/users/mojombo/received_events\",\"repos_url\":\"https://api.github.com/users/mojombo/repos\",\"score\":1,\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/mojombo/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/mojombo/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/mojombo\"}],\"total_count\":12}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ SearchUsersOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 SearchUsersOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSecretScanningAlert_EncodeDecode(t *testing.T) {
	var typ SecretScanningAlert
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SecretScanningAlert
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSecretScanningAlert_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2020-11-06T18:18:30Z\",\"html_url\":\"https://github.com/owner/private-repo/security/secret-scanning/42\",\"number\":42,\"resolution\":\"used_in_tests\",\"resolved_at\":\"2020-11-16T22:42:07Z\",\"resolved_by\":{\"avatar_url\":\"https://alambic.github.com/avatars/u/2?\",\"events_url\":\"https://api.github.com/users/monalisa/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/monalisa/followers\",\"following_url\":\"https://api.github.com/users/monalisa/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/monalisa/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/monalisa\",\"id\":2,\"login\":\"monalisa\",\"node_id\":\"MDQ6VXNlcjI=\",\"organizations_url\":\"https://api.github.com/users/monalisa/orgs\",\"received_events_url\":\"https://api.github.com/users/monalisa/received_events\",\"repos_url\":\"https://api.github.com/users/monalisa/repos\",\"site_admin\":true,\"starred_url\":\"https://api.github.com/users/monalisa/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/monalisa/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/monalisa\"},\"secret\":\"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX-us2\",\"secret_type\":\"mailchimp_api_key\",\"state\":\"resolved\",\"url\":\"https://api.github.com/repos/owner/private-repo/secret-scanning/alerts/42\"}"},
		{Input: "{\"created_at\":\"2020-11-06T18:18:30Z\",\"html_url\":\"https://github.com/owner/private-repo/security/secret-scanning/42\",\"number\":42,\"resolution\":null,\"resolved_at\":null,\"resolved_by\":null,\"secret\":\"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX-us2\",\"secret_type\":\"mailchimp_api_key\",\"state\":\"open\",\"url\":\"https://api.github.com/repos/owner/private-repo/secret-scanning/alerts/42\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ SecretScanningAlert

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 SecretScanningAlert
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSecretScanningAlertResolution_EncodeDecode(t *testing.T) {
	var typ SecretScanningAlertResolution
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SecretScanningAlertResolution
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSecretScanningAlertState_EncodeDecode(t *testing.T) {
	var typ SecretScanningAlertState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SecretScanningAlertState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSecretScanningListAlertsForRepoOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ SecretScanningListAlertsForRepoOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SecretScanningListAlertsForRepoOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSecretScanningUpdateAlertReq_EncodeDecode(t *testing.T) {
	var typ SecretScanningUpdateAlertReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SecretScanningUpdateAlertReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSecretScanningUpdateAlertReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"resolution\":\"false_positive\",\"state\":\"resolved\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ SecretScanningUpdateAlertReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 SecretScanningUpdateAlertReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSelectedActions_EncodeDecode(t *testing.T) {
	var typ SelectedActions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SelectedActions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestSelectedActions_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"github_owned_allowed\":true,\"patterns_allowed\":[\"monalisa/octocat@*\",\"docker/*\"],\"verified_allowed\":false}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ SelectedActions

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 SelectedActions
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSelectedActionsURL_EncodeDecode(t *testing.T) {
	var typ SelectedActionsURL
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SelectedActionsURL
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServiceUnavailable_EncodeDecode(t *testing.T) {
	var typ ServiceUnavailable
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServiceUnavailable
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShortBlob_EncodeDecode(t *testing.T) {
	var typ ShortBlob
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShortBlob
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestShortBlob_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"sha\":\"3a0f86fb8db8eea7ccbb9a95f325ddbedfb25e15\",\"url\":\"https://api.github.com/repos/octocat/example/git/blobs/3a0f86fb8db8eea7ccbb9a95f325ddbedfb25e15\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ShortBlob

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ShortBlob
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestShortBranch_EncodeDecode(t *testing.T) {
	var typ ShortBranch
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShortBranch
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestShortBranchCommit_EncodeDecode(t *testing.T) {
	var typ ShortBranchCommit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ShortBranchCommit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSimpleCommit_EncodeDecode(t *testing.T) {
	var typ SimpleCommit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SimpleCommit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSimpleCommitAuthor_EncodeDecode(t *testing.T) {
	var typ SimpleCommitAuthor
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SimpleCommitAuthor
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSimpleCommitCommitter_EncodeDecode(t *testing.T) {
	var typ SimpleCommitCommitter
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SimpleCommitCommitter
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSimpleCommitStatus_EncodeDecode(t *testing.T) {
	var typ SimpleCommitStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SimpleCommitStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSimpleUser_EncodeDecode(t *testing.T) {
	var typ SimpleUser
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SimpleUser
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStatus_EncodeDecode(t *testing.T) {
	var typ Status
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Status
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"avatar_url\":\"https://github.com/images/error/hubot_happy.gif\",\"context\":\"continuous-integration/jenkins\",\"created_at\":\"2012-07-20T01:19:13Z\",\"creator\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"description\":\"Build has completed successfully\",\"id\":1,\"node_id\":\"MDY6U3RhdHVzMQ==\",\"state\":\"success\",\"target_url\":\"https://ci.example.com/1000/output\",\"updated_at\":\"2012-07-20T01:19:13Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/6dcb09b5b57875f334f61aebed695e2e4193db5e\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Status

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Status
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestStatusCheckPolicy_EncodeDecode(t *testing.T) {
	var typ StatusCheckPolicy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StatusCheckPolicy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestStatusCheckPolicy_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"contexts\":[\"continuous-integration/travis-ci\"],\"contexts_url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/required_status_checks/contexts\",\"strict\":true,\"url\":\"https://api.github.com/repos/octocat/Hello-World/branches/master/protection/required_status_checks\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ StatusCheckPolicy

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 StatusCheckPolicy
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTag_EncodeDecode(t *testing.T) {
	var typ Tag
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Tag
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTagCommit_EncodeDecode(t *testing.T) {
	var typ TagCommit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TagCommit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeam_EncodeDecode(t *testing.T) {
	var typ Team
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Team
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamDiscussion_EncodeDecode(t *testing.T) {
	var typ TeamDiscussion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamDiscussion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamDiscussion_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"author\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"body\":\"Hi! This is an area for us to collaborate as a team.\",\"body_html\":\"\\u003cp\\u003eHi! This is an area for us to collaborate as a team\\u003c/p\\u003e\",\"body_version\":\"0d495416a700fb06133c612575d92bfb\",\"comments_count\":0,\"comments_url\":\"https://api.github.com/teams/2343027/discussions/1/comments\",\"created_at\":\"2018-01-25T18:56:31Z\",\"html_url\":\"https://github.com/orgs/github/teams/justice-league/discussions/1\",\"last_edited_at\":null,\"node_id\":\"MDE0OlRlYW1EaXNjdXNzaW9uMQ==\",\"number\":1,\"pinned\":false,\"private\":false,\"reactions\":{\"+1\":3,\"-1\":1,\"confused\":0,\"eyes\":1,\"heart\":1,\"hooray\":0,\"laugh\":0,\"rocket\":1,\"total_count\":5,\"url\":\"https://api.github.com/teams/2343027/discussions/1/reactions\"},\"team_url\":\"https://api.github.com/teams/2343027\",\"title\":\"Our first team post\",\"updated_at\":\"2018-01-25T18:56:31Z\",\"url\":\"https://api.github.com/teams/2343027/discussions/1\"}"},
		{Input: "{\"author\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"body\":\"Hi! This is an area for us to collaborate as a team.\",\"body_html\":\"\\u003cp\\u003eHi! This is an area for us to collaborate as a team\\u003c/p\\u003e\",\"body_version\":\"0d495416a700fb06133c612575d92bfb\",\"comments_count\":1,\"comments_url\":\"https://api.github.com/teams/2343027/discussions/1/comments\",\"created_at\":\"2018-01-25T18:56:31Z\",\"html_url\":\"https://github.com/orgs/github/teams/justice-league/discussions/1\",\"last_edited_at\":\"2018-01-26T18:22:20Z\",\"node_id\":\"MDE0OlRlYW1EaXNjdXNzaW9uMQ==\",\"number\":1,\"pinned\":false,\"private\":false,\"reactions\":{\"+1\":3,\"-1\":1,\"confused\":0,\"eyes\":1,\"heart\":1,\"hooray\":0,\"laugh\":0,\"rocket\":1,\"total_count\":5,\"url\":\"https://api.github.com/teams/2343027/discussions/1/reactions\"},\"team_url\":\"https://api.github.com/teams/2343027\",\"title\":\"Welcome to our first team post\",\"updated_at\":\"2018-01-26T18:22:20Z\",\"url\":\"https://api.github.com/teams/2343027/discussions/1\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamDiscussion

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamDiscussion
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamDiscussionComment_EncodeDecode(t *testing.T) {
	var typ TeamDiscussionComment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamDiscussionComment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamDiscussionComment_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"author\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"body\":\"Do you like apples?\",\"body_html\":\"\\u003cp\\u003eDo you like apples?\\u003c/p\\u003e\",\"body_version\":\"5eb32b219cdc6a5a9b29ba5d6caa9c51\",\"created_at\":\"2018-01-15T23:53:58Z\",\"discussion_url\":\"https://api.github.com/teams/2403582/discussions/1\",\"html_url\":\"https://github.com/orgs/github/teams/justice-league/discussions/1/comments/1\",\"last_edited_at\":null,\"node_id\":\"MDIxOlRlYW1EaXNjdXNzaW9uQ29tbWVudDE=\",\"number\":1,\"reactions\":{\"+1\":3,\"-1\":1,\"confused\":0,\"eyes\":1,\"heart\":1,\"hooray\":0,\"laugh\":0,\"rocket\":1,\"total_count\":5,\"url\":\"https://api.github.com/teams/2403582/discussions/1/reactions\"},\"updated_at\":\"2018-01-15T23:53:58Z\",\"url\":\"https://api.github.com/teams/2403582/discussions/1/comments/1\"}"},
		{Input: "{\"author\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"body\":\"Do you like pineapples?\",\"body_html\":\"\\u003cp\\u003eDo you like pineapples?\\u003c/p\\u003e\",\"body_version\":\"e6907b24d9c93cc0c5024a7af5888116\",\"created_at\":\"2018-01-15T23:53:58Z\",\"discussion_url\":\"https://api.github.com/teams/2403582/discussions/1\",\"html_url\":\"https://github.com/orgs/github/teams/justice-league/discussions/1/comments/1\",\"last_edited_at\":\"2018-01-26T18:22:20Z\",\"node_id\":\"MDIxOlRlYW1EaXNjdXNzaW9uQ29tbWVudDE=\",\"number\":1,\"reactions\":{\"+1\":3,\"-1\":1,\"confused\":0,\"eyes\":1,\"heart\":1,\"hooray\":0,\"laugh\":0,\"rocket\":1,\"total_count\":5,\"url\":\"https://api.github.com/teams/2403582/discussions/1/reactions\"},\"updated_at\":\"2018-01-26T18:22:20Z\",\"url\":\"https://api.github.com/teams/2403582/discussions/1/comments/1\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamDiscussionComment

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamDiscussionComment
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamFull_EncodeDecode(t *testing.T) {
	var typ TeamFull
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamFull
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamFull_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2017-07-14T16:53:42Z\",\"description\":\"A great team.\",\"html_url\":\"https://github.com/orgs/github/teams/justice-league\",\"id\":1,\"members_count\":3,\"members_url\":\"https://api.github.com/teams/1/members{/member}\",\"name\":\"Justice League\",\"node_id\":\"MDQ6VGVhbTE=\",\"organization\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"blog\":\"https://github.com/blog\",\"company\":\"GitHub\",\"created_at\":\"2008-01-14T04:33:35Z\",\"description\":\"A great organization\",\"email\":\"octocat@github.com\",\"events_url\":\"https://api.github.com/orgs/github/events\",\"followers\":20,\"following\":0,\"has_organization_projects\":true,\"has_repository_projects\":true,\"hooks_url\":\"https://api.github.com/orgs/github/hooks\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"is_verified\":true,\"issues_url\":\"https://api.github.com/orgs/github/issues\",\"location\":\"San Francisco\",\"login\":\"github\",\"members_url\":\"https://api.github.com/orgs/github/members{/member}\",\"name\":\"github\",\"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjE=\",\"public_gists\":1,\"public_members_url\":\"https://api.github.com/orgs/github/public_members{/member}\",\"public_repos\":2,\"repos_url\":\"https://api.github.com/orgs/github/repos\",\"type\":\"Organization\",\"updated_at\":\"2017-08-17T12:37:15Z\",\"url\":\"https://api.github.com/orgs/github\"},\"parent\":null,\"permission\":\"admin\",\"privacy\":\"closed\",\"repos_count\":10,\"repositories_url\":\"https://api.github.com/teams/1/repos\",\"slug\":\"justice-league\",\"updated_at\":\"2017-08-17T12:37:15Z\",\"url\":\"https://api.github.com/teams/1\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamFull

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamFull
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamFullPrivacy_EncodeDecode(t *testing.T) {
	var typ TeamFullPrivacy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamFullPrivacy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamFullPrivacy_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"closed\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamFullPrivacy

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamFullPrivacy
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamMembership_EncodeDecode(t *testing.T) {
	var typ TeamMembership
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamMembership
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamMembership_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"role\":\"maintainer\",\"state\":\"active\",\"url\":\"https://api.github.com/teams/1/memberships/octocat\"}"},
		{Input: "{\"role\":\"member\",\"state\":\"pending\",\"url\":\"https://api.github.com/teams/1/memberships/octocat\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamMembership

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamMembership
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamMembershipRole_EncodeDecode(t *testing.T) {
	var typ TeamMembershipRole
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamMembershipRole
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamMembershipRole_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"member\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamMembershipRole

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamMembershipRole
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamMembershipState_EncodeDecode(t *testing.T) {
	var typ TeamMembershipState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamMembershipState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamPermissions_EncodeDecode(t *testing.T) {
	var typ TeamPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamProject_EncodeDecode(t *testing.T) {
	var typ TeamProject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamProject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamProject_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"High-level roadmap for the upcoming year.\",\"columns_url\":\"https://api.github.com/projects/1002605/columns\",\"created_at\":\"2011-04-11T20:09:31Z\",\"creator\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"html_url\":\"https://github.com/orgs/api-playground/projects/1\",\"id\":1002605,\"name\":\"Organization Roadmap\",\"node_id\":\"MDc6UHJvamVjdDEwMDI2MDU=\",\"number\":1,\"organization_permission\":\"write\",\"owner_url\":\"https://api.github.com/orgs/octocat\",\"permissions\":{\"admin\":false,\"read\":true,\"write\":true},\"private\":false,\"state\":\"open\",\"updated_at\":\"2014-03-04T18:58:10Z\",\"url\":\"https://api.github.com/projects/1002605\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamProject

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamProject
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamProjectPermissions_EncodeDecode(t *testing.T) {
	var typ TeamProjectPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamProjectPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamRepository_EncodeDecode(t *testing.T) {
	var typ TeamRepository
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamRepository
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamRepository_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks\":1,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"is_template\":false,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World\",\"name\":\"Hello-World\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"open_issues\":1,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"template_repository\":{\"allow_auto_merge\":false,\"allow_merge_commit\":true,\"allow_rebase_merge\":true,\"allow_squash_merge\":true,\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/{archive_format}{/ref}\",\"archived\":false,\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/branches{/branch}\",\"clone_url\":\"https://github.com/octocat/Hello-World-Template.git\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/contributors\",\"created_at\":\"2011-01-26T19:01:12Z\",\"default_branch\":\"master\",\"delete_branch_on_merge\":true,\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/deployments\",\"description\":\"This your first repo!\",\"disabled\":false,\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/events\",\"fork\":false,\"forks\":9,\"forks_count\":9,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/forks\",\"full_name\":\"octocat/Hello-World-Template\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World-Template.git\",\"has_downloads\":true,\"has_issues\":true,\"has_pages\":false,\"has_projects\":true,\"has_wiki\":true,\"homepage\":\"https://github.com\",\"hooks_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World-Template\",\"id\":1296269,\"is_template\":true,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/labels{/name}\",\"language\":null,\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/languages\",\"license\":{\"html_url\":\"https://api.github.com/licenses/mit\",\"key\":\"mit\",\"name\":\"MIT License\",\"node_id\":\"MDc6TGljZW5zZW1pdA==\",\"spdx_id\":\"MIT\",\"url\":\"https://api.github.com/licenses/mit\"},\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/milestones{/number}\",\"mirror_url\":\"git:git.example.com/octocat/Hello-World-Template\",\"name\":\"Hello-World-Template\",\"network_count\":0,\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/notifications{?since,all,participating}\",\"open_issues\":0,\"open_issues_count\":0,\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"permissions\":{\"admin\":false,\"pull\":true,\"push\":false},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/pulls{/number}\",\"pushed_at\":\"2011-01-26T19:06:43Z\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/releases{/id}\",\"size\":108,\"ssh_url\":\"git@github.com:octocat/Hello-World-Template.git\",\"stargazers_count\":80,\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/statuses/{sha}\",\"subscribers_count\":42,\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/subscription\",\"svn_url\":\"https://svn.github.com/octocat/Hello-World-Template\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/teams\",\"temp_clone_token\":\"ABTLWHOULUVAXGTRYU7OC2876QJ2O\",\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World-Template/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World-Template\",\"visibility\":\"public\",\"watchers\":80,\"watchers_count\":80},\"topics\":[\"octocat\",\"atom\",\"electron\",\"api\"],\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"updated_at\":\"2011-01-26T19:14:43Z\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\",\"visibility\":\"public\",\"watchers\":1,\"watchers_count\":80}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamRepository

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamRepository
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamRepositoryPermissions_EncodeDecode(t *testing.T) {
	var typ TeamRepositoryPermissions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamRepositoryPermissions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamSimple_EncodeDecode(t *testing.T) {
	var typ TeamSimple
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamSimple
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsAddOrUpdateMembershipForUserInOrgReq_EncodeDecode(t *testing.T) {
	var typ TeamsAddOrUpdateMembershipForUserInOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsAddOrUpdateMembershipForUserInOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsAddOrUpdateMembershipForUserInOrgReqRole_EncodeDecode(t *testing.T) {
	var typ TeamsAddOrUpdateMembershipForUserInOrgReqRole
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsAddOrUpdateMembershipForUserInOrgReqRole
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsAddOrUpdateMembershipForUserLegacyReq_EncodeDecode(t *testing.T) {
	var typ TeamsAddOrUpdateMembershipForUserLegacyReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsAddOrUpdateMembershipForUserLegacyReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsAddOrUpdateMembershipForUserLegacyReqRole_EncodeDecode(t *testing.T) {
	var typ TeamsAddOrUpdateMembershipForUserLegacyReqRole
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsAddOrUpdateMembershipForUserLegacyReqRole
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsAddOrUpdateProjectPermissionsInOrgForbidden_EncodeDecode(t *testing.T) {
	var typ TeamsAddOrUpdateProjectPermissionsInOrgForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsAddOrUpdateProjectPermissionsInOrgForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamsAddOrUpdateProjectPermissionsInOrgForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"documentation_url\":\"https://docs.github.com/rest/reference/teams#add-or-update-team-project-permissions\",\"message\":\"Must have admin rights to Repository.\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamsAddOrUpdateProjectPermissionsInOrgForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamsAddOrUpdateProjectPermissionsInOrgForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamsAddOrUpdateProjectPermissionsInOrgReq_EncodeDecode(t *testing.T) {
	var typ TeamsAddOrUpdateProjectPermissionsInOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsAddOrUpdateProjectPermissionsInOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsAddOrUpdateProjectPermissionsInOrgReqPermission_EncodeDecode(t *testing.T) {
	var typ TeamsAddOrUpdateProjectPermissionsInOrgReqPermission
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsAddOrUpdateProjectPermissionsInOrgReqPermission
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsAddOrUpdateProjectPermissionsLegacyForbidden_EncodeDecode(t *testing.T) {
	var typ TeamsAddOrUpdateProjectPermissionsLegacyForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsAddOrUpdateProjectPermissionsLegacyForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamsAddOrUpdateProjectPermissionsLegacyForbidden_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"documentation_url\":\"https://docs.github.com/rest/reference/teams#add-or-update-team-project-permissions\",\"message\":\"Must have admin rights to Repository.\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamsAddOrUpdateProjectPermissionsLegacyForbidden

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamsAddOrUpdateProjectPermissionsLegacyForbidden
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamsAddOrUpdateProjectPermissionsLegacyReq_EncodeDecode(t *testing.T) {
	var typ TeamsAddOrUpdateProjectPermissionsLegacyReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsAddOrUpdateProjectPermissionsLegacyReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsAddOrUpdateProjectPermissionsLegacyReqPermission_EncodeDecode(t *testing.T) {
	var typ TeamsAddOrUpdateProjectPermissionsLegacyReqPermission
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsAddOrUpdateProjectPermissionsLegacyReqPermission
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsAddOrUpdateRepoPermissionsInOrgReq_EncodeDecode(t *testing.T) {
	var typ TeamsAddOrUpdateRepoPermissionsInOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsAddOrUpdateRepoPermissionsInOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsAddOrUpdateRepoPermissionsInOrgReqPermission_EncodeDecode(t *testing.T) {
	var typ TeamsAddOrUpdateRepoPermissionsInOrgReqPermission
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsAddOrUpdateRepoPermissionsInOrgReqPermission
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsAddOrUpdateRepoPermissionsLegacyReq_EncodeDecode(t *testing.T) {
	var typ TeamsAddOrUpdateRepoPermissionsLegacyReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsAddOrUpdateRepoPermissionsLegacyReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsAddOrUpdateRepoPermissionsLegacyReqPermission_EncodeDecode(t *testing.T) {
	var typ TeamsAddOrUpdateRepoPermissionsLegacyReqPermission
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsAddOrUpdateRepoPermissionsLegacyReqPermission
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsCreateDiscussionCommentInOrgReq_EncodeDecode(t *testing.T) {
	var typ TeamsCreateDiscussionCommentInOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsCreateDiscussionCommentInOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamsCreateDiscussionCommentInOrgReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"Do you like apples?\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamsCreateDiscussionCommentInOrgReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamsCreateDiscussionCommentInOrgReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamsCreateDiscussionCommentLegacyReq_EncodeDecode(t *testing.T) {
	var typ TeamsCreateDiscussionCommentLegacyReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsCreateDiscussionCommentLegacyReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamsCreateDiscussionCommentLegacyReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"Do you like apples?\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamsCreateDiscussionCommentLegacyReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamsCreateDiscussionCommentLegacyReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamsCreateDiscussionInOrgReq_EncodeDecode(t *testing.T) {
	var typ TeamsCreateDiscussionInOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsCreateDiscussionInOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamsCreateDiscussionInOrgReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"Hi! This is an area for us to collaborate as a team.\",\"title\":\"Our first team post\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamsCreateDiscussionInOrgReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamsCreateDiscussionInOrgReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamsCreateDiscussionLegacyReq_EncodeDecode(t *testing.T) {
	var typ TeamsCreateDiscussionLegacyReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsCreateDiscussionLegacyReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamsCreateDiscussionLegacyReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"Hi! This is an area for us to collaborate as a team.\",\"title\":\"Our first team post\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamsCreateDiscussionLegacyReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamsCreateDiscussionLegacyReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamsCreateOrUpdateIdpGroupConnectionsInOrgReq_EncodeDecode(t *testing.T) {
	var typ TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamsCreateOrUpdateIdpGroupConnectionsInOrgReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"groups\":[{\"group_description\":\"string\",\"group_id\":\"123\",\"group_name\":\"Octocat admins\"}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem_EncodeDecode(t *testing.T) {
	var typ TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsCreateOrUpdateIdpGroupConnectionsLegacyReq_EncodeDecode(t *testing.T) {
	var typ TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamsCreateOrUpdateIdpGroupConnectionsLegacyReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"groups\":[{\"description\":\"The people who configure your octoworld.\",\"group_description\":\"string\",\"group_id\":\"123\",\"group_name\":\"Octocat admins\"}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem_EncodeDecode(t *testing.T) {
	var typ TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsCreateReq_EncodeDecode(t *testing.T) {
	var typ TeamsCreateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsCreateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamsCreateReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"A great team\",\"name\":\"Justice League\",\"permission\":\"admin\",\"privacy\":\"closed\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamsCreateReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamsCreateReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamsCreateReqPermission_EncodeDecode(t *testing.T) {
	var typ TeamsCreateReqPermission
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsCreateReqPermission
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsCreateReqPrivacy_EncodeDecode(t *testing.T) {
	var typ TeamsCreateReqPrivacy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsCreateReqPrivacy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsListChildLegacyForbidden_EncodeDecode(t *testing.T) {
	var typ TeamsListChildLegacyForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsListChildLegacyForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsListChildLegacyNotFound_EncodeDecode(t *testing.T) {
	var typ TeamsListChildLegacyNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsListChildLegacyNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsListForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ TeamsListForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsListForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsListForAuthenticatedUserNotFound_EncodeDecode(t *testing.T) {
	var typ TeamsListForAuthenticatedUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsListForAuthenticatedUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsListIdpGroupsForLegacyForbidden_EncodeDecode(t *testing.T) {
	var typ TeamsListIdpGroupsForLegacyForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsListIdpGroupsForLegacyForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsListIdpGroupsForLegacyNotFound_EncodeDecode(t *testing.T) {
	var typ TeamsListIdpGroupsForLegacyNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsListIdpGroupsForLegacyNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsUpdateDiscussionCommentInOrgReq_EncodeDecode(t *testing.T) {
	var typ TeamsUpdateDiscussionCommentInOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsUpdateDiscussionCommentInOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamsUpdateDiscussionCommentInOrgReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"Do you like pineapples?\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamsUpdateDiscussionCommentInOrgReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamsUpdateDiscussionCommentInOrgReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamsUpdateDiscussionCommentLegacyReq_EncodeDecode(t *testing.T) {
	var typ TeamsUpdateDiscussionCommentLegacyReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsUpdateDiscussionCommentLegacyReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamsUpdateDiscussionCommentLegacyReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"body\":\"Do you like pineapples?\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamsUpdateDiscussionCommentLegacyReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamsUpdateDiscussionCommentLegacyReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamsUpdateDiscussionInOrgReq_EncodeDecode(t *testing.T) {
	var typ TeamsUpdateDiscussionInOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsUpdateDiscussionInOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamsUpdateDiscussionInOrgReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"title\":\"Welcome to our first team post\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamsUpdateDiscussionInOrgReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamsUpdateDiscussionInOrgReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamsUpdateDiscussionLegacyReq_EncodeDecode(t *testing.T) {
	var typ TeamsUpdateDiscussionLegacyReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsUpdateDiscussionLegacyReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamsUpdateDiscussionLegacyReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"title\":\"Welcome to our first team post\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamsUpdateDiscussionLegacyReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamsUpdateDiscussionLegacyReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamsUpdateInOrgReq_EncodeDecode(t *testing.T) {
	var typ TeamsUpdateInOrgReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsUpdateInOrgReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamsUpdateInOrgReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"new team description\",\"name\":\"new team name\",\"privacy\":\"closed\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamsUpdateInOrgReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamsUpdateInOrgReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamsUpdateInOrgReqPermission_EncodeDecode(t *testing.T) {
	var typ TeamsUpdateInOrgReqPermission
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsUpdateInOrgReqPermission
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsUpdateInOrgReqPrivacy_EncodeDecode(t *testing.T) {
	var typ TeamsUpdateInOrgReqPrivacy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsUpdateInOrgReqPrivacy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsUpdateLegacyCreated_EncodeDecode(t *testing.T) {
	var typ TeamsUpdateLegacyCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsUpdateLegacyCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsUpdateLegacyForbidden_EncodeDecode(t *testing.T) {
	var typ TeamsUpdateLegacyForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsUpdateLegacyForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsUpdateLegacyNotFound_EncodeDecode(t *testing.T) {
	var typ TeamsUpdateLegacyNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsUpdateLegacyNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsUpdateLegacyOK_EncodeDecode(t *testing.T) {
	var typ TeamsUpdateLegacyOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsUpdateLegacyOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsUpdateLegacyReq_EncodeDecode(t *testing.T) {
	var typ TeamsUpdateLegacyReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsUpdateLegacyReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTeamsUpdateLegacyReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"description\":\"new team description\",\"name\":\"new team name\",\"privacy\":\"closed\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ TeamsUpdateLegacyReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 TeamsUpdateLegacyReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTeamsUpdateLegacyReqPermission_EncodeDecode(t *testing.T) {
	var typ TeamsUpdateLegacyReqPermission
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsUpdateLegacyReqPermission
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeamsUpdateLegacyReqPrivacy_EncodeDecode(t *testing.T) {
	var typ TeamsUpdateLegacyReqPrivacy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TeamsUpdateLegacyReqPrivacy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThread_EncodeDecode(t *testing.T) {
	var typ Thread
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Thread
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestThread_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":\"1\",\"last_read_at\":\"2014-11-07T22:01:45Z\",\"reason\":\"subscribed\",\"repository\":{\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"hooks_url\":\"http://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"name\":\"Hello-World\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\"},\"subject\":{\"latest_comment_url\":\"https://api.github.com/repos/octokit/octokit.rb/issues/comments/123\",\"title\":\"Greetings\",\"type\":\"Issue\",\"url\":\"https://api.github.com/repos/octokit/octokit.rb/issues/123\"},\"subscription_url\":\"https://api.github.com/notifications/threads/1/subscription\",\"unread\":true,\"updated_at\":\"2014-11-07T22:01:45Z\",\"url\":\"https://api.github.com/notifications/threads/1\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Thread

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Thread
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestThreadSubject_EncodeDecode(t *testing.T) {
	var typ ThreadSubject
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreadSubject
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThreadSubscription_EncodeDecode(t *testing.T) {
	var typ ThreadSubscription
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreadSubscription
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestThreadSubscription_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2012-10-06T21:34:12Z\",\"ignored\":false,\"reason\":null,\"subscribed\":true,\"thread_url\":\"https://api.github.com/notifications/threads/1\",\"url\":\"https://api.github.com/notifications/threads/1/subscription\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ThreadSubscription

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ThreadSubscription
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTopic_EncodeDecode(t *testing.T) {
	var typ Topic
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Topic
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestTopic_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"names\":[\"octocat\",\"atom\",\"electron\",\"api\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Topic

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Topic
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestTopicSearchResultItem_EncodeDecode(t *testing.T) {
	var typ TopicSearchResultItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TopicSearchResultItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTopicSearchResultItemAliasesItem_EncodeDecode(t *testing.T) {
	var typ TopicSearchResultItemAliasesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TopicSearchResultItemAliasesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTopicSearchResultItemAliasesItemTopicRelation_EncodeDecode(t *testing.T) {
	var typ TopicSearchResultItemAliasesItemTopicRelation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TopicSearchResultItemAliasesItemTopicRelation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTopicSearchResultItemRelatedItem_EncodeDecode(t *testing.T) {
	var typ TopicSearchResultItemRelatedItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TopicSearchResultItemRelatedItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTopicSearchResultItemRelatedItemTopicRelation_EncodeDecode(t *testing.T) {
	var typ TopicSearchResultItemRelatedItemTopicRelation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TopicSearchResultItemRelatedItemTopicRelation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTraffic_EncodeDecode(t *testing.T) {
	var typ Traffic
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Traffic
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserMarketplacePurchase_EncodeDecode(t *testing.T) {
	var typ UserMarketplacePurchase
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserMarketplacePurchase
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserSearchResultItem_EncodeDecode(t *testing.T) {
	var typ UserSearchResultItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserSearchResultItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersAddEmailForAuthenticatedCreatedApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UsersAddEmailForAuthenticatedCreatedApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersAddEmailForAuthenticatedCreatedApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersAddEmailForAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersAddEmailForAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersAddEmailForAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersAddEmailForAuthenticatedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersAddEmailForAuthenticatedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersAddEmailForAuthenticatedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersAddEmailForAuthenticatedReq_EncodeDecode(t *testing.T) {
	var typ UsersAddEmailForAuthenticatedReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersAddEmailForAuthenticatedReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersAddEmailForAuthenticatedReq0_EncodeDecode(t *testing.T) {
	var typ UsersAddEmailForAuthenticatedReq0
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersAddEmailForAuthenticatedReq0
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUsersAddEmailForAuthenticatedReq0_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"emails\":[\"octocat@github.com\",\"mona@github.com\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UsersAddEmailForAuthenticatedReq0

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UsersAddEmailForAuthenticatedReq0
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUsersAddEmailForAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersAddEmailForAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersAddEmailForAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersBlockForbidden_EncodeDecode(t *testing.T) {
	var typ UsersBlockForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersBlockForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersBlockNotFound_EncodeDecode(t *testing.T) {
	var typ UsersBlockNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersBlockNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersBlockUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersBlockUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersBlockUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersCheckBlockedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersCheckBlockedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersCheckBlockedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersCheckBlockedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersCheckBlockedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersCheckBlockedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersCheckBlockedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersCheckBlockedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersCheckBlockedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersCheckPersonIsFollowedByAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersCheckPersonIsFollowedByAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersCheckPersonIsFollowedByAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersCheckPersonIsFollowedByAuthenticatedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersCheckPersonIsFollowedByAuthenticatedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersCheckPersonIsFollowedByAuthenticatedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersCheckPersonIsFollowedByAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersCheckPersonIsFollowedByAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersCheckPersonIsFollowedByAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersCreateGpgKeyForAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersCreateGpgKeyForAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersCreateGpgKeyForAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersCreateGpgKeyForAuthenticatedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersCreateGpgKeyForAuthenticatedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersCreateGpgKeyForAuthenticatedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersCreateGpgKeyForAuthenticatedReq_EncodeDecode(t *testing.T) {
	var typ UsersCreateGpgKeyForAuthenticatedReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersCreateGpgKeyForAuthenticatedReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersCreateGpgKeyForAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersCreateGpgKeyForAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersCreateGpgKeyForAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersCreatePublicSSHKeyForAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersCreatePublicSSHKeyForAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersCreatePublicSSHKeyForAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersCreatePublicSSHKeyForAuthenticatedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersCreatePublicSSHKeyForAuthenticatedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersCreatePublicSSHKeyForAuthenticatedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersCreatePublicSSHKeyForAuthenticatedReq_EncodeDecode(t *testing.T) {
	var typ UsersCreatePublicSSHKeyForAuthenticatedReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersCreatePublicSSHKeyForAuthenticatedReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersCreatePublicSSHKeyForAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersCreatePublicSSHKeyForAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersCreatePublicSSHKeyForAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersDeleteEmailForAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersDeleteEmailForAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersDeleteEmailForAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersDeleteEmailForAuthenticatedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersDeleteEmailForAuthenticatedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersDeleteEmailForAuthenticatedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersDeleteEmailForAuthenticatedReq_EncodeDecode(t *testing.T) {
	var typ UsersDeleteEmailForAuthenticatedReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersDeleteEmailForAuthenticatedReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersDeleteEmailForAuthenticatedReq0_EncodeDecode(t *testing.T) {
	var typ UsersDeleteEmailForAuthenticatedReq0
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersDeleteEmailForAuthenticatedReq0
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUsersDeleteEmailForAuthenticatedReq0_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"emails\":[\"octocat@github.com\",\"mona@github.com\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UsersDeleteEmailForAuthenticatedReq0

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UsersDeleteEmailForAuthenticatedReq0
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUsersDeleteEmailForAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersDeleteEmailForAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersDeleteEmailForAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersDeleteGpgKeyForAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersDeleteGpgKeyForAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersDeleteGpgKeyForAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersDeleteGpgKeyForAuthenticatedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersDeleteGpgKeyForAuthenticatedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersDeleteGpgKeyForAuthenticatedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersDeleteGpgKeyForAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersDeleteGpgKeyForAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersDeleteGpgKeyForAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersDeletePublicSSHKeyForAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersDeletePublicSSHKeyForAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersDeletePublicSSHKeyForAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersDeletePublicSSHKeyForAuthenticatedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersDeletePublicSSHKeyForAuthenticatedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersDeletePublicSSHKeyForAuthenticatedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersDeletePublicSSHKeyForAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersDeletePublicSSHKeyForAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersDeletePublicSSHKeyForAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersFollowForbidden_EncodeDecode(t *testing.T) {
	var typ UsersFollowForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersFollowForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersFollowNotFound_EncodeDecode(t *testing.T) {
	var typ UsersFollowNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersFollowNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersFollowUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersFollowUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersFollowUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersGetAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersGetAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersGetAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersGetAuthenticatedOK_EncodeDecode(t *testing.T) {
	var typ UsersGetAuthenticatedOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersGetAuthenticatedOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUsersGetAuthenticatedOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"bio\":\"There once was...\",\"blog\":\"https://github.com/blog\",\"collaborators\":8,\"company\":\"GitHub\",\"created_at\":\"2008-01-14T04:33:35Z\",\"disk_usage\":10000,\"email\":\"octocat@github.com\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers\":20,\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following\":0,\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"hireable\":false,\"html_url\":\"https://github.com/octocat\",\"id\":1,\"location\":\"San Francisco\",\"login\":\"octocat\",\"name\":\"monalisa octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"owned_private_repos\":100,\"plan\":{\"collaborators\":0,\"name\":\"Medium\",\"private_repos\":20,\"space\":400},\"private_gists\":81,\"public_gists\":1,\"public_repos\":2,\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"total_private_repos\":100,\"twitter_username\":\"monatheoctocat\",\"two_factor_authentication\":true,\"type\":\"User\",\"updated_at\":\"2008-01-14T04:33:35Z\",\"url\":\"https://api.github.com/users/octocat\"}"},
		{Input: "{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"bio\":\"There once was...\",\"blog\":\"https://github.com/blog\",\"company\":\"GitHub\",\"created_at\":\"2008-01-14T04:33:35Z\",\"email\":\"octocat@github.com\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers\":20,\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following\":0,\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"hireable\":false,\"html_url\":\"https://github.com/octocat\",\"id\":1,\"location\":\"San Francisco\",\"login\":\"octocat\",\"name\":\"monalisa octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"public_gists\":1,\"public_repos\":2,\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"twitter_username\":\"monatheoctocat\",\"type\":\"User\",\"updated_at\":\"2008-01-14T04:33:35Z\",\"url\":\"https://api.github.com/users/octocat\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UsersGetAuthenticatedOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UsersGetAuthenticatedOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUsersGetAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersGetAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersGetAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersGetByUsernameOK_EncodeDecode(t *testing.T) {
	var typ UsersGetByUsernameOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersGetByUsernameOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUsersGetByUsernameOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"bio\":\"There once was...\",\"blog\":\"https://github.com/blog\",\"company\":\"GitHub\",\"created_at\":\"2008-01-14T04:33:35Z\",\"email\":\"octocat@github.com\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers\":20,\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following\":0,\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"hireable\":false,\"html_url\":\"https://github.com/octocat\",\"id\":1,\"location\":\"San Francisco\",\"login\":\"octocat\",\"name\":\"monalisa octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"plan\":{\"collaborators\":0,\"name\":\"pro\",\"private_repos\":9999,\"space\":976562499},\"public_gists\":1,\"public_repos\":2,\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"twitter_username\":\"monatheoctocat\",\"type\":\"User\",\"updated_at\":\"2008-01-14T04:33:35Z\",\"url\":\"https://api.github.com/users/octocat\"}"},
		{Input: "{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"bio\":\"There once was...\",\"blog\":\"https://github.com/blog\",\"company\":\"GitHub\",\"created_at\":\"2008-01-14T04:33:35Z\",\"email\":\"octocat@github.com\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers\":20,\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following\":0,\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"hireable\":false,\"html_url\":\"https://github.com/octocat\",\"id\":1,\"location\":\"San Francisco\",\"login\":\"octocat\",\"name\":\"monalisa octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"public_gists\":1,\"public_repos\":2,\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"twitter_username\":\"monatheoctocat\",\"type\":\"User\",\"updated_at\":\"2008-01-14T04:33:35Z\",\"url\":\"https://api.github.com/users/octocat\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UsersGetByUsernameOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UsersGetByUsernameOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUsersGetGpgKeyForAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersGetGpgKeyForAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersGetGpgKeyForAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersGetGpgKeyForAuthenticatedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersGetGpgKeyForAuthenticatedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersGetGpgKeyForAuthenticatedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersGetGpgKeyForAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersGetGpgKeyForAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersGetGpgKeyForAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersGetPublicSSHKeyForAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersGetPublicSSHKeyForAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersGetPublicSSHKeyForAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersGetPublicSSHKeyForAuthenticatedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersGetPublicSSHKeyForAuthenticatedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersGetPublicSSHKeyForAuthenticatedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersGetPublicSSHKeyForAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersGetPublicSSHKeyForAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersGetPublicSSHKeyForAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListBlockedByAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersListBlockedByAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListBlockedByAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListBlockedByAuthenticatedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersListBlockedByAuthenticatedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListBlockedByAuthenticatedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListBlockedByAuthenticatedOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UsersListBlockedByAuthenticatedOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListBlockedByAuthenticatedOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListBlockedByAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersListBlockedByAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListBlockedByAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListEmailsForAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersListEmailsForAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListEmailsForAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListEmailsForAuthenticatedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersListEmailsForAuthenticatedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListEmailsForAuthenticatedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListEmailsForAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersListEmailsForAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListEmailsForAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListFollowedByAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersListFollowedByAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListFollowedByAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListFollowedByAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersListFollowedByAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListFollowedByAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListFollowersForAuthenticatedUserForbidden_EncodeDecode(t *testing.T) {
	var typ UsersListFollowersForAuthenticatedUserForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListFollowersForAuthenticatedUserForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListFollowersForAuthenticatedUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersListFollowersForAuthenticatedUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListFollowersForAuthenticatedUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListGpgKeysForAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersListGpgKeysForAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListGpgKeysForAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListGpgKeysForAuthenticatedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersListGpgKeysForAuthenticatedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListGpgKeysForAuthenticatedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListGpgKeysForAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersListGpgKeysForAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListGpgKeysForAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListPublicEmailsForAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersListPublicEmailsForAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListPublicEmailsForAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListPublicEmailsForAuthenticatedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersListPublicEmailsForAuthenticatedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListPublicEmailsForAuthenticatedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListPublicEmailsForAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersListPublicEmailsForAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListPublicEmailsForAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListPublicSSHKeysForAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersListPublicSSHKeysForAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListPublicSSHKeysForAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListPublicSSHKeysForAuthenticatedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersListPublicSSHKeysForAuthenticatedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListPublicSSHKeysForAuthenticatedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersListPublicSSHKeysForAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersListPublicSSHKeysForAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersListPublicSSHKeysForAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersSetPrimaryEmailVisibilityForAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersSetPrimaryEmailVisibilityForAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersSetPrimaryEmailVisibilityForAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersSetPrimaryEmailVisibilityForAuthenticatedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersSetPrimaryEmailVisibilityForAuthenticatedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersSetPrimaryEmailVisibilityForAuthenticatedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersSetPrimaryEmailVisibilityForAuthenticatedOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersSetPrimaryEmailVisibilityForAuthenticatedReq_EncodeDecode(t *testing.T) {
	var typ UsersSetPrimaryEmailVisibilityForAuthenticatedReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersSetPrimaryEmailVisibilityForAuthenticatedReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility_EncodeDecode(t *testing.T) {
	var typ UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersSetPrimaryEmailVisibilityForAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersSetPrimaryEmailVisibilityForAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersSetPrimaryEmailVisibilityForAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersUnblockForbidden_EncodeDecode(t *testing.T) {
	var typ UsersUnblockForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersUnblockForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersUnblockNotFound_EncodeDecode(t *testing.T) {
	var typ UsersUnblockNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersUnblockNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersUnblockUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersUnblockUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersUnblockUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersUnfollowForbidden_EncodeDecode(t *testing.T) {
	var typ UsersUnfollowForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersUnfollowForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersUnfollowNotFound_EncodeDecode(t *testing.T) {
	var typ UsersUnfollowNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersUnfollowNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersUnfollowUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersUnfollowUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersUnfollowUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersUpdateAuthenticatedForbidden_EncodeDecode(t *testing.T) {
	var typ UsersUpdateAuthenticatedForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersUpdateAuthenticatedForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersUpdateAuthenticatedNotFound_EncodeDecode(t *testing.T) {
	var typ UsersUpdateAuthenticatedNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersUpdateAuthenticatedNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersUpdateAuthenticatedReq_EncodeDecode(t *testing.T) {
	var typ UsersUpdateAuthenticatedReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersUpdateAuthenticatedReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersUpdateAuthenticatedUnauthorized_EncodeDecode(t *testing.T) {
	var typ UsersUpdateAuthenticatedUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersUpdateAuthenticatedUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestValidationError_EncodeDecode(t *testing.T) {
	var typ ValidationError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ValidationError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestValidationErrorErrorsItem_EncodeDecode(t *testing.T) {
	var typ ValidationErrorErrorsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ValidationErrorErrorsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestValidationErrorErrorsItemValue_EncodeDecode(t *testing.T) {
	var typ ValidationErrorErrorsItemValue
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ValidationErrorErrorsItemValue
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestValidationErrorSimple_EncodeDecode(t *testing.T) {
	var typ ValidationErrorSimple
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ValidationErrorSimple
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVerification_EncodeDecode(t *testing.T) {
	var typ Verification
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Verification
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestViewTraffic_EncodeDecode(t *testing.T) {
	var typ ViewTraffic
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ViewTraffic
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestViewTraffic_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"count\":14850,\"uniques\":3782,\"views\":[{\"count\":440,\"timestamp\":\"2016-10-10T00:00:00Z\",\"uniques\":143},{\"count\":1308,\"timestamp\":\"2016-10-11T00:00:00Z\",\"uniques\":414},{\"count\":1486,\"timestamp\":\"2016-10-12T00:00:00Z\",\"uniques\":452},{\"count\":1170,\"timestamp\":\"2016-10-13T00:00:00Z\",\"uniques\":401},{\"count\":868,\"timestamp\":\"2016-10-14T00:00:00Z\",\"uniques\":266},{\"count\":495,\"timestamp\":\"2016-10-15T00:00:00Z\",\"uniques\":157},{\"count\":524,\"timestamp\":\"2016-10-16T00:00:00Z\",\"uniques\":175},{\"count\":1263,\"timestamp\":\"2016-10-17T00:00:00Z\",\"uniques\":412},{\"count\":1402,\"timestamp\":\"2016-10-18T00:00:00Z\",\"uniques\":417},{\"count\":1394,\"timestamp\":\"2016-10-19T00:00:00Z\",\"uniques\":424},{\"count\":1492,\"timestamp\":\"2016-10-20T00:00:00Z\",\"uniques\":448},{\"count\":1153,\"timestamp\":\"2016-10-21T00:00:00Z\",\"uniques\":332},{\"count\":566,\"timestamp\":\"2016-10-22T00:00:00Z\",\"uniques\":168},{\"count\":675,\"timestamp\":\"2016-10-23T00:00:00Z\",\"uniques\":184},{\"count\":614,\"timestamp\":\"2016-10-24T00:00:00Z\",\"uniques\":237}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ViewTraffic

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ViewTraffic
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestWebhookConfig_EncodeDecode(t *testing.T) {
	var typ WebhookConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WebhookConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestWebhookConfig_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"content_type\":\"json\",\"insecure_ssl\":\"0\",\"secret\":\"********\",\"url\":\"https://example.com/webhook\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ WebhookConfig

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 WebhookConfig
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestWebhookConfigContentType_EncodeDecode(t *testing.T) {
	var typ WebhookConfigContentType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WebhookConfigContentType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWebhookConfigInsecureSsl_EncodeDecode(t *testing.T) {
	var typ WebhookConfigInsecureSsl
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WebhookConfigInsecureSsl
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWebhookConfigSecret_EncodeDecode(t *testing.T) {
	var typ WebhookConfigSecret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WebhookConfigSecret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWebhookConfigURL_EncodeDecode(t *testing.T) {
	var typ WebhookConfigURL
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WebhookConfigURL
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWorkflow_EncodeDecode(t *testing.T) {
	var typ Workflow
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Workflow
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestWorkflow_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"badge_url\":\"https://github.com/octo-org/octo-repo/workflows/CI/badge.svg\",\"created_at\":\"2020-01-08T23:48:37.000-08:00\",\"html_url\":\"https://github.com/octo-org/octo-repo/blob/master/.github/workflows/161335\",\"id\":161335,\"name\":\"CI\",\"node_id\":\"MDg6V29ya2Zsb3cxNjEzMzU=\",\"path\":\".github/workflows/blank.yaml\",\"state\":\"active\",\"updated_at\":\"2020-01-08T23:50:21.000-08:00\",\"url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/workflows/161335\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Workflow

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Workflow
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestWorkflowRun_EncodeDecode(t *testing.T) {
	var typ WorkflowRun
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WorkflowRun
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestWorkflowRun_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"artifacts_url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642/artifacts\",\"cancel_url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642/cancel\",\"check_suite_id\":42,\"check_suite_node_id\":\"MDEwOkNoZWNrU3VpdGU0Mg==\",\"check_suite_url\":\"https://api.github.com/repos/octo-org/octo-repo/check-suites/414944374\",\"conclusion\":null,\"created_at\":\"2020-01-22T19:33:08Z\",\"event\":\"push\",\"head_branch\":\"master\",\"head_commit\":{\"author\":{\"email\":\"octocat@github.com\",\"name\":\"Octo Cat\"},\"committer\":{\"email\":\"noreply@github.com\",\"name\":\"GitHub\"},\"id\":\"acb5820ced9479c074f688cc328bf03f341a511d\",\"message\":\"Create linter.yaml\",\"timestamp\":\"2020-01-22T19:33:05Z\",\"tree_id\":\"d23f6eedb1e1b9610bbc754ddb5197bfe7271223\"},\"head_repository\":{\"archive_url\":\"https://api.github.com/repos/octo-org/octo-repo/{archive_format}{/ref}\",\"assignees_url\":\"https://api.github.com/repos/octo-org/octo-repo/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octo-org/octo-repo/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octo-org/octo-repo/branches{/branch}\",\"collaborators_url\":\"https://api.github.com/repos/octo-org/octo-repo/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octo-org/octo-repo/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octo-org/octo-repo/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octo-org/octo-repo/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octo-org/octo-repo/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octo-org/octo-repo/contributors\",\"deployments_url\":\"https://api.github.com/repos/octo-org/octo-repo/deployments\",\"description\":null,\"downloads_url\":\"https://api.github.com/repos/octo-org/octo-repo/downloads\",\"events_url\":\"https://api.github.com/repos/octo-org/octo-repo/events\",\"fork\":false,\"forks_url\":\"https://api.github.com/repos/octo-org/octo-repo/forks\",\"full_name\":\"octo-org/octo-repo\",\"git_commits_url\":\"https://api.github.com/repos/octo-org/octo-repo/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octo-org/octo-repo/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octo-org/octo-repo/git/tags{/sha}\",\"hooks_url\":\"https://api.github.com/repos/octo-org/octo-repo/hooks\",\"html_url\":\"https://github.com/octo-org/octo-repo\",\"id\":217723378,\"issue_comment_url\":\"https://api.github.com/repos/octo-org/octo-repo/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octo-org/octo-repo/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octo-org/octo-repo/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octo-org/octo-repo/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octo-org/octo-repo/labels{/name}\",\"languages_url\":\"https://api.github.com/repos/octo-org/octo-repo/languages\",\"merges_url\":\"https://api.github.com/repos/octo-org/octo-repo/merges\",\"milestones_url\":\"https://api.github.com/repos/octo-org/octo-repo/milestones{/number}\",\"name\":\"octo-repo\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkyMTc3MjMzNzg=\",\"notifications_url\":\"https://api.github.com/repos/octo-org/octo-repo/notifications{?since,all,participating}\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"private\":true,\"pulls_url\":\"https://api.github.com/repos/octo-org/octo-repo/pulls{/number}\",\"releases_url\":\"https://api.github.com/repos/octo-org/octo-repo/releases{/id}\",\"stargazers_url\":\"https://api.github.com/repos/octo-org/octo-repo/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octo-org/octo-repo/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/octo-org/octo-repo/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octo-org/octo-repo/subscription\",\"tags_url\":\"https://api.github.com/repos/octo-org/octo-repo/tags\",\"teams_url\":\"https://api.github.com/repos/octo-org/octo-repo/teams\",\"trees_url\":\"https://api.github.com/repos/octo-org/octo-repo/git/trees{/sha}\",\"url\":\"https://api.github.com/repos/octo-org/octo-repo\"},\"head_sha\":\"acb5820ced9479c074f688cc328bf03f341a511d\",\"html_url\":\"https://github.com/octo-org/octo-repo/actions/runs/30433642\",\"id\":30433642,\"jobs_url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642/jobs\",\"logs_url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642/logs\",\"name\":\"Build\",\"node_id\":\"MDEyOldvcmtmbG93IFJ1bjI2OTI4OQ==\",\"pull_requests\":[],\"repository\":{\"archive_url\":\"https://api.github.com/repos/octocat/Hello-World/{archive_format}{/ref}\",\"assignees_url\":\"https://api.github.com/repos/octocat/Hello-World/assignees{/user}\",\"blobs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/blobs{/sha}\",\"branches_url\":\"https://api.github.com/repos/octocat/Hello-World/branches{/branch}\",\"collaborators_url\":\"https://api.github.com/repos/octocat/Hello-World/collaborators{/collaborator}\",\"comments_url\":\"https://api.github.com/repos/octocat/Hello-World/comments{/number}\",\"commits_url\":\"https://api.github.com/repos/octocat/Hello-World/commits{/sha}\",\"compare_url\":\"https://api.github.com/repos/octocat/Hello-World/compare/{base}...{head}\",\"contents_url\":\"https://api.github.com/repos/octocat/Hello-World/contents/{+path}\",\"contributors_url\":\"https://api.github.com/repos/octocat/Hello-World/contributors\",\"deployments_url\":\"https://api.github.com/repos/octocat/Hello-World/deployments\",\"description\":\"This your first repo!\",\"downloads_url\":\"https://api.github.com/repos/octocat/Hello-World/downloads\",\"events_url\":\"https://api.github.com/repos/octocat/Hello-World/events\",\"fork\":false,\"forks_url\":\"https://api.github.com/repos/octocat/Hello-World/forks\",\"full_name\":\"octocat/Hello-World\",\"git_commits_url\":\"https://api.github.com/repos/octocat/Hello-World/git/commits{/sha}\",\"git_refs_url\":\"https://api.github.com/repos/octocat/Hello-World/git/refs{/sha}\",\"git_tags_url\":\"https://api.github.com/repos/octocat/Hello-World/git/tags{/sha}\",\"git_url\":\"git:github.com/octocat/Hello-World.git\",\"hooks_url\":\"http://api.github.com/repos/octocat/Hello-World/hooks\",\"html_url\":\"https://github.com/octocat/Hello-World\",\"id\":1296269,\"issue_comment_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/comments{/number}\",\"issue_events_url\":\"https://api.github.com/repos/octocat/Hello-World/issues/events{/number}\",\"issues_url\":\"https://api.github.com/repos/octocat/Hello-World/issues{/number}\",\"keys_url\":\"https://api.github.com/repos/octocat/Hello-World/keys{/key_id}\",\"labels_url\":\"https://api.github.com/repos/octocat/Hello-World/labels{/name}\",\"languages_url\":\"https://api.github.com/repos/octocat/Hello-World/languages\",\"merges_url\":\"https://api.github.com/repos/octocat/Hello-World/merges\",\"milestones_url\":\"https://api.github.com/repos/octocat/Hello-World/milestones{/number}\",\"name\":\"Hello-World\",\"node_id\":\"MDEwOlJlcG9zaXRvcnkxMjk2MjY5\",\"notifications_url\":\"https://api.github.com/repos/octocat/Hello-World/notifications{?since,all,participating}\",\"owner\":{\"avatar_url\":\"https://github.com/images/error/octocat_happy.gif\",\"events_url\":\"https://api.github.com/users/octocat/events{/privacy}\",\"followers_url\":\"https://api.github.com/users/octocat/followers\",\"following_url\":\"https://api.github.com/users/octocat/following{/other_user}\",\"gists_url\":\"https://api.github.com/users/octocat/gists{/gist_id}\",\"gravatar_id\":\"\",\"html_url\":\"https://github.com/octocat\",\"id\":1,\"login\":\"octocat\",\"node_id\":\"MDQ6VXNlcjE=\",\"organizations_url\":\"https://api.github.com/users/octocat/orgs\",\"received_events_url\":\"https://api.github.com/users/octocat/received_events\",\"repos_url\":\"https://api.github.com/users/octocat/repos\",\"site_admin\":false,\"starred_url\":\"https://api.github.com/users/octocat/starred{/owner}{/repo}\",\"subscriptions_url\":\"https://api.github.com/users/octocat/subscriptions\",\"type\":\"User\",\"url\":\"https://api.github.com/users/octocat\"},\"private\":false,\"pulls_url\":\"https://api.github.com/repos/octocat/Hello-World/pulls{/number}\",\"releases_url\":\"https://api.github.com/repos/octocat/Hello-World/releases{/id}\",\"ssh_url\":\"git@github.com:octocat/Hello-World.git\",\"stargazers_url\":\"https://api.github.com/repos/octocat/Hello-World/stargazers\",\"statuses_url\":\"https://api.github.com/repos/octocat/Hello-World/statuses/{sha}\",\"subscribers_url\":\"https://api.github.com/repos/octocat/Hello-World/subscribers\",\"subscription_url\":\"https://api.github.com/repos/octocat/Hello-World/subscription\",\"tags_url\":\"https://api.github.com/repos/octocat/Hello-World/tags\",\"teams_url\":\"https://api.github.com/repos/octocat/Hello-World/teams\",\"trees_url\":\"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\",\"url\":\"https://api.github.com/repos/octocat/Hello-World\"},\"rerun_url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642/rerun\",\"run_number\":562,\"status\":\"queued\",\"updated_at\":\"2020-01-22T19:33:08Z\",\"url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/runs/30433642\",\"workflow_id\":159038,\"workflow_url\":\"https://api.github.com/repos/octo-org/octo-repo/actions/workflows/159038\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ WorkflowRun

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 WorkflowRun
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestWorkflowRunUsage_EncodeDecode(t *testing.T) {
	var typ WorkflowRunUsage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WorkflowRunUsage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestWorkflowRunUsage_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"billable\":{\"MACOS\":{\"jobs\":4,\"total_ms\":240000},\"UBUNTU\":{\"jobs\":1,\"total_ms\":180000},\"WINDOWS\":{\"jobs\":2,\"total_ms\":300000}},\"run_duration_ms\":500000}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ WorkflowRunUsage

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 WorkflowRunUsage
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestWorkflowRunUsageBillable_EncodeDecode(t *testing.T) {
	var typ WorkflowRunUsageBillable
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WorkflowRunUsageBillable
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWorkflowRunUsageBillableMACOS_EncodeDecode(t *testing.T) {
	var typ WorkflowRunUsageBillableMACOS
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WorkflowRunUsageBillableMACOS
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWorkflowRunUsageBillableUBUNTU_EncodeDecode(t *testing.T) {
	var typ WorkflowRunUsageBillableUBUNTU
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WorkflowRunUsageBillableUBUNTU
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWorkflowRunUsageBillableWINDOWS_EncodeDecode(t *testing.T) {
	var typ WorkflowRunUsageBillableWINDOWS
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WorkflowRunUsageBillableWINDOWS
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWorkflowState_EncodeDecode(t *testing.T) {
	var typ WorkflowState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WorkflowState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestWorkflowState_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"active\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ WorkflowState

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 WorkflowState
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
