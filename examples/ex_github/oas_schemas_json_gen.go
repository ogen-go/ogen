// Code generated by ogen, DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"math"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
)

// No-op definition for keeping imports.
var (
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = sort.Ints
	_ = chi.Context{}
	_ = http.MethodGet
	_ = io.Copy
	_ = json.Marshal
	_ = bytes.NewReader
	_ = strconv.ParseInt
	_ = time.Time{}
	_ = conv.ToInt32
	_ = uuid.UUID{}
	_ = uri.PathEncoder{}
	_ = url.URL{}
	_ = math.Mod
	_ = validate.Int{}
	_ = ht.NewRequest
	_ = net.IP{}
	_ = otelogen.Version
	_ = trace.TraceIDFromHex
	_ = otel.GetTracerProvider
	_ = metric.NewNoopMeterProvider
	_ = regexp.MustCompile
	_ = jx.Null
	_ = sync.Pool{}
)

// Encode implements json.Marshaler.
func (s APIOverview) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("verifiable_password_authentication")
	e.Bool(s.VerifiablePasswordAuthentication)
	if s.SSHKeyFingerprints.Set {
		e.FieldStart("ssh_key_fingerprints")
		s.SSHKeyFingerprints.Encode(e)
	}
	if s.Hooks != nil {
		e.FieldStart("hooks")
		e.ArrStart()
		for _, elem := range s.Hooks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Web != nil {
		e.FieldStart("web")
		e.ArrStart()
		for _, elem := range s.Web {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.API != nil {
		e.FieldStart("api")
		e.ArrStart()
		for _, elem := range s.API {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Git != nil {
		e.FieldStart("git")
		e.ArrStart()
		for _, elem := range s.Git {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Packages != nil {
		e.FieldStart("packages")
		e.ArrStart()
		for _, elem := range s.Packages {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Pages != nil {
		e.FieldStart("pages")
		e.ArrStart()
		for _, elem := range s.Pages {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Importer != nil {
		e.FieldStart("importer")
		e.ArrStart()
		for _, elem := range s.Importer {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Actions != nil {
		e.FieldStart("actions")
		e.ArrStart()
		for _, elem := range s.Actions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Dependabot != nil {
		e.FieldStart("dependabot")
		e.ArrStart()
		for _, elem := range s.Dependabot {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes APIOverview from json.
func (s *APIOverview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode APIOverview to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verifiable_password_authentication":
			v, err := d.Bool()
			s.VerifiablePasswordAuthentication = bool(v)
			if err != nil {
				return err
			}
		case "ssh_key_fingerprints":
			s.SSHKeyFingerprints.Reset()
			if err := s.SSHKeyFingerprints.Decode(d); err != nil {
				return err
			}
		case "hooks":
			s.Hooks = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Hooks = append(s.Hooks, elem)
				return nil
			}); err != nil {
				return err
			}
		case "web":
			s.Web = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Web = append(s.Web, elem)
				return nil
			}); err != nil {
				return err
			}
		case "api":
			s.API = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.API = append(s.API, elem)
				return nil
			}); err != nil {
				return err
			}
		case "git":
			s.Git = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Git = append(s.Git, elem)
				return nil
			}); err != nil {
				return err
			}
		case "packages":
			s.Packages = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Packages = append(s.Packages, elem)
				return nil
			}); err != nil {
				return err
			}
		case "pages":
			s.Pages = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Pages = append(s.Pages, elem)
				return nil
			}); err != nil {
				return err
			}
		case "importer":
			s.Importer = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Importer = append(s.Importer, elem)
				return nil
			}); err != nil {
				return err
			}
		case "actions":
			s.Actions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Actions = append(s.Actions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "dependabot":
			s.Dependabot = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Dependabot = append(s.Dependabot, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s APIOverviewSSHKeyFingerprints) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.SHA256RSA.Set {
		e.FieldStart("SHA256_RSA")
		s.SHA256RSA.Encode(e)
	}
	if s.SHA256DSA.Set {
		e.FieldStart("SHA256_DSA")
		s.SHA256DSA.Encode(e)
	}
	if s.SHA256ECDSA.Set {
		e.FieldStart("SHA256_ECDSA")
		s.SHA256ECDSA.Encode(e)
	}
	if s.SHA256ED25519.Set {
		e.FieldStart("SHA256_ED25519")
		s.SHA256ED25519.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes APIOverviewSSHKeyFingerprints from json.
func (s *APIOverviewSSHKeyFingerprints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode APIOverviewSSHKeyFingerprints to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "SHA256_RSA":
			s.SHA256RSA.Reset()
			if err := s.SHA256RSA.Decode(d); err != nil {
				return err
			}
		case "SHA256_DSA":
			s.SHA256DSA.Reset()
			if err := s.SHA256DSA.Decode(d); err != nil {
				return err
			}
		case "SHA256_ECDSA":
			s.SHA256ECDSA.Reset()
			if err := s.SHA256ECDSA.Decode(d); err != nil {
				return err
			}
		case "SHA256_ED25519":
			s.SHA256ED25519.Reset()
			if err := s.SHA256ED25519.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Accepted) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes Accepted from json.
func (s *Accepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Accepted to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent from json.
func (s *ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsAddSelectedRepoToOrgSecretConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsAddSelectedRepoToOrgSecretConflict from json.
func (s *ActionsAddSelectedRepoToOrgSecretConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsAddSelectedRepoToOrgSecretConflict to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsAddSelectedRepoToOrgSecretNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsAddSelectedRepoToOrgSecretNoContent from json.
func (s *ActionsAddSelectedRepoToOrgSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsAddSelectedRepoToOrgSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsAddSelfHostedRunnerToGroupForOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsAddSelfHostedRunnerToGroupForOrgNoContent from json.
func (s *ActionsAddSelfHostedRunnerToGroupForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsAddSelfHostedRunnerToGroupForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsApproveWorkflowRunApplicationJSONForbidden as json.
func (s ActionsApproveWorkflowRunApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActionsApproveWorkflowRunApplicationJSONForbidden from json.
func (s *ActionsApproveWorkflowRunApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsApproveWorkflowRunApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActionsApproveWorkflowRunApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActionsApproveWorkflowRunApplicationJSONNotFound as json.
func (s ActionsApproveWorkflowRunApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActionsApproveWorkflowRunApplicationJSONNotFound from json.
func (s *ActionsApproveWorkflowRunApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsApproveWorkflowRunApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActionsApproveWorkflowRunApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsBillingUsage) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_minutes_used")
	e.Int(s.TotalMinutesUsed)

	e.FieldStart("total_paid_minutes_used")
	e.Int(s.TotalPaidMinutesUsed)

	e.FieldStart("included_minutes")
	e.Int(s.IncludedMinutes)

	e.FieldStart("minutes_used_breakdown")
	s.MinutesUsedBreakdown.Encode(e)
	e.ObjEnd()
}

// Decode decodes ActionsBillingUsage from json.
func (s *ActionsBillingUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsBillingUsage to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_minutes_used":
			v, err := d.Int()
			s.TotalMinutesUsed = int(v)
			if err != nil {
				return err
			}
		case "total_paid_minutes_used":
			v, err := d.Int()
			s.TotalPaidMinutesUsed = int(v)
			if err != nil {
				return err
			}
		case "included_minutes":
			v, err := d.Int()
			s.IncludedMinutes = int(v)
			if err != nil {
				return err
			}
		case "minutes_used_breakdown":
			if err := s.MinutesUsedBreakdown.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsBillingUsageMinutesUsedBreakdown) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.UBUNTU.Set {
		e.FieldStart("UBUNTU")
		s.UBUNTU.Encode(e)
	}
	if s.MACOS.Set {
		e.FieldStart("MACOS")
		s.MACOS.Encode(e)
	}
	if s.WINDOWS.Set {
		e.FieldStart("WINDOWS")
		s.WINDOWS.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ActionsBillingUsageMinutesUsedBreakdown from json.
func (s *ActionsBillingUsageMinutesUsedBreakdown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsBillingUsageMinutesUsedBreakdown to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "UBUNTU":
			s.UBUNTU.Reset()
			if err := s.UBUNTU.Decode(d); err != nil {
				return err
			}
		case "MACOS":
			s.MACOS.Reset()
			if err := s.MACOS.Decode(d); err != nil {
				return err
			}
		case "WINDOWS":
			s.WINDOWS.Reset()
			if err := s.WINDOWS.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsCancelWorkflowRunAccepted) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsCancelWorkflowRunAccepted from json.
func (s *ActionsCancelWorkflowRunAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCancelWorkflowRunAccepted to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateEnvironmentSecretNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsCreateOrUpdateEnvironmentSecretNoContent from json.
func (s *ActionsCreateOrUpdateEnvironmentSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateOrUpdateEnvironmentSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateEnvironmentSecretReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("encrypted_value")
	e.Str(s.EncryptedValue)

	e.FieldStart("key_id")
	e.Str(s.KeyID)
	e.ObjEnd()
}

// Decode decodes ActionsCreateOrUpdateEnvironmentSecretReq from json.
func (s *ActionsCreateOrUpdateEnvironmentSecretReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateOrUpdateEnvironmentSecretReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encrypted_value":
			v, err := d.Str()
			s.EncryptedValue = string(v)
			if err != nil {
				return err
			}
		case "key_id":
			v, err := d.Str()
			s.KeyID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateOrgSecretNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsCreateOrUpdateOrgSecretNoContent from json.
func (s *ActionsCreateOrUpdateOrgSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateOrUpdateOrgSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateOrgSecretReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.EncryptedValue.Set {
		e.FieldStart("encrypted_value")
		s.EncryptedValue.Encode(e)
	}
	if s.KeyID.Set {
		e.FieldStart("key_id")
		s.KeyID.Encode(e)
	}

	e.FieldStart("visibility")
	s.Visibility.Encode(e)
	if s.SelectedRepositoryIds != nil {
		e.FieldStart("selected_repository_ids")
		e.ArrStart()
		for _, elem := range s.SelectedRepositoryIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsCreateOrUpdateOrgSecretReq from json.
func (s *ActionsCreateOrUpdateOrgSecretReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateOrUpdateOrgSecretReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encrypted_value":
			s.EncryptedValue.Reset()
			if err := s.EncryptedValue.Decode(d); err != nil {
				return err
			}
		case "key_id":
			s.KeyID.Reset()
			if err := s.KeyID.Decode(d); err != nil {
				return err
			}
		case "visibility":
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "selected_repository_ids":
			s.SelectedRepositoryIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsCreateOrUpdateOrgSecretReqVisibility as json.
func (s ActionsCreateOrUpdateOrgSecretReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActionsCreateOrUpdateOrgSecretReqVisibility from json.
func (s *ActionsCreateOrUpdateOrgSecretReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateOrUpdateOrgSecretReqVisibility to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ActionsCreateOrUpdateOrgSecretReqVisibility(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateRepoSecretCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsCreateOrUpdateRepoSecretCreated from json.
func (s *ActionsCreateOrUpdateRepoSecretCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateOrUpdateRepoSecretCreated to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateRepoSecretNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsCreateOrUpdateRepoSecretNoContent from json.
func (s *ActionsCreateOrUpdateRepoSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateOrUpdateRepoSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsCreateOrUpdateRepoSecretReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.EncryptedValue.Set {
		e.FieldStart("encrypted_value")
		s.EncryptedValue.Encode(e)
	}
	if s.KeyID.Set {
		e.FieldStart("key_id")
		s.KeyID.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ActionsCreateOrUpdateRepoSecretReq from json.
func (s *ActionsCreateOrUpdateRepoSecretReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateOrUpdateRepoSecretReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encrypted_value":
			s.EncryptedValue.Reset()
			if err := s.EncryptedValue.Decode(d); err != nil {
				return err
			}
		case "key_id":
			s.KeyID.Reset()
			if err := s.KeyID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsCreateSelfHostedRunnerGroupForOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)
	if s.Visibility.Set {
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
	if s.SelectedRepositoryIds != nil {
		e.FieldStart("selected_repository_ids")
		e.ArrStart()
		for _, elem := range s.SelectedRepositoryIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	if s.Runners != nil {
		e.FieldStart("runners")
		e.ArrStart()
		for _, elem := range s.Runners {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ActionsCreateSelfHostedRunnerGroupForOrgReq from json.
func (s *ActionsCreateSelfHostedRunnerGroupForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateSelfHostedRunnerGroupForOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "selected_repository_ids":
			s.SelectedRepositoryIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
				return nil
			}); err != nil {
				return err
			}
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility as json.
func (s ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility from json.
func (s *ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility(v)
	return nil
}

// Encode encodes ActionsCreateWorkflowDispatchWorkflowID as json.
func (s ActionsCreateWorkflowDispatchWorkflowID) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntActionsCreateWorkflowDispatchWorkflowID:
		e.Int(s.Int)
	case StringActionsCreateWorkflowDispatchWorkflowID:
		e.Str(s.String)
	}
}

// Decode decodes ActionsCreateWorkflowDispatchWorkflowID from json.
func (s *ActionsCreateWorkflowDispatchWorkflowID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsCreateWorkflowDispatchWorkflowID to nil`)
	}
	// Sum type primitive.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntActionsCreateWorkflowDispatchWorkflowID
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringActionsCreateWorkflowDispatchWorkflowID
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsDeleteArtifactNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsDeleteArtifactNoContent from json.
func (s *ActionsDeleteArtifactNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteArtifactNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDeleteEnvironmentSecretNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsDeleteEnvironmentSecretNoContent from json.
func (s *ActionsDeleteEnvironmentSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteEnvironmentSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDeleteOrgSecretNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsDeleteOrgSecretNoContent from json.
func (s *ActionsDeleteOrgSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteOrgSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDeleteRepoSecretNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsDeleteRepoSecretNoContent from json.
func (s *ActionsDeleteRepoSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteRepoSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDeleteSelfHostedRunnerFromOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsDeleteSelfHostedRunnerFromOrgNoContent from json.
func (s *ActionsDeleteSelfHostedRunnerFromOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteSelfHostedRunnerFromOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDeleteSelfHostedRunnerFromRepoNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsDeleteSelfHostedRunnerFromRepoNoContent from json.
func (s *ActionsDeleteSelfHostedRunnerFromRepoNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteSelfHostedRunnerFromRepoNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent from json.
func (s *ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteSelfHostedRunnerGroupFromOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDeleteWorkflowRunLogsNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsDeleteWorkflowRunLogsNoContent from json.
func (s *ActionsDeleteWorkflowRunLogsNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteWorkflowRunLogsNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDeleteWorkflowRunNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsDeleteWorkflowRunNoContent from json.
func (s *ActionsDeleteWorkflowRunNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDeleteWorkflowRunNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent from json.
func (s *ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDisableSelectedRepositoryGithubActionsOrganizationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsDisableWorkflowWorkflowID as json.
func (s ActionsDisableWorkflowWorkflowID) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntActionsDisableWorkflowWorkflowID:
		e.Int(s.Int)
	case StringActionsDisableWorkflowWorkflowID:
		e.Str(s.String)
	}
}

// Decode decodes ActionsDisableWorkflowWorkflowID from json.
func (s *ActionsDisableWorkflowWorkflowID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDisableWorkflowWorkflowID to nil`)
	}
	// Sum type primitive.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntActionsDisableWorkflowWorkflowID
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringActionsDisableWorkflowWorkflowID
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsDownloadArtifactFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsDownloadArtifactFound from json.
func (s *ActionsDownloadArtifactFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDownloadArtifactFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDownloadJobLogsForWorkflowRunFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsDownloadJobLogsForWorkflowRunFound from json.
func (s *ActionsDownloadJobLogsForWorkflowRunFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDownloadJobLogsForWorkflowRunFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsDownloadWorkflowRunLogsFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsDownloadWorkflowRunLogsFound from json.
func (s *ActionsDownloadWorkflowRunLogsFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsDownloadWorkflowRunLogsFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent from json.
func (s *ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsEnableSelectedRepositoryGithubActionsOrganizationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsEnableWorkflowWorkflowID as json.
func (s ActionsEnableWorkflowWorkflowID) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntActionsEnableWorkflowWorkflowID:
		e.Int(s.Int)
	case StringActionsEnableWorkflowWorkflowID:
		e.Str(s.String)
	}
}

// Decode decodes ActionsEnableWorkflowWorkflowID from json.
func (s *ActionsEnableWorkflowWorkflowID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsEnableWorkflowWorkflowID to nil`)
	}
	// Sum type primitive.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntActionsEnableWorkflowWorkflowID
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringActionsEnableWorkflowWorkflowID
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode encodes ActionsEnabled as json.
func (s ActionsEnabled) Encode(e *jx.Encoder) {
	unwrapped := bool(s)
	e.Bool(unwrapped)
}

// Decode decodes ActionsEnabled from json.
func (s *ActionsEnabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsEnabled to nil`)
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActionsEnabled(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsEnterprisePermissions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("enabled_organizations")
	s.EnabledOrganizations.Encode(e)
	if s.SelectedOrganizationsURL.Set {
		e.FieldStart("selected_organizations_url")
		s.SelectedOrganizationsURL.Encode(e)
	}
	if s.AllowedActions.Set {
		e.FieldStart("allowed_actions")
		s.AllowedActions.Encode(e)
	}
	if s.SelectedActionsURL.Set {
		e.FieldStart("selected_actions_url")
		s.SelectedActionsURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ActionsEnterprisePermissions from json.
func (s *ActionsEnterprisePermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsEnterprisePermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_organizations":
			if err := s.EnabledOrganizations.Decode(d); err != nil {
				return err
			}
		case "selected_organizations_url":
			s.SelectedOrganizationsURL.Reset()
			if err := s.SelectedOrganizationsURL.Decode(d); err != nil {
				return err
			}
		case "allowed_actions":
			s.AllowedActions.Reset()
			if err := s.AllowedActions.Decode(d); err != nil {
				return err
			}
		case "selected_actions_url":
			s.SelectedActionsURL.Reset()
			if err := s.SelectedActionsURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsGetWorkflowUsageWorkflowID as json.
func (s ActionsGetWorkflowUsageWorkflowID) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntActionsGetWorkflowUsageWorkflowID:
		e.Int(s.Int)
	case StringActionsGetWorkflowUsageWorkflowID:
		e.Str(s.String)
	}
}

// Decode decodes ActionsGetWorkflowUsageWorkflowID from json.
func (s *ActionsGetWorkflowUsageWorkflowID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsGetWorkflowUsageWorkflowID to nil`)
	}
	// Sum type primitive.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntActionsGetWorkflowUsageWorkflowID
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringActionsGetWorkflowUsageWorkflowID
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode encodes ActionsGetWorkflowWorkflowID as json.
func (s ActionsGetWorkflowWorkflowID) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntActionsGetWorkflowWorkflowID:
		e.Int(s.Int)
	case StringActionsGetWorkflowWorkflowID:
		e.Str(s.String)
	}
}

// Decode decodes ActionsGetWorkflowWorkflowID from json.
func (s *ActionsGetWorkflowWorkflowID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsGetWorkflowWorkflowID to nil`)
	}
	// Sum type primitive.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntActionsGetWorkflowWorkflowID
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringActionsGetWorkflowWorkflowID
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListArtifactsForRepoOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("artifacts")
	e.ArrStart()
	for _, elem := range s.Artifacts {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsListArtifactsForRepoOK from json.
func (s *ActionsListArtifactsForRepoOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListArtifactsForRepoOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "artifacts":
			s.Artifacts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Artifact
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Artifacts = append(s.Artifacts, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListEnvironmentSecretsOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("secrets")
	e.ArrStart()
	for _, elem := range s.Secrets {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsListEnvironmentSecretsOK from json.
func (s *ActionsListEnvironmentSecretsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListEnvironmentSecretsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "secrets":
			s.Secrets = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ActionsSecret
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Secrets = append(s.Secrets, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsListJobsForWorkflowRunFilter as json.
func (s ActionsListJobsForWorkflowRunFilter) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActionsListJobsForWorkflowRunFilter from json.
func (s *ActionsListJobsForWorkflowRunFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListJobsForWorkflowRunFilter to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ActionsListJobsForWorkflowRunFilter(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsListJobsForWorkflowRunOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("jobs")
	e.ArrStart()
	for _, elem := range s.Jobs {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsListJobsForWorkflowRunOK from json.
func (s *ActionsListJobsForWorkflowRunOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListJobsForWorkflowRunOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "jobs":
			s.Jobs = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Job
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Jobs = append(s.Jobs, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListOrgSecretsOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("secrets")
	e.ArrStart()
	for _, elem := range s.Secrets {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsListOrgSecretsOK from json.
func (s *ActionsListOrgSecretsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListOrgSecretsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "secrets":
			s.Secrets = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem OrganizationActionsSecret
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Secrets = append(s.Secrets, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Float64(s.TotalCount)

	e.FieldStart("repositories")
	e.ArrStart()
	for _, elem := range s.Repositories {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK from json.
func (s *ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListRepoAccessToSelfHostedRunnerGroupInOrgOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Float64()
			s.TotalCount = float64(v)
			if err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MinimalRepository
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListRepoSecretsOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("secrets")
	e.ArrStart()
	for _, elem := range s.Secrets {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsListRepoSecretsOK from json.
func (s *ActionsListRepoSecretsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListRepoSecretsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "secrets":
			s.Secrets = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ActionsSecret
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Secrets = append(s.Secrets, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListRepoWorkflowsOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("workflows")
	e.ArrStart()
	for _, elem := range s.Workflows {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsListRepoWorkflowsOK from json.
func (s *ActionsListRepoWorkflowsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListRepoWorkflowsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "workflows":
			s.Workflows = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Workflow
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Workflows = append(s.Workflows, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListSelectedReposForOrgSecretOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("repositories")
	e.ArrStart()
	for _, elem := range s.Repositories {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsListSelectedReposForOrgSecretOK from json.
func (s *ActionsListSelectedReposForOrgSecretOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListSelectedReposForOrgSecretOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MinimalRepository
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Float64(s.TotalCount)

	e.FieldStart("repositories")
	e.ArrStart()
	for _, elem := range s.Repositories {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK from json.
func (s *ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Float64()
			s.TotalCount = float64(v)
			if err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Repository
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListSelfHostedRunnerGroupsForOrgOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Float64(s.TotalCount)

	e.FieldStart("runner_groups")
	e.ArrStart()
	for _, elem := range s.RunnerGroups {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsListSelfHostedRunnerGroupsForOrgOK from json.
func (s *ActionsListSelfHostedRunnerGroupsForOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListSelfHostedRunnerGroupsForOrgOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Float64()
			s.TotalCount = float64(v)
			if err != nil {
				return err
			}
		case "runner_groups":
			s.RunnerGroups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem RunnerGroupsOrg
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.RunnerGroups = append(s.RunnerGroups, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListSelfHostedRunnersForOrgOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("runners")
	e.ArrStart()
	for _, elem := range s.Runners {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsListSelfHostedRunnersForOrgOK from json.
func (s *ActionsListSelfHostedRunnersForOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListSelfHostedRunnersForOrgOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Runner
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListSelfHostedRunnersForRepoOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("runners")
	e.ArrStart()
	for _, elem := range s.Runners {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsListSelfHostedRunnersForRepoOK from json.
func (s *ActionsListSelfHostedRunnersForRepoOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListSelfHostedRunnersForRepoOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Runner
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListSelfHostedRunnersInGroupForOrgOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Float64(s.TotalCount)

	e.FieldStart("runners")
	e.ArrStart()
	for _, elem := range s.Runners {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsListSelfHostedRunnersInGroupForOrgOK from json.
func (s *ActionsListSelfHostedRunnersInGroupForOrgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListSelfHostedRunnersInGroupForOrgOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Float64()
			s.TotalCount = float64(v)
			if err != nil {
				return err
			}
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Runner
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListWorkflowRunArtifactsOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("artifacts")
	e.ArrStart()
	for _, elem := range s.Artifacts {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsListWorkflowRunArtifactsOK from json.
func (s *ActionsListWorkflowRunArtifactsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListWorkflowRunArtifactsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "artifacts":
			s.Artifacts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Artifact
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Artifacts = append(s.Artifacts, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsListWorkflowRunsForRepoOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("workflow_runs")
	e.ArrStart()
	for _, elem := range s.WorkflowRuns {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsListWorkflowRunsForRepoOK from json.
func (s *ActionsListWorkflowRunsForRepoOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListWorkflowRunsForRepoOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "workflow_runs":
			s.WorkflowRuns = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem WorkflowRun
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.WorkflowRuns = append(s.WorkflowRuns, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsListWorkflowRunsForRepoStatus as json.
func (s ActionsListWorkflowRunsForRepoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActionsListWorkflowRunsForRepoStatus from json.
func (s *ActionsListWorkflowRunsForRepoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListWorkflowRunsForRepoStatus to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ActionsListWorkflowRunsForRepoStatus(v)
	return nil
}

// Encode encodes ActionsListWorkflowRunsWorkflowID as json.
func (s ActionsListWorkflowRunsWorkflowID) Encode(e *jx.Encoder) {
	switch s.Type {
	case IntActionsListWorkflowRunsWorkflowID:
		e.Int(s.Int)
	case StringActionsListWorkflowRunsWorkflowID:
		e.Str(s.String)
	}
}

// Decode decodes ActionsListWorkflowRunsWorkflowID from json.
func (s *ActionsListWorkflowRunsWorkflowID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsListWorkflowRunsWorkflowID to nil`)
	}
	// Sum type primitive.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntActionsListWorkflowRunsWorkflowID
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringActionsListWorkflowRunsWorkflowID
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsOrganizationPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("enabled_repositories")
	s.EnabledRepositories.Encode(e)
	if s.SelectedRepositoriesURL.Set {
		e.FieldStart("selected_repositories_url")
		s.SelectedRepositoriesURL.Encode(e)
	}
	if s.AllowedActions.Set {
		e.FieldStart("allowed_actions")
		s.AllowedActions.Encode(e)
	}
	if s.SelectedActionsURL.Set {
		e.FieldStart("selected_actions_url")
		s.SelectedActionsURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ActionsOrganizationPermissions from json.
func (s *ActionsOrganizationPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsOrganizationPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_repositories":
			if err := s.EnabledRepositories.Decode(d); err != nil {
				return err
			}
		case "selected_repositories_url":
			s.SelectedRepositoriesURL.Reset()
			if err := s.SelectedRepositoriesURL.Decode(d); err != nil {
				return err
			}
		case "allowed_actions":
			s.AllowedActions.Reset()
			if err := s.AllowedActions.Decode(d); err != nil {
				return err
			}
		case "selected_actions_url":
			s.SelectedActionsURL.Reset()
			if err := s.SelectedActionsURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsPublicKey) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("key_id")
	e.Str(s.KeyID)

	e.FieldStart("key")
	e.Str(s.Key)
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.Title.Set {
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	if s.CreatedAt.Set {
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ActionsPublicKey from json.
func (s *ActionsPublicKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsPublicKey to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key_id":
			v, err := d.Str()
			s.KeyID = string(v)
			if err != nil {
				return err
			}
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsReRunWorkflowCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsReRunWorkflowCreated from json.
func (s *ActionsReRunWorkflowCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsReRunWorkflowCreated to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent from json.
func (s *ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsRemoveSelectedRepoFromOrgSecretConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsRemoveSelectedRepoFromOrgSecretConflict from json.
func (s *ActionsRemoveSelectedRepoFromOrgSecretConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsRemoveSelectedRepoFromOrgSecretConflict to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsRemoveSelectedRepoFromOrgSecretNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsRemoveSelectedRepoFromOrgSecretNoContent from json.
func (s *ActionsRemoveSelectedRepoFromOrgSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsRemoveSelectedRepoFromOrgSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent from json.
func (s *ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsRemoveSelfHostedRunnerFromGroupForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsRepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("enabled")
	s.Enabled.Encode(e)
	if s.AllowedActions.Set {
		e.FieldStart("allowed_actions")
		s.AllowedActions.Encode(e)
	}
	if s.SelectedActionsURL.Set {
		e.FieldStart("selected_actions_url")
		s.SelectedActionsURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ActionsRepositoryPermissions from json.
func (s *ActionsRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsRepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			{
				var unwrapped bool
				v, err := d.Bool()
				unwrapped = bool(v)
				if err != nil {
					return err
				}
				s.Enabled = ActionsEnabled(unwrapped)
			}
		case "allowed_actions":
			s.AllowedActions.Reset()
			if err := s.AllowedActions.Decode(d); err != nil {
				return err
			}
		case "selected_actions_url":
			s.SelectedActionsURL.Reset()
			if err := s.SelectedActionsURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsRetryWorkflowCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsRetryWorkflowCreated from json.
func (s *ActionsRetryWorkflowCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsRetryWorkflowCreated to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsReviewPendingDeploymentsForRunReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("environment_ids")
	e.ArrStart()
	for _, elem := range s.EnvironmentIds {
		e.Int(elem)
	}
	e.ArrEnd()

	e.FieldStart("state")
	s.State.Encode(e)

	e.FieldStart("comment")
	e.Str(s.Comment)
	e.ObjEnd()
}

// Decode decodes ActionsReviewPendingDeploymentsForRunReq from json.
func (s *ActionsReviewPendingDeploymentsForRunReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsReviewPendingDeploymentsForRunReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "environment_ids":
			s.EnvironmentIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.EnvironmentIds = append(s.EnvironmentIds, elem)
				return nil
			}); err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "comment":
			v, err := d.Str()
			s.Comment = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsReviewPendingDeploymentsForRunReqState as json.
func (s ActionsReviewPendingDeploymentsForRunReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActionsReviewPendingDeploymentsForRunReqState from json.
func (s *ActionsReviewPendingDeploymentsForRunReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsReviewPendingDeploymentsForRunReqState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ActionsReviewPendingDeploymentsForRunReqState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ActionsSecret) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)
	e.ObjEnd()
}

// Decode decodes ActionsSecret from json.
func (s *ActionsSecret) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSecret to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetAllowedActionsOrganizationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsSetAllowedActionsOrganizationNoContent from json.
func (s *ActionsSetAllowedActionsOrganizationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetAllowedActionsOrganizationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetAllowedActionsRepositoryNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsSetAllowedActionsRepositoryNoContent from json.
func (s *ActionsSetAllowedActionsRepositoryNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetAllowedActionsRepositoryNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetGithubActionsPermissionsOrganizationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsSetGithubActionsPermissionsOrganizationNoContent from json.
func (s *ActionsSetGithubActionsPermissionsOrganizationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetGithubActionsPermissionsOrganizationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetGithubActionsPermissionsOrganizationReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("enabled_repositories")
	s.EnabledRepositories.Encode(e)
	if s.AllowedActions.Set {
		e.FieldStart("allowed_actions")
		s.AllowedActions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ActionsSetGithubActionsPermissionsOrganizationReq from json.
func (s *ActionsSetGithubActionsPermissionsOrganizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetGithubActionsPermissionsOrganizationReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_repositories":
			if err := s.EnabledRepositories.Decode(d); err != nil {
				return err
			}
		case "allowed_actions":
			s.AllowedActions.Reset()
			if err := s.AllowedActions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetGithubActionsPermissionsRepositoryNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsSetGithubActionsPermissionsRepositoryNoContent from json.
func (s *ActionsSetGithubActionsPermissionsRepositoryNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetGithubActionsPermissionsRepositoryNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetGithubActionsPermissionsRepositoryReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("enabled")
	s.Enabled.Encode(e)
	if s.AllowedActions.Set {
		e.FieldStart("allowed_actions")
		s.AllowedActions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ActionsSetGithubActionsPermissionsRepositoryReq from json.
func (s *ActionsSetGithubActionsPermissionsRepositoryReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetGithubActionsPermissionsRepositoryReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			{
				var unwrapped bool
				v, err := d.Bool()
				unwrapped = bool(v)
				if err != nil {
					return err
				}
				s.Enabled = ActionsEnabled(unwrapped)
			}
		case "allowed_actions":
			s.AllowedActions.Reset()
			if err := s.AllowedActions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent from json.
func (s *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("selected_repository_ids")
	e.ArrStart()
	for _, elem := range s.SelectedRepositoryIds {
		e.Int(elem)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq from json.
func (s *ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_repository_ids":
			s.SelectedRepositoryIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetSelectedReposForOrgSecretNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsSetSelectedReposForOrgSecretNoContent from json.
func (s *ActionsSetSelectedReposForOrgSecretNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetSelectedReposForOrgSecretNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetSelectedReposForOrgSecretReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("selected_repository_ids")
	e.ArrStart()
	for _, elem := range s.SelectedRepositoryIds {
		e.Int(elem)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsSetSelectedReposForOrgSecretReq from json.
func (s *ActionsSetSelectedReposForOrgSecretReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetSelectedReposForOrgSecretReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_repository_ids":
			s.SelectedRepositoryIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent from json.
func (s *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("selected_repository_ids")
	e.ArrStart()
	for _, elem := range s.SelectedRepositoryIds {
		e.Int(elem)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq from json.
func (s *ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_repository_ids":
			s.SelectedRepositoryIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.SelectedRepositoryIds = append(s.SelectedRepositoryIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetSelfHostedRunnersInGroupForOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActionsSetSelfHostedRunnersInGroupForOrgNoContent from json.
func (s *ActionsSetSelfHostedRunnersInGroupForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetSelfHostedRunnersInGroupForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsSetSelfHostedRunnersInGroupForOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("runners")
	e.ArrStart()
	for _, elem := range s.Runners {
		e.Int(elem)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ActionsSetSelfHostedRunnersInGroupForOrgReq from json.
func (s *ActionsSetSelfHostedRunnersInGroupForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsSetSelfHostedRunnersInGroupForOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActionsUpdateSelfHostedRunnerGroupForOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)
	if s.Visibility.Set {
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ActionsUpdateSelfHostedRunnerGroupForOrgReq from json.
func (s *ActionsUpdateSelfHostedRunnerGroupForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsUpdateSelfHostedRunnerGroupForOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility as json.
func (s ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility from json.
func (s *ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility(v)
	return nil
}

// Encode encodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound as json.
func (s ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound from json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityCheckRepoIsStarredByAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivityCheckRepoIsStarredByAuthenticatedUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActivityCheckRepoIsStarredByAuthenticatedUserNoContent from json.
func (s *ActivityCheckRepoIsStarredByAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityCheckRepoIsStarredByAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActivityDeleteRepoSubscriptionNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActivityDeleteRepoSubscriptionNoContent from json.
func (s *ActivityDeleteRepoSubscriptionNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityDeleteRepoSubscriptionNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActivityDeleteThreadSubscriptionApplicationJSONForbidden as json.
func (s ActivityDeleteThreadSubscriptionApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityDeleteThreadSubscriptionApplicationJSONForbidden from json.
func (s *ActivityDeleteThreadSubscriptionApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityDeleteThreadSubscriptionApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityDeleteThreadSubscriptionApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized as json.
func (s ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized from json.
func (s *ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityDeleteThreadSubscriptionApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivityDeleteThreadSubscriptionNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActivityDeleteThreadSubscriptionNoContent from json.
func (s *ActivityDeleteThreadSubscriptionNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityDeleteThreadSubscriptionNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActivityGetRepoSubscriptionNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActivityGetRepoSubscriptionNotFound from json.
func (s *ActivityGetRepoSubscriptionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityGetRepoSubscriptionNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActivityGetThreadApplicationJSONForbidden as json.
func (s ActivityGetThreadApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityGetThreadApplicationJSONForbidden from json.
func (s *ActivityGetThreadApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityGetThreadApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityGetThreadApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityGetThreadApplicationJSONUnauthorized as json.
func (s ActivityGetThreadApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityGetThreadApplicationJSONUnauthorized from json.
func (s *ActivityGetThreadApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityGetThreadApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityGetThreadApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityGetThreadSubscriptionForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden as json.
func (s ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden from json.
func (s *ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsForRepoNetworkApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently as json.
func (s ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently from json.
func (s *ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsForRepoNetworkApplicationJSONMovedPermanently(unwrapped)
	return nil
}

// Encode encodes ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound as json.
func (s ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound from json.
func (s *ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsForRepoNetworkApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ActivityListPublicEventsForRepoNetworkOKApplicationJSON as json.
func (s ActivityListPublicEventsForRepoNetworkOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Event(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ActivityListPublicEventsForRepoNetworkOKApplicationJSON from json.
func (s *ActivityListPublicEventsForRepoNetworkOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListPublicEventsForRepoNetworkOKApplicationJSON to nil`)
	}
	var unwrapped []Event
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Event
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsForRepoNetworkOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ActivityListPublicEventsOKApplicationJSON as json.
func (s ActivityListPublicEventsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Event(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ActivityListPublicEventsOKApplicationJSON from json.
func (s *ActivityListPublicEventsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListPublicEventsOKApplicationJSON to nil`)
	}
	var unwrapped []Event
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Event
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListPublicEventsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListReposStarredByAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListReposStarredByAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserDirection as json.
func (s ActivityListReposStarredByAuthenticatedUserDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserDirection from json.
func (s *ActivityListReposStarredByAuthenticatedUserDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListReposStarredByAuthenticatedUserDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ActivityListReposStarredByAuthenticatedUserDirection(v)
	return nil
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserOKApplicationJSON as json.
func (s ActivityListReposStarredByAuthenticatedUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Repository(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserOKApplicationJSON from json.
func (s *ActivityListReposStarredByAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListReposStarredByAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []Repository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Repository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListReposStarredByAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserSort as json.
func (s ActivityListReposStarredByAuthenticatedUserSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserSort from json.
func (s *ActivityListReposStarredByAuthenticatedUserSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListReposStarredByAuthenticatedUserSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ActivityListReposStarredByAuthenticatedUserSort(v)
	return nil
}

// Encode encodes ActivityListReposStarredByUserDirection as json.
func (s ActivityListReposStarredByUserDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActivityListReposStarredByUserDirection from json.
func (s *ActivityListReposStarredByUserDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListReposStarredByUserDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ActivityListReposStarredByUserDirection(v)
	return nil
}

// Encode encodes ActivityListReposStarredByUserSort as json.
func (s ActivityListReposStarredByUserSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActivityListReposStarredByUserSort from json.
func (s *ActivityListReposStarredByUserSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListReposStarredByUserSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ActivityListReposStarredByUserSort(v)
	return nil
}

// Encode encodes ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListWatchedReposForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListWatchedReposForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON as json.
func (s ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON from json.
func (s *ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityListWatchedReposForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivityMarkNotificationsAsReadAccepted) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ActivityMarkNotificationsAsReadAccepted from json.
func (s *ActivityMarkNotificationsAsReadAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkNotificationsAsReadAccepted to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActivityMarkNotificationsAsReadApplicationJSONForbidden as json.
func (s ActivityMarkNotificationsAsReadApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityMarkNotificationsAsReadApplicationJSONForbidden from json.
func (s *ActivityMarkNotificationsAsReadApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkNotificationsAsReadApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityMarkNotificationsAsReadApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityMarkNotificationsAsReadApplicationJSONUnauthorized as json.
func (s ActivityMarkNotificationsAsReadApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityMarkNotificationsAsReadApplicationJSONUnauthorized from json.
func (s *ActivityMarkNotificationsAsReadApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkNotificationsAsReadApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityMarkNotificationsAsReadApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivityMarkNotificationsAsReadReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.LastReadAt.Set {
		e.FieldStart("last_read_at")
		s.LastReadAt.Encode(e, json.EncodeDateTime)
	}
	if s.Read.Set {
		e.FieldStart("read")
		s.Read.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ActivityMarkNotificationsAsReadReq from json.
func (s *ActivityMarkNotificationsAsReadReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkNotificationsAsReadReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "last_read_at":
			s.LastReadAt.Reset()
			if err := s.LastReadAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "read":
			s.Read.Reset()
			if err := s.Read.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActivityMarkNotificationsAsReadResetContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActivityMarkNotificationsAsReadResetContent from json.
func (s *ActivityMarkNotificationsAsReadResetContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkNotificationsAsReadResetContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActivityMarkRepoNotificationsAsReadAccepted) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ActivityMarkRepoNotificationsAsReadAccepted from json.
func (s *ActivityMarkRepoNotificationsAsReadAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkRepoNotificationsAsReadAccepted to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActivityMarkRepoNotificationsAsReadReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.LastReadAt.Set {
		e.FieldStart("last_read_at")
		s.LastReadAt.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

// Decode decodes ActivityMarkRepoNotificationsAsReadReq from json.
func (s *ActivityMarkRepoNotificationsAsReadReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkRepoNotificationsAsReadReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "last_read_at":
			s.LastReadAt.Reset()
			if err := s.LastReadAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActivityMarkRepoNotificationsAsReadResetContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActivityMarkRepoNotificationsAsReadResetContent from json.
func (s *ActivityMarkRepoNotificationsAsReadResetContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkRepoNotificationsAsReadResetContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActivityMarkThreadAsReadResetContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActivityMarkThreadAsReadResetContent from json.
func (s *ActivityMarkThreadAsReadResetContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityMarkThreadAsReadResetContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ActivitySetRepoSubscriptionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Subscribed.Set {
		e.FieldStart("subscribed")
		s.Subscribed.Encode(e)
	}
	if s.Ignored.Set {
		e.FieldStart("ignored")
		s.Ignored.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ActivitySetRepoSubscriptionReq from json.
func (s *ActivitySetRepoSubscriptionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivitySetRepoSubscriptionReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscribed":
			s.Subscribed.Reset()
			if err := s.Subscribed.Decode(d); err != nil {
				return err
			}
		case "ignored":
			s.Ignored.Reset()
			if err := s.Ignored.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActivitySetThreadSubscriptionApplicationJSONForbidden as json.
func (s ActivitySetThreadSubscriptionApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivitySetThreadSubscriptionApplicationJSONForbidden from json.
func (s *ActivitySetThreadSubscriptionApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivitySetThreadSubscriptionApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivitySetThreadSubscriptionApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivitySetThreadSubscriptionApplicationJSONUnauthorized as json.
func (s ActivitySetThreadSubscriptionApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivitySetThreadSubscriptionApplicationJSONUnauthorized from json.
func (s *ActivitySetThreadSubscriptionApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivitySetThreadSubscriptionApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivitySetThreadSubscriptionApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivitySetThreadSubscriptionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Ignored.Set {
		e.FieldStart("ignored")
		s.Ignored.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ActivitySetThreadSubscriptionReq from json.
func (s *ActivitySetThreadSubscriptionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivitySetThreadSubscriptionReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ignored":
			s.Ignored.Reset()
			if err := s.Ignored.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityStarRepoForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound as json.
func (s ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound from json.
func (s *ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityStarRepoForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityStarRepoForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivityStarRepoForAuthenticatedUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActivityStarRepoForAuthenticatedUserNoContent from json.
func (s *ActivityStarRepoForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityStarRepoForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden as json.
func (s ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityUnstarRepoForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound as json.
func (s ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound from json.
func (s *ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityUnstarRepoForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivityUnstarRepoForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ActivityUnstarRepoForAuthenticatedUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ActivityUnstarRepoForAuthenticatedUserNoContent from json.
func (s *ActivityUnstarRepoForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ActivityUnstarRepoForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Actor) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("login")
	e.Str(s.Login)
	if s.DisplayLogin.Set {
		e.FieldStart("display_login")
		s.DisplayLogin.Encode(e)
	}

	e.FieldStart("gravatar_id")
	s.GravatarID.Encode(e)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("avatar_url")
	json.EncodeURI(e, s.AvatarURL)
	e.ObjEnd()
}

// Decode decodes Actor from json.
func (s *Actor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Actor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "display_login":
			s.DisplayLogin.Reset()
			if err := s.DisplayLogin.Decode(d); err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AlertCreatedAt as json.
func (s AlertCreatedAt) Encode(e *jx.Encoder) {
	unwrapped := time.Time(s)
	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes AlertCreatedAt from json.
func (s *AlertCreatedAt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AlertCreatedAt to nil`)
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertCreatedAt(unwrapped)
	return nil
}

// Encode encodes AlertHTMLURL as json.
func (s AlertHTMLURL) Encode(e *jx.Encoder) {
	unwrapped := url.URL(s)
	json.EncodeURI(e, unwrapped)
}

// Decode decodes AlertHTMLURL from json.
func (s *AlertHTMLURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AlertHTMLURL to nil`)
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertHTMLURL(unwrapped)
	return nil
}

// Encode encodes AlertInstancesURL as json.
func (s AlertInstancesURL) Encode(e *jx.Encoder) {
	unwrapped := url.URL(s)
	json.EncodeURI(e, unwrapped)
}

// Decode decodes AlertInstancesURL from json.
func (s *AlertInstancesURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AlertInstancesURL to nil`)
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertInstancesURL(unwrapped)
	return nil
}

// Encode encodes AlertNumber as json.
func (s AlertNumber) Encode(e *jx.Encoder) {
	unwrapped := int(s)
	e.Int(unwrapped)
}

// Decode decodes AlertNumber from json.
func (s *AlertNumber) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AlertNumber to nil`)
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertNumber(unwrapped)
	return nil
}

// Encode encodes AlertURL as json.
func (s AlertURL) Encode(e *jx.Encoder) {
	unwrapped := url.URL(s)
	json.EncodeURI(e, unwrapped)
}

// Decode decodes AlertURL from json.
func (s *AlertURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AlertURL to nil`)
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AlertURL(unwrapped)
	return nil
}

// Encode encodes AllowedActions as json.
func (s AllowedActions) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AllowedActions from json.
func (s *AllowedActions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AllowedActions to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AllowedActions(v)
	return nil
}

// Encode implements json.Marshaler.
func (s AppPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Actions.Set {
		e.FieldStart("actions")
		s.Actions.Encode(e)
	}
	if s.Administration.Set {
		e.FieldStart("administration")
		s.Administration.Encode(e)
	}
	if s.Checks.Set {
		e.FieldStart("checks")
		s.Checks.Encode(e)
	}
	if s.ContentReferences.Set {
		e.FieldStart("content_references")
		s.ContentReferences.Encode(e)
	}
	if s.Contents.Set {
		e.FieldStart("contents")
		s.Contents.Encode(e)
	}
	if s.Deployments.Set {
		e.FieldStart("deployments")
		s.Deployments.Encode(e)
	}
	if s.Environments.Set {
		e.FieldStart("environments")
		s.Environments.Encode(e)
	}
	if s.Issues.Set {
		e.FieldStart("issues")
		s.Issues.Encode(e)
	}
	if s.Metadata.Set {
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	if s.Packages.Set {
		e.FieldStart("packages")
		s.Packages.Encode(e)
	}
	if s.Pages.Set {
		e.FieldStart("pages")
		s.Pages.Encode(e)
	}
	if s.PullRequests.Set {
		e.FieldStart("pull_requests")
		s.PullRequests.Encode(e)
	}
	if s.RepositoryHooks.Set {
		e.FieldStart("repository_hooks")
		s.RepositoryHooks.Encode(e)
	}
	if s.RepositoryProjects.Set {
		e.FieldStart("repository_projects")
		s.RepositoryProjects.Encode(e)
	}
	if s.SecretScanningAlerts.Set {
		e.FieldStart("secret_scanning_alerts")
		s.SecretScanningAlerts.Encode(e)
	}
	if s.Secrets.Set {
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
	if s.SecurityEvents.Set {
		e.FieldStart("security_events")
		s.SecurityEvents.Encode(e)
	}
	if s.SingleFile.Set {
		e.FieldStart("single_file")
		s.SingleFile.Encode(e)
	}
	if s.Statuses.Set {
		e.FieldStart("statuses")
		s.Statuses.Encode(e)
	}
	if s.VulnerabilityAlerts.Set {
		e.FieldStart("vulnerability_alerts")
		s.VulnerabilityAlerts.Encode(e)
	}
	if s.Workflows.Set {
		e.FieldStart("workflows")
		s.Workflows.Encode(e)
	}
	if s.Members.Set {
		e.FieldStart("members")
		s.Members.Encode(e)
	}
	if s.OrganizationAdministration.Set {
		e.FieldStart("organization_administration")
		s.OrganizationAdministration.Encode(e)
	}
	if s.OrganizationHooks.Set {
		e.FieldStart("organization_hooks")
		s.OrganizationHooks.Encode(e)
	}
	if s.OrganizationPlan.Set {
		e.FieldStart("organization_plan")
		s.OrganizationPlan.Encode(e)
	}
	if s.OrganizationProjects.Set {
		e.FieldStart("organization_projects")
		s.OrganizationProjects.Encode(e)
	}
	if s.OrganizationPackages.Set {
		e.FieldStart("organization_packages")
		s.OrganizationPackages.Encode(e)
	}
	if s.OrganizationSecrets.Set {
		e.FieldStart("organization_secrets")
		s.OrganizationSecrets.Encode(e)
	}
	if s.OrganizationSelfHostedRunners.Set {
		e.FieldStart("organization_self_hosted_runners")
		s.OrganizationSelfHostedRunners.Encode(e)
	}
	if s.OrganizationUserBlocking.Set {
		e.FieldStart("organization_user_blocking")
		s.OrganizationUserBlocking.Encode(e)
	}
	if s.TeamDiscussions.Set {
		e.FieldStart("team_discussions")
		s.TeamDiscussions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes AppPermissions from json.
func (s *AppPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "actions":
			s.Actions.Reset()
			if err := s.Actions.Decode(d); err != nil {
				return err
			}
		case "administration":
			s.Administration.Reset()
			if err := s.Administration.Decode(d); err != nil {
				return err
			}
		case "checks":
			s.Checks.Reset()
			if err := s.Checks.Decode(d); err != nil {
				return err
			}
		case "content_references":
			s.ContentReferences.Reset()
			if err := s.ContentReferences.Decode(d); err != nil {
				return err
			}
		case "contents":
			s.Contents.Reset()
			if err := s.Contents.Decode(d); err != nil {
				return err
			}
		case "deployments":
			s.Deployments.Reset()
			if err := s.Deployments.Decode(d); err != nil {
				return err
			}
		case "environments":
			s.Environments.Reset()
			if err := s.Environments.Decode(d); err != nil {
				return err
			}
		case "issues":
			s.Issues.Reset()
			if err := s.Issues.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "packages":
			s.Packages.Reset()
			if err := s.Packages.Decode(d); err != nil {
				return err
			}
		case "pages":
			s.Pages.Reset()
			if err := s.Pages.Decode(d); err != nil {
				return err
			}
		case "pull_requests":
			s.PullRequests.Reset()
			if err := s.PullRequests.Decode(d); err != nil {
				return err
			}
		case "repository_hooks":
			s.RepositoryHooks.Reset()
			if err := s.RepositoryHooks.Decode(d); err != nil {
				return err
			}
		case "repository_projects":
			s.RepositoryProjects.Reset()
			if err := s.RepositoryProjects.Decode(d); err != nil {
				return err
			}
		case "secret_scanning_alerts":
			s.SecretScanningAlerts.Reset()
			if err := s.SecretScanningAlerts.Decode(d); err != nil {
				return err
			}
		case "secrets":
			s.Secrets.Reset()
			if err := s.Secrets.Decode(d); err != nil {
				return err
			}
		case "security_events":
			s.SecurityEvents.Reset()
			if err := s.SecurityEvents.Decode(d); err != nil {
				return err
			}
		case "single_file":
			s.SingleFile.Reset()
			if err := s.SingleFile.Decode(d); err != nil {
				return err
			}
		case "statuses":
			s.Statuses.Reset()
			if err := s.Statuses.Decode(d); err != nil {
				return err
			}
		case "vulnerability_alerts":
			s.VulnerabilityAlerts.Reset()
			if err := s.VulnerabilityAlerts.Decode(d); err != nil {
				return err
			}
		case "workflows":
			s.Workflows.Reset()
			if err := s.Workflows.Decode(d); err != nil {
				return err
			}
		case "members":
			s.Members.Reset()
			if err := s.Members.Decode(d); err != nil {
				return err
			}
		case "organization_administration":
			s.OrganizationAdministration.Reset()
			if err := s.OrganizationAdministration.Decode(d); err != nil {
				return err
			}
		case "organization_hooks":
			s.OrganizationHooks.Reset()
			if err := s.OrganizationHooks.Decode(d); err != nil {
				return err
			}
		case "organization_plan":
			s.OrganizationPlan.Reset()
			if err := s.OrganizationPlan.Decode(d); err != nil {
				return err
			}
		case "organization_projects":
			s.OrganizationProjects.Reset()
			if err := s.OrganizationProjects.Decode(d); err != nil {
				return err
			}
		case "organization_packages":
			s.OrganizationPackages.Reset()
			if err := s.OrganizationPackages.Decode(d); err != nil {
				return err
			}
		case "organization_secrets":
			s.OrganizationSecrets.Reset()
			if err := s.OrganizationSecrets.Decode(d); err != nil {
				return err
			}
		case "organization_self_hosted_runners":
			s.OrganizationSelfHostedRunners.Reset()
			if err := s.OrganizationSelfHostedRunners.Decode(d); err != nil {
				return err
			}
		case "organization_user_blocking":
			s.OrganizationUserBlocking.Reset()
			if err := s.OrganizationUserBlocking.Decode(d); err != nil {
				return err
			}
		case "team_discussions":
			s.TeamDiscussions.Reset()
			if err := s.TeamDiscussions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AppPermissionsActions as json.
func (s AppPermissionsActions) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsActions from json.
func (s *AppPermissionsActions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsActions to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsActions(v)
	return nil
}

// Encode encodes AppPermissionsAdministration as json.
func (s AppPermissionsAdministration) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsAdministration from json.
func (s *AppPermissionsAdministration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsAdministration to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsAdministration(v)
	return nil
}

// Encode encodes AppPermissionsChecks as json.
func (s AppPermissionsChecks) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsChecks from json.
func (s *AppPermissionsChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsChecks to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsChecks(v)
	return nil
}

// Encode encodes AppPermissionsContentReferences as json.
func (s AppPermissionsContentReferences) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsContentReferences from json.
func (s *AppPermissionsContentReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsContentReferences to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsContentReferences(v)
	return nil
}

// Encode encodes AppPermissionsContents as json.
func (s AppPermissionsContents) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsContents from json.
func (s *AppPermissionsContents) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsContents to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsContents(v)
	return nil
}

// Encode encodes AppPermissionsDeployments as json.
func (s AppPermissionsDeployments) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsDeployments from json.
func (s *AppPermissionsDeployments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsDeployments to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsDeployments(v)
	return nil
}

// Encode encodes AppPermissionsEnvironments as json.
func (s AppPermissionsEnvironments) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsEnvironments from json.
func (s *AppPermissionsEnvironments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsEnvironments to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsEnvironments(v)
	return nil
}

// Encode encodes AppPermissionsIssues as json.
func (s AppPermissionsIssues) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsIssues from json.
func (s *AppPermissionsIssues) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsIssues to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsIssues(v)
	return nil
}

// Encode encodes AppPermissionsMembers as json.
func (s AppPermissionsMembers) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsMembers from json.
func (s *AppPermissionsMembers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsMembers to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsMembers(v)
	return nil
}

// Encode encodes AppPermissionsMetadata as json.
func (s AppPermissionsMetadata) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsMetadata from json.
func (s *AppPermissionsMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsMetadata to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsMetadata(v)
	return nil
}

// Encode encodes AppPermissionsOrganizationAdministration as json.
func (s AppPermissionsOrganizationAdministration) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationAdministration from json.
func (s *AppPermissionsOrganizationAdministration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsOrganizationAdministration to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsOrganizationAdministration(v)
	return nil
}

// Encode encodes AppPermissionsOrganizationHooks as json.
func (s AppPermissionsOrganizationHooks) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationHooks from json.
func (s *AppPermissionsOrganizationHooks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsOrganizationHooks to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsOrganizationHooks(v)
	return nil
}

// Encode encodes AppPermissionsOrganizationPackages as json.
func (s AppPermissionsOrganizationPackages) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationPackages from json.
func (s *AppPermissionsOrganizationPackages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsOrganizationPackages to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsOrganizationPackages(v)
	return nil
}

// Encode encodes AppPermissionsOrganizationPlan as json.
func (s AppPermissionsOrganizationPlan) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationPlan from json.
func (s *AppPermissionsOrganizationPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsOrganizationPlan to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsOrganizationPlan(v)
	return nil
}

// Encode encodes AppPermissionsOrganizationProjects as json.
func (s AppPermissionsOrganizationProjects) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationProjects from json.
func (s *AppPermissionsOrganizationProjects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsOrganizationProjects to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsOrganizationProjects(v)
	return nil
}

// Encode encodes AppPermissionsOrganizationSecrets as json.
func (s AppPermissionsOrganizationSecrets) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationSecrets from json.
func (s *AppPermissionsOrganizationSecrets) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsOrganizationSecrets to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsOrganizationSecrets(v)
	return nil
}

// Encode encodes AppPermissionsOrganizationSelfHostedRunners as json.
func (s AppPermissionsOrganizationSelfHostedRunners) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationSelfHostedRunners from json.
func (s *AppPermissionsOrganizationSelfHostedRunners) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsOrganizationSelfHostedRunners to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsOrganizationSelfHostedRunners(v)
	return nil
}

// Encode encodes AppPermissionsOrganizationUserBlocking as json.
func (s AppPermissionsOrganizationUserBlocking) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsOrganizationUserBlocking from json.
func (s *AppPermissionsOrganizationUserBlocking) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsOrganizationUserBlocking to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsOrganizationUserBlocking(v)
	return nil
}

// Encode encodes AppPermissionsPackages as json.
func (s AppPermissionsPackages) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsPackages from json.
func (s *AppPermissionsPackages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsPackages to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsPackages(v)
	return nil
}

// Encode encodes AppPermissionsPages as json.
func (s AppPermissionsPages) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsPages from json.
func (s *AppPermissionsPages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsPages to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsPages(v)
	return nil
}

// Encode encodes AppPermissionsPullRequests as json.
func (s AppPermissionsPullRequests) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsPullRequests from json.
func (s *AppPermissionsPullRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsPullRequests to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsPullRequests(v)
	return nil
}

// Encode encodes AppPermissionsRepositoryHooks as json.
func (s AppPermissionsRepositoryHooks) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsRepositoryHooks from json.
func (s *AppPermissionsRepositoryHooks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsRepositoryHooks to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsRepositoryHooks(v)
	return nil
}

// Encode encodes AppPermissionsRepositoryProjects as json.
func (s AppPermissionsRepositoryProjects) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsRepositoryProjects from json.
func (s *AppPermissionsRepositoryProjects) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsRepositoryProjects to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsRepositoryProjects(v)
	return nil
}

// Encode encodes AppPermissionsSecretScanningAlerts as json.
func (s AppPermissionsSecretScanningAlerts) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsSecretScanningAlerts from json.
func (s *AppPermissionsSecretScanningAlerts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsSecretScanningAlerts to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsSecretScanningAlerts(v)
	return nil
}

// Encode encodes AppPermissionsSecrets as json.
func (s AppPermissionsSecrets) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsSecrets from json.
func (s *AppPermissionsSecrets) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsSecrets to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsSecrets(v)
	return nil
}

// Encode encodes AppPermissionsSecurityEvents as json.
func (s AppPermissionsSecurityEvents) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsSecurityEvents from json.
func (s *AppPermissionsSecurityEvents) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsSecurityEvents to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsSecurityEvents(v)
	return nil
}

// Encode encodes AppPermissionsSingleFile as json.
func (s AppPermissionsSingleFile) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsSingleFile from json.
func (s *AppPermissionsSingleFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsSingleFile to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsSingleFile(v)
	return nil
}

// Encode encodes AppPermissionsStatuses as json.
func (s AppPermissionsStatuses) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsStatuses from json.
func (s *AppPermissionsStatuses) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsStatuses to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsStatuses(v)
	return nil
}

// Encode encodes AppPermissionsTeamDiscussions as json.
func (s AppPermissionsTeamDiscussions) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsTeamDiscussions from json.
func (s *AppPermissionsTeamDiscussions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsTeamDiscussions to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsTeamDiscussions(v)
	return nil
}

// Encode encodes AppPermissionsVulnerabilityAlerts as json.
func (s AppPermissionsVulnerabilityAlerts) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsVulnerabilityAlerts from json.
func (s *AppPermissionsVulnerabilityAlerts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsVulnerabilityAlerts to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsVulnerabilityAlerts(v)
	return nil
}

// Encode encodes AppPermissionsWorkflows as json.
func (s AppPermissionsWorkflows) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppPermissionsWorkflows from json.
func (s *AppPermissionsWorkflows) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppPermissionsWorkflows to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppPermissionsWorkflows(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ApplicationGrant) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("app")
	s.App.Encode(e)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("scopes")
	e.ArrStart()
	for _, elem := range s.Scopes {
		e.Str(elem)
	}
	e.ArrEnd()
	if s.User.Set {
		e.FieldStart("user")
		s.User.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ApplicationGrant from json.
func (s *ApplicationGrant) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ApplicationGrant to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "app":
			if err := s.App.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "scopes":
			s.Scopes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Scopes = append(s.Scopes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ApplicationGrantApp) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("client_id")
	e.Str(s.ClientID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	e.ObjEnd()
}

// Decode decodes ApplicationGrantApp from json.
func (s *ApplicationGrantApp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ApplicationGrantApp to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_id":
			v, err := d.Str()
			s.ClientID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AppsAddRepoToInstallationApplicationJSONForbidden as json.
func (s AppsAddRepoToInstallationApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsAddRepoToInstallationApplicationJSONForbidden from json.
func (s *AppsAddRepoToInstallationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsAddRepoToInstallationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsAddRepoToInstallationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsAddRepoToInstallationApplicationJSONNotFound as json.
func (s AppsAddRepoToInstallationApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsAddRepoToInstallationApplicationJSONNotFound from json.
func (s *AppsAddRepoToInstallationApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsAddRepoToInstallationApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsAddRepoToInstallationApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsAddRepoToInstallationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes AppsAddRepoToInstallationNoContent from json.
func (s *AppsAddRepoToInstallationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsAddRepoToInstallationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsCheckTokenReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("access_token")
	e.Str(s.AccessToken)
	e.ObjEnd()
}

// Decode decodes AppsCheckTokenReq from json.
func (s *AppsCheckTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsCheckTokenReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			v, err := d.Str()
			s.AccessToken = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsCreateContentAttachmentReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("body")
	e.Str(s.Body)
	e.ObjEnd()
}

// Decode decodes AppsCreateContentAttachmentReq from json.
func (s *AppsCreateContentAttachmentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsCreateContentAttachmentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsCreateFromManifestReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes AppsCreateFromManifestReq from json.
func (s *AppsCreateFromManifestReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsCreateFromManifestReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsCreateInstallationAccessTokenReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Repositories != nil {
		e.FieldStart("repositories")
		e.ArrStart()
		for _, elem := range s.Repositories {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.RepositoryIds != nil {
		e.FieldStart("repository_ids")
		e.ArrStart()
		for _, elem := range s.RepositoryIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes AppsCreateInstallationAccessTokenReq from json.
func (s *AppsCreateInstallationAccessTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsCreateInstallationAccessTokenReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "repository_ids":
			s.RepositoryIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.RepositoryIds = append(s.RepositoryIds, elem)
				return nil
			}); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsDeleteAuthorizationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes AppsDeleteAuthorizationNoContent from json.
func (s *AppsDeleteAuthorizationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsDeleteAuthorizationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsDeleteAuthorizationReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("access_token")
	e.Str(s.AccessToken)
	e.ObjEnd()
}

// Decode decodes AppsDeleteAuthorizationReq from json.
func (s *AppsDeleteAuthorizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsDeleteAuthorizationReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			v, err := d.Str()
			s.AccessToken = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsDeleteInstallationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes AppsDeleteInstallationNoContent from json.
func (s *AppsDeleteInstallationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsDeleteInstallationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsDeleteTokenNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes AppsDeleteTokenNoContent from json.
func (s *AppsDeleteTokenNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsDeleteTokenNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsDeleteTokenReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("access_token")
	e.Str(s.AccessToken)
	e.ObjEnd()
}

// Decode decodes AppsDeleteTokenReq from json.
func (s *AppsDeleteTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsDeleteTokenReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			v, err := d.Str()
			s.AccessToken = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AppsGetBySlugApplicationJSONForbidden as json.
func (s AppsGetBySlugApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsGetBySlugApplicationJSONForbidden from json.
func (s *AppsGetBySlugApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsGetBySlugApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsGetBySlugApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsGetBySlugApplicationJSONNotFound as json.
func (s AppsGetBySlugApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsGetBySlugApplicationJSONNotFound from json.
func (s *AppsGetBySlugApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsGetBySlugApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsGetBySlugApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsGetSubscriptionPlanForAccountApplicationJSONNotFound as json.
func (s AppsGetSubscriptionPlanForAccountApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsGetSubscriptionPlanForAccountApplicationJSONNotFound from json.
func (s *AppsGetSubscriptionPlanForAccountApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsGetSubscriptionPlanForAccountApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsGetSubscriptionPlanForAccountApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized as json.
func (s AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized from json.
func (s *AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsGetSubscriptionPlanForAccountApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsGetSubscriptionPlanForAccountStubbedNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes AppsGetSubscriptionPlanForAccountStubbedNotFound from json.
func (s *AppsGetSubscriptionPlanForAccountStubbedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsGetSubscriptionPlanForAccountStubbedNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AppsListAccountsForPlanDirection as json.
func (s AppsListAccountsForPlanDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppsListAccountsForPlanDirection from json.
func (s *AppsListAccountsForPlanDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListAccountsForPlanDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppsListAccountsForPlanDirection(v)
	return nil
}

// Encode encodes AppsListAccountsForPlanSort as json.
func (s AppsListAccountsForPlanSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppsListAccountsForPlanSort from json.
func (s *AppsListAccountsForPlanSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListAccountsForPlanSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppsListAccountsForPlanSort(v)
	return nil
}

// Encode encodes AppsListAccountsForPlanStubbedDirection as json.
func (s AppsListAccountsForPlanStubbedDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppsListAccountsForPlanStubbedDirection from json.
func (s *AppsListAccountsForPlanStubbedDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListAccountsForPlanStubbedDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppsListAccountsForPlanStubbedDirection(v)
	return nil
}

// Encode encodes AppsListAccountsForPlanStubbedOKApplicationJSON as json.
func (s AppsListAccountsForPlanStubbedOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []MarketplacePurchase(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AppsListAccountsForPlanStubbedOKApplicationJSON from json.
func (s *AppsListAccountsForPlanStubbedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListAccountsForPlanStubbedOKApplicationJSON to nil`)
	}
	var unwrapped []MarketplacePurchase
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MarketplacePurchase
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListAccountsForPlanStubbedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsListAccountsForPlanStubbedSort as json.
func (s AppsListAccountsForPlanStubbedSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AppsListAccountsForPlanStubbedSort from json.
func (s *AppsListAccountsForPlanStubbedSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListAccountsForPlanStubbedSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AppsListAccountsForPlanStubbedSort(v)
	return nil
}

// Encode encodes AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden as json.
func (s AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden from json.
func (s *AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListInstallationReposForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound as json.
func (s AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound from json.
func (s *AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListInstallationReposForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsListInstallationReposForAuthenticatedUserOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)
	if s.RepositorySelection.Set {
		e.FieldStart("repository_selection")
		s.RepositorySelection.Encode(e)
	}

	e.FieldStart("repositories")
	e.ArrStart()
	for _, elem := range s.Repositories {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes AppsListInstallationReposForAuthenticatedUserOK from json.
func (s *AppsListInstallationReposForAuthenticatedUserOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListInstallationReposForAuthenticatedUserOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "repository_selection":
			s.RepositorySelection.Reset()
			if err := s.RepositorySelection.Decode(d); err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Repository
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AppsListPlansApplicationJSONNotFound as json.
func (s AppsListPlansApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListPlansApplicationJSONNotFound from json.
func (s *AppsListPlansApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListPlansApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListPlansApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsListPlansApplicationJSONUnauthorized as json.
func (s AppsListPlansApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListPlansApplicationJSONUnauthorized from json.
func (s *AppsListPlansApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListPlansApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListPlansApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes AppsListPlansOKApplicationJSON as json.
func (s AppsListPlansOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []MarketplaceListingPlan(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AppsListPlansOKApplicationJSON from json.
func (s *AppsListPlansOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListPlansOKApplicationJSON to nil`)
	}
	var unwrapped []MarketplaceListingPlan
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MarketplaceListingPlan
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListPlansOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsListPlansStubbedOKApplicationJSON as json.
func (s AppsListPlansStubbedOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []MarketplaceListingPlan(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AppsListPlansStubbedOKApplicationJSON from json.
func (s *AppsListPlansStubbedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListPlansStubbedOKApplicationJSON to nil`)
	}
	var unwrapped []MarketplaceListingPlan
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MarketplaceListingPlan
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListPlansStubbedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsListReposAccessibleToInstallationApplicationJSONForbidden as json.
func (s AppsListReposAccessibleToInstallationApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListReposAccessibleToInstallationApplicationJSONForbidden from json.
func (s *AppsListReposAccessibleToInstallationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListReposAccessibleToInstallationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListReposAccessibleToInstallationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsListReposAccessibleToInstallationApplicationJSONUnauthorized as json.
func (s AppsListReposAccessibleToInstallationApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListReposAccessibleToInstallationApplicationJSONUnauthorized from json.
func (s *AppsListReposAccessibleToInstallationApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListReposAccessibleToInstallationApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListReposAccessibleToInstallationApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsListReposAccessibleToInstallationOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("repositories")
	e.ArrStart()
	for _, elem := range s.Repositories {
		elem.Encode(e)
	}
	e.ArrEnd()
	if s.RepositorySelection.Set {
		e.FieldStart("repository_selection")
		s.RepositorySelection.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes AppsListReposAccessibleToInstallationOK from json.
func (s *AppsListReposAccessibleToInstallationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListReposAccessibleToInstallationOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Repository
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "repository_selection":
			s.RepositorySelection.Reset()
			if err := s.RepositorySelection.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound as json.
func (s AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound from json.
func (s *AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListSubscriptionsForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListSubscriptionsForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON as json.
func (s AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []UserMarketplacePurchase(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON from json.
func (s *AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []UserMarketplacePurchase
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserMarketplacePurchase
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListSubscriptionsForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON as json.
func (s AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []UserMarketplacePurchase(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON from json.
func (s *AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON to nil`)
	}
	var unwrapped []UserMarketplacePurchase
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserMarketplacePurchase
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsListSubscriptionsForAuthenticatedUserStubbedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes AppsRemoveRepoFromInstallationApplicationJSONForbidden as json.
func (s AppsRemoveRepoFromInstallationApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsRemoveRepoFromInstallationApplicationJSONForbidden from json.
func (s *AppsRemoveRepoFromInstallationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsRemoveRepoFromInstallationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsRemoveRepoFromInstallationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes AppsRemoveRepoFromInstallationApplicationJSONNotFound as json.
func (s AppsRemoveRepoFromInstallationApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes AppsRemoveRepoFromInstallationApplicationJSONNotFound from json.
func (s *AppsRemoveRepoFromInstallationApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsRemoveRepoFromInstallationApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AppsRemoveRepoFromInstallationApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s AppsRemoveRepoFromInstallationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes AppsRemoveRepoFromInstallationNoContent from json.
func (s *AppsRemoveRepoFromInstallationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsRemoveRepoFromInstallationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsResetTokenReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("access_token")
	e.Str(s.AccessToken)
	e.ObjEnd()
}

// Decode decodes AppsResetTokenReq from json.
func (s *AppsResetTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsResetTokenReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			v, err := d.Str()
			s.AccessToken = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsRevokeInstallationAccessTokenNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes AppsRevokeInstallationAccessTokenNoContent from json.
func (s *AppsRevokeInstallationAccessTokenNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsRevokeInstallationAccessTokenNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsScopeTokenReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("access_token")
	e.Str(s.AccessToken)
	if s.Target.Set {
		e.FieldStart("target")
		s.Target.Encode(e)
	}
	if s.TargetID.Set {
		e.FieldStart("target_id")
		s.TargetID.Encode(e)
	}
	if s.Repositories != nil {
		e.FieldStart("repositories")
		e.ArrStart()
		for _, elem := range s.Repositories {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.RepositoryIds != nil {
		e.FieldStart("repository_ids")
		e.ArrStart()
		for _, elem := range s.RepositoryIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes AppsScopeTokenReq from json.
func (s *AppsScopeTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsScopeTokenReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			v, err := d.Str()
			s.AccessToken = string(v)
			if err != nil {
				return err
			}
		case "target":
			s.Target.Reset()
			if err := s.Target.Decode(d); err != nil {
				return err
			}
		case "target_id":
			s.TargetID.Reset()
			if err := s.TargetID.Decode(d); err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "repository_ids":
			s.RepositoryIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.RepositoryIds = append(s.RepositoryIds, elem)
				return nil
			}); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsSuspendInstallationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes AppsSuspendInstallationNoContent from json.
func (s *AppsSuspendInstallationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsSuspendInstallationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsUnsuspendInstallationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes AppsUnsuspendInstallationNoContent from json.
func (s *AppsUnsuspendInstallationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsUnsuspendInstallationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AppsUpdateWebhookConfigForAppReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.ContentType.Set {
		e.FieldStart("content_type")
		s.ContentType.Encode(e)
	}
	if s.Secret.Set {
		e.FieldStart("secret")
		s.Secret.Encode(e)
	}
	if s.InsecureSsl != nil {
		e.FieldStart("insecure_ssl")
		s.InsecureSsl.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes AppsUpdateWebhookConfigForAppReq from json.
func (s *AppsUpdateWebhookConfigForAppReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AppsUpdateWebhookConfigForAppReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl = nil
			var elem WebhookConfigInsecureSsl
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.InsecureSsl = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Artifact) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("size_in_bytes")
	e.Int(s.SizeInBytes)

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("archive_download_url")
	e.Str(s.ArchiveDownloadURL)

	e.FieldStart("expired")
	e.Bool(s.Expired)

	e.FieldStart("created_at")
	s.CreatedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("expires_at")
	s.ExpiresAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("updated_at")
	s.UpdatedAt.Encode(e, json.EncodeDateTime)
	e.ObjEnd()
}

// Decode decodes Artifact from json.
func (s *Artifact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Artifact to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "size_in_bytes":
			v, err := d.Int()
			s.SizeInBytes = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "archive_download_url":
			v, err := d.Str()
			s.ArchiveDownloadURL = string(v)
			if err != nil {
				return err
			}
		case "expired":
			v, err := d.Bool()
			s.Expired = bool(v)
			if err != nil {
				return err
			}
		case "created_at":
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "expires_at":
			if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AuditLogEvent) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Timestamp.Set {
		e.FieldStart("@timestamp")
		s.Timestamp.Encode(e)
	}
	if s.Action.Set {
		e.FieldStart("action")
		s.Action.Encode(e)
	}
	if s.Active.Set {
		e.FieldStart("active")
		s.Active.Encode(e)
	}
	if s.ActiveWas.Set {
		e.FieldStart("active_was")
		s.ActiveWas.Encode(e)
	}
	if s.Actor.Set {
		e.FieldStart("actor")
		s.Actor.Encode(e)
	}
	if s.ActorID.Set {
		e.FieldStart("actor_id")
		s.ActorID.Encode(e)
	}
	if s.ActorLocation.Set {
		e.FieldStart("actor_location")
		s.ActorLocation.Encode(e)
	}
	if s.Data != nil {
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	if s.OrgID.Set {
		e.FieldStart("org_id")
		s.OrgID.Encode(e)
	}
	if s.BlockedUser.Set {
		e.FieldStart("blocked_user")
		s.BlockedUser.Encode(e)
	}
	if s.Business.Set {
		e.FieldStart("business")
		s.Business.Encode(e)
	}
	if s.Config != nil {
		e.FieldStart("config")
		e.ArrStart()
		for _, elem := range s.Config {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.ConfigWas != nil {
		e.FieldStart("config_was")
		e.ArrStart()
		for _, elem := range s.ConfigWas {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.ContentType.Set {
		e.FieldStart("content_type")
		s.ContentType.Encode(e)
	}
	if s.CreatedAt.Set {
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e)
	}
	if s.DeployKeyFingerprint.Set {
		e.FieldStart("deploy_key_fingerprint")
		s.DeployKeyFingerprint.Encode(e)
	}
	if s.DocumentID.Set {
		e.FieldStart("_document_id")
		s.DocumentID.Encode(e)
	}
	if s.Emoji.Set {
		e.FieldStart("emoji")
		s.Emoji.Encode(e)
	}
	if s.Events != nil {
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.EventsWere != nil {
		e.FieldStart("events_were")
		e.ArrStart()
		for _, elem := range s.EventsWere {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Explanation.Set {
		e.FieldStart("explanation")
		s.Explanation.Encode(e)
	}
	if s.Fingerprint.Set {
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	if s.HookID.Set {
		e.FieldStart("hook_id")
		s.HookID.Encode(e)
	}
	if s.LimitedAvailability.Set {
		e.FieldStart("limited_availability")
		s.LimitedAvailability.Encode(e)
	}
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.OldUser.Set {
		e.FieldStart("old_user")
		s.OldUser.Encode(e)
	}
	if s.OpensshPublicKey.Set {
		e.FieldStart("openssh_public_key")
		s.OpensshPublicKey.Encode(e)
	}
	if s.Org.Set {
		e.FieldStart("org")
		s.Org.Encode(e)
	}
	if s.PreviousVisibility.Set {
		e.FieldStart("previous_visibility")
		s.PreviousVisibility.Encode(e)
	}
	if s.ReadOnly.Set {
		e.FieldStart("read_only")
		s.ReadOnly.Encode(e)
	}
	if s.Repo.Set {
		e.FieldStart("repo")
		s.Repo.Encode(e)
	}
	if s.Repository.Set {
		e.FieldStart("repository")
		s.Repository.Encode(e)
	}
	if s.RepositoryPublic.Set {
		e.FieldStart("repository_public")
		s.RepositoryPublic.Encode(e)
	}
	if s.TargetLogin.Set {
		e.FieldStart("target_login")
		s.TargetLogin.Encode(e)
	}
	if s.Team.Set {
		e.FieldStart("team")
		s.Team.Encode(e)
	}
	if s.TransportProtocol.Set {
		e.FieldStart("transport_protocol")
		s.TransportProtocol.Encode(e)
	}
	if s.TransportProtocolName.Set {
		e.FieldStart("transport_protocol_name")
		s.TransportProtocolName.Encode(e)
	}
	if s.User.Set {
		e.FieldStart("user")
		s.User.Encode(e)
	}
	if s.Visibility.Set {
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes AuditLogEvent from json.
func (s *AuditLogEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AuditLogEvent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "@timestamp":
			s.Timestamp.Reset()
			if err := s.Timestamp.Decode(d); err != nil {
				return err
			}
		case "action":
			s.Action.Reset()
			if err := s.Action.Decode(d); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		case "active_was":
			s.ActiveWas.Reset()
			if err := s.ActiveWas.Decode(d); err != nil {
				return err
			}
		case "actor":
			s.Actor.Reset()
			if err := s.Actor.Decode(d); err != nil {
				return err
			}
		case "actor_id":
			s.ActorID.Reset()
			if err := s.ActorID.Decode(d); err != nil {
				return err
			}
		case "actor_location":
			s.ActorLocation.Reset()
			if err := s.ActorLocation.Decode(d); err != nil {
				return err
			}
		case "data":
			s.Data = nil
			var elem AuditLogEventData
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Data = &elem
		case "org_id":
			s.OrgID.Reset()
			if err := s.OrgID.Decode(d); err != nil {
				return err
			}
		case "blocked_user":
			s.BlockedUser.Reset()
			if err := s.BlockedUser.Decode(d); err != nil {
				return err
			}
		case "business":
			s.Business.Reset()
			if err := s.Business.Decode(d); err != nil {
				return err
			}
		case "config":
			s.Config = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Config = append(s.Config, elem)
				return nil
			}); err != nil {
				return err
			}
		case "config_was":
			s.ConfigWas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.ConfigWas = append(s.ConfigWas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "deploy_key_fingerprint":
			s.DeployKeyFingerprint.Reset()
			if err := s.DeployKeyFingerprint.Decode(d); err != nil {
				return err
			}
		case "_document_id":
			s.DocumentID.Reset()
			if err := s.DocumentID.Decode(d); err != nil {
				return err
			}
		case "emoji":
			s.Emoji.Reset()
			if err := s.Emoji.Decode(d); err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "events_were":
			s.EventsWere = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.EventsWere = append(s.EventsWere, elem)
				return nil
			}); err != nil {
				return err
			}
		case "explanation":
			s.Explanation.Reset()
			if err := s.Explanation.Decode(d); err != nil {
				return err
			}
		case "fingerprint":
			s.Fingerprint.Reset()
			if err := s.Fingerprint.Decode(d); err != nil {
				return err
			}
		case "hook_id":
			s.HookID.Reset()
			if err := s.HookID.Decode(d); err != nil {
				return err
			}
		case "limited_availability":
			s.LimitedAvailability.Reset()
			if err := s.LimitedAvailability.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "old_user":
			s.OldUser.Reset()
			if err := s.OldUser.Decode(d); err != nil {
				return err
			}
		case "openssh_public_key":
			s.OpensshPublicKey.Reset()
			if err := s.OpensshPublicKey.Decode(d); err != nil {
				return err
			}
		case "org":
			s.Org.Reset()
			if err := s.Org.Decode(d); err != nil {
				return err
			}
		case "previous_visibility":
			s.PreviousVisibility.Reset()
			if err := s.PreviousVisibility.Decode(d); err != nil {
				return err
			}
		case "read_only":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		case "repo":
			s.Repo.Reset()
			if err := s.Repo.Decode(d); err != nil {
				return err
			}
		case "repository":
			s.Repository.Reset()
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "repository_public":
			s.RepositoryPublic.Reset()
			if err := s.RepositoryPublic.Decode(d); err != nil {
				return err
			}
		case "target_login":
			s.TargetLogin.Reset()
			if err := s.TargetLogin.Decode(d); err != nil {
				return err
			}
		case "team":
			s.Team.Reset()
			if err := s.Team.Decode(d); err != nil {
				return err
			}
		case "transport_protocol":
			s.TransportProtocol.Reset()
			if err := s.TransportProtocol.Decode(d); err != nil {
				return err
			}
		case "transport_protocol_name":
			s.TransportProtocolName.Reset()
			if err := s.TransportProtocolName.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AuditLogEventActorLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.CountryName.Set {
		e.FieldStart("country_name")
		s.CountryName.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes AuditLogEventActorLocation from json.
func (s *AuditLogEventActorLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AuditLogEventActorLocation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "country_name":
			s.CountryName.Reset()
			if err := s.CountryName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AuditLogEventData) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes AuditLogEventData from json.
func (s *AuditLogEventData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AuditLogEventData to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AuthenticationToken) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("token")
	e.Str(s.Token)

	e.FieldStart("expires_at")
	json.EncodeDateTime(e, s.ExpiresAt)
	if s.Permissions != nil {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	if s.Repositories != nil {
		e.FieldStart("repositories")
		e.ArrStart()
		for _, elem := range s.Repositories {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.SingleFile.Set {
		e.FieldStart("single_file")
		s.SingleFile.Encode(e)
	}
	if s.RepositorySelection.Set {
		e.FieldStart("repository_selection")
		s.RepositorySelection.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes AuthenticationToken from json.
func (s *AuthenticationToken) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AuthenticationToken to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			v, err := d.Str()
			s.Token = string(v)
			if err != nil {
				return err
			}
		case "expires_at":
			v, err := json.DecodeDateTime(d)
			s.ExpiresAt = v
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions = nil
			var elem AuthenticationTokenPermissions
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Permissions = &elem
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Repository
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "single_file":
			s.SingleFile.Reset()
			if err := s.SingleFile.Decode(d); err != nil {
				return err
			}
		case "repository_selection":
			s.RepositorySelection.Reset()
			if err := s.RepositorySelection.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AuthenticationTokenPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes AuthenticationTokenPermissions from json.
func (s *AuthenticationTokenPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AuthenticationTokenPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AuthenticationTokenRepositorySelection as json.
func (s AuthenticationTokenRepositorySelection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AuthenticationTokenRepositorySelection from json.
func (s *AuthenticationTokenRepositorySelection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AuthenticationTokenRepositorySelection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AuthenticationTokenRepositorySelection(v)
	return nil
}

// Encode encodes AuthorAssociation as json.
func (s AuthorAssociation) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AuthorAssociation from json.
func (s *AuthorAssociation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AuthorAssociation to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AuthorAssociation(v)
	return nil
}

// Encode implements json.Marshaler.
func (s Authorization) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("scopes")
	if s.Scopes == nil {
		e.Null()
	} else {
		e.ArrStart()
		for _, elem := range s.Scopes {
			e.Str(elem)
		}
		e.ArrEnd()
	}

	e.FieldStart("token")
	e.Str(s.Token)

	e.FieldStart("token_last_eight")
	s.TokenLastEight.Encode(e)

	e.FieldStart("hashed_token")
	s.HashedToken.Encode(e)

	e.FieldStart("app")
	s.App.Encode(e)

	e.FieldStart("note")
	s.Note.Encode(e)

	e.FieldStart("note_url")
	s.NoteURL.Encode(e)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("fingerprint")
	s.Fingerprint.Encode(e)
	if s.User.Set {
		e.FieldStart("user")
		s.User.Encode(e)
	}
	if s.Installation.Set {
		e.FieldStart("installation")
		s.Installation.Encode(e)
	}

	e.FieldStart("expires_at")
	s.ExpiresAt.Encode(e, json.EncodeDateTime)
	e.ObjEnd()
}

// Decode decodes Authorization from json.
func (s *Authorization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Authorization to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "scopes":
			s.Scopes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Scopes = append(s.Scopes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "token":
			v, err := d.Str()
			s.Token = string(v)
			if err != nil {
				return err
			}
		case "token_last_eight":
			if err := s.TokenLastEight.Decode(d); err != nil {
				return err
			}
		case "hashed_token":
			if err := s.HashedToken.Decode(d); err != nil {
				return err
			}
		case "app":
			if err := s.App.Decode(d); err != nil {
				return err
			}
		case "note":
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		case "note_url":
			if err := s.NoteURL.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "fingerprint":
			if err := s.Fingerprint.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "installation":
			s.Installation.Reset()
			if err := s.Installation.Decode(d); err != nil {
				return err
			}
		case "expires_at":
			if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AuthorizationApp) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("client_id")
	e.Str(s.ClientID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	e.ObjEnd()
}

// Decode decodes AuthorizationApp from json.
func (s *AuthorizationApp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AuthorizationApp to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_id":
			v, err := d.Str()
			s.ClientID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s AutoMerge) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("enabled_by")
	s.EnabledBy.Encode(e)

	e.FieldStart("merge_method")
	s.MergeMethod.Encode(e)

	e.FieldStart("commit_title")
	e.Str(s.CommitTitle)

	e.FieldStart("commit_message")
	e.Str(s.CommitMessage)
	e.ObjEnd()
}

// Decode decodes AutoMerge from json.
func (s *AutoMerge) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AutoMerge to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_by":
			if err := s.EnabledBy.Decode(d); err != nil {
				return err
			}
		case "merge_method":
			if err := s.MergeMethod.Decode(d); err != nil {
				return err
			}
		case "commit_title":
			v, err := d.Str()
			s.CommitTitle = string(v)
			if err != nil {
				return err
			}
		case "commit_message":
			v, err := d.Str()
			s.CommitMessage = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AutoMergeMergeMethod as json.
func (s AutoMergeMergeMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AutoMergeMergeMethod from json.
func (s *AutoMergeMergeMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode AutoMergeMergeMethod to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = AutoMergeMergeMethod(v)
	return nil
}

// Encode implements json.Marshaler.
func (s Autolink) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("key_prefix")
	e.Str(s.KeyPrefix)

	e.FieldStart("url_template")
	e.Str(s.URLTemplate)
	e.ObjEnd()
}

// Decode decodes Autolink from json.
func (s *Autolink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Autolink to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "key_prefix":
			v, err := d.Str()
			s.KeyPrefix = string(v)
			if err != nil {
				return err
			}
		case "url_template":
			v, err := d.Str()
			s.URLTemplate = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BaseGist) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("forks_url")
	json.EncodeURI(e, s.ForksURL)

	e.FieldStart("commits_url")
	json.EncodeURI(e, s.CommitsURL)

	e.FieldStart("id")
	e.Str(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("git_pull_url")
	json.EncodeURI(e, s.GitPullURL)

	e.FieldStart("git_push_url")
	json.EncodeURI(e, s.GitPushURL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("files")
	s.Files.Encode(e)

	e.FieldStart("public")
	e.Bool(s.Public)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("comments")
	e.Int(s.Comments)

	e.FieldStart("user")
	s.User.Encode(e)

	e.FieldStart("comments_url")
	json.EncodeURI(e, s.CommentsURL)
	if s.Owner.Set {
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	if s.Truncated.Set {
		e.FieldStart("truncated")
		s.Truncated.Encode(e)
	}
	if s.Forks != nil {
		e.FieldStart("forks")
		e.ArrStart()
		for _, elem := range s.Forks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.History != nil {
		e.FieldStart("history")
		e.ArrStart()
		for _, elem := range s.History {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes BaseGist from json.
func (s *BaseGist) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BaseGist to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := json.DecodeURI(d)
			s.CommitsURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "git_pull_url":
			v, err := json.DecodeURI(d)
			s.GitPullURL = v
			if err != nil {
				return err
			}
		case "git_push_url":
			v, err := json.DecodeURI(d)
			s.GitPushURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "files":
			if err := s.Files.Decode(d); err != nil {
				return err
			}
		case "public":
			v, err := d.Bool()
			s.Public = bool(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "comments":
			v, err := d.Int()
			s.Comments = int(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "owner":
			s.Owner.Reset()
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "truncated":
			s.Truncated.Reset()
			if err := s.Truncated.Decode(d); err != nil {
				return err
			}
		case "forks":
			s.Forks = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Forks = append(s.Forks, elem)
				return nil
			}); err != nil {
				return err
			}
		case "history":
			s.History = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.History = append(s.History, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BaseGistFiles) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes BaseGistFiles from json.
func (s *BaseGistFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BaseGistFiles to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BasicError) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.DocumentationURL.Set {
		e.FieldStart("documentation_url")
		s.DocumentationURL.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.Status.Set {
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes BasicError from json.
func (s *BasicError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BasicError to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Blob) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("content")
	e.Str(s.Content)

	e.FieldStart("encoding")
	e.Str(s.Encoding)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("size")
	s.Size.Encode(e)

	e.FieldStart("node_id")
	e.Str(s.NodeID)
	if s.HighlightedContent.Set {
		e.FieldStart("highlighted_content")
		s.HighlightedContent.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Blob from json.
func (s *Blob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Blob to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			v, err := d.Str()
			s.Content = string(v)
			if err != nil {
				return err
			}
		case "encoding":
			v, err := d.Str()
			s.Encoding = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "size":
			if err := s.Size.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "highlighted_content":
			s.HighlightedContent.Reset()
			if err := s.HighlightedContent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchProtection) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.Enabled.Set {
		e.FieldStart("enabled")
		s.Enabled.Encode(e)
	}
	if s.RequiredStatusChecks.Set {
		e.FieldStart("required_status_checks")
		s.RequiredStatusChecks.Encode(e)
	}
	if s.EnforceAdmins.Set {
		e.FieldStart("enforce_admins")
		s.EnforceAdmins.Encode(e)
	}
	if s.RequiredPullRequestReviews.Set {
		e.FieldStart("required_pull_request_reviews")
		s.RequiredPullRequestReviews.Encode(e)
	}
	if s.Restrictions.Set {
		e.FieldStart("restrictions")
		s.Restrictions.Encode(e)
	}
	if s.RequiredLinearHistory.Set {
		e.FieldStart("required_linear_history")
		s.RequiredLinearHistory.Encode(e)
	}
	if s.AllowForcePushes.Set {
		e.FieldStart("allow_force_pushes")
		s.AllowForcePushes.Encode(e)
	}
	if s.AllowDeletions.Set {
		e.FieldStart("allow_deletions")
		s.AllowDeletions.Encode(e)
	}
	if s.RequiredConversationResolution.Set {
		e.FieldStart("required_conversation_resolution")
		s.RequiredConversationResolution.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.ProtectionURL.Set {
		e.FieldStart("protection_url")
		s.ProtectionURL.Encode(e)
	}
	if s.RequiredSignatures.Set {
		e.FieldStart("required_signatures")
		s.RequiredSignatures.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes BranchProtection from json.
func (s *BranchProtection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchProtection to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "enabled":
			s.Enabled.Reset()
			if err := s.Enabled.Decode(d); err != nil {
				return err
			}
		case "required_status_checks":
			s.RequiredStatusChecks.Reset()
			if err := s.RequiredStatusChecks.Decode(d); err != nil {
				return err
			}
		case "enforce_admins":
			s.EnforceAdmins.Reset()
			if err := s.EnforceAdmins.Decode(d); err != nil {
				return err
			}
		case "required_pull_request_reviews":
			s.RequiredPullRequestReviews.Reset()
			if err := s.RequiredPullRequestReviews.Decode(d); err != nil {
				return err
			}
		case "restrictions":
			s.Restrictions.Reset()
			if err := s.Restrictions.Decode(d); err != nil {
				return err
			}
		case "required_linear_history":
			s.RequiredLinearHistory.Reset()
			if err := s.RequiredLinearHistory.Decode(d); err != nil {
				return err
			}
		case "allow_force_pushes":
			s.AllowForcePushes.Reset()
			if err := s.AllowForcePushes.Decode(d); err != nil {
				return err
			}
		case "allow_deletions":
			s.AllowDeletions.Reset()
			if err := s.AllowDeletions.Decode(d); err != nil {
				return err
			}
		case "required_conversation_resolution":
			s.RequiredConversationResolution.Reset()
			if err := s.RequiredConversationResolution.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "protection_url":
			s.ProtectionURL.Reset()
			if err := s.ProtectionURL.Decode(d); err != nil {
				return err
			}
		case "required_signatures":
			s.RequiredSignatures.Reset()
			if err := s.RequiredSignatures.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchProtectionAllowDeletions) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Enabled.Set {
		e.FieldStart("enabled")
		s.Enabled.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes BranchProtectionAllowDeletions from json.
func (s *BranchProtectionAllowDeletions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchProtectionAllowDeletions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			s.Enabled.Reset()
			if err := s.Enabled.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchProtectionAllowForcePushes) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Enabled.Set {
		e.FieldStart("enabled")
		s.Enabled.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes BranchProtectionAllowForcePushes from json.
func (s *BranchProtectionAllowForcePushes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchProtectionAllowForcePushes to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			s.Enabled.Reset()
			if err := s.Enabled.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchProtectionRequiredConversationResolution) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Enabled.Set {
		e.FieldStart("enabled")
		s.Enabled.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes BranchProtectionRequiredConversationResolution from json.
func (s *BranchProtectionRequiredConversationResolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchProtectionRequiredConversationResolution to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			s.Enabled.Reset()
			if err := s.Enabled.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchProtectionRequiredLinearHistory) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Enabled.Set {
		e.FieldStart("enabled")
		s.Enabled.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes BranchProtectionRequiredLinearHistory from json.
func (s *BranchProtectionRequiredLinearHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchProtectionRequiredLinearHistory to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			s.Enabled.Reset()
			if err := s.Enabled.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchProtectionRequiredSignatures) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("enabled")
	e.Bool(s.Enabled)
	e.ObjEnd()
}

// Decode decodes BranchProtectionRequiredSignatures from json.
func (s *BranchProtectionRequiredSignatures) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchProtectionRequiredSignatures to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "enabled":
			v, err := d.Bool()
			s.Enabled = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchProtectionRequiredStatusChecks) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.EnforcementLevel.Set {
		e.FieldStart("enforcement_level")
		s.EnforcementLevel.Encode(e)
	}

	e.FieldStart("contexts")
	e.ArrStart()
	for _, elem := range s.Contexts {
		e.Str(elem)
	}
	e.ArrEnd()
	if s.ContextsURL.Set {
		e.FieldStart("contexts_url")
		s.ContextsURL.Encode(e)
	}
	if s.Strict.Set {
		e.FieldStart("strict")
		s.Strict.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes BranchProtectionRequiredStatusChecks from json.
func (s *BranchProtectionRequiredStatusChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchProtectionRequiredStatusChecks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "enforcement_level":
			s.EnforcementLevel.Reset()
			if err := s.EnforcementLevel.Decode(d); err != nil {
				return err
			}
		case "contexts":
			s.Contexts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Contexts = append(s.Contexts, elem)
				return nil
			}); err != nil {
				return err
			}
		case "contexts_url":
			s.ContextsURL.Reset()
			if err := s.ContextsURL.Decode(d); err != nil {
				return err
			}
		case "strict":
			s.Strict.Reset()
			if err := s.Strict.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("users_url")
	json.EncodeURI(e, s.UsersURL)

	e.FieldStart("teams_url")
	json.EncodeURI(e, s.TeamsURL)

	e.FieldStart("apps_url")
	json.EncodeURI(e, s.AppsURL)

	e.FieldStart("users")
	e.ArrStart()
	for _, elem := range s.Users {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("teams")
	e.ArrStart()
	for _, elem := range s.Teams {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("apps")
	e.ArrStart()
	for _, elem := range s.Apps {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes BranchRestrictionPolicy from json.
func (s *BranchRestrictionPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchRestrictionPolicy to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "users_url":
			v, err := json.DecodeURI(d)
			s.UsersURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "apps_url":
			v, err := json.DecodeURI(d)
			s.AppsURL = v
			if err != nil {
				return err
			}
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem BranchRestrictionPolicyUsersItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem BranchRestrictionPolicyTeamsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		case "apps":
			s.Apps = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem BranchRestrictionPolicyAppsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Apps = append(s.Apps, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicyAppsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.Slug.Set {
		e.FieldStart("slug")
		s.Slug.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	if s.Owner.Set {
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.ExternalURL.Set {
		e.FieldStart("external_url")
		s.ExternalURL.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.CreatedAt.Set {
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e)
	}
	if s.UpdatedAt.Set {
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e)
	}
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	if s.Events != nil {
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes BranchRestrictionPolicyAppsItem from json.
func (s *BranchRestrictionPolicyAppsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchRestrictionPolicyAppsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "slug":
			s.Slug.Reset()
			if err := s.Slug.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "owner":
			s.Owner.Reset()
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "external_url":
			s.ExternalURL.Reset()
			if err := s.ExternalURL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicyAppsItemOwner) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Login.Set {
		e.FieldStart("login")
		s.Login.Encode(e)
	}
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.ReposURL.Set {
		e.FieldStart("repos_url")
		s.ReposURL.Encode(e)
	}
	if s.EventsURL.Set {
		e.FieldStart("events_url")
		s.EventsURL.Encode(e)
	}
	if s.HooksURL.Set {
		e.FieldStart("hooks_url")
		s.HooksURL.Encode(e)
	}
	if s.IssuesURL.Set {
		e.FieldStart("issues_url")
		s.IssuesURL.Encode(e)
	}
	if s.MembersURL.Set {
		e.FieldStart("members_url")
		s.MembersURL.Encode(e)
	}
	if s.PublicMembersURL.Set {
		e.FieldStart("public_members_url")
		s.PublicMembersURL.Encode(e)
	}
	if s.AvatarURL.Set {
		e.FieldStart("avatar_url")
		s.AvatarURL.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.GravatarID.Set {
		e.FieldStart("gravatar_id")
		s.GravatarID.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.FollowersURL.Set {
		e.FieldStart("followers_url")
		s.FollowersURL.Encode(e)
	}
	if s.FollowingURL.Set {
		e.FieldStart("following_url")
		s.FollowingURL.Encode(e)
	}
	if s.GistsURL.Set {
		e.FieldStart("gists_url")
		s.GistsURL.Encode(e)
	}
	if s.StarredURL.Set {
		e.FieldStart("starred_url")
		s.StarredURL.Encode(e)
	}
	if s.SubscriptionsURL.Set {
		e.FieldStart("subscriptions_url")
		s.SubscriptionsURL.Encode(e)
	}
	if s.OrganizationsURL.Set {
		e.FieldStart("organizations_url")
		s.OrganizationsURL.Encode(e)
	}
	if s.ReceivedEventsURL.Set {
		e.FieldStart("received_events_url")
		s.ReceivedEventsURL.Encode(e)
	}
	if s.Type.Set {
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	if s.SiteAdmin.Set {
		e.FieldStart("site_admin")
		s.SiteAdmin.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes BranchRestrictionPolicyAppsItemOwner from json.
func (s *BranchRestrictionPolicyAppsItemOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchRestrictionPolicyAppsItemOwner to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			s.Login.Reset()
			if err := s.Login.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "repos_url":
			s.ReposURL.Reset()
			if err := s.ReposURL.Decode(d); err != nil {
				return err
			}
		case "events_url":
			s.EventsURL.Reset()
			if err := s.EventsURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			s.HooksURL.Reset()
			if err := s.HooksURL.Decode(d); err != nil {
				return err
			}
		case "issues_url":
			s.IssuesURL.Reset()
			if err := s.IssuesURL.Decode(d); err != nil {
				return err
			}
		case "members_url":
			s.MembersURL.Reset()
			if err := s.MembersURL.Decode(d); err != nil {
				return err
			}
		case "public_members_url":
			s.PublicMembersURL.Reset()
			if err := s.PublicMembersURL.Decode(d); err != nil {
				return err
			}
		case "avatar_url":
			s.AvatarURL.Reset()
			if err := s.AvatarURL.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "gravatar_id":
			s.GravatarID.Reset()
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "followers_url":
			s.FollowersURL.Reset()
			if err := s.FollowersURL.Decode(d); err != nil {
				return err
			}
		case "following_url":
			s.FollowingURL.Reset()
			if err := s.FollowingURL.Decode(d); err != nil {
				return err
			}
		case "gists_url":
			s.GistsURL.Reset()
			if err := s.GistsURL.Decode(d); err != nil {
				return err
			}
		case "starred_url":
			s.StarredURL.Reset()
			if err := s.StarredURL.Decode(d); err != nil {
				return err
			}
		case "subscriptions_url":
			s.SubscriptionsURL.Reset()
			if err := s.SubscriptionsURL.Decode(d); err != nil {
				return err
			}
		case "organizations_url":
			s.OrganizationsURL.Reset()
			if err := s.OrganizationsURL.Decode(d); err != nil {
				return err
			}
		case "received_events_url":
			s.ReceivedEventsURL.Reset()
			if err := s.ReceivedEventsURL.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "site_admin":
			s.SiteAdmin.Reset()
			if err := s.SiteAdmin.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicyAppsItemPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Metadata.Set {
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	if s.Contents.Set {
		e.FieldStart("contents")
		s.Contents.Encode(e)
	}
	if s.Issues.Set {
		e.FieldStart("issues")
		s.Issues.Encode(e)
	}
	if s.SingleFile.Set {
		e.FieldStart("single_file")
		s.SingleFile.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes BranchRestrictionPolicyAppsItemPermissions from json.
func (s *BranchRestrictionPolicyAppsItemPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchRestrictionPolicyAppsItemPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "contents":
			s.Contents.Reset()
			if err := s.Contents.Decode(d); err != nil {
				return err
			}
		case "issues":
			s.Issues.Reset()
			if err := s.Issues.Decode(d); err != nil {
				return err
			}
		case "single_file":
			s.SingleFile.Reset()
			if err := s.SingleFile.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicyTeamsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Slug.Set {
		e.FieldStart("slug")
		s.Slug.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.Privacy.Set {
		e.FieldStart("privacy")
		s.Privacy.Encode(e)
	}
	if s.Permission.Set {
		e.FieldStart("permission")
		s.Permission.Encode(e)
	}
	if s.MembersURL.Set {
		e.FieldStart("members_url")
		s.MembersURL.Encode(e)
	}
	if s.RepositoriesURL.Set {
		e.FieldStart("repositories_url")
		s.RepositoriesURL.Encode(e)
	}
	if s.Parent.Set {
		e.FieldStart("parent")
		s.Parent.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes BranchRestrictionPolicyTeamsItem from json.
func (s *BranchRestrictionPolicyTeamsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchRestrictionPolicyTeamsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "slug":
			s.Slug.Reset()
			if err := s.Slug.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "privacy":
			s.Privacy.Reset()
			if err := s.Privacy.Decode(d); err != nil {
				return err
			}
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		case "members_url":
			s.MembersURL.Reset()
			if err := s.MembersURL.Decode(d); err != nil {
				return err
			}
		case "repositories_url":
			s.RepositoriesURL.Reset()
			if err := s.RepositoriesURL.Decode(d); err != nil {
				return err
			}
		case "parent":
			s.Parent.Reset()
			if err := s.Parent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchRestrictionPolicyUsersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Login.Set {
		e.FieldStart("login")
		s.Login.Encode(e)
	}
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	if s.AvatarURL.Set {
		e.FieldStart("avatar_url")
		s.AvatarURL.Encode(e)
	}
	if s.GravatarID.Set {
		e.FieldStart("gravatar_id")
		s.GravatarID.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.FollowersURL.Set {
		e.FieldStart("followers_url")
		s.FollowersURL.Encode(e)
	}
	if s.FollowingURL.Set {
		e.FieldStart("following_url")
		s.FollowingURL.Encode(e)
	}
	if s.GistsURL.Set {
		e.FieldStart("gists_url")
		s.GistsURL.Encode(e)
	}
	if s.StarredURL.Set {
		e.FieldStart("starred_url")
		s.StarredURL.Encode(e)
	}
	if s.SubscriptionsURL.Set {
		e.FieldStart("subscriptions_url")
		s.SubscriptionsURL.Encode(e)
	}
	if s.OrganizationsURL.Set {
		e.FieldStart("organizations_url")
		s.OrganizationsURL.Encode(e)
	}
	if s.ReposURL.Set {
		e.FieldStart("repos_url")
		s.ReposURL.Encode(e)
	}
	if s.EventsURL.Set {
		e.FieldStart("events_url")
		s.EventsURL.Encode(e)
	}
	if s.ReceivedEventsURL.Set {
		e.FieldStart("received_events_url")
		s.ReceivedEventsURL.Encode(e)
	}
	if s.Type.Set {
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	if s.SiteAdmin.Set {
		e.FieldStart("site_admin")
		s.SiteAdmin.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes BranchRestrictionPolicyUsersItem from json.
func (s *BranchRestrictionPolicyUsersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchRestrictionPolicyUsersItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			s.Login.Reset()
			if err := s.Login.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "avatar_url":
			s.AvatarURL.Reset()
			if err := s.AvatarURL.Decode(d); err != nil {
				return err
			}
		case "gravatar_id":
			s.GravatarID.Reset()
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "followers_url":
			s.FollowersURL.Reset()
			if err := s.FollowersURL.Decode(d); err != nil {
				return err
			}
		case "following_url":
			s.FollowingURL.Reset()
			if err := s.FollowingURL.Decode(d); err != nil {
				return err
			}
		case "gists_url":
			s.GistsURL.Reset()
			if err := s.GistsURL.Decode(d); err != nil {
				return err
			}
		case "starred_url":
			s.StarredURL.Reset()
			if err := s.StarredURL.Decode(d); err != nil {
				return err
			}
		case "subscriptions_url":
			s.SubscriptionsURL.Reset()
			if err := s.SubscriptionsURL.Decode(d); err != nil {
				return err
			}
		case "organizations_url":
			s.OrganizationsURL.Reset()
			if err := s.OrganizationsURL.Decode(d); err != nil {
				return err
			}
		case "repos_url":
			s.ReposURL.Reset()
			if err := s.ReposURL.Decode(d); err != nil {
				return err
			}
		case "events_url":
			s.EventsURL.Reset()
			if err := s.EventsURL.Decode(d); err != nil {
				return err
			}
		case "received_events_url":
			s.ReceivedEventsURL.Reset()
			if err := s.ReceivedEventsURL.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "site_admin":
			s.SiteAdmin.Reset()
			if err := s.SiteAdmin.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchShort) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("commit")
	s.Commit.Encode(e)

	e.FieldStart("protected")
	e.Bool(s.Protected)
	e.ObjEnd()
}

// Decode decodes BranchShort from json.
func (s *BranchShort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchShort to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "commit":
			if err := s.Commit.Decode(d); err != nil {
				return err
			}
		case "protected":
			v, err := d.Bool()
			s.Protected = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchShortCommit) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("url")
	e.Str(s.URL)
	e.ObjEnd()
}

// Decode decodes BranchShortCommit from json.
func (s *BranchShortCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchShortCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchWithProtection) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("commit")
	s.Commit.Encode(e)

	e.FieldStart("_links")
	s.Links.Encode(e)

	e.FieldStart("protected")
	e.Bool(s.Protected)

	e.FieldStart("protection")
	s.Protection.Encode(e)

	e.FieldStart("protection_url")
	json.EncodeURI(e, s.ProtectionURL)
	if s.Pattern.Set {
		e.FieldStart("pattern")
		s.Pattern.Encode(e)
	}
	if s.RequiredApprovingReviewCount.Set {
		e.FieldStart("required_approving_review_count")
		s.RequiredApprovingReviewCount.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes BranchWithProtection from json.
func (s *BranchWithProtection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchWithProtection to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "commit":
			if err := s.Commit.Decode(d); err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		case "protected":
			v, err := d.Bool()
			s.Protected = bool(v)
			if err != nil {
				return err
			}
		case "protection":
			if err := s.Protection.Decode(d); err != nil {
				return err
			}
		case "protection_url":
			v, err := json.DecodeURI(d)
			s.ProtectionURL = v
			if err != nil {
				return err
			}
		case "pattern":
			s.Pattern.Reset()
			if err := s.Pattern.Decode(d); err != nil {
				return err
			}
		case "required_approving_review_count":
			s.RequiredApprovingReviewCount.Reset()
			if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s BranchWithProtectionLinks) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("html")
	e.Str(s.HTML)

	e.FieldStart("self")
	json.EncodeURI(e, s.Self)
	e.ObjEnd()
}

// Decode decodes BranchWithProtectionLinks from json.
func (s *BranchWithProtectionLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode BranchWithProtectionLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "html":
			v, err := d.Str()
			s.HTML = string(v)
			if err != nil {
				return err
			}
		case "self":
			v, err := json.DecodeURI(d)
			s.Self = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CheckAnnotation) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("path")
	e.Str(s.Path)

	e.FieldStart("start_line")
	e.Int(s.StartLine)

	e.FieldStart("end_line")
	e.Int(s.EndLine)

	e.FieldStart("start_column")
	s.StartColumn.Encode(e)

	e.FieldStart("end_column")
	s.EndColumn.Encode(e)

	e.FieldStart("annotation_level")
	s.AnnotationLevel.Encode(e)

	e.FieldStart("title")
	s.Title.Encode(e)

	e.FieldStart("message")
	s.Message.Encode(e)

	e.FieldStart("raw_details")
	s.RawDetails.Encode(e)

	e.FieldStart("blob_href")
	e.Str(s.BlobHref)
	e.ObjEnd()
}

// Decode decodes CheckAnnotation from json.
func (s *CheckAnnotation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckAnnotation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "start_line":
			v, err := d.Int()
			s.StartLine = int(v)
			if err != nil {
				return err
			}
		case "end_line":
			v, err := d.Int()
			s.EndLine = int(v)
			if err != nil {
				return err
			}
		case "start_column":
			if err := s.StartColumn.Decode(d); err != nil {
				return err
			}
		case "end_column":
			if err := s.EndColumn.Decode(d); err != nil {
				return err
			}
		case "annotation_level":
			if err := s.AnnotationLevel.Decode(d); err != nil {
				return err
			}
		case "title":
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "message":
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "raw_details":
			if err := s.RawDetails.Decode(d); err != nil {
				return err
			}
		case "blob_href":
			v, err := d.Str()
			s.BlobHref = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CheckRun) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("head_sha")
	e.Str(s.HeadSha)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("external_id")
	s.ExternalID.Encode(e)

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("html_url")
	s.HTMLURL.Encode(e)

	e.FieldStart("details_url")
	s.DetailsURL.Encode(e)

	e.FieldStart("status")
	s.Status.Encode(e)

	e.FieldStart("conclusion")
	s.Conclusion.Encode(e)

	e.FieldStart("started_at")
	s.StartedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("completed_at")
	s.CompletedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("output")
	s.Output.Encode(e)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("check_suite")
	s.CheckSuite.Encode(e)

	e.FieldStart("app")
	s.App.Encode(e)

	e.FieldStart("pull_requests")
	e.Str(s.PullRequests)
	if s.Deployment.Set {
		e.FieldStart("deployment")
		s.Deployment.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CheckRun from json.
func (s *CheckRun) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckRun to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "head_sha":
			v, err := d.Str()
			s.HeadSha = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "external_id":
			if err := s.ExternalID.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "details_url":
			if err := s.DetailsURL.Decode(d); err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "conclusion":
			if err := s.Conclusion.Decode(d); err != nil {
				return err
			}
		case "started_at":
			if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "completed_at":
			if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "output":
			if err := s.Output.Decode(d); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "check_suite":
			if err := s.CheckSuite.Decode(d); err != nil {
				return err
			}
		case "app":
			if err := s.App.Decode(d); err != nil {
				return err
			}
		case "pull_requests":
			v, err := d.Str()
			s.PullRequests = string(v)
			if err != nil {
				return err
			}
		case "deployment":
			s.Deployment.Reset()
			if err := s.Deployment.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CheckRunCheckSuite) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)
	e.ObjEnd()
}

// Decode decodes CheckRunCheckSuite from json.
func (s *CheckRunCheckSuite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckRunCheckSuite to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CheckRunConclusion as json.
func (s CheckRunConclusion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CheckRunConclusion from json.
func (s *CheckRunConclusion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckRunConclusion to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = CheckRunConclusion(v)
	return nil
}

// Encode implements json.Marshaler.
func (s CheckRunOutput) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("title")
	s.Title.Encode(e)

	e.FieldStart("summary")
	s.Summary.Encode(e)

	e.FieldStart("text")
	s.Text.Encode(e)

	e.FieldStart("annotations_count")
	e.Int(s.AnnotationsCount)

	e.FieldStart("annotations_url")
	json.EncodeURI(e, s.AnnotationsURL)
	e.ObjEnd()
}

// Decode decodes CheckRunOutput from json.
func (s *CheckRunOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckRunOutput to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "summary":
			if err := s.Summary.Decode(d); err != nil {
				return err
			}
		case "text":
			if err := s.Text.Decode(d); err != nil {
				return err
			}
		case "annotations_count":
			v, err := d.Int()
			s.AnnotationsCount = int(v)
			if err != nil {
				return err
			}
		case "annotations_url":
			v, err := json.DecodeURI(d)
			s.AnnotationsURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CheckRunStatus as json.
func (s CheckRunStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CheckRunStatus from json.
func (s *CheckRunStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckRunStatus to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = CheckRunStatus(v)
	return nil
}

// Encode implements json.Marshaler.
func (s CheckSuite) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("head_branch")
	s.HeadBranch.Encode(e)

	e.FieldStart("head_sha")
	e.Str(s.HeadSha)

	e.FieldStart("status")
	s.Status.Encode(e)

	e.FieldStart("conclusion")
	s.Conclusion.Encode(e)

	e.FieldStart("url")
	s.URL.Encode(e)

	e.FieldStart("before")
	s.Before.Encode(e)

	e.FieldStart("after")
	s.After.Encode(e)

	e.FieldStart("pull_requests")
	if s.PullRequests == nil {
		e.Null()
	} else {
		e.ArrStart()
		for _, elem := range s.PullRequests {
			elem.Encode(e)
		}
		e.ArrEnd()
	}

	e.FieldStart("app")
	s.App.Encode(e)

	e.FieldStart("repository")
	s.Repository.Encode(e)

	e.FieldStart("created_at")
	s.CreatedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("updated_at")
	s.UpdatedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("head_commit")
	s.HeadCommit.Encode(e)

	e.FieldStart("latest_check_runs_count")
	e.Int(s.LatestCheckRunsCount)

	e.FieldStart("check_runs_url")
	e.Str(s.CheckRunsURL)
	e.ObjEnd()
}

// Decode decodes CheckSuite from json.
func (s *CheckSuite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckSuite to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "head_branch":
			if err := s.HeadBranch.Decode(d); err != nil {
				return err
			}
		case "head_sha":
			v, err := d.Str()
			s.HeadSha = string(v)
			if err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "conclusion":
			if err := s.Conclusion.Decode(d); err != nil {
				return err
			}
		case "url":
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "before":
			if err := s.Before.Decode(d); err != nil {
				return err
			}
		case "after":
			if err := s.After.Decode(d); err != nil {
				return err
			}
		case "pull_requests":
			s.PullRequests = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PullRequestMinimal
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PullRequests = append(s.PullRequests, elem)
				return nil
			}); err != nil {
				return err
			}
		case "app":
			if err := s.App.Decode(d); err != nil {
				return err
			}
		case "repository":
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "created_at":
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "head_commit":
			if err := s.HeadCommit.Decode(d); err != nil {
				return err
			}
		case "latest_check_runs_count":
			v, err := d.Int()
			s.LatestCheckRunsCount = int(v)
			if err != nil {
				return err
			}
		case "check_runs_url":
			v, err := d.Str()
			s.CheckRunsURL = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CheckSuiteConclusion as json.
func (s CheckSuiteConclusion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CheckSuiteConclusion from json.
func (s *CheckSuiteConclusion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckSuiteConclusion to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = CheckSuiteConclusion(v)
	return nil
}

// Encode implements json.Marshaler.
func (s CheckSuitePreference) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("preferences")
	s.Preferences.Encode(e)

	e.FieldStart("repository")
	s.Repository.Encode(e)
	e.ObjEnd()
}

// Decode decodes CheckSuitePreference from json.
func (s *CheckSuitePreference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckSuitePreference to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "preferences":
			if err := s.Preferences.Decode(d); err != nil {
				return err
			}
		case "repository":
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CheckSuitePreferencePreferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.AutoTriggerChecks != nil {
		e.FieldStart("auto_trigger_checks")
		e.ArrStart()
		for _, elem := range s.AutoTriggerChecks {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes CheckSuitePreferencePreferences from json.
func (s *CheckSuitePreferencePreferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckSuitePreferencePreferences to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auto_trigger_checks":
			s.AutoTriggerChecks = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CheckSuitePreferencePreferencesAutoTriggerChecksItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AutoTriggerChecks = append(s.AutoTriggerChecks, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CheckSuitePreferencePreferencesAutoTriggerChecksItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("app_id")
	e.Int(s.AppID)

	e.FieldStart("setting")
	e.Bool(s.Setting)
	e.ObjEnd()
}

// Decode decodes CheckSuitePreferencePreferencesAutoTriggerChecksItem from json.
func (s *CheckSuitePreferencePreferencesAutoTriggerChecksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckSuitePreferencePreferencesAutoTriggerChecksItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "app_id":
			v, err := d.Int()
			s.AppID = int(v)
			if err != nil {
				return err
			}
		case "setting":
			v, err := d.Bool()
			s.Setting = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CheckSuiteStatus as json.
func (s CheckSuiteStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CheckSuiteStatus from json.
func (s *CheckSuiteStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CheckSuiteStatus to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = CheckSuiteStatus(v)
	return nil
}

// Encode encodes ChecksCreateSuiteApplicationJSONCreated as json.
func (s ChecksCreateSuiteApplicationJSONCreated) Encode(e *jx.Encoder) {
	unwrapped := CheckSuite(s)
	unwrapped.Encode(e)
}

// Decode decodes ChecksCreateSuiteApplicationJSONCreated from json.
func (s *ChecksCreateSuiteApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksCreateSuiteApplicationJSONCreated to nil`)
	}
	var unwrapped CheckSuite
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ChecksCreateSuiteApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ChecksCreateSuiteApplicationJSONOK as json.
func (s ChecksCreateSuiteApplicationJSONOK) Encode(e *jx.Encoder) {
	unwrapped := CheckSuite(s)
	unwrapped.Encode(e)
}

// Decode decodes ChecksCreateSuiteApplicationJSONOK from json.
func (s *ChecksCreateSuiteApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksCreateSuiteApplicationJSONOK to nil`)
	}
	var unwrapped CheckSuite
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ChecksCreateSuiteApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ChecksCreateSuiteReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("head_sha")
	e.Str(s.HeadSha)
	e.ObjEnd()
}

// Decode decodes ChecksCreateSuiteReq from json.
func (s *ChecksCreateSuiteReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksCreateSuiteReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "head_sha":
			v, err := d.Str()
			s.HeadSha = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ChecksListForRefFilter as json.
func (s ChecksListForRefFilter) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ChecksListForRefFilter from json.
func (s *ChecksListForRefFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksListForRefFilter to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ChecksListForRefFilter(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ChecksListForRefOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("check_runs")
	e.ArrStart()
	for _, elem := range s.CheckRuns {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ChecksListForRefOK from json.
func (s *ChecksListForRefOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksListForRefOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "check_runs":
			s.CheckRuns = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CheckRun
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CheckRuns = append(s.CheckRuns, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ChecksListForRefStatus as json.
func (s ChecksListForRefStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ChecksListForRefStatus from json.
func (s *ChecksListForRefStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksListForRefStatus to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ChecksListForRefStatus(v)
	return nil
}

// Encode encodes ChecksListForSuiteFilter as json.
func (s ChecksListForSuiteFilter) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ChecksListForSuiteFilter from json.
func (s *ChecksListForSuiteFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksListForSuiteFilter to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ChecksListForSuiteFilter(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ChecksListForSuiteOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("check_runs")
	e.ArrStart()
	for _, elem := range s.CheckRuns {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ChecksListForSuiteOK from json.
func (s *ChecksListForSuiteOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksListForSuiteOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "check_runs":
			s.CheckRuns = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CheckRun
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CheckRuns = append(s.CheckRuns, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ChecksListForSuiteStatus as json.
func (s ChecksListForSuiteStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ChecksListForSuiteStatus from json.
func (s *ChecksListForSuiteStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksListForSuiteStatus to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ChecksListForSuiteStatus(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ChecksListSuitesForRefOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("check_suites")
	e.ArrStart()
	for _, elem := range s.CheckSuites {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ChecksListSuitesForRefOK from json.
func (s *ChecksListSuitesForRefOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksListSuitesForRefOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "check_suites":
			s.CheckSuites = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CheckSuite
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CheckSuites = append(s.CheckSuites, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ChecksRerequestSuiteCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ChecksRerequestSuiteCreated from json.
func (s *ChecksRerequestSuiteCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksRerequestSuiteCreated to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ChecksSetSuitesPreferencesReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.AutoTriggerChecks != nil {
		e.FieldStart("auto_trigger_checks")
		e.ArrStart()
		for _, elem := range s.AutoTriggerChecks {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ChecksSetSuitesPreferencesReq from json.
func (s *ChecksSetSuitesPreferencesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksSetSuitesPreferencesReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auto_trigger_checks":
			s.AutoTriggerChecks = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ChecksSetSuitesPreferencesReqAutoTriggerChecksItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AutoTriggerChecks = append(s.AutoTriggerChecks, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ChecksSetSuitesPreferencesReqAutoTriggerChecksItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("app_id")
	e.Int(s.AppID)

	e.FieldStart("setting")
	e.Bool(s.Setting)
	e.ObjEnd()
}

// Decode decodes ChecksSetSuitesPreferencesReqAutoTriggerChecksItem from json.
func (s *ChecksSetSuitesPreferencesReqAutoTriggerChecksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ChecksSetSuitesPreferencesReqAutoTriggerChecksItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "app_id":
			v, err := d.Int()
			s.AppID = int(v)
			if err != nil {
				return err
			}
		case "setting":
			v, err := d.Bool()
			s.Setting = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CloneTraffic) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("count")
	e.Int(s.Count)

	e.FieldStart("uniques")
	e.Int(s.Uniques)

	e.FieldStart("clones")
	e.ArrStart()
	for _, elem := range s.Clones {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes CloneTraffic from json.
func (s *CloneTraffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CloneTraffic to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			v, err := d.Int()
			s.Count = int(v)
			if err != nil {
				return err
			}
		case "uniques":
			v, err := d.Int()
			s.Uniques = int(v)
			if err != nil {
				return err
			}
		case "clones":
			s.Clones = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Traffic
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Clones = append(s.Clones, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeFrequencyStat as json.
func (s CodeFrequencyStat) Encode(e *jx.Encoder) {
	unwrapped := []int(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		e.Int(elem)
	}
	e.ArrEnd()
}

// Decode decodes CodeFrequencyStat from json.
func (s *CodeFrequencyStat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeFrequencyStat to nil`)
	}
	var unwrapped []int
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem int
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeFrequencyStat(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeOfConduct) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("key")
	e.Str(s.Key)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}

	e.FieldStart("html_url")
	s.HTMLURL.Encode(e)
	e.ObjEnd()
}

// Decode decodes CodeOfConduct from json.
func (s *CodeOfConduct) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeOfConduct to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeOfConductSimple) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("key")
	e.Str(s.Key)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("html_url")
	s.HTMLURL.Encode(e)
	e.ObjEnd()
}

// Decode decodes CodeOfConductSimple from json.
func (s *CodeOfConductSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeOfConductSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeScanningAlert) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("number")
	s.Number.Encode(e)

	e.FieldStart("created_at")
	s.CreatedAt.Encode(e)

	e.FieldStart("url")
	s.URL.Encode(e)

	e.FieldStart("html_url")
	s.HTMLURL.Encode(e)
	if s.Instances.Set {
		e.FieldStart("instances")
		s.Instances.Encode(e)
	}

	e.FieldStart("instances_url")
	s.InstancesURL.Encode(e)

	e.FieldStart("state")
	s.State.Encode(e)

	e.FieldStart("dismissed_by")
	s.DismissedBy.Encode(e)

	e.FieldStart("dismissed_at")
	s.DismissedAt.Encode(e)

	e.FieldStart("dismissed_reason")
	s.DismissedReason.Encode(e)

	e.FieldStart("rule")
	s.Rule.Encode(e)

	e.FieldStart("tool")
	s.Tool.Encode(e)

	e.FieldStart("most_recent_instance")
	s.MostRecentInstance.Encode(e)
	e.ObjEnd()
}

// Decode decodes CodeScanningAlert from json.
func (s *CodeScanningAlert) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlert to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			{
				var unwrapped int
				v, err := d.Int()
				unwrapped = int(v)
				if err != nil {
					return err
				}
				s.Number = AlertNumber(unwrapped)
			}
		case "created_at":
			{
				var unwrapped time.Time
				v, err := json.DecodeDateTime(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.CreatedAt = AlertCreatedAt(unwrapped)
			}
		case "url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.URL = AlertURL(unwrapped)
			}
		case "html_url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.HTMLURL = AlertHTMLURL(unwrapped)
			}
		case "instances":
			s.Instances.Reset()
			if err := s.Instances.Decode(d); err != nil {
				return err
			}
		case "instances_url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.InstancesURL = AlertInstancesURL(unwrapped)
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "dismissed_by":
			if err := s.DismissedBy.Decode(d); err != nil {
				return err
			}
		case "dismissed_at":
			if err := s.DismissedAt.Decode(d); err != nil {
				return err
			}
		case "dismissed_reason":
			if err := s.DismissedReason.Decode(d); err != nil {
				return err
			}
		case "rule":
			if err := s.Rule.Decode(d); err != nil {
				return err
			}
		case "tool":
			if err := s.Tool.Decode(d); err != nil {
				return err
			}
		case "most_recent_instance":
			if err := s.MostRecentInstance.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningAlertClassification as json.
func (s CodeScanningAlertClassification) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertClassification from json.
func (s *CodeScanningAlertClassification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertClassification to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = CodeScanningAlertClassification(v)
	return nil
}

// Encode encodes CodeScanningAlertDismissedAt as json.
func (s CodeScanningAlertDismissedAt) Encode(e *jx.Encoder) {
	unwrapped := time.Time(s)
	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes CodeScanningAlertDismissedAt from json.
func (s *CodeScanningAlertDismissedAt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertDismissedAt to nil`)
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAlertDismissedAt(unwrapped)
	return nil
}

// Encode encodes CodeScanningAlertDismissedReason as json.
func (s CodeScanningAlertDismissedReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertDismissedReason from json.
func (s *CodeScanningAlertDismissedReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertDismissedReason to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = CodeScanningAlertDismissedReason(v)
	return nil
}

// Encode encodes CodeScanningAlertEnvironment as json.
func (s CodeScanningAlertEnvironment) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAlertEnvironment from json.
func (s *CodeScanningAlertEnvironment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertEnvironment to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAlertEnvironment(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertInstance) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Ref.Set {
		e.FieldStart("ref")
		s.Ref.Encode(e)
	}
	if s.AnalysisKey.Set {
		e.FieldStart("analysis_key")
		s.AnalysisKey.Encode(e)
	}
	if s.Environment.Set {
		e.FieldStart("environment")
		s.Environment.Encode(e)
	}
	if s.Category.Set {
		e.FieldStart("category")
		s.Category.Encode(e)
	}
	if s.State.Set {
		e.FieldStart("state")
		s.State.Encode(e)
	}
	if s.CommitSha.Set {
		e.FieldStart("commit_sha")
		s.CommitSha.Encode(e)
	}
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.Location.Set {
		e.FieldStart("location")
		s.Location.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.Classifications != nil {
		e.FieldStart("classifications")
		e.ArrStart()
		for _, elem := range s.Classifications {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAlertInstance from json.
func (s *CodeScanningAlertInstance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertInstance to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			s.Ref.Reset()
			if err := s.Ref.Decode(d); err != nil {
				return err
			}
		case "analysis_key":
			s.AnalysisKey.Reset()
			if err := s.AnalysisKey.Decode(d); err != nil {
				return err
			}
		case "environment":
			s.Environment.Reset()
			if err := s.Environment.Decode(d); err != nil {
				return err
			}
		case "category":
			s.Category.Reset()
			if err := s.Category.Decode(d); err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "commit_sha":
			s.CommitSha.Reset()
			if err := s.CommitSha.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "classifications":
			s.Classifications = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CodeScanningAlertClassification
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Classifications = append(s.Classifications, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertInstanceMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Text.Set {
		e.FieldStart("text")
		s.Text.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAlertInstanceMessage from json.
func (s *CodeScanningAlertInstanceMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertInstanceMessage to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			s.Text.Reset()
			if err := s.Text.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertItems) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("number")
	s.Number.Encode(e)

	e.FieldStart("created_at")
	s.CreatedAt.Encode(e)

	e.FieldStart("url")
	s.URL.Encode(e)

	e.FieldStart("html_url")
	s.HTMLURL.Encode(e)

	e.FieldStart("instances_url")
	s.InstancesURL.Encode(e)

	e.FieldStart("state")
	s.State.Encode(e)

	e.FieldStart("dismissed_by")
	s.DismissedBy.Encode(e)

	e.FieldStart("dismissed_at")
	s.DismissedAt.Encode(e)

	e.FieldStart("dismissed_reason")
	s.DismissedReason.Encode(e)

	e.FieldStart("rule")
	s.Rule.Encode(e)

	e.FieldStart("tool")
	s.Tool.Encode(e)

	e.FieldStart("most_recent_instance")
	s.MostRecentInstance.Encode(e)
	e.ObjEnd()
}

// Decode decodes CodeScanningAlertItems from json.
func (s *CodeScanningAlertItems) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertItems to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			{
				var unwrapped int
				v, err := d.Int()
				unwrapped = int(v)
				if err != nil {
					return err
				}
				s.Number = AlertNumber(unwrapped)
			}
		case "created_at":
			{
				var unwrapped time.Time
				v, err := json.DecodeDateTime(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.CreatedAt = AlertCreatedAt(unwrapped)
			}
		case "url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.URL = AlertURL(unwrapped)
			}
		case "html_url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.HTMLURL = AlertHTMLURL(unwrapped)
			}
		case "instances_url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.InstancesURL = AlertInstancesURL(unwrapped)
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "dismissed_by":
			if err := s.DismissedBy.Decode(d); err != nil {
				return err
			}
		case "dismissed_at":
			if err := s.DismissedAt.Decode(d); err != nil {
				return err
			}
		case "dismissed_reason":
			if err := s.DismissedReason.Decode(d); err != nil {
				return err
			}
		case "rule":
			if err := s.Rule.Decode(d); err != nil {
				return err
			}
		case "tool":
			if err := s.Tool.Decode(d); err != nil {
				return err
			}
		case "most_recent_instance":
			if err := s.MostRecentInstance.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertLocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Path.Set {
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	if s.StartLine.Set {
		e.FieldStart("start_line")
		s.StartLine.Encode(e)
	}
	if s.EndLine.Set {
		e.FieldStart("end_line")
		s.EndLine.Encode(e)
	}
	if s.StartColumn.Set {
		e.FieldStart("start_column")
		s.StartColumn.Encode(e)
	}
	if s.EndColumn.Set {
		e.FieldStart("end_column")
		s.EndColumn.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAlertLocation from json.
func (s *CodeScanningAlertLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertLocation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "start_line":
			s.StartLine.Reset()
			if err := s.StartLine.Decode(d); err != nil {
				return err
			}
		case "end_line":
			s.EndLine.Reset()
			if err := s.EndLine.Decode(d); err != nil {
				return err
			}
		case "start_column":
			s.StartColumn.Reset()
			if err := s.StartColumn.Decode(d); err != nil {
				return err
			}
		case "end_column":
			s.EndColumn.Reset()
			if err := s.EndColumn.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Severity.Set {
		e.FieldStart("severity")
		s.Severity.Encode(e)
	}
	if s.SecuritySeverityLevel.Set {
		e.FieldStart("security_severity_level")
		s.SecuritySeverityLevel.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.FullDescription.Set {
		e.FieldStart("full_description")
		s.FullDescription.Encode(e)
	}
	if s.Tags.Set {
		e.FieldStart("tags")
		s.Tags.Encode(e)
	}
	if s.Help.Set {
		e.FieldStart("help")
		s.Help.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAlertRule from json.
func (s *CodeScanningAlertRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertRule to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "severity":
			s.Severity.Reset()
			if err := s.Severity.Decode(d); err != nil {
				return err
			}
		case "security_severity_level":
			s.SecuritySeverityLevel.Reset()
			if err := s.SecuritySeverityLevel.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "full_description":
			s.FullDescription.Reset()
			if err := s.FullDescription.Decode(d); err != nil {
				return err
			}
		case "tags":
			s.Tags.Reset()
			if err := s.Tags.Decode(d); err != nil {
				return err
			}
		case "help":
			s.Help.Reset()
			if err := s.Help.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningAlertRuleSecuritySeverityLevel as json.
func (s CodeScanningAlertRuleSecuritySeverityLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertRuleSecuritySeverityLevel from json.
func (s *CodeScanningAlertRuleSecuritySeverityLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertRuleSecuritySeverityLevel to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = CodeScanningAlertRuleSecuritySeverityLevel(v)
	return nil
}

// Encode encodes CodeScanningAlertRuleSeverity as json.
func (s CodeScanningAlertRuleSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertRuleSeverity from json.
func (s *CodeScanningAlertRuleSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertRuleSeverity to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = CodeScanningAlertRuleSeverity(v)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAlertRuleSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Severity.Set {
		e.FieldStart("severity")
		s.Severity.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAlertRuleSummary from json.
func (s *CodeScanningAlertRuleSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertRuleSummary to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "severity":
			s.Severity.Reset()
			if err := s.Severity.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningAlertRuleSummarySeverity as json.
func (s CodeScanningAlertRuleSummarySeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertRuleSummarySeverity from json.
func (s *CodeScanningAlertRuleSummarySeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertRuleSummarySeverity to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = CodeScanningAlertRuleSummarySeverity(v)
	return nil
}

// Encode encodes CodeScanningAlertSetState as json.
func (s CodeScanningAlertSetState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertSetState from json.
func (s *CodeScanningAlertSetState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertSetState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = CodeScanningAlertSetState(v)
	return nil
}

// Encode encodes CodeScanningAlertState as json.
func (s CodeScanningAlertState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CodeScanningAlertState from json.
func (s *CodeScanningAlertState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAlertState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = CodeScanningAlertState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("ref")
	s.Ref.Encode(e)

	e.FieldStart("commit_sha")
	s.CommitSha.Encode(e)

	e.FieldStart("analysis_key")
	s.AnalysisKey.Encode(e)

	e.FieldStart("environment")
	s.Environment.Encode(e)
	if s.Category.Set {
		e.FieldStart("category")
		s.Category.Encode(e)
	}

	e.FieldStart("error")
	e.Str(s.Error)

	e.FieldStart("created_at")
	s.CreatedAt.Encode(e)

	e.FieldStart("results_count")
	e.Int(s.ResultsCount)

	e.FieldStart("rules_count")
	e.Int(s.RulesCount)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("url")
	s.URL.Encode(e)

	e.FieldStart("sarif_id")
	s.SarifID.Encode(e)

	e.FieldStart("tool")
	s.Tool.Encode(e)

	e.FieldStart("deletable")
	e.Bool(s.Deletable)

	e.FieldStart("warning")
	e.Str(s.Warning)
	if s.ToolName.Set {
		e.FieldStart("tool_name")
		s.ToolName.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAnalysis from json.
func (s *CodeScanningAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysis to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.Ref = CodeScanningRef(unwrapped)
			}
		case "commit_sha":
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.CommitSha = CodeScanningAnalysisCommitSha(unwrapped)
			}
		case "analysis_key":
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.AnalysisKey = CodeScanningAnalysisAnalysisKey(unwrapped)
			}
		case "environment":
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.Environment = CodeScanningAnalysisEnvironment(unwrapped)
			}
		case "category":
			s.Category.Reset()
			if err := s.Category.Decode(d); err != nil {
				return err
			}
		case "error":
			v, err := d.Str()
			s.Error = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			{
				var unwrapped time.Time
				v, err := json.DecodeDateTime(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.CreatedAt = CodeScanningAnalysisCreatedAt(unwrapped)
			}
		case "results_count":
			v, err := d.Int()
			s.ResultsCount = int(v)
			if err != nil {
				return err
			}
		case "rules_count":
			v, err := d.Int()
			s.RulesCount = int(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.URL = CodeScanningAnalysisURL(unwrapped)
			}
		case "sarif_id":
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.SarifID = CodeScanningAnalysisSarifID(unwrapped)
			}
		case "tool":
			if err := s.Tool.Decode(d); err != nil {
				return err
			}
		case "deletable":
			v, err := d.Bool()
			s.Deletable = bool(v)
			if err != nil {
				return err
			}
		case "warning":
			v, err := d.Str()
			s.Warning = string(v)
			if err != nil {
				return err
			}
		case "tool_name":
			s.ToolName.Reset()
			if err := s.ToolName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningAnalysisAnalysisKey as json.
func (s CodeScanningAnalysisAnalysisKey) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisAnalysisKey from json.
func (s *CodeScanningAnalysisAnalysisKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisAnalysisKey to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisAnalysisKey(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisCategory as json.
func (s CodeScanningAnalysisCategory) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisCategory from json.
func (s *CodeScanningAnalysisCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisCategory to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisCategory(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisCommitSha as json.
func (s CodeScanningAnalysisCommitSha) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisCommitSha from json.
func (s *CodeScanningAnalysisCommitSha) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisCommitSha to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisCommitSha(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisCreatedAt as json.
func (s CodeScanningAnalysisCreatedAt) Encode(e *jx.Encoder) {
	unwrapped := time.Time(s)
	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes CodeScanningAnalysisCreatedAt from json.
func (s *CodeScanningAnalysisCreatedAt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisCreatedAt to nil`)
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisCreatedAt(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAnalysisDeletion) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("next_analysis_url")
	s.NextAnalysisURL.Encode(e)

	e.FieldStart("confirm_delete_url")
	s.ConfirmDeleteURL.Encode(e)
	e.ObjEnd()
}

// Decode decodes CodeScanningAnalysisDeletion from json.
func (s *CodeScanningAnalysisDeletion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisDeletion to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "next_analysis_url":
			if err := s.NextAnalysisURL.Decode(d); err != nil {
				return err
			}
		case "confirm_delete_url":
			if err := s.ConfirmDeleteURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningAnalysisEnvironment as json.
func (s CodeScanningAnalysisEnvironment) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisEnvironment from json.
func (s *CodeScanningAnalysisEnvironment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisEnvironment to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisEnvironment(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisSarifFile as json.
func (s CodeScanningAnalysisSarifFile) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisSarifFile from json.
func (s *CodeScanningAnalysisSarifFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisSarifFile to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisSarifFile(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisSarifID as json.
func (s CodeScanningAnalysisSarifID) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisSarifID from json.
func (s *CodeScanningAnalysisSarifID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisSarifID to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisSarifID(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningAnalysisTool) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Version.Set {
		e.FieldStart("version")
		s.Version.Encode(e)
	}
	if s.GUID.Set {
		e.FieldStart("guid")
		s.GUID.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningAnalysisTool from json.
func (s *CodeScanningAnalysisTool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisTool to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "version":
			s.Version.Reset()
			if err := s.Version.Decode(d); err != nil {
				return err
			}
		case "guid":
			s.GUID.Reset()
			if err := s.GUID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningAnalysisToolGUID as json.
func (s CodeScanningAnalysisToolGUID) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisToolGUID from json.
func (s *CodeScanningAnalysisToolGUID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisToolGUID to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisToolGUID(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisToolName as json.
func (s CodeScanningAnalysisToolName) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisToolName from json.
func (s *CodeScanningAnalysisToolName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisToolName to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisToolName(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisToolVersion as json.
func (s CodeScanningAnalysisToolVersion) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningAnalysisToolVersion from json.
func (s *CodeScanningAnalysisToolVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisToolVersion to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisToolVersion(unwrapped)
	return nil
}

// Encode encodes CodeScanningAnalysisURL as json.
func (s CodeScanningAnalysisURL) Encode(e *jx.Encoder) {
	unwrapped := url.URL(s)
	json.EncodeURI(e, unwrapped)
}

// Decode decodes CodeScanningAnalysisURL from json.
func (s *CodeScanningAnalysisURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningAnalysisURL to nil`)
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningAnalysisURL(unwrapped)
	return nil
}

// Encode encodes CodeScanningDeleteAnalysisApplicationJSONBadRequest as json.
func (s CodeScanningDeleteAnalysisApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningDeleteAnalysisApplicationJSONBadRequest from json.
func (s *CodeScanningDeleteAnalysisApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningDeleteAnalysisApplicationJSONBadRequest to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningDeleteAnalysisApplicationJSONBadRequest(unwrapped)
	return nil
}

// Encode encodes CodeScanningDeleteAnalysisApplicationJSONForbidden as json.
func (s CodeScanningDeleteAnalysisApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningDeleteAnalysisApplicationJSONForbidden from json.
func (s *CodeScanningDeleteAnalysisApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningDeleteAnalysisApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningDeleteAnalysisApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningDeleteAnalysisApplicationJSONNotFound as json.
func (s CodeScanningDeleteAnalysisApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningDeleteAnalysisApplicationJSONNotFound from json.
func (s *CodeScanningDeleteAnalysisApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningDeleteAnalysisApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningDeleteAnalysisApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes CodeScanningGetAlertApplicationJSONForbidden as json.
func (s CodeScanningGetAlertApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningGetAlertApplicationJSONForbidden from json.
func (s *CodeScanningGetAlertApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningGetAlertApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningGetAlertApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningGetAlertApplicationJSONNotFound as json.
func (s CodeScanningGetAlertApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningGetAlertApplicationJSONNotFound from json.
func (s *CodeScanningGetAlertApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningGetAlertApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningGetAlertApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes CodeScanningGetAnalysisApplicationJSONForbidden as json.
func (s CodeScanningGetAnalysisApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningGetAnalysisApplicationJSONForbidden from json.
func (s *CodeScanningGetAnalysisApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningGetAnalysisApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningGetAnalysisApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningGetAnalysisApplicationJSONNotFound as json.
func (s CodeScanningGetAnalysisApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningGetAnalysisApplicationJSONNotFound from json.
func (s *CodeScanningGetAnalysisApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningGetAnalysisApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningGetAnalysisApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningGetSarifNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes CodeScanningGetSarifNotFound from json.
func (s *CodeScanningGetSarifNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningGetSarifNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningListAlertInstancesApplicationJSONForbidden as json.
func (s CodeScanningListAlertInstancesApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListAlertInstancesApplicationJSONForbidden from json.
func (s *CodeScanningListAlertInstancesApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListAlertInstancesApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertInstancesApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningListAlertInstancesApplicationJSONNotFound as json.
func (s CodeScanningListAlertInstancesApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListAlertInstancesApplicationJSONNotFound from json.
func (s *CodeScanningListAlertInstancesApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListAlertInstancesApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertInstancesApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes CodeScanningListAlertInstancesOKApplicationJSON as json.
func (s CodeScanningListAlertInstancesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CodeScanningAlertInstance(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes CodeScanningListAlertInstancesOKApplicationJSON from json.
func (s *CodeScanningListAlertInstancesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListAlertInstancesOKApplicationJSON to nil`)
	}
	var unwrapped []CodeScanningAlertInstance
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeScanningAlertInstance
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertInstancesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes CodeScanningListAlertsForRepoApplicationJSONForbidden as json.
func (s CodeScanningListAlertsForRepoApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListAlertsForRepoApplicationJSONForbidden from json.
func (s *CodeScanningListAlertsForRepoApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListAlertsForRepoApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertsForRepoApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningListAlertsForRepoApplicationJSONNotFound as json.
func (s CodeScanningListAlertsForRepoApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListAlertsForRepoApplicationJSONNotFound from json.
func (s *CodeScanningListAlertsForRepoApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListAlertsForRepoApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertsForRepoApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes CodeScanningListAlertsForRepoOKApplicationJSON as json.
func (s CodeScanningListAlertsForRepoOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CodeScanningAlertItems(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes CodeScanningListAlertsForRepoOKApplicationJSON from json.
func (s *CodeScanningListAlertsForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListAlertsForRepoOKApplicationJSON to nil`)
	}
	var unwrapped []CodeScanningAlertItems
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeScanningAlertItems
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListAlertsForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes CodeScanningListRecentAnalysesApplicationJSONForbidden as json.
func (s CodeScanningListRecentAnalysesApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListRecentAnalysesApplicationJSONForbidden from json.
func (s *CodeScanningListRecentAnalysesApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListRecentAnalysesApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListRecentAnalysesApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningListRecentAnalysesApplicationJSONNotFound as json.
func (s CodeScanningListRecentAnalysesApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningListRecentAnalysesApplicationJSONNotFound from json.
func (s *CodeScanningListRecentAnalysesApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListRecentAnalysesApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListRecentAnalysesApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes CodeScanningListRecentAnalysesOKApplicationJSON as json.
func (s CodeScanningListRecentAnalysesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CodeScanningAnalysis(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes CodeScanningListRecentAnalysesOKApplicationJSON from json.
func (s *CodeScanningListRecentAnalysesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningListRecentAnalysesOKApplicationJSON to nil`)
	}
	var unwrapped []CodeScanningAnalysis
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeScanningAnalysis
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningListRecentAnalysesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes CodeScanningRef as json.
func (s CodeScanningRef) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes CodeScanningRef from json.
func (s *CodeScanningRef) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningRef to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningRef(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningSarifsReceipt) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningSarifsReceipt from json.
func (s *CodeScanningSarifsReceipt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningSarifsReceipt to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeScanningSarifsStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ProcessingStatus.Set {
		e.FieldStart("processing_status")
		s.ProcessingStatus.Encode(e)
	}
	if s.AnalysesURL.Set {
		e.FieldStart("analyses_url")
		s.AnalysesURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningSarifsStatus from json.
func (s *CodeScanningSarifsStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningSarifsStatus to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "processing_status":
			s.ProcessingStatus.Reset()
			if err := s.ProcessingStatus.Decode(d); err != nil {
				return err
			}
		case "analyses_url":
			s.AnalysesURL.Reset()
			if err := s.AnalysesURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningSarifsStatusProcessingStatus as json.
func (s CodeScanningSarifsStatusProcessingStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CodeScanningSarifsStatusProcessingStatus from json.
func (s *CodeScanningSarifsStatusProcessingStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningSarifsStatusProcessingStatus to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = CodeScanningSarifsStatusProcessingStatus(v)
	return nil
}

// Encode encodes CodeScanningUpdateAlertApplicationJSONForbidden as json.
func (s CodeScanningUpdateAlertApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningUpdateAlertApplicationJSONForbidden from json.
func (s *CodeScanningUpdateAlertApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningUpdateAlertApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningUpdateAlertApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningUpdateAlertApplicationJSONNotFound as json.
func (s CodeScanningUpdateAlertApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningUpdateAlertApplicationJSONNotFound from json.
func (s *CodeScanningUpdateAlertApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningUpdateAlertApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningUpdateAlertApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningUpdateAlertReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("state")
	s.State.Encode(e)
	if s.DismissedReason.Set {
		e.FieldStart("dismissed_reason")
		s.DismissedReason.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningUpdateAlertReq from json.
func (s *CodeScanningUpdateAlertReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningUpdateAlertReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "dismissed_reason":
			s.DismissedReason.Reset()
			if err := s.DismissedReason.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodeScanningUploadSarifApplicationJSONForbidden as json.
func (s CodeScanningUploadSarifApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningUploadSarifApplicationJSONForbidden from json.
func (s *CodeScanningUploadSarifApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningUploadSarifApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningUploadSarifApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes CodeScanningUploadSarifApplicationJSONNotFound as json.
func (s CodeScanningUploadSarifApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes CodeScanningUploadSarifApplicationJSONNotFound from json.
func (s *CodeScanningUploadSarifApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningUploadSarifApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodeScanningUploadSarifApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s CodeScanningUploadSarifBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes CodeScanningUploadSarifBadRequest from json.
func (s *CodeScanningUploadSarifBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningUploadSarifBadRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeScanningUploadSarifReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("commit_sha")
	s.CommitSha.Encode(e)

	e.FieldStart("ref")
	s.Ref.Encode(e)

	e.FieldStart("sarif")
	s.Sarif.Encode(e)
	if s.CheckoutURI.Set {
		e.FieldStart("checkout_uri")
		s.CheckoutURI.Encode(e)
	}
	if s.StartedAt.Set {
		e.FieldStart("started_at")
		s.StartedAt.Encode(e, json.EncodeDateTime)
	}
	if s.ToolName.Set {
		e.FieldStart("tool_name")
		s.ToolName.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CodeScanningUploadSarifReq from json.
func (s *CodeScanningUploadSarifReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningUploadSarifReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commit_sha":
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.CommitSha = CodeScanningAnalysisCommitSha(unwrapped)
			}
		case "ref":
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.Ref = CodeScanningRef(unwrapped)
			}
		case "sarif":
			{
				var unwrapped string
				v, err := d.Str()
				unwrapped = string(v)
				if err != nil {
					return err
				}
				s.Sarif = CodeScanningAnalysisSarifFile(unwrapped)
			}
		case "checkout_uri":
			s.CheckoutURI.Reset()
			if err := s.CheckoutURI.Decode(d); err != nil {
				return err
			}
		case "started_at":
			s.StartedAt.Reset()
			if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "tool_name":
			s.ToolName.Reset()
			if err := s.ToolName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeScanningUploadSarifRequestEntityTooLarge) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes CodeScanningUploadSarifRequestEntityTooLarge from json.
func (s *CodeScanningUploadSarifRequestEntityTooLarge) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeScanningUploadSarifRequestEntityTooLarge to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CodeSearchResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("path")
	e.Str(s.Path)

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("git_url")
	json.EncodeURI(e, s.GitURL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("repository")
	s.Repository.Encode(e)

	e.FieldStart("score")
	e.Float64(s.Score)
	if s.FileSize.Set {
		e.FieldStart("file_size")
		s.FileSize.Encode(e)
	}
	if s.Language.Set {
		e.FieldStart("language")
		s.Language.Encode(e)
	}
	if s.LastModifiedAt.Set {
		e.FieldStart("last_modified_at")
		s.LastModifiedAt.Encode(e, json.EncodeDateTime)
	}
	if s.LineNumbers != nil {
		e.FieldStart("line_numbers")
		e.ArrStart()
		for _, elem := range s.LineNumbers {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.TextMatches != nil {
		e.FieldStart("text_matches")
		s.TextMatches.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CodeSearchResultItem from json.
func (s *CodeSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodeSearchResultItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "git_url":
			v, err := json.DecodeURI(d)
			s.GitURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "repository":
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "score":
			v, err := d.Float64()
			s.Score = float64(v)
			if err != nil {
				return err
			}
		case "file_size":
			s.FileSize.Reset()
			if err := s.FileSize.Decode(d); err != nil {
				return err
			}
		case "language":
			s.Language.Reset()
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "last_modified_at":
			s.LastModifiedAt.Reset()
			if err := s.LastModifiedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "line_numbers":
			s.LineNumbers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.LineNumbers = append(s.LineNumbers, elem)
				return nil
			}); err != nil {
				return err
			}
		case "text_matches":
			s.TextMatches = nil
			var elem SearchResultTextMatches
			{
				var unwrapped []SearchResultTextMatchesItem
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultTextMatchesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = SearchResultTextMatches(unwrapped)
			}
			s.TextMatches = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CodesOfConductGetAllCodesOfConductOKApplicationJSON as json.
func (s CodesOfConductGetAllCodesOfConductOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CodeOfConduct(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes CodesOfConductGetAllCodesOfConductOKApplicationJSON from json.
func (s *CodesOfConductGetAllCodesOfConductOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CodesOfConductGetAllCodesOfConductOKApplicationJSON to nil`)
	}
	var unwrapped []CodeOfConduct
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeOfConduct
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CodesOfConductGetAllCodesOfConductOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s Collaborator) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("login")
	e.Str(s.Login)

	e.FieldStart("id")
	e.Int(s.ID)
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("avatar_url")
	json.EncodeURI(e, s.AvatarURL)

	e.FieldStart("gravatar_id")
	s.GravatarID.Encode(e)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("followers_url")
	json.EncodeURI(e, s.FollowersURL)

	e.FieldStart("following_url")
	e.Str(s.FollowingURL)

	e.FieldStart("gists_url")
	e.Str(s.GistsURL)

	e.FieldStart("starred_url")
	e.Str(s.StarredURL)

	e.FieldStart("subscriptions_url")
	json.EncodeURI(e, s.SubscriptionsURL)

	e.FieldStart("organizations_url")
	json.EncodeURI(e, s.OrganizationsURL)

	e.FieldStart("repos_url")
	json.EncodeURI(e, s.ReposURL)

	e.FieldStart("events_url")
	e.Str(s.EventsURL)

	e.FieldStart("received_events_url")
	json.EncodeURI(e, s.ReceivedEventsURL)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("site_admin")
	e.Bool(s.SiteAdmin)
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Collaborator from json.
func (s *Collaborator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Collaborator to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CollaboratorPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("pull")
	e.Bool(s.Pull)
	if s.Triage.Set {
		e.FieldStart("triage")
		s.Triage.Encode(e)
	}

	e.FieldStart("push")
	e.Bool(s.Push)
	if s.Maintain.Set {
		e.FieldStart("maintain")
		s.Maintain.Encode(e)
	}

	e.FieldStart("admin")
	e.Bool(s.Admin)
	e.ObjEnd()
}

// Decode decodes CollaboratorPermissions from json.
func (s *CollaboratorPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CollaboratorPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CombinedBillingUsage) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("days_left_in_billing_cycle")
	e.Int(s.DaysLeftInBillingCycle)

	e.FieldStart("estimated_paid_storage_for_month")
	e.Int(s.EstimatedPaidStorageForMonth)

	e.FieldStart("estimated_storage_for_month")
	e.Int(s.EstimatedStorageForMonth)
	e.ObjEnd()
}

// Decode decodes CombinedBillingUsage from json.
func (s *CombinedBillingUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CombinedBillingUsage to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "days_left_in_billing_cycle":
			v, err := d.Int()
			s.DaysLeftInBillingCycle = int(v)
			if err != nil {
				return err
			}
		case "estimated_paid_storage_for_month":
			v, err := d.Int()
			s.EstimatedPaidStorageForMonth = int(v)
			if err != nil {
				return err
			}
		case "estimated_storage_for_month":
			v, err := d.Int()
			s.EstimatedStorageForMonth = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CombinedCommitStatus) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("state")
	e.Str(s.State)

	e.FieldStart("statuses")
	e.ArrStart()
	for _, elem := range s.Statuses {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("repository")
	s.Repository.Encode(e)

	e.FieldStart("commit_url")
	json.EncodeURI(e, s.CommitURL)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	e.ObjEnd()
}

// Decode decodes CombinedCommitStatus from json.
func (s *CombinedCommitStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CombinedCommitStatus to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "statuses":
			s.Statuses = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem SimpleCommitStatus
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Statuses = append(s.Statuses, elem)
				return nil
			}); err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "repository":
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "commit_url":
			v, err := json.DecodeURI(d)
			s.CommitURL = v
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Commit) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("comments_url")
	json.EncodeURI(e, s.CommentsURL)

	e.FieldStart("commit")
	s.Commit.Encode(e)

	e.FieldStart("author")
	s.Author.Encode(e)

	e.FieldStart("committer")
	s.Committer.Encode(e)

	e.FieldStart("parents")
	e.ArrStart()
	for _, elem := range s.Parents {
		elem.Encode(e)
	}
	e.ArrEnd()
	if s.Stats.Set {
		e.FieldStart("stats")
		s.Stats.Encode(e)
	}
	if s.Files != nil {
		e.FieldStart("files")
		e.ArrStart()
		for _, elem := range s.Files {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes Commit from json.
func (s *Commit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Commit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "commit":
			if err := s.Commit.Decode(d); err != nil {
				return err
			}
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "parents":
			s.Parents = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CommitParentsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Parents = append(s.Parents, elem)
				return nil
			}); err != nil {
				return err
			}
		case "stats":
			s.Stats.Reset()
			if err := s.Stats.Decode(d); err != nil {
				return err
			}
		case "files":
			s.Files = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CommitFilesItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Files = append(s.Files, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitActivity) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("days")
	e.ArrStart()
	for _, elem := range s.Days {
		e.Int(elem)
	}
	e.ArrEnd()

	e.FieldStart("total")
	e.Int(s.Total)

	e.FieldStart("week")
	e.Int(s.Week)
	e.ObjEnd()
}

// Decode decodes CommitActivity from json.
func (s *CommitActivity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitActivity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "days":
			s.Days = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Days = append(s.Days, elem)
				return nil
			}); err != nil {
				return err
			}
		case "total":
			v, err := d.Int()
			s.Total = int(v)
			if err != nil {
				return err
			}
		case "week":
			v, err := d.Int()
			s.Week = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitComment) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("body")
	e.Str(s.Body)

	e.FieldStart("path")
	s.Path.Encode(e)

	e.FieldStart("position")
	s.Position.Encode(e)

	e.FieldStart("line")
	s.Line.Encode(e)

	e.FieldStart("commit_id")
	e.Str(s.CommitID)

	e.FieldStart("user")
	s.User.Encode(e)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("author_association")
	s.AuthorAssociation.Encode(e)
	if s.Reactions.Set {
		e.FieldStart("reactions")
		s.Reactions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CommitComment from json.
func (s *CommitComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitComment to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "path":
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "position":
			if err := s.Position.Decode(d); err != nil {
				return err
			}
		case "line":
			if err := s.Line.Decode(d); err != nil {
				return err
			}
		case "commit_id":
			v, err := d.Str()
			s.CommitID = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "reactions":
			s.Reactions.Reset()
			if err := s.Reactions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitCommit) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("author")
	s.Author.Encode(e)

	e.FieldStart("committer")
	s.Committer.Encode(e)

	e.FieldStart("message")
	e.Str(s.Message)

	e.FieldStart("comment_count")
	e.Int(s.CommentCount)

	e.FieldStart("tree")
	s.Tree.Encode(e)
	if s.Verification.Set {
		e.FieldStart("verification")
		s.Verification.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CommitCommit from json.
func (s *CommitCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "comment_count":
			v, err := d.Int()
			s.CommentCount = int(v)
			if err != nil {
				return err
			}
		case "tree":
			if err := s.Tree.Decode(d); err != nil {
				return err
			}
		case "verification":
			s.Verification.Reset()
			if err := s.Verification.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitCommitTree) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	e.ObjEnd()
}

// Decode decodes CommitCommitTree from json.
func (s *CommitCommitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitCommitTree to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitComparison) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("permalink_url")
	json.EncodeURI(e, s.PermalinkURL)

	e.FieldStart("diff_url")
	json.EncodeURI(e, s.DiffURL)

	e.FieldStart("patch_url")
	json.EncodeURI(e, s.PatchURL)

	e.FieldStart("base_commit")
	s.BaseCommit.Encode(e)

	e.FieldStart("merge_base_commit")
	s.MergeBaseCommit.Encode(e)

	e.FieldStart("status")
	s.Status.Encode(e)

	e.FieldStart("ahead_by")
	e.Int(s.AheadBy)

	e.FieldStart("behind_by")
	e.Int(s.BehindBy)

	e.FieldStart("total_commits")
	e.Int(s.TotalCommits)

	e.FieldStart("commits")
	e.ArrStart()
	for _, elem := range s.Commits {
		elem.Encode(e)
	}
	e.ArrEnd()
	if s.Files != nil {
		e.FieldStart("files")
		e.ArrStart()
		for _, elem := range s.Files {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes CommitComparison from json.
func (s *CommitComparison) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitComparison to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "permalink_url":
			v, err := json.DecodeURI(d)
			s.PermalinkURL = v
			if err != nil {
				return err
			}
		case "diff_url":
			v, err := json.DecodeURI(d)
			s.DiffURL = v
			if err != nil {
				return err
			}
		case "patch_url":
			v, err := json.DecodeURI(d)
			s.PatchURL = v
			if err != nil {
				return err
			}
		case "base_commit":
			if err := s.BaseCommit.Decode(d); err != nil {
				return err
			}
		case "merge_base_commit":
			if err := s.MergeBaseCommit.Decode(d); err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "ahead_by":
			v, err := d.Int()
			s.AheadBy = int(v)
			if err != nil {
				return err
			}
		case "behind_by":
			v, err := d.Int()
			s.BehindBy = int(v)
			if err != nil {
				return err
			}
		case "total_commits":
			v, err := d.Int()
			s.TotalCommits = int(v)
			if err != nil {
				return err
			}
		case "commits":
			s.Commits = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Commit
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Commits = append(s.Commits, elem)
				return nil
			}); err != nil {
				return err
			}
		case "files":
			s.Files = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem DiffEntry
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Files = append(s.Files, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes CommitComparisonStatus as json.
func (s CommitComparisonStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CommitComparisonStatus from json.
func (s *CommitComparisonStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitComparisonStatus to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = CommitComparisonStatus(v)
	return nil
}

// Encode implements json.Marshaler.
func (s CommitFilesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Filename.Set {
		e.FieldStart("filename")
		s.Filename.Encode(e)
	}
	if s.Additions.Set {
		e.FieldStart("additions")
		s.Additions.Encode(e)
	}
	if s.Deletions.Set {
		e.FieldStart("deletions")
		s.Deletions.Encode(e)
	}
	if s.Changes.Set {
		e.FieldStart("changes")
		s.Changes.Encode(e)
	}
	if s.Status.Set {
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	if s.RawURL.Set {
		e.FieldStart("raw_url")
		s.RawURL.Encode(e)
	}
	if s.BlobURL.Set {
		e.FieldStart("blob_url")
		s.BlobURL.Encode(e)
	}
	if s.Patch.Set {
		e.FieldStart("patch")
		s.Patch.Encode(e)
	}
	if s.Sha.Set {
		e.FieldStart("sha")
		s.Sha.Encode(e)
	}
	if s.ContentsURL.Set {
		e.FieldStart("contents_url")
		s.ContentsURL.Encode(e)
	}
	if s.PreviousFilename.Set {
		e.FieldStart("previous_filename")
		s.PreviousFilename.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CommitFilesItem from json.
func (s *CommitFilesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitFilesItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "filename":
			s.Filename.Reset()
			if err := s.Filename.Decode(d); err != nil {
				return err
			}
		case "additions":
			s.Additions.Reset()
			if err := s.Additions.Decode(d); err != nil {
				return err
			}
		case "deletions":
			s.Deletions.Reset()
			if err := s.Deletions.Decode(d); err != nil {
				return err
			}
		case "changes":
			s.Changes.Reset()
			if err := s.Changes.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "raw_url":
			s.RawURL.Reset()
			if err := s.RawURL.Decode(d); err != nil {
				return err
			}
		case "blob_url":
			s.BlobURL.Reset()
			if err := s.BlobURL.Decode(d); err != nil {
				return err
			}
		case "patch":
			s.Patch.Reset()
			if err := s.Patch.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		case "contents_url":
			s.ContentsURL.Reset()
			if err := s.ContentsURL.Decode(d); err != nil {
				return err
			}
		case "previous_filename":
			s.PreviousFilename.Reset()
			if err := s.PreviousFilename.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitParentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CommitParentsItem from json.
func (s *CommitParentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitParentsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitSearchResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("comments_url")
	json.EncodeURI(e, s.CommentsURL)

	e.FieldStart("commit")
	s.Commit.Encode(e)

	e.FieldStart("author")
	s.Author.Encode(e)

	e.FieldStart("committer")
	s.Committer.Encode(e)

	e.FieldStart("parents")
	e.ArrStart()
	for _, elem := range s.Parents {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("repository")
	s.Repository.Encode(e)

	e.FieldStart("score")
	e.Float64(s.Score)

	e.FieldStart("node_id")
	e.Str(s.NodeID)
	if s.TextMatches != nil {
		e.FieldStart("text_matches")
		s.TextMatches.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CommitSearchResultItem from json.
func (s *CommitSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitSearchResultItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "commit":
			if err := s.Commit.Decode(d); err != nil {
				return err
			}
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "parents":
			s.Parents = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CommitSearchResultItemParentsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Parents = append(s.Parents, elem)
				return nil
			}); err != nil {
				return err
			}
		case "repository":
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "score":
			v, err := d.Float64()
			s.Score = float64(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "text_matches":
			s.TextMatches = nil
			var elem SearchResultTextMatches
			{
				var unwrapped []SearchResultTextMatchesItem
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultTextMatchesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = SearchResultTextMatches(unwrapped)
			}
			s.TextMatches = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitSearchResultItemCommit) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("author")
	s.Author.Encode(e)

	e.FieldStart("committer")
	s.Committer.Encode(e)

	e.FieldStart("comment_count")
	e.Int(s.CommentCount)

	e.FieldStart("message")
	e.Str(s.Message)

	e.FieldStart("tree")
	s.Tree.Encode(e)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	if s.Verification.Set {
		e.FieldStart("verification")
		s.Verification.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CommitSearchResultItemCommit from json.
func (s *CommitSearchResultItemCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitSearchResultItemCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "comment_count":
			v, err := d.Int()
			s.CommentCount = int(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "tree":
			if err := s.Tree.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "verification":
			s.Verification.Reset()
			if err := s.Verification.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitSearchResultItemCommitAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("email")
	e.Str(s.Email)

	e.FieldStart("date")
	json.EncodeDateTime(e, s.Date)
	e.ObjEnd()
}

// Decode decodes CommitSearchResultItemCommitAuthor from json.
func (s *CommitSearchResultItemCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitSearchResultItemCommitAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "date":
			v, err := json.DecodeDateTime(d)
			s.Date = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitSearchResultItemCommitTree) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	e.ObjEnd()
}

// Decode decodes CommitSearchResultItemCommitTree from json.
func (s *CommitSearchResultItemCommitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitSearchResultItemCommitTree to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitSearchResultItemParentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.Sha.Set {
		e.FieldStart("sha")
		s.Sha.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CommitSearchResultItemParentsItem from json.
func (s *CommitSearchResultItemParentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitSearchResultItemParentsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommitStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Additions.Set {
		e.FieldStart("additions")
		s.Additions.Encode(e)
	}
	if s.Deletions.Set {
		e.FieldStart("deletions")
		s.Deletions.Encode(e)
	}
	if s.Total.Set {
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CommitStats from json.
func (s *CommitStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommitStats to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "additions":
			s.Additions.Reset()
			if err := s.Additions.Decode(d); err != nil {
				return err
			}
		case "deletions":
			s.Deletions.Reset()
			if err := s.Deletions.Decode(d); err != nil {
				return err
			}
		case "total":
			s.Total.Reset()
			if err := s.Total.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommunityProfile) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("health_percentage")
	e.Int(s.HealthPercentage)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("documentation")
	s.Documentation.Encode(e)

	e.FieldStart("files")
	s.Files.Encode(e)

	e.FieldStart("updated_at")
	s.UpdatedAt.Encode(e, json.EncodeDateTime)
	if s.ContentReportsEnabled.Set {
		e.FieldStart("content_reports_enabled")
		s.ContentReportsEnabled.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CommunityProfile from json.
func (s *CommunityProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommunityProfile to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "health_percentage":
			v, err := d.Int()
			s.HealthPercentage = int(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "documentation":
			if err := s.Documentation.Decode(d); err != nil {
				return err
			}
		case "files":
			if err := s.Files.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "content_reports_enabled":
			s.ContentReportsEnabled.Reset()
			if err := s.ContentReportsEnabled.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CommunityProfileFiles) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("code_of_conduct")
	s.CodeOfConduct.Encode(e)

	e.FieldStart("code_of_conduct_file")
	s.CodeOfConductFile.Encode(e)

	e.FieldStart("license")
	s.License.Encode(e)

	e.FieldStart("contributing")
	s.Contributing.Encode(e)

	e.FieldStart("readme")
	s.Readme.Encode(e)

	e.FieldStart("issue_template")
	s.IssueTemplate.Encode(e)

	e.FieldStart("pull_request_template")
	s.PullRequestTemplate.Encode(e)
	e.ObjEnd()
}

// Decode decodes CommunityProfileFiles from json.
func (s *CommunityProfileFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CommunityProfileFiles to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code_of_conduct":
			if err := s.CodeOfConduct.Decode(d); err != nil {
				return err
			}
		case "code_of_conduct_file":
			if err := s.CodeOfConductFile.Decode(d); err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "contributing":
			if err := s.Contributing.Decode(d); err != nil {
				return err
			}
		case "readme":
			if err := s.Readme.Decode(d); err != nil {
				return err
			}
		case "issue_template":
			if err := s.IssueTemplate.Decode(d); err != nil {
				return err
			}
		case "pull_request_template":
			if err := s.PullRequestTemplate.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ContentFile) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("encoding")
	e.Str(s.Encoding)

	e.FieldStart("size")
	e.Int(s.Size)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("path")
	e.Str(s.Path)

	e.FieldStart("content")
	e.Str(s.Content)

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("git_url")
	s.GitURL.Encode(e)

	e.FieldStart("html_url")
	s.HTMLURL.Encode(e)

	e.FieldStart("download_url")
	s.DownloadURL.Encode(e)

	e.FieldStart("_links")
	s.Links.Encode(e)
	if s.Target.Set {
		e.FieldStart("target")
		s.Target.Encode(e)
	}
	if s.SubmoduleGitURL.Set {
		e.FieldStart("submodule_git_url")
		s.SubmoduleGitURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ContentFile from json.
func (s *ContentFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ContentFile to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "encoding":
			v, err := d.Str()
			s.Encoding = string(v)
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "content":
			v, err := d.Str()
			s.Content = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "git_url":
			if err := s.GitURL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "download_url":
			if err := s.DownloadURL.Decode(d); err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		case "target":
			s.Target.Reset()
			if err := s.Target.Decode(d); err != nil {
				return err
			}
		case "submodule_git_url":
			s.SubmoduleGitURL.Reset()
			if err := s.SubmoduleGitURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ContentFileLinks) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("git")
	s.Git.Encode(e)

	e.FieldStart("html")
	s.HTML.Encode(e)

	e.FieldStart("self")
	json.EncodeURI(e, s.Self)
	e.ObjEnd()
}

// Decode decodes ContentFileLinks from json.
func (s *ContentFileLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ContentFileLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "git":
			if err := s.Git.Decode(d); err != nil {
				return err
			}
		case "html":
			if err := s.HTML.Decode(d); err != nil {
				return err
			}
		case "self":
			v, err := json.DecodeURI(d)
			s.Self = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ContentReferenceAttachment) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("body")
	e.Str(s.Body)
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ContentReferenceAttachment from json.
func (s *ContentReferenceAttachment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ContentReferenceAttachment to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ContentTraffic) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("path")
	e.Str(s.Path)

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("count")
	e.Int(s.Count)

	e.FieldStart("uniques")
	e.Int(s.Uniques)
	e.ObjEnd()
}

// Decode decodes ContentTraffic from json.
func (s *ContentTraffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ContentTraffic to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "count":
			v, err := d.Int()
			s.Count = int(v)
			if err != nil {
				return err
			}
		case "uniques":
			v, err := d.Int()
			s.Uniques = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Contributor) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Login.Set {
		e.FieldStart("login")
		s.Login.Encode(e)
	}
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	if s.AvatarURL.Set {
		e.FieldStart("avatar_url")
		s.AvatarURL.Encode(e)
	}
	if s.GravatarID.Set {
		e.FieldStart("gravatar_id")
		s.GravatarID.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.FollowersURL.Set {
		e.FieldStart("followers_url")
		s.FollowersURL.Encode(e)
	}
	if s.FollowingURL.Set {
		e.FieldStart("following_url")
		s.FollowingURL.Encode(e)
	}
	if s.GistsURL.Set {
		e.FieldStart("gists_url")
		s.GistsURL.Encode(e)
	}
	if s.StarredURL.Set {
		e.FieldStart("starred_url")
		s.StarredURL.Encode(e)
	}
	if s.SubscriptionsURL.Set {
		e.FieldStart("subscriptions_url")
		s.SubscriptionsURL.Encode(e)
	}
	if s.OrganizationsURL.Set {
		e.FieldStart("organizations_url")
		s.OrganizationsURL.Encode(e)
	}
	if s.ReposURL.Set {
		e.FieldStart("repos_url")
		s.ReposURL.Encode(e)
	}
	if s.EventsURL.Set {
		e.FieldStart("events_url")
		s.EventsURL.Encode(e)
	}
	if s.ReceivedEventsURL.Set {
		e.FieldStart("received_events_url")
		s.ReceivedEventsURL.Encode(e)
	}

	e.FieldStart("type")
	e.Str(s.Type)
	if s.SiteAdmin.Set {
		e.FieldStart("site_admin")
		s.SiteAdmin.Encode(e)
	}

	e.FieldStart("contributions")
	e.Int(s.Contributions)
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Contributor from json.
func (s *Contributor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Contributor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			s.Login.Reset()
			if err := s.Login.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "avatar_url":
			s.AvatarURL.Reset()
			if err := s.AvatarURL.Decode(d); err != nil {
				return err
			}
		case "gravatar_id":
			s.GravatarID.Reset()
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "followers_url":
			s.FollowersURL.Reset()
			if err := s.FollowersURL.Decode(d); err != nil {
				return err
			}
		case "following_url":
			s.FollowingURL.Reset()
			if err := s.FollowingURL.Decode(d); err != nil {
				return err
			}
		case "gists_url":
			s.GistsURL.Reset()
			if err := s.GistsURL.Decode(d); err != nil {
				return err
			}
		case "starred_url":
			s.StarredURL.Reset()
			if err := s.StarredURL.Decode(d); err != nil {
				return err
			}
		case "subscriptions_url":
			s.SubscriptionsURL.Reset()
			if err := s.SubscriptionsURL.Decode(d); err != nil {
				return err
			}
		case "organizations_url":
			s.OrganizationsURL.Reset()
			if err := s.OrganizationsURL.Decode(d); err != nil {
				return err
			}
		case "repos_url":
			s.ReposURL.Reset()
			if err := s.ReposURL.Decode(d); err != nil {
				return err
			}
		case "events_url":
			s.EventsURL.Reset()
			if err := s.EventsURL.Decode(d); err != nil {
				return err
			}
		case "received_events_url":
			s.ReceivedEventsURL.Reset()
			if err := s.ReceivedEventsURL.Decode(d); err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "site_admin":
			s.SiteAdmin.Reset()
			if err := s.SiteAdmin.Decode(d); err != nil {
				return err
			}
		case "contributions":
			v, err := d.Int()
			s.Contributions = int(v)
			if err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ContributorActivity) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("author")
	s.Author.Encode(e)

	e.FieldStart("total")
	e.Int(s.Total)

	e.FieldStart("weeks")
	e.ArrStart()
	for _, elem := range s.Weeks {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ContributorActivity from json.
func (s *ContributorActivity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ContributorActivity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "total":
			v, err := d.Int()
			s.Total = int(v)
			if err != nil {
				return err
			}
		case "weeks":
			s.Weeks = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ContributorActivityWeeksItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Weeks = append(s.Weeks, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ContributorActivityWeeksItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.W.Set {
		e.FieldStart("w")
		s.W.Encode(e)
	}
	if s.A.Set {
		e.FieldStart("a")
		s.A.Encode(e)
	}
	if s.D.Set {
		e.FieldStart("d")
		s.D.Encode(e)
	}
	if s.C.Set {
		e.FieldStart("c")
		s.C.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ContributorActivityWeeksItem from json.
func (s *ContributorActivityWeeksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ContributorActivityWeeksItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "w":
			s.W.Reset()
			if err := s.W.Decode(d); err != nil {
				return err
			}
		case "a":
			s.A.Reset()
			if err := s.A.Decode(d); err != nil {
				return err
			}
		case "d":
			s.D.Reset()
			if err := s.D.Decode(d); err != nil {
				return err
			}
		case "c":
			s.C.Reset()
			if err := s.C.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s CredentialAuthorization) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("login")
	e.Str(s.Login)

	e.FieldStart("credential_id")
	e.Int(s.CredentialID)

	e.FieldStart("credential_type")
	e.Str(s.CredentialType)
	if s.TokenLastEight.Set {
		e.FieldStart("token_last_eight")
		s.TokenLastEight.Encode(e)
	}

	e.FieldStart("credential_authorized_at")
	json.EncodeDateTime(e, s.CredentialAuthorizedAt)
	if s.Scopes != nil {
		e.FieldStart("scopes")
		e.ArrStart()
		for _, elem := range s.Scopes {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Fingerprint.Set {
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	if s.CredentialAccessedAt.Set {
		e.FieldStart("credential_accessed_at")
		s.CredentialAccessedAt.Encode(e, json.EncodeDateTime)
	}
	if s.AuthorizedCredentialID.Set {
		e.FieldStart("authorized_credential_id")
		s.AuthorizedCredentialID.Encode(e)
	}
	if s.AuthorizedCredentialTitle.Set {
		e.FieldStart("authorized_credential_title")
		s.AuthorizedCredentialTitle.Encode(e)
	}
	if s.AuthorizedCredentialNote.Set {
		e.FieldStart("authorized_credential_note")
		s.AuthorizedCredentialNote.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes CredentialAuthorization from json.
func (s *CredentialAuthorization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode CredentialAuthorization to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "credential_id":
			v, err := d.Int()
			s.CredentialID = int(v)
			if err != nil {
				return err
			}
		case "credential_type":
			v, err := d.Str()
			s.CredentialType = string(v)
			if err != nil {
				return err
			}
		case "token_last_eight":
			s.TokenLastEight.Reset()
			if err := s.TokenLastEight.Decode(d); err != nil {
				return err
			}
		case "credential_authorized_at":
			v, err := json.DecodeDateTime(d)
			s.CredentialAuthorizedAt = v
			if err != nil {
				return err
			}
		case "scopes":
			s.Scopes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Scopes = append(s.Scopes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "fingerprint":
			s.Fingerprint.Reset()
			if err := s.Fingerprint.Decode(d); err != nil {
				return err
			}
		case "credential_accessed_at":
			s.CredentialAccessedAt.Reset()
			if err := s.CredentialAccessedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "authorized_credential_id":
			s.AuthorizedCredentialID.Reset()
			if err := s.AuthorizedCredentialID.Decode(d); err != nil {
				return err
			}
		case "authorized_credential_title":
			s.AuthorizedCredentialTitle.Reset()
			if err := s.AuthorizedCredentialTitle.Decode(d); err != nil {
				return err
			}
		case "authorized_credential_note":
			s.AuthorizedCredentialNote.Reset()
			if err := s.AuthorizedCredentialNote.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s DeployKey) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("key")
	e.Str(s.Key)

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("verified")
	e.Bool(s.Verified)

	e.FieldStart("created_at")
	e.Str(s.CreatedAt)

	e.FieldStart("read_only")
	e.Bool(s.ReadOnly)
	e.ObjEnd()
}

// Decode decodes DeployKey from json.
func (s *DeployKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeployKey to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "verified":
			v, err := d.Bool()
			s.Verified = bool(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := d.Str()
			s.CreatedAt = string(v)
			if err != nil {
				return err
			}
		case "read_only":
			v, err := d.Bool()
			s.ReadOnly = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s DeploymentBranchPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("protected_branches")
	e.Bool(s.ProtectedBranches)

	e.FieldStart("custom_branch_policies")
	e.Bool(s.CustomBranchPolicies)
	e.ObjEnd()
}

// Decode decodes DeploymentBranchPolicy from json.
func (s *DeploymentBranchPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeploymentBranchPolicy to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "protected_branches":
			v, err := d.Bool()
			s.ProtectedBranches = bool(v)
			if err != nil {
				return err
			}
		case "custom_branch_policies":
			v, err := d.Bool()
			s.CustomBranchPolicies = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes DeploymentReviewerType as json.
func (s DeploymentReviewerType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeploymentReviewerType from json.
func (s *DeploymentReviewerType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeploymentReviewerType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = DeploymentReviewerType(v)
	return nil
}

// Encode implements json.Marshaler.
func (s DeploymentSimple) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("task")
	e.Str(s.Task)
	if s.OriginalEnvironment.Set {
		e.FieldStart("original_environment")
		s.OriginalEnvironment.Encode(e)
	}

	e.FieldStart("environment")
	e.Str(s.Environment)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("statuses_url")
	json.EncodeURI(e, s.StatusesURL)

	e.FieldStart("repository_url")
	json.EncodeURI(e, s.RepositoryURL)
	if s.TransientEnvironment.Set {
		e.FieldStart("transient_environment")
		s.TransientEnvironment.Encode(e)
	}
	if s.ProductionEnvironment.Set {
		e.FieldStart("production_environment")
		s.ProductionEnvironment.Encode(e)
	}
	if s.PerformedViaGithubApp.Set {
		e.FieldStart("performed_via_github_app")
		s.PerformedViaGithubApp.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes DeploymentSimple from json.
func (s *DeploymentSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeploymentSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "task":
			v, err := d.Str()
			s.Task = string(v)
			if err != nil {
				return err
			}
		case "original_environment":
			s.OriginalEnvironment.Reset()
			if err := s.OriginalEnvironment.Decode(d); err != nil {
				return err
			}
		case "environment":
			v, err := d.Str()
			s.Environment = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := json.DecodeURI(d)
			s.StatusesURL = v
			if err != nil {
				return err
			}
		case "repository_url":
			v, err := json.DecodeURI(d)
			s.RepositoryURL = v
			if err != nil {
				return err
			}
		case "transient_environment":
			s.TransientEnvironment.Reset()
			if err := s.TransientEnvironment.Decode(d); err != nil {
				return err
			}
		case "production_environment":
			s.ProductionEnvironment.Reset()
			if err := s.ProductionEnvironment.Decode(d); err != nil {
				return err
			}
		case "performed_via_github_app":
			s.PerformedViaGithubApp.Reset()
			if err := s.PerformedViaGithubApp.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s DeploymentStatus) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("state")
	s.State.Encode(e)

	e.FieldStart("creator")
	s.Creator.Encode(e)

	e.FieldStart("description")
	e.Str(s.Description)
	if s.Environment.Set {
		e.FieldStart("environment")
		s.Environment.Encode(e)
	}

	e.FieldStart("target_url")
	json.EncodeURI(e, s.TargetURL)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("deployment_url")
	json.EncodeURI(e, s.DeploymentURL)

	e.FieldStart("repository_url")
	json.EncodeURI(e, s.RepositoryURL)
	if s.EnvironmentURL.Set {
		e.FieldStart("environment_url")
		s.EnvironmentURL.Encode(e)
	}
	if s.LogURL.Set {
		e.FieldStart("log_url")
		s.LogURL.Encode(e)
	}
	if s.PerformedViaGithubApp.Set {
		e.FieldStart("performed_via_github_app")
		s.PerformedViaGithubApp.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes DeploymentStatus from json.
func (s *DeploymentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeploymentStatus to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "creator":
			if err := s.Creator.Decode(d); err != nil {
				return err
			}
		case "description":
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "environment":
			s.Environment.Reset()
			if err := s.Environment.Decode(d); err != nil {
				return err
			}
		case "target_url":
			v, err := json.DecodeURI(d)
			s.TargetURL = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "deployment_url":
			v, err := json.DecodeURI(d)
			s.DeploymentURL = v
			if err != nil {
				return err
			}
		case "repository_url":
			v, err := json.DecodeURI(d)
			s.RepositoryURL = v
			if err != nil {
				return err
			}
		case "environment_url":
			s.EnvironmentURL.Reset()
			if err := s.EnvironmentURL.Decode(d); err != nil {
				return err
			}
		case "log_url":
			s.LogURL.Reset()
			if err := s.LogURL.Decode(d); err != nil {
				return err
			}
		case "performed_via_github_app":
			s.PerformedViaGithubApp.Reset()
			if err := s.PerformedViaGithubApp.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes DeploymentStatusState as json.
func (s DeploymentStatusState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeploymentStatusState from json.
func (s *DeploymentStatusState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DeploymentStatusState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = DeploymentStatusState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s DiffEntry) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("filename")
	e.Str(s.Filename)

	e.FieldStart("status")
	s.Status.Encode(e)

	e.FieldStart("additions")
	e.Int(s.Additions)

	e.FieldStart("deletions")
	e.Int(s.Deletions)

	e.FieldStart("changes")
	e.Int(s.Changes)

	e.FieldStart("blob_url")
	json.EncodeURI(e, s.BlobURL)

	e.FieldStart("raw_url")
	json.EncodeURI(e, s.RawURL)

	e.FieldStart("contents_url")
	json.EncodeURI(e, s.ContentsURL)
	if s.Patch.Set {
		e.FieldStart("patch")
		s.Patch.Encode(e)
	}
	if s.PreviousFilename.Set {
		e.FieldStart("previous_filename")
		s.PreviousFilename.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes DiffEntry from json.
func (s *DiffEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DiffEntry to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "filename":
			v, err := d.Str()
			s.Filename = string(v)
			if err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "additions":
			v, err := d.Int()
			s.Additions = int(v)
			if err != nil {
				return err
			}
		case "deletions":
			v, err := d.Int()
			s.Deletions = int(v)
			if err != nil {
				return err
			}
		case "changes":
			v, err := d.Int()
			s.Changes = int(v)
			if err != nil {
				return err
			}
		case "blob_url":
			v, err := json.DecodeURI(d)
			s.BlobURL = v
			if err != nil {
				return err
			}
		case "raw_url":
			v, err := json.DecodeURI(d)
			s.RawURL = v
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := json.DecodeURI(d)
			s.ContentsURL = v
			if err != nil {
				return err
			}
		case "patch":
			s.Patch.Reset()
			if err := s.Patch.Decode(d); err != nil {
				return err
			}
		case "previous_filename":
			s.PreviousFilename.Reset()
			if err := s.PreviousFilename.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes DiffEntryStatus as json.
func (s DiffEntryStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DiffEntryStatus from json.
func (s *DiffEntryStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode DiffEntryStatus to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = DiffEntryStatus(v)
	return nil
}

// Encode implements json.Marshaler.
func (s Email) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("email")
	e.Str(s.Email)

	e.FieldStart("primary")
	e.Bool(s.Primary)

	e.FieldStart("verified")
	e.Bool(s.Verified)

	e.FieldStart("visibility")
	s.Visibility.Encode(e)
	e.ObjEnd()
}

// Decode decodes Email from json.
func (s *Email) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Email to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "primary":
			v, err := d.Bool()
			s.Primary = bool(v)
			if err != nil {
				return err
			}
		case "verified":
			v, err := d.Bool()
			s.Verified = bool(v)
			if err != nil {
				return err
			}
		case "visibility":
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EmojisGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EmojisGetOK from json.
func (s *EmojisGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EmojisGetOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EmptyObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EmptyObject from json.
func (s *EmptyObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EmptyObject to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes EnabledOrganizations as json.
func (s EnabledOrganizations) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnabledOrganizations from json.
func (s *EnabledOrganizations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnabledOrganizations to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = EnabledOrganizations(v)
	return nil
}

// Encode encodes EnabledRepositories as json.
func (s EnabledRepositories) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnabledRepositories from json.
func (s *EnabledRepositories) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnabledRepositories to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = EnabledRepositories(v)
	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent from json.
func (s *EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent from json.
func (s *EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)
	if s.Visibility.Set {
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
	if s.SelectedOrganizationIds != nil {
		e.FieldStart("selected_organization_ids")
		e.ArrStart()
		for _, elem := range s.SelectedOrganizationIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	if s.Runners != nil {
		e.FieldStart("runners")
		e.ArrStart()
		for _, elem := range s.Runners {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq from json.
func (s *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "selected_organization_ids":
			s.SelectedOrganizationIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.SelectedOrganizationIds = append(s.SelectedOrganizationIds, elem)
				return nil
			}); err != nil {
				return err
			}
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility as json.
func (s EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility from json.
func (s *EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility(v)
	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent from json.
func (s *EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminDeleteScimGroupFromEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent from json.
func (s *EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent from json.
func (s *EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminDeleteUserFromEnterpriseNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminDeleteUserFromEnterpriseNoContent from json.
func (s *EnterpriseAdminDeleteUserFromEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminDeleteUserFromEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent from json.
func (s *EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent from json.
func (s *EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes EnterpriseAdminGetAuditLogInclude as json.
func (s EnterpriseAdminGetAuditLogInclude) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnterpriseAdminGetAuditLogInclude from json.
func (s *EnterpriseAdminGetAuditLogInclude) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminGetAuditLogInclude to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = EnterpriseAdminGetAuditLogInclude(v)
	return nil
}

// Encode encodes EnterpriseAdminGetAuditLogOrder as json.
func (s EnterpriseAdminGetAuditLogOrder) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnterpriseAdminGetAuditLogOrder from json.
func (s *EnterpriseAdminGetAuditLogOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminGetAuditLogOrder to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = EnterpriseAdminGetAuditLogOrder(v)
	return nil
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Float64(s.TotalCount)

	e.FieldStart("organizations")
	e.ArrStart()
	for _, elem := range s.Organizations {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK from json.
func (s *EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Float64()
			s.TotalCount = float64(v)
			if err != nil {
				return err
			}
		case "organizations":
			s.Organizations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem OrganizationSimple
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Organizations = append(s.Organizations, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Float64(s.TotalCount)

	e.FieldStart("organizations")
	e.ArrStart()
	for _, elem := range s.Organizations {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK from json.
func (s *EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Float64()
			s.TotalCount = float64(v)
			if err != nil {
				return err
			}
		case "organizations":
			s.Organizations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem OrganizationSimple
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Organizations = append(s.Organizations, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Float64(s.TotalCount)

	e.FieldStart("runner_groups")
	e.ArrStart()
	for _, elem := range s.RunnerGroups {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK from json.
func (s *EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Float64()
			s.TotalCount = float64(v)
			if err != nil {
				return err
			}
		case "runner_groups":
			s.RunnerGroups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem RunnerGroupsEnterprise
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.RunnerGroups = append(s.RunnerGroups, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminListSelfHostedRunnersForEnterpriseOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.TotalCount.Set {
		e.FieldStart("total_count")
		s.TotalCount.Encode(e)
	}
	if s.Runners != nil {
		e.FieldStart("runners")
		e.ArrStart()
		for _, elem := range s.Runners {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminListSelfHostedRunnersForEnterpriseOK from json.
func (s *EnterpriseAdminListSelfHostedRunnersForEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminListSelfHostedRunnersForEnterpriseOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			s.TotalCount.Reset()
			if err := s.TotalCount.Decode(d); err != nil {
				return err
			}
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Runner
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Float64(s.TotalCount)

	e.FieldStart("runners")
	e.ArrStart()
	for _, elem := range s.Runners {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK from json.
func (s *EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Float64()
			s.TotalCount = float64(v)
			if err != nil {
				return err
			}
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Runner
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseGroupReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("schemas")
	e.ArrStart()
	for _, elem := range s.Schemas {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("displayName")
	e.Str(s.DisplayName)
	if s.Members != nil {
		e.FieldStart("members")
		e.ArrStart()
		for _, elem := range s.Members {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseGroupReq from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseGroupReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "displayName":
			v, err := d.Str()
			s.DisplayName = string(v)
			if err != nil {
				return err
			}
		case "members":
			s.Members = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Members = append(s.Members, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("value")
	e.Str(s.Value)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseGroupReqMembersItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			v, err := d.Str()
			s.Value = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("schemas")
	e.ArrStart()
	for _, elem := range s.Schemas {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("userName")
	e.Str(s.UserName)

	e.FieldStart("name")
	s.Name.Encode(e)

	e.FieldStart("emails")
	e.ArrStart()
	for _, elem := range s.Emails {
		elem.Encode(e)
	}
	e.ArrEnd()
	if s.Groups != nil {
		e.FieldStart("groups")
		e.ArrStart()
		for _, elem := range s.Groups {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseUserReq from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "userName":
			v, err := d.Str()
			s.UserName = string(v)
			if err != nil {
				return err
			}
		case "name":
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("value")
	e.Str(s.Value)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("primary")
	e.Bool(s.Primary)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqEmailsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			v, err := d.Str()
			s.Value = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "primary":
			v, err := d.Bool()
			s.Primary = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Value.Set {
		e.FieldStart("value")
		s.Value.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqGroupsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminProvisionAndInviteEnterpriseUserReqName) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("givenName")
	e.Str(s.GivenName)

	e.FieldStart("familyName")
	e.Str(s.FamilyName)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminProvisionAndInviteEnterpriseUserReqName from json.
func (s *EnterpriseAdminProvisionAndInviteEnterpriseUserReqName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminProvisionAndInviteEnterpriseUserReqName to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			v, err := d.Str()
			s.GivenName = string(v)
			if err != nil {
				return err
			}
		case "familyName":
			v, err := d.Str()
			s.FamilyName = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent from json.
func (s *EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent from json.
func (s *EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetAllowedActionsEnterpriseNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetAllowedActionsEnterpriseNoContent from json.
func (s *EnterpriseAdminSetAllowedActionsEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetAllowedActionsEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent from json.
func (s *EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetGithubActionsPermissionsEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("enabled_organizations")
	s.EnabledOrganizations.Encode(e)
	if s.AllowedActions.Set {
		e.FieldStart("allowed_actions")
		s.AllowedActions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq from json.
func (s *EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetGithubActionsPermissionsEnterpriseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled_organizations":
			if err := s.EnabledOrganizations.Decode(d); err != nil {
				return err
			}
		case "allowed_actions":
			s.AllowedActions.Reset()
			if err := s.AllowedActions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("schemas")
	e.ArrStart()
	for _, elem := range s.Schemas {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("displayName")
	e.Str(s.DisplayName)
	if s.Members != nil {
		e.FieldStart("members")
		e.ArrStart()
		for _, elem := range s.Members {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "displayName":
			v, err := d.Str()
			s.DisplayName = string(v)
			if err != nil {
				return err
			}
		case "members":
			s.Members = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Members = append(s.Members, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("value")
	e.Str(s.Value)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseGroupReqMembersItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			v, err := d.Str()
			s.Value = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("schemas")
	e.ArrStart()
	for _, elem := range s.Schemas {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("userName")
	e.Str(s.UserName)

	e.FieldStart("name")
	s.Name.Encode(e)

	e.FieldStart("emails")
	e.ArrStart()
	for _, elem := range s.Emails {
		elem.Encode(e)
	}
	e.ArrEnd()
	if s.Groups != nil {
		e.FieldStart("groups")
		e.ArrStart()
		for _, elem := range s.Groups {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "userName":
			v, err := d.Str()
			s.UserName = string(v)
			if err != nil {
				return err
			}
		case "name":
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("value")
	e.Str(s.Value)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("primary")
	e.Bool(s.Primary)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqEmailsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			v, err := d.Str()
			s.Value = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "primary":
			v, err := d.Bool()
			s.Primary = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Value.Set {
		e.FieldStart("value")
		s.Value.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqGroupsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("givenName")
	e.Str(s.GivenName)

	e.FieldStart("familyName")
	e.Str(s.FamilyName)
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName from json.
func (s *EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetInformationForProvisionedEnterpriseUserReqName to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			v, err := d.Str()
			s.GivenName = string(v)
			if err != nil {
				return err
			}
		case "familyName":
			v, err := d.Str()
			s.FamilyName = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent from json.
func (s *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("selected_organization_ids")
	e.ArrStart()
	for _, elem := range s.SelectedOrganizationIds {
		e.Int(elem)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq from json.
func (s *EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_organization_ids":
			s.SelectedOrganizationIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.SelectedOrganizationIds = append(s.SelectedOrganizationIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent from json.
func (s *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("selected_organization_ids")
	e.ArrStart()
	for _, elem := range s.SelectedOrganizationIds {
		e.Int(elem)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq from json.
func (s *EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "selected_organization_ids":
			s.SelectedOrganizationIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.SelectedOrganizationIds = append(s.SelectedOrganizationIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent from json.
func (s *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("runners")
	e.ArrStart()
	for _, elem := range s.Runners {
		e.Int(elem)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq from json.
func (s *EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "runners":
			s.Runners = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Runners = append(s.Runners, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminUpdateAttributeForEnterpriseUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("schemas")
	e.ArrStart()
	for _, elem := range s.Schemas {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("Operations")
	e.ArrStart()
	for _, elem := range s.Operations {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseUserReq from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "Operations":
			s.Operations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Operations = append(s.Operations, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem from json.
func (s *EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminUpdateAttributeForEnterpriseUserReqOperationsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Visibility.Set {
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq from json.
func (s *EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility as json.
func (s EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility from json.
func (s *EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility(v)
	return nil
}

// Encode implements json.Marshaler.
func (s EnvironmentApprovals) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("environments")
	e.ArrStart()
	for _, elem := range s.Environments {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("state")
	s.State.Encode(e)

	e.FieldStart("user")
	s.User.Encode(e)

	e.FieldStart("comment")
	e.Str(s.Comment)
	e.ObjEnd()
}

// Decode decodes EnvironmentApprovals from json.
func (s *EnvironmentApprovals) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnvironmentApprovals to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "environments":
			s.Environments = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EnvironmentApprovalsEnvironmentsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Environments = append(s.Environments, elem)
				return nil
			}); err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "comment":
			v, err := d.Str()
			s.Comment = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EnvironmentApprovalsEnvironmentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.CreatedAt.Set {
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	if s.UpdatedAt.Set {
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

// Decode decodes EnvironmentApprovalsEnvironmentsItem from json.
func (s *EnvironmentApprovalsEnvironmentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnvironmentApprovalsEnvironmentsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes EnvironmentApprovalsState as json.
func (s EnvironmentApprovalsState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnvironmentApprovalsState from json.
func (s *EnvironmentApprovalsState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EnvironmentApprovalsState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = EnvironmentApprovalsState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s Event) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Str(s.ID)

	e.FieldStart("type")
	s.Type.Encode(e)

	e.FieldStart("actor")
	s.Actor.Encode(e)

	e.FieldStart("repo")
	s.Repo.Encode(e)
	if s.Org.Set {
		e.FieldStart("org")
		s.Org.Encode(e)
	}

	e.FieldStart("payload")
	s.Payload.Encode(e)

	e.FieldStart("public")
	e.Bool(s.Public)

	e.FieldStart("created_at")
	s.CreatedAt.Encode(e, json.EncodeDateTime)
	e.ObjEnd()
}

// Decode decodes Event from json.
func (s *Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Event to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "type":
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "actor":
			if err := s.Actor.Decode(d); err != nil {
				return err
			}
		case "repo":
			if err := s.Repo.Decode(d); err != nil {
				return err
			}
		case "org":
			s.Org.Reset()
			if err := s.Org.Decode(d); err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		case "public":
			v, err := d.Bool()
			s.Public = bool(v)
			if err != nil {
				return err
			}
		case "created_at":
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EventPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Action.Set {
		e.FieldStart("action")
		s.Action.Encode(e)
	}
	if s.Issue.Set {
		e.FieldStart("issue")
		s.Issue.Encode(e)
	}
	if s.Comment.Set {
		e.FieldStart("comment")
		s.Comment.Encode(e)
	}
	if s.Pages != nil {
		e.FieldStart("pages")
		e.ArrStart()
		for _, elem := range s.Pages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes EventPayload from json.
func (s *EventPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EventPayload to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			s.Action.Reset()
			if err := s.Action.Decode(d); err != nil {
				return err
			}
		case "issue":
			s.Issue.Reset()
			if err := s.Issue.Decode(d); err != nil {
				return err
			}
		case "comment":
			s.Comment.Reset()
			if err := s.Comment.Decode(d); err != nil {
				return err
			}
		case "pages":
			s.Pages = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem EventPayloadPagesItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Pages = append(s.Pages, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EventPayloadPagesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.PageName.Set {
		e.FieldStart("page_name")
		s.PageName.Encode(e)
	}
	if s.Title.Set {
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	if s.Summary.Set {
		e.FieldStart("summary")
		s.Summary.Encode(e)
	}
	if s.Action.Set {
		e.FieldStart("action")
		s.Action.Encode(e)
	}
	if s.Sha.Set {
		e.FieldStart("sha")
		s.Sha.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes EventPayloadPagesItem from json.
func (s *EventPayloadPagesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EventPayloadPagesItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page_name":
			s.PageName.Reset()
			if err := s.PageName.Decode(d); err != nil {
				return err
			}
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "summary":
			s.Summary.Reset()
			if err := s.Summary.Decode(d); err != nil {
				return err
			}
		case "action":
			s.Action.Reset()
			if err := s.Action.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s EventRepo) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	e.ObjEnd()
}

// Decode decodes EventRepo from json.
func (s *EventRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode EventRepo to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Feed) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("timeline_url")
	e.Str(s.TimelineURL)

	e.FieldStart("user_url")
	e.Str(s.UserURL)
	if s.CurrentUserPublicURL.Set {
		e.FieldStart("current_user_public_url")
		s.CurrentUserPublicURL.Encode(e)
	}
	if s.CurrentUserURL.Set {
		e.FieldStart("current_user_url")
		s.CurrentUserURL.Encode(e)
	}
	if s.CurrentUserActorURL.Set {
		e.FieldStart("current_user_actor_url")
		s.CurrentUserActorURL.Encode(e)
	}
	if s.CurrentUserOrganizationURL.Set {
		e.FieldStart("current_user_organization_url")
		s.CurrentUserOrganizationURL.Encode(e)
	}
	if s.CurrentUserOrganizationUrls != nil {
		e.FieldStart("current_user_organization_urls")
		e.ArrStart()
		for _, elem := range s.CurrentUserOrganizationUrls {
			json.EncodeURI(e, elem)
		}
		e.ArrEnd()
	}
	if s.SecurityAdvisoriesURL.Set {
		e.FieldStart("security_advisories_url")
		s.SecurityAdvisoriesURL.Encode(e)
	}

	e.FieldStart("_links")
	s.Links.Encode(e)
	e.ObjEnd()
}

// Decode decodes Feed from json.
func (s *Feed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Feed to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeline_url":
			v, err := d.Str()
			s.TimelineURL = string(v)
			if err != nil {
				return err
			}
		case "user_url":
			v, err := d.Str()
			s.UserURL = string(v)
			if err != nil {
				return err
			}
		case "current_user_public_url":
			s.CurrentUserPublicURL.Reset()
			if err := s.CurrentUserPublicURL.Decode(d); err != nil {
				return err
			}
		case "current_user_url":
			s.CurrentUserURL.Reset()
			if err := s.CurrentUserURL.Decode(d); err != nil {
				return err
			}
		case "current_user_actor_url":
			s.CurrentUserActorURL.Reset()
			if err := s.CurrentUserActorURL.Decode(d); err != nil {
				return err
			}
		case "current_user_organization_url":
			s.CurrentUserOrganizationURL.Reset()
			if err := s.CurrentUserOrganizationURL.Decode(d); err != nil {
				return err
			}
		case "current_user_organization_urls":
			s.CurrentUserOrganizationUrls = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem url.URL
				v, err := json.DecodeURI(d)
				elem = v
				if err != nil {
					return err
				}
				s.CurrentUserOrganizationUrls = append(s.CurrentUserOrganizationUrls, elem)
				return nil
			}); err != nil {
				return err
			}
		case "security_advisories_url":
			s.SecurityAdvisoriesURL.Reset()
			if err := s.SecurityAdvisoriesURL.Decode(d); err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FeedLinks) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("timeline")
	s.Timeline.Encode(e)

	e.FieldStart("user")
	s.User.Encode(e)
	if s.SecurityAdvisories.Set {
		e.FieldStart("security_advisories")
		s.SecurityAdvisories.Encode(e)
	}
	if s.CurrentUser.Set {
		e.FieldStart("current_user")
		s.CurrentUser.Encode(e)
	}
	if s.CurrentUserPublic.Set {
		e.FieldStart("current_user_public")
		s.CurrentUserPublic.Encode(e)
	}
	if s.CurrentUserActor.Set {
		e.FieldStart("current_user_actor")
		s.CurrentUserActor.Encode(e)
	}
	if s.CurrentUserOrganization.Set {
		e.FieldStart("current_user_organization")
		s.CurrentUserOrganization.Encode(e)
	}
	if s.CurrentUserOrganizations != nil {
		e.FieldStart("current_user_organizations")
		e.ArrStart()
		for _, elem := range s.CurrentUserOrganizations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes FeedLinks from json.
func (s *FeedLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FeedLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeline":
			if err := s.Timeline.Decode(d); err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "security_advisories":
			s.SecurityAdvisories.Reset()
			if err := s.SecurityAdvisories.Decode(d); err != nil {
				return err
			}
		case "current_user":
			s.CurrentUser.Reset()
			if err := s.CurrentUser.Decode(d); err != nil {
				return err
			}
		case "current_user_public":
			s.CurrentUserPublic.Reset()
			if err := s.CurrentUserPublic.Decode(d); err != nil {
				return err
			}
		case "current_user_actor":
			s.CurrentUserActor.Reset()
			if err := s.CurrentUserActor.Decode(d); err != nil {
				return err
			}
		case "current_user_organization":
			s.CurrentUserOrganization.Reset()
			if err := s.CurrentUserOrganization.Decode(d); err != nil {
				return err
			}
		case "current_user_organizations":
			s.CurrentUserOrganizations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem LinkWithType
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CurrentUserOrganizations = append(s.CurrentUserOrganizations, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommit) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("content")
	s.Content.Encode(e)

	e.FieldStart("commit")
	s.Commit.Encode(e)
	e.ObjEnd()
}

// Decode decodes FileCommit from json.
func (s *FileCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		case "commit":
			if err := s.Commit.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommitCommit) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Sha.Set {
		e.FieldStart("sha")
		s.Sha.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.Author.Set {
		e.FieldStart("author")
		s.Author.Encode(e)
	}
	if s.Committer.Set {
		e.FieldStart("committer")
		s.Committer.Encode(e)
	}
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.Tree.Set {
		e.FieldStart("tree")
		s.Tree.Encode(e)
	}
	if s.Parents != nil {
		e.FieldStart("parents")
		e.ArrStart()
		for _, elem := range s.Parents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Verification.Set {
		e.FieldStart("verification")
		s.Verification.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes FileCommitCommit from json.
func (s *FileCommitCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommitCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "author":
			s.Author.Reset()
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			s.Committer.Reset()
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "tree":
			s.Tree.Reset()
			if err := s.Tree.Decode(d); err != nil {
				return err
			}
		case "parents":
			s.Parents = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem FileCommitCommitParentsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Parents = append(s.Parents, elem)
				return nil
			}); err != nil {
				return err
			}
		case "verification":
			s.Verification.Reset()
			if err := s.Verification.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommitCommitAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Date.Set {
		e.FieldStart("date")
		s.Date.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes FileCommitCommitAuthor from json.
func (s *FileCommitCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommitCommitAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			s.Date.Reset()
			if err := s.Date.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommitCommitCommitter) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Date.Set {
		e.FieldStart("date")
		s.Date.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes FileCommitCommitCommitter from json.
func (s *FileCommitCommitCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommitCommitCommitter to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			s.Date.Reset()
			if err := s.Date.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommitCommitParentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.Sha.Set {
		e.FieldStart("sha")
		s.Sha.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes FileCommitCommitParentsItem from json.
func (s *FileCommitCommitParentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommitCommitParentsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommitCommitTree) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.Sha.Set {
		e.FieldStart("sha")
		s.Sha.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes FileCommitCommitTree from json.
func (s *FileCommitCommitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommitCommitTree to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommitCommitVerification) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Verified.Set {
		e.FieldStart("verified")
		s.Verified.Encode(e)
	}
	if s.Reason.Set {
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
	if s.Signature.Set {
		e.FieldStart("signature")
		s.Signature.Encode(e)
	}
	if s.Payload.Set {
		e.FieldStart("payload")
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes FileCommitCommitVerification from json.
func (s *FileCommitCommitVerification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommitCommitVerification to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verified":
			s.Verified.Reset()
			if err := s.Verified.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "signature":
			s.Signature.Reset()
			if err := s.Signature.Decode(d); err != nil {
				return err
			}
		case "payload":
			s.Payload.Reset()
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommitContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Path.Set {
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	if s.Sha.Set {
		e.FieldStart("sha")
		s.Sha.Encode(e)
	}
	if s.Size.Set {
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.GitURL.Set {
		e.FieldStart("git_url")
		s.GitURL.Encode(e)
	}
	if s.DownloadURL.Set {
		e.FieldStart("download_url")
		s.DownloadURL.Encode(e)
	}
	if s.Type.Set {
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	if s.Links.Set {
		e.FieldStart("_links")
		s.Links.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes FileCommitContent from json.
func (s *FileCommitContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommitContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		case "size":
			s.Size.Reset()
			if err := s.Size.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "git_url":
			s.GitURL.Reset()
			if err := s.GitURL.Decode(d); err != nil {
				return err
			}
		case "download_url":
			s.DownloadURL.Reset()
			if err := s.DownloadURL.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "_links":
			s.Links.Reset()
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FileCommitContentLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Self.Set {
		e.FieldStart("self")
		s.Self.Encode(e)
	}
	if s.Git.Set {
		e.FieldStart("git")
		s.Git.Encode(e)
	}
	if s.HTML.Set {
		e.FieldStart("html")
		s.HTML.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes FileCommitContentLinks from json.
func (s *FileCommitContentLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FileCommitContentLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			s.Self.Reset()
			if err := s.Self.Decode(d); err != nil {
				return err
			}
		case "git":
			s.Git.Reset()
			if err := s.Git.Decode(d); err != nil {
				return err
			}
		case "html":
			s.HTML.Reset()
			if err := s.HTML.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ForbiddenGist) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Block.Set {
		e.FieldStart("block")
		s.Block.Encode(e)
	}
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.DocumentationURL.Set {
		e.FieldStart("documentation_url")
		s.DocumentationURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ForbiddenGist from json.
func (s *ForbiddenGist) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ForbiddenGist to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "block":
			s.Block.Reset()
			if err := s.Block.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ForbiddenGistBlock) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Reason.Set {
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
	if s.CreatedAt.Set {
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ForbiddenGistBlock from json.
func (s *ForbiddenGistBlock) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ForbiddenGistBlock to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Found) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes Found from json.
func (s *Found) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Found to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FullRepository) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("full_name")
	e.Str(s.FullName)

	e.FieldStart("owner")
	s.Owner.Encode(e)

	e.FieldStart("private")
	e.Bool(s.Private)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("fork")
	e.Bool(s.Fork)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("archive_url")
	e.Str(s.ArchiveURL)

	e.FieldStart("assignees_url")
	e.Str(s.AssigneesURL)

	e.FieldStart("blobs_url")
	e.Str(s.BlobsURL)

	e.FieldStart("branches_url")
	e.Str(s.BranchesURL)

	e.FieldStart("collaborators_url")
	e.Str(s.CollaboratorsURL)

	e.FieldStart("comments_url")
	e.Str(s.CommentsURL)

	e.FieldStart("commits_url")
	e.Str(s.CommitsURL)

	e.FieldStart("compare_url")
	e.Str(s.CompareURL)

	e.FieldStart("contents_url")
	e.Str(s.ContentsURL)

	e.FieldStart("contributors_url")
	json.EncodeURI(e, s.ContributorsURL)

	e.FieldStart("deployments_url")
	json.EncodeURI(e, s.DeploymentsURL)

	e.FieldStart("downloads_url")
	json.EncodeURI(e, s.DownloadsURL)

	e.FieldStart("events_url")
	json.EncodeURI(e, s.EventsURL)

	e.FieldStart("forks_url")
	json.EncodeURI(e, s.ForksURL)

	e.FieldStart("git_commits_url")
	e.Str(s.GitCommitsURL)

	e.FieldStart("git_refs_url")
	e.Str(s.GitRefsURL)

	e.FieldStart("git_tags_url")
	e.Str(s.GitTagsURL)

	e.FieldStart("git_url")
	e.Str(s.GitURL)

	e.FieldStart("issue_comment_url")
	e.Str(s.IssueCommentURL)

	e.FieldStart("issue_events_url")
	e.Str(s.IssueEventsURL)

	e.FieldStart("issues_url")
	e.Str(s.IssuesURL)

	e.FieldStart("keys_url")
	e.Str(s.KeysURL)

	e.FieldStart("labels_url")
	e.Str(s.LabelsURL)

	e.FieldStart("languages_url")
	json.EncodeURI(e, s.LanguagesURL)

	e.FieldStart("merges_url")
	json.EncodeURI(e, s.MergesURL)

	e.FieldStart("milestones_url")
	e.Str(s.MilestonesURL)

	e.FieldStart("notifications_url")
	e.Str(s.NotificationsURL)

	e.FieldStart("pulls_url")
	e.Str(s.PullsURL)

	e.FieldStart("releases_url")
	e.Str(s.ReleasesURL)

	e.FieldStart("ssh_url")
	e.Str(s.SSHURL)

	e.FieldStart("stargazers_url")
	json.EncodeURI(e, s.StargazersURL)

	e.FieldStart("statuses_url")
	e.Str(s.StatusesURL)

	e.FieldStart("subscribers_url")
	json.EncodeURI(e, s.SubscribersURL)

	e.FieldStart("subscription_url")
	json.EncodeURI(e, s.SubscriptionURL)

	e.FieldStart("tags_url")
	json.EncodeURI(e, s.TagsURL)

	e.FieldStart("teams_url")
	json.EncodeURI(e, s.TeamsURL)

	e.FieldStart("trees_url")
	e.Str(s.TreesURL)

	e.FieldStart("clone_url")
	e.Str(s.CloneURL)

	e.FieldStart("mirror_url")
	s.MirrorURL.Encode(e)

	e.FieldStart("hooks_url")
	json.EncodeURI(e, s.HooksURL)

	e.FieldStart("svn_url")
	json.EncodeURI(e, s.SvnURL)

	e.FieldStart("homepage")
	s.Homepage.Encode(e)

	e.FieldStart("language")
	s.Language.Encode(e)

	e.FieldStart("forks_count")
	e.Int(s.ForksCount)

	e.FieldStart("stargazers_count")
	e.Int(s.StargazersCount)

	e.FieldStart("watchers_count")
	e.Int(s.WatchersCount)

	e.FieldStart("size")
	e.Int(s.Size)

	e.FieldStart("default_branch")
	e.Str(s.DefaultBranch)

	e.FieldStart("open_issues_count")
	e.Int(s.OpenIssuesCount)
	if s.IsTemplate.Set {
		e.FieldStart("is_template")
		s.IsTemplate.Encode(e)
	}
	if s.Topics != nil {
		e.FieldStart("topics")
		e.ArrStart()
		for _, elem := range s.Topics {
			e.Str(elem)
		}
		e.ArrEnd()
	}

	e.FieldStart("has_issues")
	e.Bool(s.HasIssues)

	e.FieldStart("has_projects")
	e.Bool(s.HasProjects)

	e.FieldStart("has_wiki")
	e.Bool(s.HasWiki)

	e.FieldStart("has_pages")
	e.Bool(s.HasPages)

	e.FieldStart("has_downloads")
	e.Bool(s.HasDownloads)

	e.FieldStart("archived")
	e.Bool(s.Archived)

	e.FieldStart("disabled")
	e.Bool(s.Disabled)
	if s.Visibility.Set {
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}

	e.FieldStart("pushed_at")
	json.EncodeDateTime(e, s.PushedAt)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	if s.AllowRebaseMerge.Set {
		e.FieldStart("allow_rebase_merge")
		s.AllowRebaseMerge.Encode(e)
	}
	if s.TemplateRepository.Set {
		e.FieldStart("template_repository")
		s.TemplateRepository.Encode(e)
	}
	if s.TempCloneToken.Set {
		e.FieldStart("temp_clone_token")
		s.TempCloneToken.Encode(e)
	}
	if s.AllowSquashMerge.Set {
		e.FieldStart("allow_squash_merge")
		s.AllowSquashMerge.Encode(e)
	}
	if s.AllowAutoMerge.Set {
		e.FieldStart("allow_auto_merge")
		s.AllowAutoMerge.Encode(e)
	}
	if s.DeleteBranchOnMerge.Set {
		e.FieldStart("delete_branch_on_merge")
		s.DeleteBranchOnMerge.Encode(e)
	}
	if s.AllowMergeCommit.Set {
		e.FieldStart("allow_merge_commit")
		s.AllowMergeCommit.Encode(e)
	}
	if s.AllowForking.Set {
		e.FieldStart("allow_forking")
		s.AllowForking.Encode(e)
	}

	e.FieldStart("subscribers_count")
	e.Int(s.SubscribersCount)

	e.FieldStart("network_count")
	e.Int(s.NetworkCount)

	e.FieldStart("license")
	s.License.Encode(e)
	if s.Organization.Set {
		e.FieldStart("organization")
		s.Organization.Encode(e)
	}
	if s.Parent.Set {
		e.FieldStart("parent")
		s.Parent.Encode(e)
	}
	if s.Source.Set {
		e.FieldStart("source")
		s.Source.Encode(e)
	}

	e.FieldStart("forks")
	e.Int(s.Forks)
	if s.MasterBranch.Set {
		e.FieldStart("master_branch")
		s.MasterBranch.Encode(e)
	}

	e.FieldStart("open_issues")
	e.Int(s.OpenIssues)

	e.FieldStart("watchers")
	e.Int(s.Watchers)
	if s.AnonymousAccessEnabled.Set {
		e.FieldStart("anonymous_access_enabled")
		s.AnonymousAccessEnabled.Encode(e)
	}
	if s.CodeOfConduct.Set {
		e.FieldStart("code_of_conduct")
		s.CodeOfConduct.Encode(e)
	}
	if s.SecurityAndAnalysis.Set {
		e.FieldStart("security_and_analysis")
		s.SecurityAndAnalysis.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes FullRepository from json.
func (s *FullRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FullRepository to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "git_url":
			v, err := d.Str()
			s.GitURL = string(v)
			if err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			v, err := d.Str()
			s.SSHURL = string(v)
			if err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "clone_url":
			v, err := d.Str()
			s.CloneURL = string(v)
			if err != nil {
				return err
			}
		case "mirror_url":
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "svn_url":
			v, err := json.DecodeURI(d)
			s.SvnURL = v
			if err != nil {
				return err
			}
		case "homepage":
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			v, err := d.Int()
			s.ForksCount = int(v)
			if err != nil {
				return err
			}
		case "stargazers_count":
			v, err := d.Int()
			s.StargazersCount = int(v)
			if err != nil {
				return err
			}
		case "watchers_count":
			v, err := d.Int()
			s.WatchersCount = int(v)
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "default_branch":
			v, err := d.Str()
			s.DefaultBranch = string(v)
			if err != nil {
				return err
			}
		case "open_issues_count":
			v, err := d.Int()
			s.OpenIssuesCount = int(v)
			if err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "has_issues":
			v, err := d.Bool()
			s.HasIssues = bool(v)
			if err != nil {
				return err
			}
		case "has_projects":
			v, err := d.Bool()
			s.HasProjects = bool(v)
			if err != nil {
				return err
			}
		case "has_wiki":
			v, err := d.Bool()
			s.HasWiki = bool(v)
			if err != nil {
				return err
			}
		case "has_pages":
			v, err := d.Bool()
			s.HasPages = bool(v)
			if err != nil {
				return err
			}
		case "has_downloads":
			v, err := d.Bool()
			s.HasDownloads = bool(v)
			if err != nil {
				return err
			}
		case "archived":
			v, err := d.Bool()
			s.Archived = bool(v)
			if err != nil {
				return err
			}
		case "disabled":
			v, err := d.Bool()
			s.Disabled = bool(v)
			if err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			v, err := json.DecodeDateTime(d)
			s.PushedAt = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "template_repository":
			s.TemplateRepository.Reset()
			if err := s.TemplateRepository.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		case "subscribers_count":
			v, err := d.Int()
			s.SubscribersCount = int(v)
			if err != nil {
				return err
			}
		case "network_count":
			v, err := d.Int()
			s.NetworkCount = int(v)
			if err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "organization":
			s.Organization.Reset()
			if err := s.Organization.Decode(d); err != nil {
				return err
			}
		case "parent":
			s.Parent.Reset()
			if err := s.Parent.Decode(d); err != nil {
				return err
			}
		case "source":
			s.Source.Reset()
			if err := s.Source.Decode(d); err != nil {
				return err
			}
		case "forks":
			v, err := d.Int()
			s.Forks = int(v)
			if err != nil {
				return err
			}
		case "master_branch":
			s.MasterBranch.Reset()
			if err := s.MasterBranch.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "watchers":
			v, err := d.Int()
			s.Watchers = int(v)
			if err != nil {
				return err
			}
		case "anonymous_access_enabled":
			s.AnonymousAccessEnabled.Reset()
			if err := s.AnonymousAccessEnabled.Decode(d); err != nil {
				return err
			}
		case "code_of_conduct":
			s.CodeOfConduct.Reset()
			if err := s.CodeOfConduct.Decode(d); err != nil {
				return err
			}
		case "security_and_analysis":
			s.SecurityAndAnalysis.Reset()
			if err := s.SecurityAndAnalysis.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FullRepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("admin")
	e.Bool(s.Admin)
	if s.Maintain.Set {
		e.FieldStart("maintain")
		s.Maintain.Encode(e)
	}

	e.FieldStart("push")
	e.Bool(s.Push)
	if s.Triage.Set {
		e.FieldStart("triage")
		s.Triage.Encode(e)
	}

	e.FieldStart("pull")
	e.Bool(s.Pull)
	e.ObjEnd()
}

// Decode decodes FullRepositoryPermissions from json.
func (s *FullRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FullRepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FullRepositorySecurityAndAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.AdvancedSecurity.Set {
		e.FieldStart("advanced_security")
		s.AdvancedSecurity.Encode(e)
	}
	if s.SecretScanning.Set {
		e.FieldStart("secret_scanning")
		s.SecretScanning.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes FullRepositorySecurityAndAnalysis from json.
func (s *FullRepositorySecurityAndAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FullRepositorySecurityAndAnalysis to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "advanced_security":
			s.AdvancedSecurity.Reset()
			if err := s.AdvancedSecurity.Decode(d); err != nil {
				return err
			}
		case "secret_scanning":
			s.SecretScanning.Reset()
			if err := s.SecretScanning.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s FullRepositorySecurityAndAnalysisAdvancedSecurity) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Status.Set {
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes FullRepositorySecurityAndAnalysisAdvancedSecurity from json.
func (s *FullRepositorySecurityAndAnalysisAdvancedSecurity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FullRepositorySecurityAndAnalysisAdvancedSecurity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes FullRepositorySecurityAndAnalysisAdvancedSecurityStatus as json.
func (s FullRepositorySecurityAndAnalysisAdvancedSecurityStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FullRepositorySecurityAndAnalysisAdvancedSecurityStatus from json.
func (s *FullRepositorySecurityAndAnalysisAdvancedSecurityStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FullRepositorySecurityAndAnalysisAdvancedSecurityStatus to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = FullRepositorySecurityAndAnalysisAdvancedSecurityStatus(v)
	return nil
}

// Encode implements json.Marshaler.
func (s FullRepositorySecurityAndAnalysisSecretScanning) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Status.Set {
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes FullRepositorySecurityAndAnalysisSecretScanning from json.
func (s *FullRepositorySecurityAndAnalysisSecretScanning) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FullRepositorySecurityAndAnalysisSecretScanning to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes FullRepositorySecurityAndAnalysisSecretScanningStatus as json.
func (s FullRepositorySecurityAndAnalysisSecretScanningStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FullRepositorySecurityAndAnalysisSecretScanningStatus from json.
func (s *FullRepositorySecurityAndAnalysisSecretScanningStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode FullRepositorySecurityAndAnalysisSecretScanningStatus to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = FullRepositorySecurityAndAnalysisSecretScanningStatus(v)
	return nil
}

// Encode implements json.Marshaler.
func (s GistComment) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("body")
	e.Str(s.Body)

	e.FieldStart("user")
	s.User.Encode(e)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("author_association")
	s.AuthorAssociation.Encode(e)
	e.ObjEnd()
}

// Decode decodes GistComment from json.
func (s *GistComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistComment to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistCommit) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("version")
	e.Str(s.Version)

	e.FieldStart("user")
	s.User.Encode(e)

	e.FieldStart("change_status")
	s.ChangeStatus.Encode(e)

	e.FieldStart("committed_at")
	json.EncodeDateTime(e, s.CommittedAt)
	e.ObjEnd()
}

// Decode decodes GistCommit from json.
func (s *GistCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "version":
			v, err := d.Str()
			s.Version = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "change_status":
			if err := s.ChangeStatus.Decode(d); err != nil {
				return err
			}
		case "committed_at":
			v, err := json.DecodeDateTime(d)
			s.CommittedAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistCommitChangeStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Total.Set {
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	if s.Additions.Set {
		e.FieldStart("additions")
		s.Additions.Encode(e)
	}
	if s.Deletions.Set {
		e.FieldStart("deletions")
		s.Deletions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GistCommitChangeStatus from json.
func (s *GistCommitChangeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistCommitChangeStatus to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			s.Total.Reset()
			if err := s.Total.Decode(d); err != nil {
				return err
			}
		case "additions":
			s.Additions.Reset()
			if err := s.Additions.Decode(d); err != nil {
				return err
			}
		case "deletions":
			s.Deletions.Reset()
			if err := s.Deletions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistHistory) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.User.Set {
		e.FieldStart("user")
		s.User.Encode(e)
	}
	if s.Version.Set {
		e.FieldStart("version")
		s.Version.Encode(e)
	}
	if s.CommittedAt.Set {
		e.FieldStart("committed_at")
		s.CommittedAt.Encode(e, json.EncodeDateTime)
	}
	if s.ChangeStatus.Set {
		e.FieldStart("change_status")
		s.ChangeStatus.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GistHistory from json.
func (s *GistHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistHistory to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "version":
			s.Version.Reset()
			if err := s.Version.Decode(d); err != nil {
				return err
			}
		case "committed_at":
			s.CommittedAt.Reset()
			if err := s.CommittedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "change_status":
			s.ChangeStatus.Reset()
			if err := s.ChangeStatus.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistHistoryChangeStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Total.Set {
		e.FieldStart("total")
		s.Total.Encode(e)
	}
	if s.Additions.Set {
		e.FieldStart("additions")
		s.Additions.Encode(e)
	}
	if s.Deletions.Set {
		e.FieldStart("deletions")
		s.Deletions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GistHistoryChangeStatus from json.
func (s *GistHistoryChangeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistHistoryChangeStatus to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			s.Total.Reset()
			if err := s.Total.Decode(d); err != nil {
				return err
			}
		case "additions":
			s.Additions.Reset()
			if err := s.Additions.Decode(d); err != nil {
				return err
			}
		case "deletions":
			s.Deletions.Reset()
			if err := s.Deletions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistSimple) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Forks.Set {
		e.FieldStart("forks")
		s.Forks.Encode(e)
	}
	if s.History.Set {
		e.FieldStart("history")
		s.History.Encode(e)
	}
	if s.ForkOf.Set {
		e.FieldStart("fork_of")
		s.ForkOf.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.ForksURL.Set {
		e.FieldStart("forks_url")
		s.ForksURL.Encode(e)
	}
	if s.CommitsURL.Set {
		e.FieldStart("commits_url")
		s.CommitsURL.Encode(e)
	}
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	if s.GitPullURL.Set {
		e.FieldStart("git_pull_url")
		s.GitPullURL.Encode(e)
	}
	if s.GitPushURL.Set {
		e.FieldStart("git_push_url")
		s.GitPushURL.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.Files != nil {
		e.FieldStart("files")
		s.Files.Encode(e)
	}
	if s.Public.Set {
		e.FieldStart("public")
		s.Public.Encode(e)
	}
	if s.CreatedAt.Set {
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e)
	}
	if s.UpdatedAt.Set {
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.Comments.Set {
		e.FieldStart("comments")
		s.Comments.Encode(e)
	}
	if s.User.Set {
		e.FieldStart("user")
		s.User.Encode(e)
	}
	if s.CommentsURL.Set {
		e.FieldStart("comments_url")
		s.CommentsURL.Encode(e)
	}
	if s.Owner.Set {
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	if s.Truncated.Set {
		e.FieldStart("truncated")
		s.Truncated.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GistSimple from json.
func (s *GistSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "forks":
			s.Forks.Reset()
			if err := s.Forks.Decode(d); err != nil {
				return err
			}
		case "history":
			s.History.Reset()
			if err := s.History.Decode(d); err != nil {
				return err
			}
		case "fork_of":
			s.ForkOf.Reset()
			if err := s.ForkOf.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "forks_url":
			s.ForksURL.Reset()
			if err := s.ForksURL.Decode(d); err != nil {
				return err
			}
		case "commits_url":
			s.CommitsURL.Reset()
			if err := s.CommitsURL.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "git_pull_url":
			s.GitPullURL.Reset()
			if err := s.GitPullURL.Decode(d); err != nil {
				return err
			}
		case "git_push_url":
			s.GitPushURL.Reset()
			if err := s.GitPushURL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "files":
			s.Files = nil
			var elem GistSimpleFiles
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Files = &elem
		case "public":
			s.Public.Reset()
			if err := s.Public.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "comments":
			s.Comments.Reset()
			if err := s.Comments.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "comments_url":
			s.CommentsURL.Reset()
			if err := s.CommentsURL.Decode(d); err != nil {
				return err
			}
		case "owner":
			s.Owner.Reset()
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "truncated":
			s.Truncated.Reset()
			if err := s.Truncated.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistSimpleFiles) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes GistSimpleFiles from json.
func (s *GistSimpleFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistSimpleFiles to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistSimpleForkOf) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("forks_url")
	json.EncodeURI(e, s.ForksURL)

	e.FieldStart("commits_url")
	json.EncodeURI(e, s.CommitsURL)

	e.FieldStart("id")
	e.Str(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("git_pull_url")
	json.EncodeURI(e, s.GitPullURL)

	e.FieldStart("git_push_url")
	json.EncodeURI(e, s.GitPushURL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("files")
	s.Files.Encode(e)

	e.FieldStart("public")
	e.Bool(s.Public)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("comments")
	e.Int(s.Comments)

	e.FieldStart("user")
	s.User.Encode(e)

	e.FieldStart("comments_url")
	json.EncodeURI(e, s.CommentsURL)
	if s.Owner.Set {
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	if s.Truncated.Set {
		e.FieldStart("truncated")
		s.Truncated.Encode(e)
	}
	if s.Forks != nil {
		e.FieldStart("forks")
		e.ArrStart()
		for _, elem := range s.Forks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.History != nil {
		e.FieldStart("history")
		e.ArrStart()
		for _, elem := range s.History {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes GistSimpleForkOf from json.
func (s *GistSimpleForkOf) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistSimpleForkOf to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := json.DecodeURI(d)
			s.CommitsURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "git_pull_url":
			v, err := json.DecodeURI(d)
			s.GitPullURL = v
			if err != nil {
				return err
			}
		case "git_push_url":
			v, err := json.DecodeURI(d)
			s.GitPushURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "files":
			if err := s.Files.Decode(d); err != nil {
				return err
			}
		case "public":
			v, err := d.Bool()
			s.Public = bool(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "comments":
			v, err := d.Int()
			s.Comments = int(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "owner":
			s.Owner.Reset()
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "truncated":
			s.Truncated.Reset()
			if err := s.Truncated.Decode(d); err != nil {
				return err
			}
		case "forks":
			s.Forks = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Forks = append(s.Forks, elem)
				return nil
			}); err != nil {
				return err
			}
		case "history":
			s.History = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.History = append(s.History, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistSimpleForkOfFiles) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes GistSimpleForkOfFiles from json.
func (s *GistSimpleForkOfFiles) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistSimpleForkOfFiles to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistSimpleForksItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.User.Set {
		e.FieldStart("user")
		s.User.Encode(e)
	}
	if s.CreatedAt.Set {
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	if s.UpdatedAt.Set {
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

// Decode decodes GistSimpleForksItem from json.
func (s *GistSimpleForksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistSimpleForksItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "user":
			s.User.Reset()
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistsCheckIsStarredNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes GistsCheckIsStarredNoContent from json.
func (s *GistsCheckIsStarredNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsCheckIsStarredNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistsCheckIsStarredNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes GistsCheckIsStarredNotFound from json.
func (s *GistsCheckIsStarredNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsCheckIsStarredNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes GistsCreateCommentApplicationJSONForbidden as json.
func (s GistsCreateCommentApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsCreateCommentApplicationJSONForbidden from json.
func (s *GistsCreateCommentApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsCreateCommentApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsCreateCommentApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsCreateCommentApplicationJSONNotFound as json.
func (s GistsCreateCommentApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsCreateCommentApplicationJSONNotFound from json.
func (s *GistsCreateCommentApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsCreateCommentApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsCreateCommentApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GistsCreateCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("body")
	e.Str(s.Body)
	e.ObjEnd()
}

// Decode decodes GistsCreateCommentReq from json.
func (s *GistsCreateCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsCreateCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes GistsDeleteApplicationJSONForbidden as json.
func (s GistsDeleteApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsDeleteApplicationJSONForbidden from json.
func (s *GistsDeleteApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsDeleteApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsDeleteApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsDeleteApplicationJSONNotFound as json.
func (s GistsDeleteApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsDeleteApplicationJSONNotFound from json.
func (s *GistsDeleteApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsDeleteApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsDeleteApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsDeleteCommentApplicationJSONForbidden as json.
func (s GistsDeleteCommentApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsDeleteCommentApplicationJSONForbidden from json.
func (s *GistsDeleteCommentApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsDeleteCommentApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsDeleteCommentApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsDeleteCommentApplicationJSONNotFound as json.
func (s GistsDeleteCommentApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsDeleteCommentApplicationJSONNotFound from json.
func (s *GistsDeleteCommentApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsDeleteCommentApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsDeleteCommentApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GistsDeleteCommentNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes GistsDeleteCommentNoContent from json.
func (s *GistsDeleteCommentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsDeleteCommentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistsDeleteNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes GistsDeleteNoContent from json.
func (s *GistsDeleteNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsDeleteNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes GistsListCommentsApplicationJSONForbidden as json.
func (s GistsListCommentsApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListCommentsApplicationJSONForbidden from json.
func (s *GistsListCommentsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListCommentsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommentsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsListCommentsApplicationJSONNotFound as json.
func (s GistsListCommentsApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListCommentsApplicationJSONNotFound from json.
func (s *GistsListCommentsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListCommentsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommentsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsListCommentsOKApplicationJSON as json.
func (s GistsListCommentsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []GistComment(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GistsListCommentsOKApplicationJSON from json.
func (s *GistsListCommentsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListCommentsOKApplicationJSON to nil`)
	}
	var unwrapped []GistComment
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GistComment
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommentsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsListCommitsApplicationJSONForbidden as json.
func (s GistsListCommitsApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListCommitsApplicationJSONForbidden from json.
func (s *GistsListCommitsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListCommitsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommitsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsListCommitsApplicationJSONNotFound as json.
func (s GistsListCommitsApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListCommitsApplicationJSONNotFound from json.
func (s *GistsListCommitsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListCommitsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommitsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsListCommitsOKApplicationJSON as json.
func (s GistsListCommitsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []GistCommit(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GistsListCommitsOKApplicationJSON from json.
func (s *GistsListCommitsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListCommitsOKApplicationJSON to nil`)
	}
	var unwrapped []GistCommit
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GistCommit
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListCommitsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsListForksApplicationJSONForbidden as json.
func (s GistsListForksApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListForksApplicationJSONForbidden from json.
func (s *GistsListForksApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListForksApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListForksApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsListForksApplicationJSONNotFound as json.
func (s GistsListForksApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListForksApplicationJSONNotFound from json.
func (s *GistsListForksApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListForksApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListForksApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes GistsListForksOKApplicationJSON as json.
func (s GistsListForksOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []GistSimple(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GistsListForksOKApplicationJSON from json.
func (s *GistsListForksOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListForksOKApplicationJSON to nil`)
	}
	var unwrapped []GistSimple
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GistSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListForksOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsListOKApplicationJSON as json.
func (s GistsListOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []BaseGist(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GistsListOKApplicationJSON from json.
func (s *GistsListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListOKApplicationJSON to nil`)
	}
	var unwrapped []BaseGist
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BaseGist
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsListStarredApplicationJSONForbidden as json.
func (s GistsListStarredApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListStarredApplicationJSONForbidden from json.
func (s *GistsListStarredApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListStarredApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListStarredApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsListStarredApplicationJSONUnauthorized as json.
func (s GistsListStarredApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsListStarredApplicationJSONUnauthorized from json.
func (s *GistsListStarredApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListStarredApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListStarredApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes GistsListStarredOKApplicationJSON as json.
func (s GistsListStarredOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []BaseGist(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GistsListStarredOKApplicationJSON from json.
func (s *GistsListStarredOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsListStarredOKApplicationJSON to nil`)
	}
	var unwrapped []BaseGist
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BaseGist
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsListStarredOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes GistsStarApplicationJSONForbidden as json.
func (s GistsStarApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsStarApplicationJSONForbidden from json.
func (s *GistsStarApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsStarApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsStarApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsStarApplicationJSONNotFound as json.
func (s GistsStarApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsStarApplicationJSONNotFound from json.
func (s *GistsStarApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsStarApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsStarApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GistsStarNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes GistsStarNoContent from json.
func (s *GistsStarNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsStarNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes GistsUnstarApplicationJSONForbidden as json.
func (s GistsUnstarApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsUnstarApplicationJSONForbidden from json.
func (s *GistsUnstarApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsUnstarApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsUnstarApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes GistsUnstarApplicationJSONNotFound as json.
func (s GistsUnstarApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes GistsUnstarApplicationJSONNotFound from json.
func (s *GistsUnstarApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsUnstarApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GistsUnstarApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GistsUnstarNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes GistsUnstarNoContent from json.
func (s *GistsUnstarNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsUnstarNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GistsUpdateCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("body")
	e.Str(s.Body)
	e.ObjEnd()
}

// Decode decodes GistsUpdateCommentReq from json.
func (s *GistsUpdateCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GistsUpdateCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCommit) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("author")
	s.Author.Encode(e)

	e.FieldStart("committer")
	s.Committer.Encode(e)

	e.FieldStart("message")
	e.Str(s.Message)

	e.FieldStart("tree")
	s.Tree.Encode(e)

	e.FieldStart("parents")
	e.ArrStart()
	for _, elem := range s.Parents {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("verification")
	s.Verification.Encode(e)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)
	e.ObjEnd()
}

// Decode decodes GitCommit from json.
func (s *GitCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "tree":
			if err := s.Tree.Decode(d); err != nil {
				return err
			}
		case "parents":
			s.Parents = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem GitCommitParentsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Parents = append(s.Parents, elem)
				return nil
			}); err != nil {
				return err
			}
		case "verification":
			if err := s.Verification.Decode(d); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCommitAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("date")
	json.EncodeDateTime(e, s.Date)

	e.FieldStart("email")
	e.Str(s.Email)

	e.FieldStart("name")
	e.Str(s.Name)
	e.ObjEnd()
}

// Decode decodes GitCommitAuthor from json.
func (s *GitCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCommitAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			v, err := json.DecodeDateTime(d)
			s.Date = v
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCommitCommitter) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("date")
	json.EncodeDateTime(e, s.Date)

	e.FieldStart("email")
	e.Str(s.Email)

	e.FieldStart("name")
	e.Str(s.Name)
	e.ObjEnd()
}

// Decode decodes GitCommitCommitter from json.
func (s *GitCommitCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCommitCommitter to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			v, err := json.DecodeDateTime(d)
			s.Date = v
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCommitParentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)
	e.ObjEnd()
}

// Decode decodes GitCommitParentsItem from json.
func (s *GitCommitParentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCommitParentsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCommitTree) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	e.ObjEnd()
}

// Decode decodes GitCommitTree from json.
func (s *GitCommitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCommitTree to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCommitVerification) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("verified")
	e.Bool(s.Verified)

	e.FieldStart("reason")
	e.Str(s.Reason)

	e.FieldStart("signature")
	s.Signature.Encode(e)

	e.FieldStart("payload")
	s.Payload.Encode(e)
	e.ObjEnd()
}

// Decode decodes GitCommitVerification from json.
func (s *GitCommitVerification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCommitVerification to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verified":
			v, err := d.Bool()
			s.Verified = bool(v)
			if err != nil {
				return err
			}
		case "reason":
			v, err := d.Str()
			s.Reason = string(v)
			if err != nil {
				return err
			}
		case "signature":
			if err := s.Signature.Decode(d); err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCreateBlobReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("content")
	e.Str(s.Content)
	if s.Encoding.Set {
		e.FieldStart("encoding")
		s.Encoding.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GitCreateBlobReq from json.
func (s *GitCreateBlobReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateBlobReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			v, err := d.Str()
			s.Content = string(v)
			if err != nil {
				return err
			}
		case "encoding":
			s.Encoding.Reset()
			if err := s.Encoding.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCreateCommitReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("message")
	e.Str(s.Message)

	e.FieldStart("tree")
	e.Str(s.Tree)
	if s.Parents != nil {
		e.FieldStart("parents")
		e.ArrStart()
		for _, elem := range s.Parents {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Author.Set {
		e.FieldStart("author")
		s.Author.Encode(e)
	}
	if s.Committer.Set {
		e.FieldStart("committer")
		s.Committer.Encode(e)
	}
	if s.Signature.Set {
		e.FieldStart("signature")
		s.Signature.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GitCreateCommitReq from json.
func (s *GitCreateCommitReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateCommitReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "tree":
			v, err := d.Str()
			s.Tree = string(v)
			if err != nil {
				return err
			}
		case "parents":
			s.Parents = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Parents = append(s.Parents, elem)
				return nil
			}); err != nil {
				return err
			}
		case "author":
			s.Author.Reset()
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			s.Committer.Reset()
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "signature":
			s.Signature.Reset()
			if err := s.Signature.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCreateCommitReqAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("email")
	e.Str(s.Email)
	if s.Date.Set {
		e.FieldStart("date")
		s.Date.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

// Decode decodes GitCreateCommitReqAuthor from json.
func (s *GitCreateCommitReqAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateCommitReqAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "date":
			s.Date.Reset()
			if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCreateCommitReqCommitter) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	if s.Date.Set {
		e.FieldStart("date")
		s.Date.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

// Decode decodes GitCreateCommitReqCommitter from json.
func (s *GitCreateCommitReqCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateCommitReqCommitter to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "date":
			s.Date.Reset()
			if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCreateRefReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("ref")
	e.Str(s.Ref)

	e.FieldStart("sha")
	e.Str(s.Sha)
	if s.Key.Set {
		e.FieldStart("key")
		s.Key.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GitCreateRefReq from json.
func (s *GitCreateRefReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateRefReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "key":
			s.Key.Reset()
			if err := s.Key.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCreateTagReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("tag")
	e.Str(s.Tag)

	e.FieldStart("message")
	e.Str(s.Message)

	e.FieldStart("object")
	e.Str(s.Object)

	e.FieldStart("type")
	s.Type.Encode(e)
	if s.Tagger.Set {
		e.FieldStart("tagger")
		s.Tagger.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GitCreateTagReq from json.
func (s *GitCreateTagReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateTagReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			v, err := d.Str()
			s.Tag = string(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "object":
			v, err := d.Str()
			s.Object = string(v)
			if err != nil {
				return err
			}
		case "type":
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "tagger":
			s.Tagger.Reset()
			if err := s.Tagger.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCreateTagReqTagger) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("email")
	e.Str(s.Email)
	if s.Date.Set {
		e.FieldStart("date")
		s.Date.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

// Decode decodes GitCreateTagReqTagger from json.
func (s *GitCreateTagReqTagger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateTagReqTagger to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "date":
			s.Date.Reset()
			if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes GitCreateTagReqType as json.
func (s GitCreateTagReqType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GitCreateTagReqType from json.
func (s *GitCreateTagReqType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateTagReqType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = GitCreateTagReqType(v)
	return nil
}

// Encode implements json.Marshaler.
func (s GitCreateTreeReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("tree")
	e.ArrStart()
	for _, elem := range s.Tree {
		elem.Encode(e)
	}
	e.ArrEnd()
	if s.BaseTree.Set {
		e.FieldStart("base_tree")
		s.BaseTree.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GitCreateTreeReq from json.
func (s *GitCreateTreeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateTreeReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tree":
			s.Tree = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem GitCreateTreeReqTreeItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Tree = append(s.Tree, elem)
				return nil
			}); err != nil {
				return err
			}
		case "base_tree":
			s.BaseTree.Reset()
			if err := s.BaseTree.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitCreateTreeReqTreeItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Path.Set {
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	if s.Mode.Set {
		e.FieldStart("mode")
		s.Mode.Encode(e)
	}
	if s.Type.Set {
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	if s.Sha.Set {
		e.FieldStart("sha")
		s.Sha.Encode(e)
	}
	if s.Content.Set {
		e.FieldStart("content")
		s.Content.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GitCreateTreeReqTreeItem from json.
func (s *GitCreateTreeReqTreeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateTreeReqTreeItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "mode":
			s.Mode.Reset()
			if err := s.Mode.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		case "content":
			s.Content.Reset()
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes GitCreateTreeReqTreeItemMode as json.
func (s GitCreateTreeReqTreeItemMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GitCreateTreeReqTreeItemMode from json.
func (s *GitCreateTreeReqTreeItemMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateTreeReqTreeItemMode to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = GitCreateTreeReqTreeItemMode(v)
	return nil
}

// Encode encodes GitCreateTreeReqTreeItemType as json.
func (s GitCreateTreeReqTreeItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GitCreateTreeReqTreeItemType from json.
func (s *GitCreateTreeReqTreeItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitCreateTreeReqTreeItemType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = GitCreateTreeReqTreeItemType(v)
	return nil
}

// Encode implements json.Marshaler.
func (s GitDeleteRefNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes GitDeleteRefNoContent from json.
func (s *GitDeleteRefNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitDeleteRefNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitRef) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("ref")
	e.Str(s.Ref)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("object")
	s.Object.Encode(e)
	e.ObjEnd()
}

// Decode decodes GitRef from json.
func (s *GitRef) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitRef to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "object":
			if err := s.Object.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitRefObject) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	e.ObjEnd()
}

// Decode decodes GitRefObject from json.
func (s *GitRefObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitRefObject to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitTag) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("tag")
	e.Str(s.Tag)

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("message")
	e.Str(s.Message)

	e.FieldStart("tagger")
	s.Tagger.Encode(e)

	e.FieldStart("object")
	s.Object.Encode(e)
	if s.Verification.Set {
		e.FieldStart("verification")
		s.Verification.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GitTag from json.
func (s *GitTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitTag to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "tag":
			v, err := d.Str()
			s.Tag = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "tagger":
			if err := s.Tagger.Decode(d); err != nil {
				return err
			}
		case "object":
			if err := s.Object.Decode(d); err != nil {
				return err
			}
		case "verification":
			s.Verification.Reset()
			if err := s.Verification.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitTagObject) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	e.ObjEnd()
}

// Decode decodes GitTagObject from json.
func (s *GitTagObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitTagObject to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitTagTagger) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("date")
	e.Str(s.Date)

	e.FieldStart("email")
	e.Str(s.Email)

	e.FieldStart("name")
	e.Str(s.Name)
	e.ObjEnd()
}

// Decode decodes GitTagTagger from json.
func (s *GitTagTagger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitTagTagger to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			v, err := d.Str()
			s.Date = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitTree) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("truncated")
	e.Bool(s.Truncated)

	e.FieldStart("tree")
	e.ArrStart()
	for _, elem := range s.Tree {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes GitTree from json.
func (s *GitTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitTree to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "truncated":
			v, err := d.Bool()
			s.Truncated = bool(v)
			if err != nil {
				return err
			}
		case "tree":
			s.Tree = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem GitTreeTreeItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Tree = append(s.Tree, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitTreeTreeItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Path.Set {
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	if s.Mode.Set {
		e.FieldStart("mode")
		s.Mode.Encode(e)
	}
	if s.Type.Set {
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	if s.Sha.Set {
		e.FieldStart("sha")
		s.Sha.Encode(e)
	}
	if s.Size.Set {
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GitTreeTreeItem from json.
func (s *GitTreeTreeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitTreeTreeItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "mode":
			s.Mode.Reset()
			if err := s.Mode.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		case "size":
			s.Size.Reset()
			if err := s.Size.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GitUpdateRefReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("sha")
	e.Str(s.Sha)
	if s.Force.Set {
		e.FieldStart("force")
		s.Force.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GitUpdateRefReq from json.
func (s *GitUpdateRefReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitUpdateRefReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "force":
			s.Force.Reset()
			if err := s.Force.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes GitignoreGetAllTemplatesOKApplicationJSON as json.
func (s GitignoreGetAllTemplatesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes GitignoreGetAllTemplatesOKApplicationJSON from json.
func (s *GitignoreGetAllTemplatesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitignoreGetAllTemplatesOKApplicationJSON to nil`)
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GitignoreGetAllTemplatesOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s GitignoreTemplate) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("source")
	e.Str(s.Source)
	e.ObjEnd()
}

// Decode decodes GitignoreTemplate from json.
func (s *GitignoreTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GitignoreTemplate to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "source":
			v, err := d.Str()
			s.Source = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GpgKey) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("primary_key_id")
	s.PrimaryKeyID.Encode(e)

	e.FieldStart("key_id")
	e.Str(s.KeyID)

	e.FieldStart("public_key")
	e.Str(s.PublicKey)

	e.FieldStart("emails")
	e.ArrStart()
	for _, elem := range s.Emails {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("subkeys")
	e.ArrStart()
	for _, elem := range s.Subkeys {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("can_sign")
	e.Bool(s.CanSign)

	e.FieldStart("can_encrypt_comms")
	e.Bool(s.CanEncryptComms)

	e.FieldStart("can_encrypt_storage")
	e.Bool(s.CanEncryptStorage)

	e.FieldStart("can_certify")
	e.Bool(s.CanCertify)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("expires_at")
	s.ExpiresAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("raw_key")
	s.RawKey.Encode(e)
	e.ObjEnd()
}

// Decode decodes GpgKey from json.
func (s *GpgKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GpgKey to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "primary_key_id":
			if err := s.PrimaryKeyID.Decode(d); err != nil {
				return err
			}
		case "key_id":
			v, err := d.Str()
			s.KeyID = string(v)
			if err != nil {
				return err
			}
		case "public_key":
			v, err := d.Str()
			s.PublicKey = string(v)
			if err != nil {
				return err
			}
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem GpgKeyEmailsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		case "subkeys":
			s.Subkeys = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem GpgKeySubkeysItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Subkeys = append(s.Subkeys, elem)
				return nil
			}); err != nil {
				return err
			}
		case "can_sign":
			v, err := d.Bool()
			s.CanSign = bool(v)
			if err != nil {
				return err
			}
		case "can_encrypt_comms":
			v, err := d.Bool()
			s.CanEncryptComms = bool(v)
			if err != nil {
				return err
			}
		case "can_encrypt_storage":
			v, err := d.Bool()
			s.CanEncryptStorage = bool(v)
			if err != nil {
				return err
			}
		case "can_certify":
			v, err := d.Bool()
			s.CanCertify = bool(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "expires_at":
			if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "raw_key":
			if err := s.RawKey.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GpgKeyEmailsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	if s.Verified.Set {
		e.FieldStart("verified")
		s.Verified.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GpgKeyEmailsItem from json.
func (s *GpgKeyEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GpgKeyEmailsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "verified":
			s.Verified.Reset()
			if err := s.Verified.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GpgKeySubkeysItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.PrimaryKeyID.Set {
		e.FieldStart("primary_key_id")
		s.PrimaryKeyID.Encode(e)
	}
	if s.KeyID.Set {
		e.FieldStart("key_id")
		s.KeyID.Encode(e)
	}
	if s.PublicKey.Set {
		e.FieldStart("public_key")
		s.PublicKey.Encode(e)
	}
	if s.Emails != nil {
		e.FieldStart("emails")
		e.ArrStart()
		for _, elem := range s.Emails {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Subkeys != nil {
		e.FieldStart("subkeys")
		e.ArrStart()
		for _, elem := range s.Subkeys {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.CanSign.Set {
		e.FieldStart("can_sign")
		s.CanSign.Encode(e)
	}
	if s.CanEncryptComms.Set {
		e.FieldStart("can_encrypt_comms")
		s.CanEncryptComms.Encode(e)
	}
	if s.CanEncryptStorage.Set {
		e.FieldStart("can_encrypt_storage")
		s.CanEncryptStorage.Encode(e)
	}
	if s.CanCertify.Set {
		e.FieldStart("can_certify")
		s.CanCertify.Encode(e)
	}
	if s.CreatedAt.Set {
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e)
	}
	if s.ExpiresAt.Set {
		e.FieldStart("expires_at")
		s.ExpiresAt.Encode(e)
	}
	if s.RawKey.Set {
		e.FieldStart("raw_key")
		s.RawKey.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GpgKeySubkeysItem from json.
func (s *GpgKeySubkeysItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GpgKeySubkeysItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "primary_key_id":
			s.PrimaryKeyID.Reset()
			if err := s.PrimaryKeyID.Decode(d); err != nil {
				return err
			}
		case "key_id":
			s.KeyID.Reset()
			if err := s.KeyID.Decode(d); err != nil {
				return err
			}
		case "public_key":
			s.PublicKey.Reset()
			if err := s.PublicKey.Decode(d); err != nil {
				return err
			}
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		case "subkeys":
			s.Subkeys = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Subkeys = append(s.Subkeys, elem)
				return nil
			}); err != nil {
				return err
			}
		case "can_sign":
			s.CanSign.Reset()
			if err := s.CanSign.Decode(d); err != nil {
				return err
			}
		case "can_encrypt_comms":
			s.CanEncryptComms.Reset()
			if err := s.CanEncryptComms.Decode(d); err != nil {
				return err
			}
		case "can_encrypt_storage":
			s.CanEncryptStorage.Reset()
			if err := s.CanEncryptStorage.Decode(d); err != nil {
				return err
			}
		case "can_certify":
			s.CanCertify.Reset()
			if err := s.CanCertify.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "expires_at":
			s.ExpiresAt.Reset()
			if err := s.ExpiresAt.Decode(d); err != nil {
				return err
			}
		case "raw_key":
			s.RawKey.Reset()
			if err := s.RawKey.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GroupMapping) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Groups != nil {
		e.FieldStart("groups")
		e.ArrStart()
		for _, elem := range s.Groups {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes GroupMapping from json.
func (s *GroupMapping) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GroupMapping to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem GroupMappingGroupsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s GroupMappingGroupsItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("group_id")
	e.Str(s.GroupID)

	e.FieldStart("group_name")
	e.Str(s.GroupName)

	e.FieldStart("group_description")
	e.Str(s.GroupDescription)
	if s.Status.Set {
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	if s.SyncedAt.Set {
		e.FieldStart("synced_at")
		s.SyncedAt.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes GroupMappingGroupsItem from json.
func (s *GroupMappingGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode GroupMappingGroupsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group_id":
			v, err := d.Str()
			s.GroupID = string(v)
			if err != nil {
				return err
			}
		case "group_name":
			v, err := d.Str()
			s.GroupName = string(v)
			if err != nil {
				return err
			}
		case "group_description":
			v, err := d.Str()
			s.GroupDescription = string(v)
			if err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "synced_at":
			s.SyncedAt.Reset()
			if err := s.SyncedAt.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Hook) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("active")
	e.Bool(s.Active)

	e.FieldStart("events")
	e.ArrStart()
	for _, elem := range s.Events {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("config")
	s.Config.Encode(e)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("test_url")
	json.EncodeURI(e, s.TestURL)

	e.FieldStart("ping_url")
	json.EncodeURI(e, s.PingURL)
	if s.DeliveriesURL.Set {
		e.FieldStart("deliveries_url")
		s.DeliveriesURL.Encode(e)
	}

	e.FieldStart("last_response")
	s.LastResponse.Encode(e)
	e.ObjEnd()
}

// Decode decodes Hook from json.
func (s *Hook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Hook to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "active":
			v, err := d.Bool()
			s.Active = bool(v)
			if err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "config":
			if err := s.Config.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "test_url":
			v, err := json.DecodeURI(d)
			s.TestURL = v
			if err != nil {
				return err
			}
		case "ping_url":
			v, err := json.DecodeURI(d)
			s.PingURL = v
			if err != nil {
				return err
			}
		case "deliveries_url":
			s.DeliveriesURL.Reset()
			if err := s.DeliveriesURL.Decode(d); err != nil {
				return err
			}
		case "last_response":
			if err := s.LastResponse.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	if s.Password.Set {
		e.FieldStart("password")
		s.Password.Encode(e)
	}
	if s.Room.Set {
		e.FieldStart("room")
		s.Room.Encode(e)
	}
	if s.Subdomain.Set {
		e.FieldStart("subdomain")
		s.Subdomain.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.InsecureSsl != nil {
		e.FieldStart("insecure_ssl")
		s.InsecureSsl.Encode(e)
	}
	if s.ContentType.Set {
		e.FieldStart("content_type")
		s.ContentType.Encode(e)
	}
	if s.Digest.Set {
		e.FieldStart("digest")
		s.Digest.Encode(e)
	}
	if s.Secret.Set {
		e.FieldStart("secret")
		s.Secret.Encode(e)
	}
	if s.Token.Set {
		e.FieldStart("token")
		s.Token.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes HookConfig from json.
func (s *HookConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookConfig to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "password":
			s.Password.Reset()
			if err := s.Password.Decode(d); err != nil {
				return err
			}
		case "room":
			s.Room.Reset()
			if err := s.Room.Decode(d); err != nil {
				return err
			}
		case "subdomain":
			s.Subdomain.Reset()
			if err := s.Subdomain.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl = nil
			var elem WebhookConfigInsecureSsl
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.InsecureSsl = &elem
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "digest":
			s.Digest.Reset()
			if err := s.Digest.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "token":
			s.Token.Reset()
			if err := s.Token.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookDelivery) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("guid")
	e.Str(s.GUID)

	e.FieldStart("delivered_at")
	json.EncodeDateTime(e, s.DeliveredAt)

	e.FieldStart("redelivery")
	e.Bool(s.Redelivery)

	e.FieldStart("duration")
	e.Float64(s.Duration)

	e.FieldStart("status")
	e.Str(s.Status)

	e.FieldStart("status_code")
	e.Int(s.StatusCode)

	e.FieldStart("event")
	e.Str(s.Event)

	e.FieldStart("action")
	s.Action.Encode(e)

	e.FieldStart("installation_id")
	s.InstallationID.Encode(e)

	e.FieldStart("repository_id")
	s.RepositoryID.Encode(e)
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}

	e.FieldStart("request")
	s.Request.Encode(e)

	e.FieldStart("response")
	s.Response.Encode(e)
	e.ObjEnd()
}

// Decode decodes HookDelivery from json.
func (s *HookDelivery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookDelivery to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "guid":
			v, err := d.Str()
			s.GUID = string(v)
			if err != nil {
				return err
			}
		case "delivered_at":
			v, err := json.DecodeDateTime(d)
			s.DeliveredAt = v
			if err != nil {
				return err
			}
		case "redelivery":
			v, err := d.Bool()
			s.Redelivery = bool(v)
			if err != nil {
				return err
			}
		case "duration":
			v, err := d.Float64()
			s.Duration = float64(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "status_code":
			v, err := d.Int()
			s.StatusCode = int(v)
			if err != nil {
				return err
			}
		case "event":
			v, err := d.Str()
			s.Event = string(v)
			if err != nil {
				return err
			}
		case "action":
			if err := s.Action.Decode(d); err != nil {
				return err
			}
		case "installation_id":
			if err := s.InstallationID.Decode(d); err != nil {
				return err
			}
		case "repository_id":
			if err := s.RepositoryID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "request":
			if err := s.Request.Decode(d); err != nil {
				return err
			}
		case "response":
			if err := s.Response.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookDeliveryItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("guid")
	e.Str(s.GUID)

	e.FieldStart("delivered_at")
	json.EncodeDateTime(e, s.DeliveredAt)

	e.FieldStart("redelivery")
	e.Bool(s.Redelivery)

	e.FieldStart("duration")
	e.Float64(s.Duration)

	e.FieldStart("status")
	e.Str(s.Status)

	e.FieldStart("status_code")
	e.Int(s.StatusCode)

	e.FieldStart("event")
	e.Str(s.Event)

	e.FieldStart("action")
	s.Action.Encode(e)

	e.FieldStart("installation_id")
	s.InstallationID.Encode(e)

	e.FieldStart("repository_id")
	s.RepositoryID.Encode(e)
	e.ObjEnd()
}

// Decode decodes HookDeliveryItem from json.
func (s *HookDeliveryItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookDeliveryItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "guid":
			v, err := d.Str()
			s.GUID = string(v)
			if err != nil {
				return err
			}
		case "delivered_at":
			v, err := json.DecodeDateTime(d)
			s.DeliveredAt = v
			if err != nil {
				return err
			}
		case "redelivery":
			v, err := d.Bool()
			s.Redelivery = bool(v)
			if err != nil {
				return err
			}
		case "duration":
			v, err := d.Float64()
			s.Duration = float64(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "status_code":
			v, err := d.Int()
			s.StatusCode = int(v)
			if err != nil {
				return err
			}
		case "event":
			v, err := d.Str()
			s.Event = string(v)
			if err != nil {
				return err
			}
		case "action":
			if err := s.Action.Decode(d); err != nil {
				return err
			}
		case "installation_id":
			if err := s.InstallationID.Decode(d); err != nil {
				return err
			}
		case "repository_id":
			if err := s.RepositoryID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookDeliveryRequest) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("headers")
	if s.Headers == nil {
		e.Null()
	} else {
		s.Headers.Encode(e)
	}

	e.FieldStart("payload")
	if s.Payload == nil {
		e.Null()
	} else {
		s.Payload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes HookDeliveryRequest from json.
func (s *HookDeliveryRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookDeliveryRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headers":
			s.Headers = nil
			var elem HookDeliveryRequestHeaders
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Headers = &elem
		case "payload":
			s.Payload = nil
			var elem HookDeliveryRequestPayload
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Payload = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookDeliveryRequestHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes HookDeliveryRequestHeaders from json.
func (s *HookDeliveryRequestHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookDeliveryRequestHeaders to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookDeliveryRequestPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes HookDeliveryRequestPayload from json.
func (s *HookDeliveryRequestPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookDeliveryRequestPayload to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookDeliveryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("headers")
	if s.Headers == nil {
		e.Null()
	} else {
		s.Headers.Encode(e)
	}

	e.FieldStart("payload")
	s.Payload.Encode(e)
	e.ObjEnd()
}

// Decode decodes HookDeliveryResponse from json.
func (s *HookDeliveryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookDeliveryResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headers":
			s.Headers = nil
			var elem HookDeliveryResponseHeaders
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.Headers = &elem
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookDeliveryResponseHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes HookDeliveryResponseHeaders from json.
func (s *HookDeliveryResponseHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookDeliveryResponseHeaders to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HookResponse) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("code")
	s.Code.Encode(e)

	e.FieldStart("status")
	s.Status.Encode(e)

	e.FieldStart("message")
	s.Message.Encode(e)
	e.ObjEnd()
}

// Decode decodes HookResponse from json.
func (s *HookResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HookResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := s.Code.Decode(d); err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "message":
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Hovercard) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("contexts")
	e.ArrStart()
	for _, elem := range s.Contexts {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes Hovercard from json.
func (s *Hovercard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Hovercard to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contexts":
			s.Contexts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem HovercardContextsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Contexts = append(s.Contexts, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s HovercardContextsItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("message")
	e.Str(s.Message)

	e.FieldStart("octicon")
	e.Str(s.Octicon)
	e.ObjEnd()
}

// Decode decodes HovercardContextsItem from json.
func (s *HovercardContextsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode HovercardContextsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "octicon":
			v, err := d.Str()
			s.Octicon = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Import) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("vcs")
	s.Vcs.Encode(e)
	if s.UseLfs.Set {
		e.FieldStart("use_lfs")
		s.UseLfs.Encode(e)
	}

	e.FieldStart("vcs_url")
	e.Str(s.VcsURL)
	if s.SvcRoot.Set {
		e.FieldStart("svc_root")
		s.SvcRoot.Encode(e)
	}
	if s.TfvcProject.Set {
		e.FieldStart("tfvc_project")
		s.TfvcProject.Encode(e)
	}

	e.FieldStart("status")
	s.Status.Encode(e)
	if s.StatusText.Set {
		e.FieldStart("status_text")
		s.StatusText.Encode(e)
	}
	if s.FailedStep.Set {
		e.FieldStart("failed_step")
		s.FailedStep.Encode(e)
	}
	if s.ErrorMessage.Set {
		e.FieldStart("error_message")
		s.ErrorMessage.Encode(e)
	}
	if s.ImportPercent.Set {
		e.FieldStart("import_percent")
		s.ImportPercent.Encode(e)
	}
	if s.CommitCount.Set {
		e.FieldStart("commit_count")
		s.CommitCount.Encode(e)
	}
	if s.PushPercent.Set {
		e.FieldStart("push_percent")
		s.PushPercent.Encode(e)
	}
	if s.HasLargeFiles.Set {
		e.FieldStart("has_large_files")
		s.HasLargeFiles.Encode(e)
	}
	if s.LargeFilesSize.Set {
		e.FieldStart("large_files_size")
		s.LargeFilesSize.Encode(e)
	}
	if s.LargeFilesCount.Set {
		e.FieldStart("large_files_count")
		s.LargeFilesCount.Encode(e)
	}
	if s.ProjectChoices != nil {
		e.FieldStart("project_choices")
		e.ArrStart()
		for _, elem := range s.ProjectChoices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.AuthorsCount.Set {
		e.FieldStart("authors_count")
		s.AuthorsCount.Encode(e)
	}

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("authors_url")
	json.EncodeURI(e, s.AuthorsURL)

	e.FieldStart("repository_url")
	json.EncodeURI(e, s.RepositoryURL)
	if s.SvnRoot.Set {
		e.FieldStart("svn_root")
		s.SvnRoot.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Import from json.
func (s *Import) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Import to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcs":
			if err := s.Vcs.Decode(d); err != nil {
				return err
			}
		case "use_lfs":
			s.UseLfs.Reset()
			if err := s.UseLfs.Decode(d); err != nil {
				return err
			}
		case "vcs_url":
			v, err := d.Str()
			s.VcsURL = string(v)
			if err != nil {
				return err
			}
		case "svc_root":
			s.SvcRoot.Reset()
			if err := s.SvcRoot.Decode(d); err != nil {
				return err
			}
		case "tfvc_project":
			s.TfvcProject.Reset()
			if err := s.TfvcProject.Decode(d); err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "status_text":
			s.StatusText.Reset()
			if err := s.StatusText.Decode(d); err != nil {
				return err
			}
		case "failed_step":
			s.FailedStep.Reset()
			if err := s.FailedStep.Decode(d); err != nil {
				return err
			}
		case "error_message":
			s.ErrorMessage.Reset()
			if err := s.ErrorMessage.Decode(d); err != nil {
				return err
			}
		case "import_percent":
			s.ImportPercent.Reset()
			if err := s.ImportPercent.Decode(d); err != nil {
				return err
			}
		case "commit_count":
			s.CommitCount.Reset()
			if err := s.CommitCount.Decode(d); err != nil {
				return err
			}
		case "push_percent":
			s.PushPercent.Reset()
			if err := s.PushPercent.Decode(d); err != nil {
				return err
			}
		case "has_large_files":
			s.HasLargeFiles.Reset()
			if err := s.HasLargeFiles.Decode(d); err != nil {
				return err
			}
		case "large_files_size":
			s.LargeFilesSize.Reset()
			if err := s.LargeFilesSize.Decode(d); err != nil {
				return err
			}
		case "large_files_count":
			s.LargeFilesCount.Reset()
			if err := s.LargeFilesCount.Decode(d); err != nil {
				return err
			}
		case "project_choices":
			s.ProjectChoices = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ImportProjectChoicesItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ProjectChoices = append(s.ProjectChoices, elem)
				return nil
			}); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "authors_count":
			s.AuthorsCount.Reset()
			if err := s.AuthorsCount.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "authors_url":
			v, err := json.DecodeURI(d)
			s.AuthorsURL = v
			if err != nil {
				return err
			}
		case "repository_url":
			v, err := json.DecodeURI(d)
			s.RepositoryURL = v
			if err != nil {
				return err
			}
		case "svn_root":
			s.SvnRoot.Reset()
			if err := s.SvnRoot.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ImportProjectChoicesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Vcs.Set {
		e.FieldStart("vcs")
		s.Vcs.Encode(e)
	}
	if s.TfvcProject.Set {
		e.FieldStart("tfvc_project")
		s.TfvcProject.Encode(e)
	}
	if s.HumanName.Set {
		e.FieldStart("human_name")
		s.HumanName.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ImportProjectChoicesItem from json.
func (s *ImportProjectChoicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ImportProjectChoicesItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcs":
			s.Vcs.Reset()
			if err := s.Vcs.Decode(d); err != nil {
				return err
			}
		case "tfvc_project":
			s.TfvcProject.Reset()
			if err := s.TfvcProject.Decode(d); err != nil {
				return err
			}
		case "human_name":
			s.HumanName.Reset()
			if err := s.HumanName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ImportStatus as json.
func (s ImportStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ImportStatus from json.
func (s *ImportStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ImportStatus to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ImportStatus(v)
	return nil
}

// Encode implements json.Marshaler.
func (s InstallationToken) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("token")
	e.Str(s.Token)

	e.FieldStart("expires_at")
	e.Str(s.ExpiresAt)
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	if s.RepositorySelection.Set {
		e.FieldStart("repository_selection")
		s.RepositorySelection.Encode(e)
	}
	if s.Repositories != nil {
		e.FieldStart("repositories")
		e.ArrStart()
		for _, elem := range s.Repositories {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.SingleFile.Set {
		e.FieldStart("single_file")
		s.SingleFile.Encode(e)
	}
	if s.HasMultipleSingleFiles.Set {
		e.FieldStart("has_multiple_single_files")
		s.HasMultipleSingleFiles.Encode(e)
	}
	if s.SingleFilePaths != nil {
		e.FieldStart("single_file_paths")
		e.ArrStart()
		for _, elem := range s.SingleFilePaths {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes InstallationToken from json.
func (s *InstallationToken) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InstallationToken to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			v, err := d.Str()
			s.Token = string(v)
			if err != nil {
				return err
			}
		case "expires_at":
			v, err := d.Str()
			s.ExpiresAt = string(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "repository_selection":
			s.RepositorySelection.Reset()
			if err := s.RepositorySelection.Decode(d); err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Repository
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "single_file":
			s.SingleFile.Reset()
			if err := s.SingleFile.Decode(d); err != nil {
				return err
			}
		case "has_multiple_single_files":
			s.HasMultipleSingleFiles.Reset()
			if err := s.HasMultipleSingleFiles.Decode(d); err != nil {
				return err
			}
		case "single_file_paths":
			s.SingleFilePaths = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.SingleFilePaths = append(s.SingleFilePaths, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes InstallationTokenRepositorySelection as json.
func (s InstallationTokenRepositorySelection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InstallationTokenRepositorySelection from json.
func (s *InstallationTokenRepositorySelection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InstallationTokenRepositorySelection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = InstallationTokenRepositorySelection(v)
	return nil
}

// Encode implements json.Marshaler.
func (s Integration) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)
	if s.Slug.Set {
		e.FieldStart("slug")
		s.Slug.Encode(e)
	}

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("owner")
	s.Owner.Encode(e)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("external_url")
	json.EncodeURI(e, s.ExternalURL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("permissions")
	s.Permissions.Encode(e)

	e.FieldStart("events")
	e.ArrStart()
	for _, elem := range s.Events {
		e.Str(elem)
	}
	e.ArrEnd()
	if s.InstallationsCount.Set {
		e.FieldStart("installations_count")
		s.InstallationsCount.Encode(e)
	}
	if s.ClientID.Set {
		e.FieldStart("client_id")
		s.ClientID.Encode(e)
	}
	if s.ClientSecret.Set {
		e.FieldStart("client_secret")
		s.ClientSecret.Encode(e)
	}
	if s.WebhookSecret.Set {
		e.FieldStart("webhook_secret")
		s.WebhookSecret.Encode(e)
	}
	if s.Pem.Set {
		e.FieldStart("pem")
		s.Pem.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Integration from json.
func (s *Integration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Integration to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "slug":
			s.Slug.Reset()
			if err := s.Slug.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "external_url":
			v, err := json.DecodeURI(d)
			s.ExternalURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "permissions":
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "installations_count":
			s.InstallationsCount.Reset()
			if err := s.InstallationsCount.Decode(d); err != nil {
				return err
			}
		case "client_id":
			s.ClientID.Reset()
			if err := s.ClientID.Decode(d); err != nil {
				return err
			}
		case "client_secret":
			s.ClientSecret.Reset()
			if err := s.ClientSecret.Decode(d); err != nil {
				return err
			}
		case "webhook_secret":
			s.WebhookSecret.Reset()
			if err := s.WebhookSecret.Decode(d); err != nil {
				return err
			}
		case "pem":
			s.Pem.Reset()
			if err := s.Pem.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IntegrationPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Issues.Set {
		e.FieldStart("issues")
		s.Issues.Encode(e)
	}
	if s.Checks.Set {
		e.FieldStart("checks")
		s.Checks.Encode(e)
	}
	if s.Metadata.Set {
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	if s.Contents.Set {
		e.FieldStart("contents")
		s.Contents.Encode(e)
	}
	if s.Deployments.Set {
		e.FieldStart("deployments")
		s.Deployments.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes IntegrationPermissions from json.
func (s *IntegrationPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IntegrationPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "issues":
			s.Issues.Reset()
			if err := s.Issues.Decode(d); err != nil {
				return err
			}
		case "checks":
			s.Checks.Reset()
			if err := s.Checks.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "contents":
			s.Contents.Reset()
			if err := s.Contents.Decode(d); err != nil {
				return err
			}
		case "deployments":
			s.Deployments.Reset()
			if err := s.Deployments.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes InteractionExpiry as json.
func (s InteractionExpiry) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InteractionExpiry from json.
func (s *InteractionExpiry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionExpiry to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = InteractionExpiry(v)
	return nil
}

// Encode encodes InteractionGroup as json.
func (s InteractionGroup) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InteractionGroup from json.
func (s *InteractionGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionGroup to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = InteractionGroup(v)
	return nil
}

// Encode implements json.Marshaler.
func (s InteractionLimit) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("limit")
	s.Limit.Encode(e)
	if s.Expiry.Set {
		e.FieldStart("expiry")
		s.Expiry.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes InteractionLimit from json.
func (s *InteractionLimit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionLimit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			if err := s.Limit.Decode(d); err != nil {
				return err
			}
		case "expiry":
			s.Expiry.Reset()
			if err := s.Expiry.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InteractionLimitResponse) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("limit")
	s.Limit.Encode(e)

	e.FieldStart("origin")
	e.Str(s.Origin)

	e.FieldStart("expires_at")
	json.EncodeDateTime(e, s.ExpiresAt)
	e.ObjEnd()
}

// Decode decodes InteractionLimitResponse from json.
func (s *InteractionLimitResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionLimitResponse to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			if err := s.Limit.Decode(d); err != nil {
				return err
			}
		case "origin":
			v, err := d.Str()
			s.Origin = string(v)
			if err != nil {
				return err
			}
		case "expires_at":
			v, err := json.DecodeDateTime(d)
			s.ExpiresAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InteractionsRemoveRestrictionsForAuthenticatedUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes InteractionsRemoveRestrictionsForAuthenticatedUserNoContent from json.
func (s *InteractionsRemoveRestrictionsForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionsRemoveRestrictionsForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InteractionsRemoveRestrictionsForOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes InteractionsRemoveRestrictionsForOrgNoContent from json.
func (s *InteractionsRemoveRestrictionsForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionsRemoveRestrictionsForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InteractionsRemoveRestrictionsForRepoConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes InteractionsRemoveRestrictionsForRepoConflict from json.
func (s *InteractionsRemoveRestrictionsForRepoConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionsRemoveRestrictionsForRepoConflict to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InteractionsRemoveRestrictionsForRepoNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes InteractionsRemoveRestrictionsForRepoNoContent from json.
func (s *InteractionsRemoveRestrictionsForRepoNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionsRemoveRestrictionsForRepoNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s InteractionsSetRestrictionsForRepoConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes InteractionsSetRestrictionsForRepoConflict from json.
func (s *InteractionsSetRestrictionsForRepoConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode InteractionsSetRestrictionsForRepoConflict to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueComment) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	if s.BodyText.Set {
		e.FieldStart("body_text")
		s.BodyText.Encode(e)
	}
	if s.BodyHTML.Set {
		e.FieldStart("body_html")
		s.BodyHTML.Encode(e)
	}

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("user")
	s.User.Encode(e)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("issue_url")
	json.EncodeURI(e, s.IssueURL)

	e.FieldStart("author_association")
	s.AuthorAssociation.Encode(e)
	if s.PerformedViaGithubApp.Set {
		e.FieldStart("performed_via_github_app")
		s.PerformedViaGithubApp.Encode(e)
	}
	if s.Reactions.Set {
		e.FieldStart("reactions")
		s.Reactions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes IssueComment from json.
func (s *IssueComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueComment to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "body_text":
			s.BodyText.Reset()
			if err := s.BodyText.Decode(d); err != nil {
				return err
			}
		case "body_html":
			s.BodyHTML.Reset()
			if err := s.BodyHTML.Decode(d); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "issue_url":
			v, err := json.DecodeURI(d)
			s.IssueURL = v
			if err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "performed_via_github_app":
			s.PerformedViaGithubApp.Reset()
			if err := s.PerformedViaGithubApp.Decode(d); err != nil {
				return err
			}
		case "reactions":
			s.Reactions.Reset()
			if err := s.Reactions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueEvent) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("actor")
	s.Actor.Encode(e)

	e.FieldStart("event")
	e.Str(s.Event)

	e.FieldStart("commit_id")
	s.CommitID.Encode(e)

	e.FieldStart("commit_url")
	s.CommitURL.Encode(e)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)
	if s.Issue.Set {
		e.FieldStart("issue")
		s.Issue.Encode(e)
	}
	if s.Label.Set {
		e.FieldStart("label")
		s.Label.Encode(e)
	}
	if s.Assignee.Set {
		e.FieldStart("assignee")
		s.Assignee.Encode(e)
	}
	if s.Assigner.Set {
		e.FieldStart("assigner")
		s.Assigner.Encode(e)
	}
	if s.ReviewRequester.Set {
		e.FieldStart("review_requester")
		s.ReviewRequester.Encode(e)
	}
	if s.RequestedReviewer.Set {
		e.FieldStart("requested_reviewer")
		s.RequestedReviewer.Encode(e)
	}
	if s.RequestedTeam.Set {
		e.FieldStart("requested_team")
		s.RequestedTeam.Encode(e)
	}
	if s.DismissedReview.Set {
		e.FieldStart("dismissed_review")
		s.DismissedReview.Encode(e)
	}
	if s.Milestone.Set {
		e.FieldStart("milestone")
		s.Milestone.Encode(e)
	}
	if s.ProjectCard.Set {
		e.FieldStart("project_card")
		s.ProjectCard.Encode(e)
	}
	if s.Rename.Set {
		e.FieldStart("rename")
		s.Rename.Encode(e)
	}
	if s.AuthorAssociation.Set {
		e.FieldStart("author_association")
		s.AuthorAssociation.Encode(e)
	}
	if s.LockReason.Set {
		e.FieldStart("lock_reason")
		s.LockReason.Encode(e)
	}
	if s.PerformedViaGithubApp.Set {
		e.FieldStart("performed_via_github_app")
		s.PerformedViaGithubApp.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes IssueEvent from json.
func (s *IssueEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueEvent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "actor":
			if err := s.Actor.Decode(d); err != nil {
				return err
			}
		case "event":
			v, err := d.Str()
			s.Event = string(v)
			if err != nil {
				return err
			}
		case "commit_id":
			if err := s.CommitID.Decode(d); err != nil {
				return err
			}
		case "commit_url":
			if err := s.CommitURL.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "issue":
			s.Issue.Reset()
			if err := s.Issue.Decode(d); err != nil {
				return err
			}
		case "label":
			s.Label.Reset()
			if err := s.Label.Decode(d); err != nil {
				return err
			}
		case "assignee":
			s.Assignee.Reset()
			if err := s.Assignee.Decode(d); err != nil {
				return err
			}
		case "assigner":
			s.Assigner.Reset()
			if err := s.Assigner.Decode(d); err != nil {
				return err
			}
		case "review_requester":
			s.ReviewRequester.Reset()
			if err := s.ReviewRequester.Decode(d); err != nil {
				return err
			}
		case "requested_reviewer":
			s.RequestedReviewer.Reset()
			if err := s.RequestedReviewer.Decode(d); err != nil {
				return err
			}
		case "requested_team":
			s.RequestedTeam.Reset()
			if err := s.RequestedTeam.Decode(d); err != nil {
				return err
			}
		case "dismissed_review":
			s.DismissedReview.Reset()
			if err := s.DismissedReview.Decode(d); err != nil {
				return err
			}
		case "milestone":
			s.Milestone.Reset()
			if err := s.Milestone.Decode(d); err != nil {
				return err
			}
		case "project_card":
			s.ProjectCard.Reset()
			if err := s.ProjectCard.Decode(d); err != nil {
				return err
			}
		case "rename":
			s.Rename.Reset()
			if err := s.Rename.Decode(d); err != nil {
				return err
			}
		case "author_association":
			s.AuthorAssociation.Reset()
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "lock_reason":
			s.LockReason.Reset()
			if err := s.LockReason.Decode(d); err != nil {
				return err
			}
		case "performed_via_github_app":
			s.PerformedViaGithubApp.Reset()
			if err := s.PerformedViaGithubApp.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueEventDismissedReview) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("state")
	e.Str(s.State)

	e.FieldStart("review_id")
	e.Int(s.ReviewID)

	e.FieldStart("dismissal_message")
	s.DismissalMessage.Encode(e)
	if s.DismissalCommitID.Set {
		e.FieldStart("dismissal_commit_id")
		s.DismissalCommitID.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes IssueEventDismissedReview from json.
func (s *IssueEventDismissedReview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueEventDismissedReview to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "review_id":
			v, err := d.Int()
			s.ReviewID = int(v)
			if err != nil {
				return err
			}
		case "dismissal_message":
			if err := s.DismissalMessage.Decode(d); err != nil {
				return err
			}
		case "dismissal_commit_id":
			s.DismissalCommitID.Reset()
			if err := s.DismissalCommitID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueEventLabel) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	s.Name.Encode(e)

	e.FieldStart("color")
	s.Color.Encode(e)
	e.ObjEnd()
}

// Decode decodes IssueEventLabel from json.
func (s *IssueEventLabel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueEventLabel to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "color":
			if err := s.Color.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueEventMilestone) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("title")
	e.Str(s.Title)
	e.ObjEnd()
}

// Decode decodes IssueEventMilestone from json.
func (s *IssueEventMilestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueEventMilestone to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueEventProjectCard) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("project_url")
	json.EncodeURI(e, s.ProjectURL)

	e.FieldStart("project_id")
	e.Int(s.ProjectID)

	e.FieldStart("column_name")
	e.Str(s.ColumnName)
	if s.PreviousColumnName.Set {
		e.FieldStart("previous_column_name")
		s.PreviousColumnName.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes IssueEventProjectCard from json.
func (s *IssueEventProjectCard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueEventProjectCard to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "project_url":
			v, err := json.DecodeURI(d)
			s.ProjectURL = v
			if err != nil {
				return err
			}
		case "project_id":
			v, err := d.Int()
			s.ProjectID = int(v)
			if err != nil {
				return err
			}
		case "column_name":
			v, err := d.Str()
			s.ColumnName = string(v)
			if err != nil {
				return err
			}
		case "previous_column_name":
			s.PreviousColumnName.Reset()
			if err := s.PreviousColumnName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueEventRename) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("from")
	e.Str(s.From)

	e.FieldStart("to")
	e.Str(s.To)
	e.ObjEnd()
}

// Decode decodes IssueEventRename from json.
func (s *IssueEventRename) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueEventRename to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			v, err := d.Str()
			s.From = string(v)
			if err != nil {
				return err
			}
		case "to":
			v, err := d.Str()
			s.To = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueSearchResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("repository_url")
	json.EncodeURI(e, s.RepositoryURL)

	e.FieldStart("labels_url")
	e.Str(s.LabelsURL)

	e.FieldStart("comments_url")
	json.EncodeURI(e, s.CommentsURL)

	e.FieldStart("events_url")
	json.EncodeURI(e, s.EventsURL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("number")
	e.Int(s.Number)

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("locked")
	e.Bool(s.Locked)
	if s.ActiveLockReason.Set {
		e.FieldStart("active_lock_reason")
		s.ActiveLockReason.Encode(e)
	}
	if s.Assignees.Set {
		e.FieldStart("assignees")
		s.Assignees.Encode(e)
	}

	e.FieldStart("user")
	s.User.Encode(e)

	e.FieldStart("labels")
	e.ArrStart()
	for _, elem := range s.Labels {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("state")
	e.Str(s.State)

	e.FieldStart("assignee")
	s.Assignee.Encode(e)

	e.FieldStart("milestone")
	s.Milestone.Encode(e)

	e.FieldStart("comments")
	e.Int(s.Comments)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("closed_at")
	s.ClosedAt.Encode(e, json.EncodeDateTime)
	if s.TextMatches != nil {
		e.FieldStart("text_matches")
		s.TextMatches.Encode(e)
	}
	if s.PullRequest.Set {
		e.FieldStart("pull_request")
		s.PullRequest.Encode(e)
	}
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}

	e.FieldStart("score")
	e.Float64(s.Score)

	e.FieldStart("author_association")
	s.AuthorAssociation.Encode(e)
	if s.Draft.Set {
		e.FieldStart("draft")
		s.Draft.Encode(e)
	}
	if s.Repository.Set {
		e.FieldStart("repository")
		s.Repository.Encode(e)
	}
	if s.BodyHTML.Set {
		e.FieldStart("body_html")
		s.BodyHTML.Encode(e)
	}
	if s.BodyText.Set {
		e.FieldStart("body_text")
		s.BodyText.Encode(e)
	}
	if s.TimelineURL.Set {
		e.FieldStart("timeline_url")
		s.TimelineURL.Encode(e)
	}
	if s.PerformedViaGithubApp.Set {
		e.FieldStart("performed_via_github_app")
		s.PerformedViaGithubApp.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes IssueSearchResultItem from json.
func (s *IssueSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueSearchResultItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "repository_url":
			v, err := json.DecodeURI(d)
			s.RepositoryURL = v
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "locked":
			v, err := d.Bool()
			s.Locked = bool(v)
			if err != nil {
				return err
			}
		case "active_lock_reason":
			s.ActiveLockReason.Reset()
			if err := s.ActiveLockReason.Decode(d); err != nil {
				return err
			}
		case "assignees":
			s.Assignees.Reset()
			if err := s.Assignees.Decode(d); err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "labels":
			s.Labels = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IssueSearchResultItemLabelsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Labels = append(s.Labels, elem)
				return nil
			}); err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "assignee":
			if err := s.Assignee.Decode(d); err != nil {
				return err
			}
		case "milestone":
			if err := s.Milestone.Decode(d); err != nil {
				return err
			}
		case "comments":
			v, err := d.Int()
			s.Comments = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "closed_at":
			if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "text_matches":
			s.TextMatches = nil
			var elem SearchResultTextMatches
			{
				var unwrapped []SearchResultTextMatchesItem
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultTextMatchesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = SearchResultTextMatches(unwrapped)
			}
			s.TextMatches = &elem
		case "pull_request":
			s.PullRequest.Reset()
			if err := s.PullRequest.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "score":
			v, err := d.Float64()
			s.Score = float64(v)
			if err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "draft":
			s.Draft.Reset()
			if err := s.Draft.Decode(d); err != nil {
				return err
			}
		case "repository":
			s.Repository.Reset()
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "body_html":
			s.BodyHTML.Reset()
			if err := s.BodyHTML.Decode(d); err != nil {
				return err
			}
		case "body_text":
			s.BodyText.Reset()
			if err := s.BodyText.Decode(d); err != nil {
				return err
			}
		case "timeline_url":
			s.TimelineURL.Reset()
			if err := s.TimelineURL.Decode(d); err != nil {
				return err
			}
		case "performed_via_github_app":
			s.PerformedViaGithubApp.Reset()
			if err := s.PerformedViaGithubApp.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueSearchResultItemLabelsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Color.Set {
		e.FieldStart("color")
		s.Color.Encode(e)
	}
	if s.Default.Set {
		e.FieldStart("default")
		s.Default.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes IssueSearchResultItemLabelsItem from json.
func (s *IssueSearchResultItemLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueSearchResultItemLabelsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "color":
			s.Color.Reset()
			if err := s.Color.Decode(d); err != nil {
				return err
			}
		case "default":
			s.Default.Reset()
			if err := s.Default.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueSearchResultItemPullRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.MergedAt.Set {
		e.FieldStart("merged_at")
		s.MergedAt.Encode(e, json.EncodeDateTime)
	}

	e.FieldStart("diff_url")
	s.DiffURL.Encode(e)

	e.FieldStart("html_url")
	s.HTMLURL.Encode(e)

	e.FieldStart("patch_url")
	s.PatchURL.Encode(e)

	e.FieldStart("url")
	s.URL.Encode(e)
	e.ObjEnd()
}

// Decode decodes IssueSearchResultItemPullRequest from json.
func (s *IssueSearchResultItemPullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueSearchResultItemPullRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "merged_at":
			s.MergedAt.Reset()
			if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "diff_url":
			if err := s.DiffURL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "patch_url":
			if err := s.PatchURL.Decode(d); err != nil {
				return err
			}
		case "url":
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueSimple) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("repository_url")
	json.EncodeURI(e, s.RepositoryURL)

	e.FieldStart("labels_url")
	e.Str(s.LabelsURL)

	e.FieldStart("comments_url")
	json.EncodeURI(e, s.CommentsURL)

	e.FieldStart("events_url")
	json.EncodeURI(e, s.EventsURL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("number")
	e.Int(s.Number)

	e.FieldStart("state")
	e.Str(s.State)

	e.FieldStart("title")
	e.Str(s.Title)
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}

	e.FieldStart("user")
	s.User.Encode(e)

	e.FieldStart("labels")
	e.ArrStart()
	for _, elem := range s.Labels {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("assignee")
	s.Assignee.Encode(e)
	if s.Assignees.Set {
		e.FieldStart("assignees")
		s.Assignees.Encode(e)
	}

	e.FieldStart("milestone")
	s.Milestone.Encode(e)

	e.FieldStart("locked")
	e.Bool(s.Locked)
	if s.ActiveLockReason.Set {
		e.FieldStart("active_lock_reason")
		s.ActiveLockReason.Encode(e)
	}

	e.FieldStart("comments")
	e.Int(s.Comments)
	if s.PullRequest.Set {
		e.FieldStart("pull_request")
		s.PullRequest.Encode(e)
	}

	e.FieldStart("closed_at")
	s.ClosedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("author_association")
	s.AuthorAssociation.Encode(e)
	if s.BodyHTML.Set {
		e.FieldStart("body_html")
		s.BodyHTML.Encode(e)
	}
	if s.BodyText.Set {
		e.FieldStart("body_text")
		s.BodyText.Encode(e)
	}
	if s.TimelineURL.Set {
		e.FieldStart("timeline_url")
		s.TimelineURL.Encode(e)
	}
	if s.Repository.Set {
		e.FieldStart("repository")
		s.Repository.Encode(e)
	}
	if s.PerformedViaGithubApp.Set {
		e.FieldStart("performed_via_github_app")
		s.PerformedViaGithubApp.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes IssueSimple from json.
func (s *IssueSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "repository_url":
			v, err := json.DecodeURI(d)
			s.RepositoryURL = v
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "labels":
			s.Labels = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Label
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Labels = append(s.Labels, elem)
				return nil
			}); err != nil {
				return err
			}
		case "assignee":
			if err := s.Assignee.Decode(d); err != nil {
				return err
			}
		case "assignees":
			s.Assignees.Reset()
			if err := s.Assignees.Decode(d); err != nil {
				return err
			}
		case "milestone":
			if err := s.Milestone.Decode(d); err != nil {
				return err
			}
		case "locked":
			v, err := d.Bool()
			s.Locked = bool(v)
			if err != nil {
				return err
			}
		case "active_lock_reason":
			s.ActiveLockReason.Reset()
			if err := s.ActiveLockReason.Decode(d); err != nil {
				return err
			}
		case "comments":
			v, err := d.Int()
			s.Comments = int(v)
			if err != nil {
				return err
			}
		case "pull_request":
			s.PullRequest.Reset()
			if err := s.PullRequest.Decode(d); err != nil {
				return err
			}
		case "closed_at":
			if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "body_html":
			s.BodyHTML.Reset()
			if err := s.BodyHTML.Decode(d); err != nil {
				return err
			}
		case "body_text":
			s.BodyText.Reset()
			if err := s.BodyText.Decode(d); err != nil {
				return err
			}
		case "timeline_url":
			s.TimelineURL.Reset()
			if err := s.TimelineURL.Decode(d); err != nil {
				return err
			}
		case "repository":
			s.Repository.Reset()
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "performed_via_github_app":
			s.PerformedViaGithubApp.Reset()
			if err := s.PerformedViaGithubApp.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssueSimplePullRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.MergedAt.Set {
		e.FieldStart("merged_at")
		s.MergedAt.Encode(e, json.EncodeDateTime)
	}

	e.FieldStart("diff_url")
	s.DiffURL.Encode(e)

	e.FieldStart("html_url")
	s.HTMLURL.Encode(e)

	e.FieldStart("patch_url")
	s.PatchURL.Encode(e)

	e.FieldStart("url")
	s.URL.Encode(e)
	e.ObjEnd()
}

// Decode decodes IssueSimplePullRequest from json.
func (s *IssueSimplePullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssueSimplePullRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "merged_at":
			s.MergedAt.Reset()
			if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "diff_url":
			if err := s.DiffURL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "patch_url":
			if err := s.PatchURL.Decode(d); err != nil {
				return err
			}
		case "url":
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesAddAssigneesReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Assignees != nil {
		e.FieldStart("assignees")
		e.ArrStart()
		for _, elem := range s.Assignees {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes IssuesAddAssigneesReq from json.
func (s *IssuesAddAssigneesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesAddAssigneesReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assignees":
			s.Assignees = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Assignees = append(s.Assignees, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesCheckUserCanBeAssignedNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes IssuesCheckUserCanBeAssignedNoContent from json.
func (s *IssuesCheckUserCanBeAssignedNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCheckUserCanBeAssignedNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesCreateCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("body")
	e.Str(s.Body)
	e.ObjEnd()
}

// Decode decodes IssuesCreateCommentReq from json.
func (s *IssuesCreateCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesCreateLabelReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)
	if s.Color.Set {
		e.FieldStart("color")
		s.Color.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes IssuesCreateLabelReq from json.
func (s *IssuesCreateLabelReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateLabelReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "color":
			s.Color.Reset()
			if err := s.Color.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesCreateMilestoneReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("title")
	e.Str(s.Title)
	if s.State.Set {
		e.FieldStart("state")
		s.State.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.DueOn.Set {
		e.FieldStart("due_on")
		s.DueOn.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

// Decode decodes IssuesCreateMilestoneReq from json.
func (s *IssuesCreateMilestoneReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateMilestoneReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "due_on":
			s.DueOn.Reset()
			if err := s.DueOn.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssuesCreateMilestoneReqState as json.
func (s IssuesCreateMilestoneReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesCreateMilestoneReqState from json.
func (s *IssuesCreateMilestoneReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesCreateMilestoneReqState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesCreateMilestoneReqState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s IssuesDeleteCommentNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes IssuesDeleteCommentNoContent from json.
func (s *IssuesDeleteCommentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesDeleteCommentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesDeleteLabelNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes IssuesDeleteLabelNoContent from json.
func (s *IssuesDeleteLabelNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesDeleteLabelNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesDeleteMilestoneNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes IssuesDeleteMilestoneNoContent from json.
func (s *IssuesDeleteMilestoneNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesDeleteMilestoneNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssuesGetEventApplicationJSONForbidden as json.
func (s IssuesGetEventApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesGetEventApplicationJSONForbidden from json.
func (s *IssuesGetEventApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesGetEventApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetEventApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes IssuesGetEventApplicationJSONGone as json.
func (s IssuesGetEventApplicationJSONGone) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesGetEventApplicationJSONGone from json.
func (s *IssuesGetEventApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesGetEventApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetEventApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesGetEventApplicationJSONNotFound as json.
func (s IssuesGetEventApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesGetEventApplicationJSONNotFound from json.
func (s *IssuesGetEventApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesGetEventApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesGetEventApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes IssuesListAssigneesOKApplicationJSON as json.
func (s IssuesListAssigneesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes IssuesListAssigneesOKApplicationJSON from json.
func (s *IssuesListAssigneesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListAssigneesOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListAssigneesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListCommentsApplicationJSONGone as json.
func (s IssuesListCommentsApplicationJSONGone) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesListCommentsApplicationJSONGone from json.
func (s *IssuesListCommentsApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListCommentsApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListCommentsApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesListCommentsApplicationJSONNotFound as json.
func (s IssuesListCommentsApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesListCommentsApplicationJSONNotFound from json.
func (s *IssuesListCommentsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListCommentsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListCommentsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes IssuesListCommentsForRepoDirection as json.
func (s IssuesListCommentsForRepoDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListCommentsForRepoDirection from json.
func (s *IssuesListCommentsForRepoDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListCommentsForRepoDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListCommentsForRepoDirection(v)
	return nil
}

// Encode encodes IssuesListCommentsForRepoSort as json.
func (s IssuesListCommentsForRepoSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListCommentsForRepoSort from json.
func (s *IssuesListCommentsForRepoSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListCommentsForRepoSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListCommentsForRepoSort(v)
	return nil
}

// Encode encodes IssuesListCommentsOKApplicationJSON as json.
func (s IssuesListCommentsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []IssueComment(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes IssuesListCommentsOKApplicationJSON from json.
func (s *IssuesListCommentsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListCommentsOKApplicationJSON to nil`)
	}
	var unwrapped []IssueComment
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem IssueComment
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListCommentsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListDirection as json.
func (s IssuesListDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListDirection from json.
func (s *IssuesListDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListDirection(v)
	return nil
}

// Encode encodes IssuesListFilter as json.
func (s IssuesListFilter) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListFilter from json.
func (s *IssuesListFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListFilter to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListFilter(v)
	return nil
}

// Encode encodes IssuesListForAuthenticatedUserDirection as json.
func (s IssuesListForAuthenticatedUserDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListForAuthenticatedUserDirection from json.
func (s *IssuesListForAuthenticatedUserDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForAuthenticatedUserDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListForAuthenticatedUserDirection(v)
	return nil
}

// Encode encodes IssuesListForAuthenticatedUserFilter as json.
func (s IssuesListForAuthenticatedUserFilter) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListForAuthenticatedUserFilter from json.
func (s *IssuesListForAuthenticatedUserFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForAuthenticatedUserFilter to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListForAuthenticatedUserFilter(v)
	return nil
}

// Encode encodes IssuesListForAuthenticatedUserSort as json.
func (s IssuesListForAuthenticatedUserSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListForAuthenticatedUserSort from json.
func (s *IssuesListForAuthenticatedUserSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForAuthenticatedUserSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListForAuthenticatedUserSort(v)
	return nil
}

// Encode encodes IssuesListForAuthenticatedUserState as json.
func (s IssuesListForAuthenticatedUserState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListForAuthenticatedUserState from json.
func (s *IssuesListForAuthenticatedUserState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForAuthenticatedUserState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListForAuthenticatedUserState(v)
	return nil
}

// Encode encodes IssuesListForOrgDirection as json.
func (s IssuesListForOrgDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListForOrgDirection from json.
func (s *IssuesListForOrgDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForOrgDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListForOrgDirection(v)
	return nil
}

// Encode encodes IssuesListForOrgFilter as json.
func (s IssuesListForOrgFilter) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListForOrgFilter from json.
func (s *IssuesListForOrgFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForOrgFilter to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListForOrgFilter(v)
	return nil
}

// Encode encodes IssuesListForOrgSort as json.
func (s IssuesListForOrgSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListForOrgSort from json.
func (s *IssuesListForOrgSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForOrgSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListForOrgSort(v)
	return nil
}

// Encode encodes IssuesListForOrgState as json.
func (s IssuesListForOrgState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListForOrgState from json.
func (s *IssuesListForOrgState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForOrgState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListForOrgState(v)
	return nil
}

// Encode encodes IssuesListForRepoDirection as json.
func (s IssuesListForRepoDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListForRepoDirection from json.
func (s *IssuesListForRepoDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForRepoDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListForRepoDirection(v)
	return nil
}

// Encode encodes IssuesListForRepoSort as json.
func (s IssuesListForRepoSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListForRepoSort from json.
func (s *IssuesListForRepoSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForRepoSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListForRepoSort(v)
	return nil
}

// Encode encodes IssuesListForRepoState as json.
func (s IssuesListForRepoState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListForRepoState from json.
func (s *IssuesListForRepoState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListForRepoState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListForRepoState(v)
	return nil
}

// Encode encodes IssuesListLabelsForRepoOKApplicationJSON as json.
func (s IssuesListLabelsForRepoOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Label(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes IssuesListLabelsForRepoOKApplicationJSON from json.
func (s *IssuesListLabelsForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListLabelsForRepoOKApplicationJSON to nil`)
	}
	var unwrapped []Label
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Label
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListLabelsForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListLabelsOnIssueOKApplicationJSON as json.
func (s IssuesListLabelsOnIssueOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Label(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes IssuesListLabelsOnIssueOKApplicationJSON from json.
func (s *IssuesListLabelsOnIssueOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListLabelsOnIssueOKApplicationJSON to nil`)
	}
	var unwrapped []Label
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Label
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListLabelsOnIssueOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListMilestonesDirection as json.
func (s IssuesListMilestonesDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListMilestonesDirection from json.
func (s *IssuesListMilestonesDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListMilestonesDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListMilestonesDirection(v)
	return nil
}

// Encode encodes IssuesListMilestonesOKApplicationJSON as json.
func (s IssuesListMilestonesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Milestone(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes IssuesListMilestonesOKApplicationJSON from json.
func (s *IssuesListMilestonesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListMilestonesOKApplicationJSON to nil`)
	}
	var unwrapped []Milestone
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Milestone
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesListMilestonesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesListMilestonesSort as json.
func (s IssuesListMilestonesSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListMilestonesSort from json.
func (s *IssuesListMilestonesSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListMilestonesSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListMilestonesSort(v)
	return nil
}

// Encode encodes IssuesListMilestonesState as json.
func (s IssuesListMilestonesState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListMilestonesState from json.
func (s *IssuesListMilestonesState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListMilestonesState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListMilestonesState(v)
	return nil
}

// Encode encodes IssuesListSort as json.
func (s IssuesListSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListSort from json.
func (s *IssuesListSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListSort(v)
	return nil
}

// Encode encodes IssuesListState as json.
func (s IssuesListState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesListState from json.
func (s *IssuesListState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesListState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesListState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s IssuesLockNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes IssuesLockNoContent from json.
func (s *IssuesLockNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesLockNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesLockReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.LockReason.Set {
		e.FieldStart("lock_reason")
		s.LockReason.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes IssuesLockReq from json.
func (s *IssuesLockReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesLockReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lock_reason":
			s.LockReason.Reset()
			if err := s.LockReason.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssuesLockReqLockReason as json.
func (s IssuesLockReqLockReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesLockReqLockReason from json.
func (s *IssuesLockReqLockReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesLockReqLockReason to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesLockReqLockReason(v)
	return nil
}

// Encode implements json.Marshaler.
func (s IssuesRemoveAllLabelsNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes IssuesRemoveAllLabelsNoContent from json.
func (s *IssuesRemoveAllLabelsNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesRemoveAllLabelsNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesRemoveAssigneesReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Assignees != nil {
		e.FieldStart("assignees")
		e.ArrStart()
		for _, elem := range s.Assignees {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes IssuesRemoveAssigneesReq from json.
func (s *IssuesRemoveAssigneesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesRemoveAssigneesReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assignees":
			s.Assignees = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Assignees = append(s.Assignees, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssuesRemoveLabelApplicationJSONGone as json.
func (s IssuesRemoveLabelApplicationJSONGone) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesRemoveLabelApplicationJSONGone from json.
func (s *IssuesRemoveLabelApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesRemoveLabelApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesRemoveLabelApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes IssuesRemoveLabelApplicationJSONNotFound as json.
func (s IssuesRemoveLabelApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesRemoveLabelApplicationJSONNotFound from json.
func (s *IssuesRemoveLabelApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesRemoveLabelApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesRemoveLabelApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes IssuesRemoveLabelOKApplicationJSON as json.
func (s IssuesRemoveLabelOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Label(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes IssuesRemoveLabelOKApplicationJSON from json.
func (s *IssuesRemoveLabelOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesRemoveLabelOKApplicationJSON to nil`)
	}
	var unwrapped []Label
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Label
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesRemoveLabelOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes IssuesUnlockApplicationJSONForbidden as json.
func (s IssuesUnlockApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesUnlockApplicationJSONForbidden from json.
func (s *IssuesUnlockApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUnlockApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUnlockApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes IssuesUnlockApplicationJSONNotFound as json.
func (s IssuesUnlockApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes IssuesUnlockApplicationJSONNotFound from json.
func (s *IssuesUnlockApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUnlockApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IssuesUnlockApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s IssuesUnlockNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes IssuesUnlockNoContent from json.
func (s *IssuesUnlockNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUnlockNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesUpdateCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("body")
	e.Str(s.Body)
	e.ObjEnd()
}

// Decode decodes IssuesUpdateCommentReq from json.
func (s *IssuesUpdateCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesUpdateLabelReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.NewName.Set {
		e.FieldStart("new_name")
		s.NewName.Encode(e)
	}
	if s.Color.Set {
		e.FieldStart("color")
		s.Color.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes IssuesUpdateLabelReq from json.
func (s *IssuesUpdateLabelReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateLabelReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "new_name":
			s.NewName.Reset()
			if err := s.NewName.Decode(d); err != nil {
				return err
			}
		case "color":
			s.Color.Reset()
			if err := s.Color.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s IssuesUpdateMilestoneReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Title.Set {
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	if s.State.Set {
		e.FieldStart("state")
		s.State.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.DueOn.Set {
		e.FieldStart("due_on")
		s.DueOn.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

// Decode decodes IssuesUpdateMilestoneReq from json.
func (s *IssuesUpdateMilestoneReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateMilestoneReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "due_on":
			s.DueOn.Reset()
			if err := s.DueOn.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes IssuesUpdateMilestoneReqState as json.
func (s IssuesUpdateMilestoneReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IssuesUpdateMilestoneReqState from json.
func (s *IssuesUpdateMilestoneReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode IssuesUpdateMilestoneReqState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = IssuesUpdateMilestoneReqState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s Job) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("run_id")
	e.Int(s.RunID)

	e.FieldStart("run_url")
	e.Str(s.RunURL)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("head_sha")
	e.Str(s.HeadSha)

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("html_url")
	s.HTMLURL.Encode(e)

	e.FieldStart("status")
	s.Status.Encode(e)

	e.FieldStart("conclusion")
	s.Conclusion.Encode(e)

	e.FieldStart("started_at")
	json.EncodeDateTime(e, s.StartedAt)

	e.FieldStart("completed_at")
	s.CompletedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("name")
	e.Str(s.Name)
	if s.Steps != nil {
		e.FieldStart("steps")
		e.ArrStart()
		for _, elem := range s.Steps {
			elem.Encode(e)
		}
		e.ArrEnd()
	}

	e.FieldStart("check_run_url")
	e.Str(s.CheckRunURL)
	e.ObjEnd()
}

// Decode decodes Job from json.
func (s *Job) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Job to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "run_id":
			v, err := d.Int()
			s.RunID = int(v)
			if err != nil {
				return err
			}
		case "run_url":
			v, err := d.Str()
			s.RunURL = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "head_sha":
			v, err := d.Str()
			s.HeadSha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "conclusion":
			if err := s.Conclusion.Decode(d); err != nil {
				return err
			}
		case "started_at":
			v, err := json.DecodeDateTime(d)
			s.StartedAt = v
			if err != nil {
				return err
			}
		case "completed_at":
			if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "steps":
			s.Steps = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem JobStepsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Steps = append(s.Steps, elem)
				return nil
			}); err != nil {
				return err
			}
		case "check_run_url":
			v, err := d.Str()
			s.CheckRunURL = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes JobStatus as json.
func (s JobStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes JobStatus from json.
func (s *JobStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode JobStatus to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = JobStatus(v)
	return nil
}

// Encode implements json.Marshaler.
func (s JobStepsItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("status")
	s.Status.Encode(e)

	e.FieldStart("conclusion")
	s.Conclusion.Encode(e)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("number")
	e.Int(s.Number)
	if s.StartedAt.Set {
		e.FieldStart("started_at")
		s.StartedAt.Encode(e, json.EncodeDateTime)
	}
	if s.CompletedAt.Set {
		e.FieldStart("completed_at")
		s.CompletedAt.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

// Decode decodes JobStepsItem from json.
func (s *JobStepsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode JobStepsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "conclusion":
			if err := s.Conclusion.Decode(d); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "started_at":
			s.StartedAt.Reset()
			if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "completed_at":
			s.CompletedAt.Reset()
			if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes JobStepsItemStatus as json.
func (s JobStepsItemStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes JobStepsItemStatus from json.
func (s *JobStepsItemStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode JobStepsItemStatus to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = JobStepsItemStatus(v)
	return nil
}

// Encode implements json.Marshaler.
func (s Key) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("key")
	e.Str(s.Key)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("verified")
	e.Bool(s.Verified)

	e.FieldStart("read_only")
	e.Bool(s.ReadOnly)
	e.ObjEnd()
}

// Decode decodes Key from json.
func (s *Key) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Key to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "verified":
			v, err := d.Bool()
			s.Verified = bool(v)
			if err != nil {
				return err
			}
		case "read_only":
			v, err := d.Bool()
			s.ReadOnly = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s KeySimple) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("key")
	e.Str(s.Key)
	e.ObjEnd()
}

// Decode decodes KeySimple from json.
func (s *KeySimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode KeySimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Label) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int64(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("color")
	e.Str(s.Color)

	e.FieldStart("default")
	e.Bool(s.Default)
	e.ObjEnd()
}

// Decode decodes Label from json.
func (s *Label) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Label to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int64()
			s.ID = int64(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "color":
			v, err := d.Str()
			s.Color = string(v)
			if err != nil {
				return err
			}
		case "default":
			v, err := d.Bool()
			s.Default = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s LabelSearchResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("color")
	e.Str(s.Color)

	e.FieldStart("default")
	e.Bool(s.Default)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("score")
	e.Float64(s.Score)
	if s.TextMatches != nil {
		e.FieldStart("text_matches")
		s.TextMatches.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes LabelSearchResultItem from json.
func (s *LabelSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LabelSearchResultItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "color":
			v, err := d.Str()
			s.Color = string(v)
			if err != nil {
				return err
			}
		case "default":
			v, err := d.Bool()
			s.Default = bool(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "score":
			v, err := d.Float64()
			s.Score = float64(v)
			if err != nil {
				return err
			}
		case "text_matches":
			s.TextMatches = nil
			var elem SearchResultTextMatches
			{
				var unwrapped []SearchResultTextMatchesItem
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultTextMatchesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = SearchResultTextMatches(unwrapped)
			}
			s.TextMatches = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Language) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes Language from json.
func (s *Language) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Language to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s License) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("key")
	e.Str(s.Key)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("spdx_id")
	s.SpdxID.Encode(e)

	e.FieldStart("url")
	s.URL.Encode(e)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("description")
	e.Str(s.Description)

	e.FieldStart("implementation")
	e.Str(s.Implementation)

	e.FieldStart("permissions")
	e.ArrStart()
	for _, elem := range s.Permissions {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("conditions")
	e.ArrStart()
	for _, elem := range s.Conditions {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("limitations")
	e.ArrStart()
	for _, elem := range s.Limitations {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("body")
	e.Str(s.Body)

	e.FieldStart("featured")
	e.Bool(s.Featured)
	e.ObjEnd()
}

// Decode decodes License from json.
func (s *License) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode License to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "spdx_id":
			if err := s.SpdxID.Decode(d); err != nil {
				return err
			}
		case "url":
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "description":
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "implementation":
			v, err := d.Str()
			s.Implementation = string(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Permissions = append(s.Permissions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "conditions":
			s.Conditions = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Conditions = append(s.Conditions, elem)
				return nil
			}); err != nil {
				return err
			}
		case "limitations":
			s.Limitations = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Limitations = append(s.Limitations, elem)
				return nil
			}); err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "featured":
			v, err := d.Bool()
			s.Featured = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s LicenseContent) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("path")
	e.Str(s.Path)

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("size")
	e.Int(s.Size)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	s.HTMLURL.Encode(e)

	e.FieldStart("git_url")
	s.GitURL.Encode(e)

	e.FieldStart("download_url")
	s.DownloadURL.Encode(e)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("content")
	e.Str(s.Content)

	e.FieldStart("encoding")
	e.Str(s.Encoding)

	e.FieldStart("_links")
	s.Links.Encode(e)

	e.FieldStart("license")
	s.License.Encode(e)
	e.ObjEnd()
}

// Decode decodes LicenseContent from json.
func (s *LicenseContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LicenseContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "git_url":
			if err := s.GitURL.Decode(d); err != nil {
				return err
			}
		case "download_url":
			if err := s.DownloadURL.Decode(d); err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "content":
			v, err := d.Str()
			s.Content = string(v)
			if err != nil {
				return err
			}
		case "encoding":
			v, err := d.Str()
			s.Encoding = string(v)
			if err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s LicenseContentLinks) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("git")
	s.Git.Encode(e)

	e.FieldStart("html")
	s.HTML.Encode(e)

	e.FieldStart("self")
	json.EncodeURI(e, s.Self)
	e.ObjEnd()
}

// Decode decodes LicenseContentLinks from json.
func (s *LicenseContentLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LicenseContentLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "git":
			if err := s.Git.Decode(d); err != nil {
				return err
			}
		case "html":
			if err := s.HTML.Decode(d); err != nil {
				return err
			}
		case "self":
			v, err := json.DecodeURI(d)
			s.Self = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s LicenseSimple) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("key")
	e.Str(s.Key)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("url")
	s.URL.Encode(e)

	e.FieldStart("spdx_id")
	s.SpdxID.Encode(e)

	e.FieldStart("node_id")
	e.Str(s.NodeID)
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes LicenseSimple from json.
func (s *LicenseSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LicenseSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "spdx_id":
			if err := s.SpdxID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes LicensesGetAllCommonlyUsedOKApplicationJSON as json.
func (s LicensesGetAllCommonlyUsedOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []LicenseSimple(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes LicensesGetAllCommonlyUsedOKApplicationJSON from json.
func (s *LicensesGetAllCommonlyUsedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LicensesGetAllCommonlyUsedOKApplicationJSON to nil`)
	}
	var unwrapped []LicenseSimple
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LicenseSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LicensesGetAllCommonlyUsedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes LicensesGetApplicationJSONForbidden as json.
func (s LicensesGetApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes LicensesGetApplicationJSONForbidden from json.
func (s *LicensesGetApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LicensesGetApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LicensesGetApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes LicensesGetApplicationJSONNotFound as json.
func (s LicensesGetApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes LicensesGetApplicationJSONNotFound from json.
func (s *LicensesGetApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LicensesGetApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LicensesGetApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s Link) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("href")
	e.Str(s.Href)
	e.ObjEnd()
}

// Decode decodes Link from json.
func (s *Link) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Link to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			v, err := d.Str()
			s.Href = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s LinkWithType) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("href")
	e.Str(s.Href)

	e.FieldStart("type")
	e.Str(s.Type)
	e.ObjEnd()
}

// Decode decodes LinkWithType from json.
func (s *LinkWithType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode LinkWithType to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			v, err := d.Str()
			s.Href = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MarkdownRenderReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("text")
	e.Str(s.Text)
	if s.Mode.Set {
		e.FieldStart("mode")
		s.Mode.Encode(e)
	}
	if s.Context.Set {
		e.FieldStart("context")
		s.Context.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MarkdownRenderReq from json.
func (s *MarkdownRenderReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarkdownRenderReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			v, err := d.Str()
			s.Text = string(v)
			if err != nil {
				return err
			}
		case "mode":
			s.Mode.Reset()
			if err := s.Mode.Decode(d); err != nil {
				return err
			}
		case "context":
			s.Context.Reset()
			if err := s.Context.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MarkdownRenderReqMode as json.
func (s MarkdownRenderReqMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MarkdownRenderReqMode from json.
func (s *MarkdownRenderReqMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarkdownRenderReqMode to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = MarkdownRenderReqMode(v)
	return nil
}

// Encode implements json.Marshaler.
func (s MarketplaceAccount) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("type")
	e.Str(s.Type)
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}

	e.FieldStart("login")
	e.Str(s.Login)
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	if s.OrganizationBillingEmail.Set {
		e.FieldStart("organization_billing_email")
		s.OrganizationBillingEmail.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MarketplaceAccount from json.
func (s *MarketplaceAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarketplaceAccount to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "organization_billing_email":
			s.OrganizationBillingEmail.Reset()
			if err := s.OrganizationBillingEmail.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MarketplaceListingPlan) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("accounts_url")
	json.EncodeURI(e, s.AccountsURL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("number")
	e.Int(s.Number)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("description")
	e.Str(s.Description)

	e.FieldStart("monthly_price_in_cents")
	e.Int(s.MonthlyPriceInCents)

	e.FieldStart("yearly_price_in_cents")
	e.Int(s.YearlyPriceInCents)

	e.FieldStart("price_model")
	e.Str(s.PriceModel)

	e.FieldStart("has_free_trial")
	e.Bool(s.HasFreeTrial)

	e.FieldStart("unit_name")
	s.UnitName.Encode(e)

	e.FieldStart("state")
	e.Str(s.State)

	e.FieldStart("bullets")
	e.ArrStart()
	for _, elem := range s.Bullets {
		e.Str(elem)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes MarketplaceListingPlan from json.
func (s *MarketplaceListingPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarketplaceListingPlan to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "accounts_url":
			v, err := json.DecodeURI(d)
			s.AccountsURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "monthly_price_in_cents":
			v, err := d.Int()
			s.MonthlyPriceInCents = int(v)
			if err != nil {
				return err
			}
		case "yearly_price_in_cents":
			v, err := d.Int()
			s.YearlyPriceInCents = int(v)
			if err != nil {
				return err
			}
		case "price_model":
			v, err := d.Str()
			s.PriceModel = string(v)
			if err != nil {
				return err
			}
		case "has_free_trial":
			v, err := d.Bool()
			s.HasFreeTrial = bool(v)
			if err != nil {
				return err
			}
		case "unit_name":
			if err := s.UnitName.Decode(d); err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "bullets":
			s.Bullets = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Bullets = append(s.Bullets, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MarketplacePurchase) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("login")
	e.Str(s.Login)
	if s.OrganizationBillingEmail.Set {
		e.FieldStart("organization_billing_email")
		s.OrganizationBillingEmail.Encode(e)
	}
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	if s.MarketplacePendingChange.Set {
		e.FieldStart("marketplace_pending_change")
		s.MarketplacePendingChange.Encode(e)
	}

	e.FieldStart("marketplace_purchase")
	s.MarketplacePurchase.Encode(e)
	e.ObjEnd()
}

// Decode decodes MarketplacePurchase from json.
func (s *MarketplacePurchase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarketplacePurchase to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "organization_billing_email":
			s.OrganizationBillingEmail.Reset()
			if err := s.OrganizationBillingEmail.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "marketplace_pending_change":
			s.MarketplacePendingChange.Reset()
			if err := s.MarketplacePendingChange.Decode(d); err != nil {
				return err
			}
		case "marketplace_purchase":
			if err := s.MarketplacePurchase.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MarketplacePurchaseMarketplacePendingChange) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.IsInstalled.Set {
		e.FieldStart("is_installed")
		s.IsInstalled.Encode(e)
	}
	if s.EffectiveDate.Set {
		e.FieldStart("effective_date")
		s.EffectiveDate.Encode(e)
	}
	if s.UnitCount.Set {
		e.FieldStart("unit_count")
		s.UnitCount.Encode(e)
	}
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.Plan.Set {
		e.FieldStart("plan")
		s.Plan.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MarketplacePurchaseMarketplacePendingChange from json.
func (s *MarketplacePurchaseMarketplacePendingChange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarketplacePurchaseMarketplacePendingChange to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_installed":
			s.IsInstalled.Reset()
			if err := s.IsInstalled.Decode(d); err != nil {
				return err
			}
		case "effective_date":
			s.EffectiveDate.Reset()
			if err := s.EffectiveDate.Decode(d); err != nil {
				return err
			}
		case "unit_count":
			s.UnitCount.Reset()
			if err := s.UnitCount.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "plan":
			s.Plan.Reset()
			if err := s.Plan.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MarketplacePurchaseMarketplacePurchase) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.BillingCycle.Set {
		e.FieldStart("billing_cycle")
		s.BillingCycle.Encode(e)
	}
	if s.NextBillingDate.Set {
		e.FieldStart("next_billing_date")
		s.NextBillingDate.Encode(e)
	}
	if s.IsInstalled.Set {
		e.FieldStart("is_installed")
		s.IsInstalled.Encode(e)
	}
	if s.UnitCount.Set {
		e.FieldStart("unit_count")
		s.UnitCount.Encode(e)
	}
	if s.OnFreeTrial.Set {
		e.FieldStart("on_free_trial")
		s.OnFreeTrial.Encode(e)
	}
	if s.FreeTrialEndsOn.Set {
		e.FieldStart("free_trial_ends_on")
		s.FreeTrialEndsOn.Encode(e)
	}
	if s.UpdatedAt.Set {
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e)
	}
	if s.Plan.Set {
		e.FieldStart("plan")
		s.Plan.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MarketplacePurchaseMarketplacePurchase from json.
func (s *MarketplacePurchaseMarketplacePurchase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MarketplacePurchaseMarketplacePurchase to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billing_cycle":
			s.BillingCycle.Reset()
			if err := s.BillingCycle.Decode(d); err != nil {
				return err
			}
		case "next_billing_date":
			s.NextBillingDate.Reset()
			if err := s.NextBillingDate.Decode(d); err != nil {
				return err
			}
		case "is_installed":
			s.IsInstalled.Reset()
			if err := s.IsInstalled.Decode(d); err != nil {
				return err
			}
		case "unit_count":
			s.UnitCount.Reset()
			if err := s.UnitCount.Decode(d); err != nil {
				return err
			}
		case "on_free_trial":
			s.OnFreeTrial.Reset()
			if err := s.OnFreeTrial.Decode(d); err != nil {
				return err
			}
		case "free_trial_ends_on":
			s.FreeTrialEndsOn.Reset()
			if err := s.FreeTrialEndsOn.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d); err != nil {
				return err
			}
		case "plan":
			s.Plan.Reset()
			if err := s.Plan.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MergedUpstream) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.MergeType.Set {
		e.FieldStart("merge_type")
		s.MergeType.Encode(e)
	}
	if s.BaseBranch.Set {
		e.FieldStart("base_branch")
		s.BaseBranch.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MergedUpstream from json.
func (s *MergedUpstream) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MergedUpstream to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "merge_type":
			s.MergeType.Reset()
			if err := s.MergeType.Decode(d); err != nil {
				return err
			}
		case "base_branch":
			s.BaseBranch.Reset()
			if err := s.BaseBranch.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MergedUpstreamMergeType as json.
func (s MergedUpstreamMergeType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MergedUpstreamMergeType from json.
func (s *MergedUpstreamMergeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MergedUpstreamMergeType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = MergedUpstreamMergeType(v)
	return nil
}

// Encode implements json.Marshaler.
func (s MetaRootOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("current_user_url")
	e.Str(s.CurrentUserURL)

	e.FieldStart("current_user_authorizations_html_url")
	e.Str(s.CurrentUserAuthorizationsHTMLURL)

	e.FieldStart("authorizations_url")
	e.Str(s.AuthorizationsURL)

	e.FieldStart("code_search_url")
	e.Str(s.CodeSearchURL)

	e.FieldStart("commit_search_url")
	e.Str(s.CommitSearchURL)

	e.FieldStart("emails_url")
	e.Str(s.EmailsURL)

	e.FieldStart("emojis_url")
	e.Str(s.EmojisURL)

	e.FieldStart("events_url")
	e.Str(s.EventsURL)

	e.FieldStart("feeds_url")
	e.Str(s.FeedsURL)

	e.FieldStart("followers_url")
	e.Str(s.FollowersURL)

	e.FieldStart("following_url")
	e.Str(s.FollowingURL)

	e.FieldStart("gists_url")
	e.Str(s.GistsURL)

	e.FieldStart("hub_url")
	e.Str(s.HubURL)

	e.FieldStart("issue_search_url")
	e.Str(s.IssueSearchURL)

	e.FieldStart("issues_url")
	e.Str(s.IssuesURL)

	e.FieldStart("keys_url")
	e.Str(s.KeysURL)

	e.FieldStart("label_search_url")
	e.Str(s.LabelSearchURL)

	e.FieldStart("notifications_url")
	e.Str(s.NotificationsURL)

	e.FieldStart("organization_url")
	e.Str(s.OrganizationURL)

	e.FieldStart("organization_repositories_url")
	e.Str(s.OrganizationRepositoriesURL)

	e.FieldStart("organization_teams_url")
	e.Str(s.OrganizationTeamsURL)

	e.FieldStart("public_gists_url")
	e.Str(s.PublicGistsURL)

	e.FieldStart("rate_limit_url")
	e.Str(s.RateLimitURL)

	e.FieldStart("repository_url")
	e.Str(s.RepositoryURL)

	e.FieldStart("repository_search_url")
	e.Str(s.RepositorySearchURL)

	e.FieldStart("current_user_repositories_url")
	e.Str(s.CurrentUserRepositoriesURL)

	e.FieldStart("starred_url")
	e.Str(s.StarredURL)

	e.FieldStart("starred_gists_url")
	e.Str(s.StarredGistsURL)
	if s.TopicSearchURL.Set {
		e.FieldStart("topic_search_url")
		s.TopicSearchURL.Encode(e)
	}

	e.FieldStart("user_url")
	e.Str(s.UserURL)

	e.FieldStart("user_organizations_url")
	e.Str(s.UserOrganizationsURL)

	e.FieldStart("user_repositories_url")
	e.Str(s.UserRepositoriesURL)

	e.FieldStart("user_search_url")
	e.Str(s.UserSearchURL)
	e.ObjEnd()
}

// Decode decodes MetaRootOK from json.
func (s *MetaRootOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MetaRootOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current_user_url":
			v, err := d.Str()
			s.CurrentUserURL = string(v)
			if err != nil {
				return err
			}
		case "current_user_authorizations_html_url":
			v, err := d.Str()
			s.CurrentUserAuthorizationsHTMLURL = string(v)
			if err != nil {
				return err
			}
		case "authorizations_url":
			v, err := d.Str()
			s.AuthorizationsURL = string(v)
			if err != nil {
				return err
			}
		case "code_search_url":
			v, err := d.Str()
			s.CodeSearchURL = string(v)
			if err != nil {
				return err
			}
		case "commit_search_url":
			v, err := d.Str()
			s.CommitSearchURL = string(v)
			if err != nil {
				return err
			}
		case "emails_url":
			v, err := d.Str()
			s.EmailsURL = string(v)
			if err != nil {
				return err
			}
		case "emojis_url":
			v, err := d.Str()
			s.EmojisURL = string(v)
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "feeds_url":
			v, err := d.Str()
			s.FeedsURL = string(v)
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := d.Str()
			s.FollowersURL = string(v)
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "hub_url":
			v, err := d.Str()
			s.HubURL = string(v)
			if err != nil {
				return err
			}
		case "issue_search_url":
			v, err := d.Str()
			s.IssueSearchURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "label_search_url":
			v, err := d.Str()
			s.LabelSearchURL = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "organization_url":
			v, err := d.Str()
			s.OrganizationURL = string(v)
			if err != nil {
				return err
			}
		case "organization_repositories_url":
			v, err := d.Str()
			s.OrganizationRepositoriesURL = string(v)
			if err != nil {
				return err
			}
		case "organization_teams_url":
			v, err := d.Str()
			s.OrganizationTeamsURL = string(v)
			if err != nil {
				return err
			}
		case "public_gists_url":
			v, err := d.Str()
			s.PublicGistsURL = string(v)
			if err != nil {
				return err
			}
		case "rate_limit_url":
			v, err := d.Str()
			s.RateLimitURL = string(v)
			if err != nil {
				return err
			}
		case "repository_url":
			v, err := d.Str()
			s.RepositoryURL = string(v)
			if err != nil {
				return err
			}
		case "repository_search_url":
			v, err := d.Str()
			s.RepositorySearchURL = string(v)
			if err != nil {
				return err
			}
		case "current_user_repositories_url":
			v, err := d.Str()
			s.CurrentUserRepositoriesURL = string(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "starred_gists_url":
			v, err := d.Str()
			s.StarredGistsURL = string(v)
			if err != nil {
				return err
			}
		case "topic_search_url":
			s.TopicSearchURL.Reset()
			if err := s.TopicSearchURL.Decode(d); err != nil {
				return err
			}
		case "user_url":
			v, err := d.Str()
			s.UserURL = string(v)
			if err != nil {
				return err
			}
		case "user_organizations_url":
			v, err := d.Str()
			s.UserOrganizationsURL = string(v)
			if err != nil {
				return err
			}
		case "user_repositories_url":
			v, err := d.Str()
			s.UserRepositoriesURL = string(v)
			if err != nil {
				return err
			}
		case "user_search_url":
			v, err := d.Str()
			s.UserSearchURL = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Migration) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("owner")
	s.Owner.Encode(e)

	e.FieldStart("guid")
	e.Str(s.GUID)

	e.FieldStart("state")
	e.Str(s.State)

	e.FieldStart("lock_repositories")
	e.Bool(s.LockRepositories)

	e.FieldStart("exclude_metadata")
	e.Bool(s.ExcludeMetadata)

	e.FieldStart("exclude_git_data")
	e.Bool(s.ExcludeGitData)

	e.FieldStart("exclude_attachments")
	e.Bool(s.ExcludeAttachments)

	e.FieldStart("exclude_releases")
	e.Bool(s.ExcludeReleases)

	e.FieldStart("exclude_owner_projects")
	e.Bool(s.ExcludeOwnerProjects)

	e.FieldStart("repositories")
	e.ArrStart()
	for _, elem := range s.Repositories {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("node_id")
	e.Str(s.NodeID)
	if s.ArchiveURL.Set {
		e.FieldStart("archive_url")
		s.ArchiveURL.Encode(e)
	}
	if s.Exclude != nil {
		e.FieldStart("exclude")
		e.ArrStart()
		for _, elem := range s.Exclude {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes Migration from json.
func (s *Migration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Migration to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "guid":
			v, err := d.Str()
			s.GUID = string(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "lock_repositories":
			v, err := d.Bool()
			s.LockRepositories = bool(v)
			if err != nil {
				return err
			}
		case "exclude_metadata":
			v, err := d.Bool()
			s.ExcludeMetadata = bool(v)
			if err != nil {
				return err
			}
		case "exclude_git_data":
			v, err := d.Bool()
			s.ExcludeGitData = bool(v)
			if err != nil {
				return err
			}
		case "exclude_attachments":
			v, err := d.Bool()
			s.ExcludeAttachments = bool(v)
			if err != nil {
				return err
			}
		case "exclude_releases":
			v, err := d.Bool()
			s.ExcludeReleases = bool(v)
			if err != nil {
				return err
			}
		case "exclude_owner_projects":
			v, err := d.Bool()
			s.ExcludeOwnerProjects = bool(v)
			if err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Repository
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "archive_url":
			s.ArchiveURL.Reset()
			if err := s.ArchiveURL.Decode(d); err != nil {
				return err
			}
		case "exclude":
			s.Exclude = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Exclude = append(s.Exclude, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MigrationsCancelImportNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes MigrationsCancelImportNoContent from json.
func (s *MigrationsCancelImportNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsCancelImportNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound as json.
func (s MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound from json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsDeleteArchiveForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsDeleteArchiveForAuthenticatedUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes MigrationsDeleteArchiveForAuthenticatedUserNoContent from json.
func (s *MigrationsDeleteArchiveForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsDeleteArchiveForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MigrationsDeleteArchiveForOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes MigrationsDeleteArchiveForOrgNoContent from json.
func (s *MigrationsDeleteArchiveForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsDeleteArchiveForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MigrationsDownloadArchiveForOrgFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes MigrationsDownloadArchiveForOrgFound from json.
func (s *MigrationsDownloadArchiveForOrgFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsDownloadArchiveForOrgFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetArchiveForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetArchiveForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsGetArchiveForAuthenticatedUserFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes MigrationsGetArchiveForAuthenticatedUserFound from json.
func (s *MigrationsGetArchiveForAuthenticatedUserFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsGetArchiveForAuthenticatedUserFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MigrationsGetCommitAuthorsOKApplicationJSON as json.
func (s MigrationsGetCommitAuthorsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PorterAuthor(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes MigrationsGetCommitAuthorsOKApplicationJSON from json.
func (s *MigrationsGetCommitAuthorsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsGetCommitAuthorsOKApplicationJSON to nil`)
	}
	var unwrapped []PorterAuthor
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PorterAuthor
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetCommitAuthorsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetStatusForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound as json.
func (s MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound from json.
func (s *MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetStatusForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsGetStatusForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes MigrationsGetStatusForOrgExcludeItem as json.
func (s MigrationsGetStatusForOrgExcludeItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MigrationsGetStatusForOrgExcludeItem from json.
func (s *MigrationsGetStatusForOrgExcludeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsGetStatusForOrgExcludeItem to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = MigrationsGetStatusForOrgExcludeItem(v)
	return nil
}

// Encode encodes MigrationsListForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsListForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsListForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsListForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsListForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsListForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsListForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsListForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsListForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsListForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes MigrationsListForAuthenticatedUserOKApplicationJSON as json.
func (s MigrationsListForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Migration(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes MigrationsListForAuthenticatedUserOKApplicationJSON from json.
func (s *MigrationsListForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsListForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []Migration
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Migration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes MigrationsListForOrgExcludeItem as json.
func (s MigrationsListForOrgExcludeItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MigrationsListForOrgExcludeItem from json.
func (s *MigrationsListForOrgExcludeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsListForOrgExcludeItem to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = MigrationsListForOrgExcludeItem(v)
	return nil
}

// Encode encodes MigrationsListReposForOrgOKApplicationJSON as json.
func (s MigrationsListReposForOrgOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes MigrationsListReposForOrgOKApplicationJSON from json.
func (s *MigrationsListReposForOrgOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsListReposForOrgOKApplicationJSON to nil`)
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListReposForOrgOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes MigrationsListReposForUserOKApplicationJSON as json.
func (s MigrationsListReposForUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes MigrationsListReposForUserOKApplicationJSON from json.
func (s *MigrationsListReposForUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsListReposForUserOKApplicationJSON to nil`)
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsListReposForUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsMapCommitAuthorReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MigrationsMapCommitAuthorReq from json.
func (s *MigrationsMapCommitAuthorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsMapCommitAuthorReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MigrationsSetLfsPreferenceReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("use_lfs")
	s.UseLfs.Encode(e)
	e.ObjEnd()
}

// Decode decodes MigrationsSetLfsPreferenceReq from json.
func (s *MigrationsSetLfsPreferenceReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsSetLfsPreferenceReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "use_lfs":
			if err := s.UseLfs.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MigrationsSetLfsPreferenceReqUseLfs as json.
func (s MigrationsSetLfsPreferenceReqUseLfs) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MigrationsSetLfsPreferenceReqUseLfs from json.
func (s *MigrationsSetLfsPreferenceReqUseLfs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsSetLfsPreferenceReqUseLfs to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = MigrationsSetLfsPreferenceReqUseLfs(v)
	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsStartForAuthenticatedUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.LockRepositories.Set {
		e.FieldStart("lock_repositories")
		s.LockRepositories.Encode(e)
	}
	if s.ExcludeAttachments.Set {
		e.FieldStart("exclude_attachments")
		s.ExcludeAttachments.Encode(e)
	}
	if s.ExcludeReleases.Set {
		e.FieldStart("exclude_releases")
		s.ExcludeReleases.Encode(e)
	}
	if s.ExcludeOwnerProjects.Set {
		e.FieldStart("exclude_owner_projects")
		s.ExcludeOwnerProjects.Encode(e)
	}
	if s.Exclude != nil {
		e.FieldStart("exclude")
		e.ArrStart()
		for _, elem := range s.Exclude {
			elem.Encode(e)
		}
		e.ArrEnd()
	}

	e.FieldStart("repositories")
	e.ArrStart()
	for _, elem := range s.Repositories {
		e.Str(elem)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes MigrationsStartForAuthenticatedUserReq from json.
func (s *MigrationsStartForAuthenticatedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsStartForAuthenticatedUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lock_repositories":
			s.LockRepositories.Reset()
			if err := s.LockRepositories.Decode(d); err != nil {
				return err
			}
		case "exclude_attachments":
			s.ExcludeAttachments.Reset()
			if err := s.ExcludeAttachments.Decode(d); err != nil {
				return err
			}
		case "exclude_releases":
			s.ExcludeReleases.Reset()
			if err := s.ExcludeReleases.Decode(d); err != nil {
				return err
			}
		case "exclude_owner_projects":
			s.ExcludeOwnerProjects.Reset()
			if err := s.ExcludeOwnerProjects.Decode(d); err != nil {
				return err
			}
		case "exclude":
			s.Exclude = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MigrationsStartForAuthenticatedUserReqExcludeItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Exclude = append(s.Exclude, elem)
				return nil
			}); err != nil {
				return err
			}
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MigrationsStartForAuthenticatedUserReqExcludeItem as json.
func (s MigrationsStartForAuthenticatedUserReqExcludeItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MigrationsStartForAuthenticatedUserReqExcludeItem from json.
func (s *MigrationsStartForAuthenticatedUserReqExcludeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsStartForAuthenticatedUserReqExcludeItem to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = MigrationsStartForAuthenticatedUserReqExcludeItem(v)
	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsStartForOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("repositories")
	e.ArrStart()
	for _, elem := range s.Repositories {
		e.Str(elem)
	}
	e.ArrEnd()
	if s.LockRepositories.Set {
		e.FieldStart("lock_repositories")
		s.LockRepositories.Encode(e)
	}
	if s.ExcludeAttachments.Set {
		e.FieldStart("exclude_attachments")
		s.ExcludeAttachments.Encode(e)
	}
	if s.ExcludeReleases.Set {
		e.FieldStart("exclude_releases")
		s.ExcludeReleases.Encode(e)
	}
	if s.ExcludeOwnerProjects.Set {
		e.FieldStart("exclude_owner_projects")
		s.ExcludeOwnerProjects.Encode(e)
	}
	if s.Exclude != nil {
		e.FieldStart("exclude")
		e.ArrStart()
		for _, elem := range s.Exclude {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes MigrationsStartForOrgReq from json.
func (s *MigrationsStartForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsStartForOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "repositories":
			s.Repositories = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Repositories = append(s.Repositories, elem)
				return nil
			}); err != nil {
				return err
			}
		case "lock_repositories":
			s.LockRepositories.Reset()
			if err := s.LockRepositories.Decode(d); err != nil {
				return err
			}
		case "exclude_attachments":
			s.ExcludeAttachments.Reset()
			if err := s.ExcludeAttachments.Decode(d); err != nil {
				return err
			}
		case "exclude_releases":
			s.ExcludeReleases.Reset()
			if err := s.ExcludeReleases.Decode(d); err != nil {
				return err
			}
		case "exclude_owner_projects":
			s.ExcludeOwnerProjects.Reset()
			if err := s.ExcludeOwnerProjects.Decode(d); err != nil {
				return err
			}
		case "exclude":
			s.Exclude = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem MigrationsStartForOrgReqExcludeItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Exclude = append(s.Exclude, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MigrationsStartForOrgReqExcludeItem as json.
func (s MigrationsStartForOrgReqExcludeItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MigrationsStartForOrgReqExcludeItem from json.
func (s *MigrationsStartForOrgReqExcludeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsStartForOrgReqExcludeItem to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = MigrationsStartForOrgReqExcludeItem(v)
	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsStartImportReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("vcs_url")
	e.Str(s.VcsURL)
	if s.Vcs.Set {
		e.FieldStart("vcs")
		s.Vcs.Encode(e)
	}
	if s.VcsUsername.Set {
		e.FieldStart("vcs_username")
		s.VcsUsername.Encode(e)
	}
	if s.VcsPassword.Set {
		e.FieldStart("vcs_password")
		s.VcsPassword.Encode(e)
	}
	if s.TfvcProject.Set {
		e.FieldStart("tfvc_project")
		s.TfvcProject.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MigrationsStartImportReq from json.
func (s *MigrationsStartImportReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsStartImportReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcs_url":
			v, err := d.Str()
			s.VcsURL = string(v)
			if err != nil {
				return err
			}
		case "vcs":
			s.Vcs.Reset()
			if err := s.Vcs.Decode(d); err != nil {
				return err
			}
		case "vcs_username":
			s.VcsUsername.Reset()
			if err := s.VcsUsername.Decode(d); err != nil {
				return err
			}
		case "vcs_password":
			s.VcsPassword.Reset()
			if err := s.VcsPassword.Decode(d); err != nil {
				return err
			}
		case "tfvc_project":
			s.TfvcProject.Reset()
			if err := s.TfvcProject.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MigrationsStartImportReqVcs as json.
func (s MigrationsStartImportReqVcs) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MigrationsStartImportReqVcs from json.
func (s *MigrationsStartImportReqVcs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsStartImportReqVcs to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = MigrationsStartImportReqVcs(v)
	return nil
}

// Encode encodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden as json.
func (s MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden from json.
func (s *MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsUnlockRepoForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound as json.
func (s MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound from json.
func (s *MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsUnlockRepoForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MigrationsUnlockRepoForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s MigrationsUnlockRepoForAuthenticatedUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes MigrationsUnlockRepoForAuthenticatedUserNoContent from json.
func (s *MigrationsUnlockRepoForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsUnlockRepoForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MigrationsUnlockRepoForOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes MigrationsUnlockRepoForOrgNoContent from json.
func (s *MigrationsUnlockRepoForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsUnlockRepoForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MigrationsUpdateImportReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.VcsUsername.Set {
		e.FieldStart("vcs_username")
		s.VcsUsername.Encode(e)
	}
	if s.VcsPassword.Set {
		e.FieldStart("vcs_password")
		s.VcsPassword.Encode(e)
	}
	if s.Vcs.Set {
		e.FieldStart("vcs")
		s.Vcs.Encode(e)
	}
	if s.TfvcProject.Set {
		e.FieldStart("tfvc_project")
		s.TfvcProject.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MigrationsUpdateImportReq from json.
func (s *MigrationsUpdateImportReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MigrationsUpdateImportReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vcs_username":
			s.VcsUsername.Reset()
			if err := s.VcsUsername.Decode(d); err != nil {
				return err
			}
		case "vcs_password":
			s.VcsPassword.Reset()
			if err := s.VcsPassword.Decode(d); err != nil {
				return err
			}
		case "vcs":
			s.Vcs.Reset()
			if err := s.Vcs.Decode(d); err != nil {
				return err
			}
		case "tfvc_project":
			s.TfvcProject.Reset()
			if err := s.TfvcProject.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Milestone) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("labels_url")
	json.EncodeURI(e, s.LabelsURL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("number")
	e.Int(s.Number)

	e.FieldStart("state")
	s.State.Encode(e)

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("creator")
	s.Creator.Encode(e)

	e.FieldStart("open_issues")
	e.Int(s.OpenIssues)

	e.FieldStart("closed_issues")
	e.Int(s.ClosedIssues)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("closed_at")
	s.ClosedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("due_on")
	s.DueOn.Encode(e, json.EncodeDateTime)
	e.ObjEnd()
}

// Decode decodes Milestone from json.
func (s *Milestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Milestone to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := json.DecodeURI(d)
			s.LabelsURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "creator":
			if err := s.Creator.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "closed_issues":
			v, err := d.Int()
			s.ClosedIssues = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "closed_at":
			if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "due_on":
			if err := s.DueOn.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes MilestoneState as json.
func (s MilestoneState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MilestoneState from json.
func (s *MilestoneState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MilestoneState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = MilestoneState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s MinimalRepository) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("full_name")
	e.Str(s.FullName)

	e.FieldStart("owner")
	s.Owner.Encode(e)

	e.FieldStart("private")
	e.Bool(s.Private)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("fork")
	e.Bool(s.Fork)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("archive_url")
	e.Str(s.ArchiveURL)

	e.FieldStart("assignees_url")
	e.Str(s.AssigneesURL)

	e.FieldStart("blobs_url")
	e.Str(s.BlobsURL)

	e.FieldStart("branches_url")
	e.Str(s.BranchesURL)

	e.FieldStart("collaborators_url")
	e.Str(s.CollaboratorsURL)

	e.FieldStart("comments_url")
	e.Str(s.CommentsURL)

	e.FieldStart("commits_url")
	e.Str(s.CommitsURL)

	e.FieldStart("compare_url")
	e.Str(s.CompareURL)

	e.FieldStart("contents_url")
	e.Str(s.ContentsURL)

	e.FieldStart("contributors_url")
	json.EncodeURI(e, s.ContributorsURL)

	e.FieldStart("deployments_url")
	json.EncodeURI(e, s.DeploymentsURL)

	e.FieldStart("downloads_url")
	json.EncodeURI(e, s.DownloadsURL)

	e.FieldStart("events_url")
	json.EncodeURI(e, s.EventsURL)

	e.FieldStart("forks_url")
	json.EncodeURI(e, s.ForksURL)

	e.FieldStart("git_commits_url")
	e.Str(s.GitCommitsURL)

	e.FieldStart("git_refs_url")
	e.Str(s.GitRefsURL)

	e.FieldStart("git_tags_url")
	e.Str(s.GitTagsURL)
	if s.GitURL.Set {
		e.FieldStart("git_url")
		s.GitURL.Encode(e)
	}

	e.FieldStart("issue_comment_url")
	e.Str(s.IssueCommentURL)

	e.FieldStart("issue_events_url")
	e.Str(s.IssueEventsURL)

	e.FieldStart("issues_url")
	e.Str(s.IssuesURL)

	e.FieldStart("keys_url")
	e.Str(s.KeysURL)

	e.FieldStart("labels_url")
	e.Str(s.LabelsURL)

	e.FieldStart("languages_url")
	json.EncodeURI(e, s.LanguagesURL)

	e.FieldStart("merges_url")
	json.EncodeURI(e, s.MergesURL)

	e.FieldStart("milestones_url")
	e.Str(s.MilestonesURL)

	e.FieldStart("notifications_url")
	e.Str(s.NotificationsURL)

	e.FieldStart("pulls_url")
	e.Str(s.PullsURL)

	e.FieldStart("releases_url")
	e.Str(s.ReleasesURL)
	if s.SSHURL.Set {
		e.FieldStart("ssh_url")
		s.SSHURL.Encode(e)
	}

	e.FieldStart("stargazers_url")
	json.EncodeURI(e, s.StargazersURL)

	e.FieldStart("statuses_url")
	e.Str(s.StatusesURL)

	e.FieldStart("subscribers_url")
	json.EncodeURI(e, s.SubscribersURL)

	e.FieldStart("subscription_url")
	json.EncodeURI(e, s.SubscriptionURL)

	e.FieldStart("tags_url")
	json.EncodeURI(e, s.TagsURL)

	e.FieldStart("teams_url")
	json.EncodeURI(e, s.TeamsURL)

	e.FieldStart("trees_url")
	e.Str(s.TreesURL)
	if s.CloneURL.Set {
		e.FieldStart("clone_url")
		s.CloneURL.Encode(e)
	}
	if s.MirrorURL.Set {
		e.FieldStart("mirror_url")
		s.MirrorURL.Encode(e)
	}

	e.FieldStart("hooks_url")
	json.EncodeURI(e, s.HooksURL)
	if s.SvnURL.Set {
		e.FieldStart("svn_url")
		s.SvnURL.Encode(e)
	}
	if s.Homepage.Set {
		e.FieldStart("homepage")
		s.Homepage.Encode(e)
	}
	if s.Language.Set {
		e.FieldStart("language")
		s.Language.Encode(e)
	}
	if s.ForksCount.Set {
		e.FieldStart("forks_count")
		s.ForksCount.Encode(e)
	}
	if s.StargazersCount.Set {
		e.FieldStart("stargazers_count")
		s.StargazersCount.Encode(e)
	}
	if s.WatchersCount.Set {
		e.FieldStart("watchers_count")
		s.WatchersCount.Encode(e)
	}
	if s.Size.Set {
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	if s.DefaultBranch.Set {
		e.FieldStart("default_branch")
		s.DefaultBranch.Encode(e)
	}
	if s.OpenIssuesCount.Set {
		e.FieldStart("open_issues_count")
		s.OpenIssuesCount.Encode(e)
	}
	if s.IsTemplate.Set {
		e.FieldStart("is_template")
		s.IsTemplate.Encode(e)
	}
	if s.Topics != nil {
		e.FieldStart("topics")
		e.ArrStart()
		for _, elem := range s.Topics {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.HasIssues.Set {
		e.FieldStart("has_issues")
		s.HasIssues.Encode(e)
	}
	if s.HasProjects.Set {
		e.FieldStart("has_projects")
		s.HasProjects.Encode(e)
	}
	if s.HasWiki.Set {
		e.FieldStart("has_wiki")
		s.HasWiki.Encode(e)
	}
	if s.HasPages.Set {
		e.FieldStart("has_pages")
		s.HasPages.Encode(e)
	}
	if s.HasDownloads.Set {
		e.FieldStart("has_downloads")
		s.HasDownloads.Encode(e)
	}
	if s.Archived.Set {
		e.FieldStart("archived")
		s.Archived.Encode(e)
	}
	if s.Disabled.Set {
		e.FieldStart("disabled")
		s.Disabled.Encode(e)
	}
	if s.Visibility.Set {
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
	if s.PushedAt.Set {
		e.FieldStart("pushed_at")
		s.PushedAt.Encode(e, json.EncodeDateTime)
	}
	if s.CreatedAt.Set {
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	if s.UpdatedAt.Set {
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	if s.TemplateRepository.Set {
		e.FieldStart("template_repository")
		s.TemplateRepository.Encode(e)
	}
	if s.TempCloneToken.Set {
		e.FieldStart("temp_clone_token")
		s.TempCloneToken.Encode(e)
	}
	if s.DeleteBranchOnMerge.Set {
		e.FieldStart("delete_branch_on_merge")
		s.DeleteBranchOnMerge.Encode(e)
	}
	if s.SubscribersCount.Set {
		e.FieldStart("subscribers_count")
		s.SubscribersCount.Encode(e)
	}
	if s.NetworkCount.Set {
		e.FieldStart("network_count")
		s.NetworkCount.Encode(e)
	}
	if s.CodeOfConduct.Set {
		e.FieldStart("code_of_conduct")
		s.CodeOfConduct.Encode(e)
	}
	if s.License.Set {
		e.FieldStart("license")
		s.License.Encode(e)
	}
	if s.Forks.Set {
		e.FieldStart("forks")
		s.Forks.Encode(e)
	}
	if s.OpenIssues.Set {
		e.FieldStart("open_issues")
		s.OpenIssues.Encode(e)
	}
	if s.Watchers.Set {
		e.FieldStart("watchers")
		s.Watchers.Encode(e)
	}
	if s.AllowForking.Set {
		e.FieldStart("allow_forking")
		s.AllowForking.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MinimalRepository from json.
func (s *MinimalRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MinimalRepository to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "git_url":
			s.GitURL.Reset()
			if err := s.GitURL.Decode(d); err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			s.SSHURL.Reset()
			if err := s.SSHURL.Decode(d); err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "clone_url":
			s.CloneURL.Reset()
			if err := s.CloneURL.Decode(d); err != nil {
				return err
			}
		case "mirror_url":
			s.MirrorURL.Reset()
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "svn_url":
			s.SvnURL.Reset()
			if err := s.SvnURL.Decode(d); err != nil {
				return err
			}
		case "homepage":
			s.Homepage.Reset()
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			s.Language.Reset()
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			s.ForksCount.Reset()
			if err := s.ForksCount.Decode(d); err != nil {
				return err
			}
		case "stargazers_count":
			s.StargazersCount.Reset()
			if err := s.StargazersCount.Decode(d); err != nil {
				return err
			}
		case "watchers_count":
			s.WatchersCount.Reset()
			if err := s.WatchersCount.Decode(d); err != nil {
				return err
			}
		case "size":
			s.Size.Reset()
			if err := s.Size.Decode(d); err != nil {
				return err
			}
		case "default_branch":
			s.DefaultBranch.Reset()
			if err := s.DefaultBranch.Decode(d); err != nil {
				return err
			}
		case "open_issues_count":
			s.OpenIssuesCount.Reset()
			if err := s.OpenIssuesCount.Decode(d); err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "has_issues":
			s.HasIssues.Reset()
			if err := s.HasIssues.Decode(d); err != nil {
				return err
			}
		case "has_projects":
			s.HasProjects.Reset()
			if err := s.HasProjects.Decode(d); err != nil {
				return err
			}
		case "has_wiki":
			s.HasWiki.Reset()
			if err := s.HasWiki.Decode(d); err != nil {
				return err
			}
		case "has_pages":
			s.HasPages.Reset()
			if err := s.HasPages.Decode(d); err != nil {
				return err
			}
		case "has_downloads":
			s.HasDownloads.Reset()
			if err := s.HasDownloads.Decode(d); err != nil {
				return err
			}
		case "archived":
			s.Archived.Reset()
			if err := s.Archived.Decode(d); err != nil {
				return err
			}
		case "disabled":
			s.Disabled.Reset()
			if err := s.Disabled.Decode(d); err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			s.PushedAt.Reset()
			if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "template_repository":
			s.TemplateRepository.Reset()
			if err := s.TemplateRepository.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "subscribers_count":
			s.SubscribersCount.Reset()
			if err := s.SubscribersCount.Decode(d); err != nil {
				return err
			}
		case "network_count":
			s.NetworkCount.Reset()
			if err := s.NetworkCount.Decode(d); err != nil {
				return err
			}
		case "code_of_conduct":
			s.CodeOfConduct.Reset()
			if err := s.CodeOfConduct.Decode(d); err != nil {
				return err
			}
		case "license":
			s.License.Reset()
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "forks":
			s.Forks.Reset()
			if err := s.Forks.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			s.OpenIssues.Reset()
			if err := s.OpenIssues.Decode(d); err != nil {
				return err
			}
		case "watchers":
			s.Watchers.Reset()
			if err := s.Watchers.Decode(d); err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MinimalRepositoryLicense) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Key.Set {
		e.FieldStart("key")
		s.Key.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.SpdxID.Set {
		e.FieldStart("spdx_id")
		s.SpdxID.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MinimalRepositoryLicense from json.
func (s *MinimalRepositoryLicense) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MinimalRepositoryLicense to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			s.Key.Reset()
			if err := s.Key.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "spdx_id":
			s.SpdxID.Reset()
			if err := s.SpdxID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s MinimalRepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Admin.Set {
		e.FieldStart("admin")
		s.Admin.Encode(e)
	}
	if s.Maintain.Set {
		e.FieldStart("maintain")
		s.Maintain.Encode(e)
	}
	if s.Push.Set {
		e.FieldStart("push")
		s.Push.Encode(e)
	}
	if s.Triage.Set {
		e.FieldStart("triage")
		s.Triage.Encode(e)
	}
	if s.Pull.Set {
		e.FieldStart("pull")
		s.Pull.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes MinimalRepositoryPermissions from json.
func (s *MinimalRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode MinimalRepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			s.Admin.Reset()
			if err := s.Admin.Decode(d); err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "push":
			s.Push.Reset()
			if err := s.Push.Decode(d); err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "pull":
			s.Pull.Reset()
			if err := s.Pull.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes AutoMerge as json.
func (o NilAutoMerge) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AutoMerge from json.
func (o *NilAutoMerge) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilAutoMerge to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v AutoMerge
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilAutoMerge`, d.Next())
	}
}

// Encode encodes bool as json.
func (o NilBool) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *NilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilBool to nil`)
	}
	switch d.Next() {
	case jx.Bool:
		o.Null = false
		v, err := d.Bool()
		if err != nil {
			return err
		}
		o.Value = bool(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v bool
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilBool`, d.Next())
	}
}

// Encode encodes CheckRunCheckSuite as json.
func (o NilCheckRunCheckSuite) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CheckRunCheckSuite from json.
func (o *NilCheckRunCheckSuite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilCheckRunCheckSuite to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CheckRunCheckSuite
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilCheckRunCheckSuite`, d.Next())
	}
}

// Encode encodes CheckRunConclusion as json.
func (o NilCheckRunConclusion) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CheckRunConclusion from json.
func (o *NilCheckRunConclusion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilCheckRunConclusion to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = CheckRunConclusion(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CheckRunConclusion
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilCheckRunConclusion`, d.Next())
	}
}

// Encode encodes CheckSuiteConclusion as json.
func (o NilCheckSuiteConclusion) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CheckSuiteConclusion from json.
func (o *NilCheckSuiteConclusion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilCheckSuiteConclusion to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = CheckSuiteConclusion(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CheckSuiteConclusion
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilCheckSuiteConclusion`, d.Next())
	}
}

// Encode encodes CheckSuiteStatus as json.
func (o NilCheckSuiteStatus) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CheckSuiteStatus from json.
func (o *NilCheckSuiteStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilCheckSuiteStatus to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = CheckSuiteStatus(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CheckSuiteStatus
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilCheckSuiteStatus`, d.Next())
	}
}

// Encode encodes CodeScanningAlertDismissedAt as json.
func (o NilCodeScanningAlertDismissedAt) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes CodeScanningAlertDismissedAt from json.
func (o *NilCodeScanningAlertDismissedAt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilCodeScanningAlertDismissedAt to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertDismissedAt
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilCodeScanningAlertDismissedAt`, d.Next())
	}
}

// Encode encodes CodeScanningAlertDismissedReason as json.
func (o NilCodeScanningAlertDismissedReason) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertDismissedReason from json.
func (o *NilCodeScanningAlertDismissedReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilCodeScanningAlertDismissedReason to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = CodeScanningAlertDismissedReason(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertDismissedReason
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilCodeScanningAlertDismissedReason`, d.Next())
	}
}

// Encode encodes FileCommitContent as json.
func (o NilFileCommitContent) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileCommitContent from json.
func (o *NilFileCommitContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilFileCommitContent to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v FileCommitContent
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilFileCommitContent`, d.Next())
	}
}

// Encode encodes int as json.
func (o NilInt) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *NilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilInt to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Null = false
		v, err := d.Int()
		if err != nil {
			return err
		}
		o.Value = int(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v int
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilInt`, d.Next())
	}
}

// Encode encodes NullableCodeOfConductSimple as json.
func (o NilNullableCodeOfConductSimple) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableCodeOfConductSimple from json.
func (o *NilNullableCodeOfConductSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableCodeOfConductSimple to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableCodeOfConductSimple
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableCodeOfConductSimple`, d.Next())
	}
}

// Encode encodes NullableCommunityHealthFile as json.
func (o NilNullableCommunityHealthFile) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableCommunityHealthFile from json.
func (o *NilNullableCommunityHealthFile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableCommunityHealthFile to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableCommunityHealthFile
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableCommunityHealthFile`, d.Next())
	}
}

// Encode encodes NullableGitUser as json.
func (o NilNullableGitUser) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableGitUser from json.
func (o *NilNullableGitUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableGitUser to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableGitUser
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableGitUser`, d.Next())
	}
}

// Encode encodes NullableIntegration as json.
func (o NilNullableIntegration) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableIntegration from json.
func (o *NilNullableIntegration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableIntegration to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableIntegration
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableIntegration`, d.Next())
	}
}

// Encode encodes NullableLicenseSimple as json.
func (o NilNullableLicenseSimple) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableLicenseSimple from json.
func (o *NilNullableLicenseSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableLicenseSimple to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableLicenseSimple
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableLicenseSimple`, d.Next())
	}
}

// Encode encodes NullableMilestone as json.
func (o NilNullableMilestone) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableMilestone from json.
func (o *NilNullableMilestone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableMilestone to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableMilestone
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableMilestone`, d.Next())
	}
}

// Encode encodes NullableSimpleCommit as json.
func (o NilNullableSimpleCommit) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleCommit from json.
func (o *NilNullableSimpleCommit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableSimpleCommit to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableSimpleCommit
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableSimpleCommit`, d.Next())
	}
}

// Encode encodes NullableSimpleCommitAuthor as json.
func (o NilNullableSimpleCommitAuthor) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleCommitAuthor from json.
func (o *NilNullableSimpleCommitAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableSimpleCommitAuthor to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableSimpleCommitAuthor
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableSimpleCommitAuthor`, d.Next())
	}
}

// Encode encodes NullableSimpleCommitCommitter as json.
func (o NilNullableSimpleCommitCommitter) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleCommitCommitter from json.
func (o *NilNullableSimpleCommitCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableSimpleCommitCommitter to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableSimpleCommitCommitter
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableSimpleCommitCommitter`, d.Next())
	}
}

// Encode encodes NullableSimpleUser as json.
func (o NilNullableSimpleUser) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleUser from json.
func (o *NilNullableSimpleUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableSimpleUser to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableSimpleUser
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableSimpleUser`, d.Next())
	}
}

// Encode encodes NullableTeamSimple as json.
func (o NilNullableTeamSimple) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableTeamSimple from json.
func (o *NilNullableTeamSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilNullableTeamSimple to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableTeamSimple
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilNullableTeamSimple`, d.Next())
	}
}

// Encode encodes PageStatus as json.
func (o NilPageStatus) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PageStatus from json.
func (o *NilPageStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilPageStatus to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PageStatus(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PageStatus
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilPageStatus`, d.Next())
	}
}

// Encode encodes PullRequestHeadRepo as json.
func (o NilPullRequestHeadRepo) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullRequestHeadRepo from json.
func (o *NilPullRequestHeadRepo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilPullRequestHeadRepo to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PullRequestHeadRepo
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilPullRequestHeadRepo`, d.Next())
	}
}

// Encode encodes PullRequestHeadRepoLicense as json.
func (o NilPullRequestHeadRepoLicense) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PullRequestHeadRepoLicense from json.
func (o *NilPullRequestHeadRepoLicense) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilPullRequestHeadRepoLicense to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PullRequestHeadRepoLicense
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilPullRequestHeadRepoLicense`, d.Next())
	}
}

// Encode encodes ReposUpdateBranchProtectionReqRequiredPullRequestReviews as json.
func (o NilReposUpdateBranchProtectionReqRequiredPullRequestReviews) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredPullRequestReviews from json.
func (o *NilReposUpdateBranchProtectionReqRequiredPullRequestReviews) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilReposUpdateBranchProtectionReqRequiredPullRequestReviews to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v ReposUpdateBranchProtectionReqRequiredPullRequestReviews
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilReposUpdateBranchProtectionReqRequiredPullRequestReviews`, d.Next())
	}
}

// Encode encodes ReposUpdateBranchProtectionReqRequiredStatusChecks as json.
func (o NilReposUpdateBranchProtectionReqRequiredStatusChecks) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredStatusChecks from json.
func (o *NilReposUpdateBranchProtectionReqRequiredStatusChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilReposUpdateBranchProtectionReqRequiredStatusChecks to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v ReposUpdateBranchProtectionReqRequiredStatusChecks
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilReposUpdateBranchProtectionReqRequiredStatusChecks`, d.Next())
	}
}

// Encode encodes ReposUpdateBranchProtectionReqRestrictions as json.
func (o NilReposUpdateBranchProtectionReqRestrictions) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionReqRestrictions from json.
func (o *NilReposUpdateBranchProtectionReqRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilReposUpdateBranchProtectionReqRestrictions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v ReposUpdateBranchProtectionReqRestrictions
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilReposUpdateBranchProtectionReqRestrictions`, d.Next())
	}
}

// Encode encodes SimpleCommitAuthor as json.
func (o NilSimpleCommitAuthor) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SimpleCommitAuthor from json.
func (o *NilSimpleCommitAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilSimpleCommitAuthor to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v SimpleCommitAuthor
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilSimpleCommitAuthor`, d.Next())
	}
}

// Encode encodes SimpleCommitCommitter as json.
func (o NilSimpleCommitCommitter) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SimpleCommitCommitter from json.
func (o *NilSimpleCommitCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilSimpleCommitCommitter to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v SimpleCommitCommitter
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilSimpleCommitCommitter`, d.Next())
	}
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilString to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v string
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilString`, d.Next())
	}
}

// Encode encodes time.Time as json.
func (o NilTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *NilTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilTime to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		v, err := format(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v time.Time
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilTime`, d.Next())
	}
}

// Encode encodes url.URL as json.
func (o NilURL) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *NilURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode NilURL to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Null = false
		v, err := json.DecodeURI(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v url.URL
		o.Value = v
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading NilURL`, d.Next())
	}
}

// Encode implements json.Marshaler.
func (s NoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes NoContent from json.
func (s *NoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NotModified) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes NotModified from json.
func (s *NotModified) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NotModified to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableCodeOfConductSimple) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("key")
	e.Str(s.Key)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("html_url")
	s.HTMLURL.Encode(e)
	e.ObjEnd()
}

// Decode decodes NullableCodeOfConductSimple from json.
func (s *NullableCodeOfConductSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableCodeOfConductSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableCommunityHealthFile) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)
	e.ObjEnd()
}

// Decode decodes NullableCommunityHealthFile from json.
func (s *NullableCommunityHealthFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableCommunityHealthFile to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableGitUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	if s.Date.Set {
		e.FieldStart("date")
		s.Date.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableGitUser from json.
func (s *NullableGitUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableGitUser to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "date":
			s.Date.Reset()
			if err := s.Date.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableIntegration) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)
	if s.Slug.Set {
		e.FieldStart("slug")
		s.Slug.Encode(e)
	}

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("owner")
	s.Owner.Encode(e)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("external_url")
	json.EncodeURI(e, s.ExternalURL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("permissions")
	s.Permissions.Encode(e)

	e.FieldStart("events")
	e.ArrStart()
	for _, elem := range s.Events {
		e.Str(elem)
	}
	e.ArrEnd()
	if s.InstallationsCount.Set {
		e.FieldStart("installations_count")
		s.InstallationsCount.Encode(e)
	}
	if s.ClientID.Set {
		e.FieldStart("client_id")
		s.ClientID.Encode(e)
	}
	if s.ClientSecret.Set {
		e.FieldStart("client_secret")
		s.ClientSecret.Encode(e)
	}
	if s.WebhookSecret.Set {
		e.FieldStart("webhook_secret")
		s.WebhookSecret.Encode(e)
	}
	if s.Pem.Set {
		e.FieldStart("pem")
		s.Pem.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableIntegration from json.
func (s *NullableIntegration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableIntegration to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "slug":
			s.Slug.Reset()
			if err := s.Slug.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "external_url":
			v, err := json.DecodeURI(d)
			s.ExternalURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "permissions":
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "installations_count":
			s.InstallationsCount.Reset()
			if err := s.InstallationsCount.Decode(d); err != nil {
				return err
			}
		case "client_id":
			s.ClientID.Reset()
			if err := s.ClientID.Decode(d); err != nil {
				return err
			}
		case "client_secret":
			s.ClientSecret.Reset()
			if err := s.ClientSecret.Decode(d); err != nil {
				return err
			}
		case "webhook_secret":
			s.WebhookSecret.Reset()
			if err := s.WebhookSecret.Decode(d); err != nil {
				return err
			}
		case "pem":
			s.Pem.Reset()
			if err := s.Pem.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableIntegrationPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Issues.Set {
		e.FieldStart("issues")
		s.Issues.Encode(e)
	}
	if s.Checks.Set {
		e.FieldStart("checks")
		s.Checks.Encode(e)
	}
	if s.Metadata.Set {
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	if s.Contents.Set {
		e.FieldStart("contents")
		s.Contents.Encode(e)
	}
	if s.Deployments.Set {
		e.FieldStart("deployments")
		s.Deployments.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableIntegrationPermissions from json.
func (s *NullableIntegrationPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableIntegrationPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "issues":
			s.Issues.Reset()
			if err := s.Issues.Decode(d); err != nil {
				return err
			}
		case "checks":
			s.Checks.Reset()
			if err := s.Checks.Decode(d); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		case "contents":
			s.Contents.Reset()
			if err := s.Contents.Decode(d); err != nil {
				return err
			}
		case "deployments":
			s.Deployments.Reset()
			if err := s.Deployments.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableLicenseSimple) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("key")
	e.Str(s.Key)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("url")
	s.URL.Encode(e)

	e.FieldStart("spdx_id")
	s.SpdxID.Encode(e)

	e.FieldStart("node_id")
	e.Str(s.NodeID)
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableLicenseSimple from json.
func (s *NullableLicenseSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableLicenseSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "spdx_id":
			if err := s.SpdxID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableMilestone) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("labels_url")
	json.EncodeURI(e, s.LabelsURL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("number")
	e.Int(s.Number)

	e.FieldStart("state")
	s.State.Encode(e)

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("creator")
	s.Creator.Encode(e)

	e.FieldStart("open_issues")
	e.Int(s.OpenIssues)

	e.FieldStart("closed_issues")
	e.Int(s.ClosedIssues)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("closed_at")
	s.ClosedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("due_on")
	s.DueOn.Encode(e, json.EncodeDateTime)
	e.ObjEnd()
}

// Decode decodes NullableMilestone from json.
func (s *NullableMilestone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableMilestone to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := json.DecodeURI(d)
			s.LabelsURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "creator":
			if err := s.Creator.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "closed_issues":
			v, err := d.Int()
			s.ClosedIssues = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "closed_at":
			if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "due_on":
			if err := s.DueOn.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes NullableMilestoneState as json.
func (s NullableMilestoneState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NullableMilestoneState from json.
func (s *NullableMilestoneState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableMilestoneState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = NullableMilestoneState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s NullableMinimalRepository) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("full_name")
	e.Str(s.FullName)

	e.FieldStart("owner")
	s.Owner.Encode(e)

	e.FieldStart("private")
	e.Bool(s.Private)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("fork")
	e.Bool(s.Fork)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("archive_url")
	e.Str(s.ArchiveURL)

	e.FieldStart("assignees_url")
	e.Str(s.AssigneesURL)

	e.FieldStart("blobs_url")
	e.Str(s.BlobsURL)

	e.FieldStart("branches_url")
	e.Str(s.BranchesURL)

	e.FieldStart("collaborators_url")
	e.Str(s.CollaboratorsURL)

	e.FieldStart("comments_url")
	e.Str(s.CommentsURL)

	e.FieldStart("commits_url")
	e.Str(s.CommitsURL)

	e.FieldStart("compare_url")
	e.Str(s.CompareURL)

	e.FieldStart("contents_url")
	e.Str(s.ContentsURL)

	e.FieldStart("contributors_url")
	json.EncodeURI(e, s.ContributorsURL)

	e.FieldStart("deployments_url")
	json.EncodeURI(e, s.DeploymentsURL)

	e.FieldStart("downloads_url")
	json.EncodeURI(e, s.DownloadsURL)

	e.FieldStart("events_url")
	json.EncodeURI(e, s.EventsURL)

	e.FieldStart("forks_url")
	json.EncodeURI(e, s.ForksURL)

	e.FieldStart("git_commits_url")
	e.Str(s.GitCommitsURL)

	e.FieldStart("git_refs_url")
	e.Str(s.GitRefsURL)

	e.FieldStart("git_tags_url")
	e.Str(s.GitTagsURL)
	if s.GitURL.Set {
		e.FieldStart("git_url")
		s.GitURL.Encode(e)
	}

	e.FieldStart("issue_comment_url")
	e.Str(s.IssueCommentURL)

	e.FieldStart("issue_events_url")
	e.Str(s.IssueEventsURL)

	e.FieldStart("issues_url")
	e.Str(s.IssuesURL)

	e.FieldStart("keys_url")
	e.Str(s.KeysURL)

	e.FieldStart("labels_url")
	e.Str(s.LabelsURL)

	e.FieldStart("languages_url")
	json.EncodeURI(e, s.LanguagesURL)

	e.FieldStart("merges_url")
	json.EncodeURI(e, s.MergesURL)

	e.FieldStart("milestones_url")
	e.Str(s.MilestonesURL)

	e.FieldStart("notifications_url")
	e.Str(s.NotificationsURL)

	e.FieldStart("pulls_url")
	e.Str(s.PullsURL)

	e.FieldStart("releases_url")
	e.Str(s.ReleasesURL)
	if s.SSHURL.Set {
		e.FieldStart("ssh_url")
		s.SSHURL.Encode(e)
	}

	e.FieldStart("stargazers_url")
	json.EncodeURI(e, s.StargazersURL)

	e.FieldStart("statuses_url")
	e.Str(s.StatusesURL)

	e.FieldStart("subscribers_url")
	json.EncodeURI(e, s.SubscribersURL)

	e.FieldStart("subscription_url")
	json.EncodeURI(e, s.SubscriptionURL)

	e.FieldStart("tags_url")
	json.EncodeURI(e, s.TagsURL)

	e.FieldStart("teams_url")
	json.EncodeURI(e, s.TeamsURL)

	e.FieldStart("trees_url")
	e.Str(s.TreesURL)
	if s.CloneURL.Set {
		e.FieldStart("clone_url")
		s.CloneURL.Encode(e)
	}
	if s.MirrorURL.Set {
		e.FieldStart("mirror_url")
		s.MirrorURL.Encode(e)
	}

	e.FieldStart("hooks_url")
	json.EncodeURI(e, s.HooksURL)
	if s.SvnURL.Set {
		e.FieldStart("svn_url")
		s.SvnURL.Encode(e)
	}
	if s.Homepage.Set {
		e.FieldStart("homepage")
		s.Homepage.Encode(e)
	}
	if s.Language.Set {
		e.FieldStart("language")
		s.Language.Encode(e)
	}
	if s.ForksCount.Set {
		e.FieldStart("forks_count")
		s.ForksCount.Encode(e)
	}
	if s.StargazersCount.Set {
		e.FieldStart("stargazers_count")
		s.StargazersCount.Encode(e)
	}
	if s.WatchersCount.Set {
		e.FieldStart("watchers_count")
		s.WatchersCount.Encode(e)
	}
	if s.Size.Set {
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	if s.DefaultBranch.Set {
		e.FieldStart("default_branch")
		s.DefaultBranch.Encode(e)
	}
	if s.OpenIssuesCount.Set {
		e.FieldStart("open_issues_count")
		s.OpenIssuesCount.Encode(e)
	}
	if s.IsTemplate.Set {
		e.FieldStart("is_template")
		s.IsTemplate.Encode(e)
	}
	if s.Topics != nil {
		e.FieldStart("topics")
		e.ArrStart()
		for _, elem := range s.Topics {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.HasIssues.Set {
		e.FieldStart("has_issues")
		s.HasIssues.Encode(e)
	}
	if s.HasProjects.Set {
		e.FieldStart("has_projects")
		s.HasProjects.Encode(e)
	}
	if s.HasWiki.Set {
		e.FieldStart("has_wiki")
		s.HasWiki.Encode(e)
	}
	if s.HasPages.Set {
		e.FieldStart("has_pages")
		s.HasPages.Encode(e)
	}
	if s.HasDownloads.Set {
		e.FieldStart("has_downloads")
		s.HasDownloads.Encode(e)
	}
	if s.Archived.Set {
		e.FieldStart("archived")
		s.Archived.Encode(e)
	}
	if s.Disabled.Set {
		e.FieldStart("disabled")
		s.Disabled.Encode(e)
	}
	if s.Visibility.Set {
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
	if s.PushedAt.Set {
		e.FieldStart("pushed_at")
		s.PushedAt.Encode(e, json.EncodeDateTime)
	}
	if s.CreatedAt.Set {
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	if s.UpdatedAt.Set {
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	if s.TemplateRepository.Set {
		e.FieldStart("template_repository")
		s.TemplateRepository.Encode(e)
	}
	if s.TempCloneToken.Set {
		e.FieldStart("temp_clone_token")
		s.TempCloneToken.Encode(e)
	}
	if s.DeleteBranchOnMerge.Set {
		e.FieldStart("delete_branch_on_merge")
		s.DeleteBranchOnMerge.Encode(e)
	}
	if s.SubscribersCount.Set {
		e.FieldStart("subscribers_count")
		s.SubscribersCount.Encode(e)
	}
	if s.NetworkCount.Set {
		e.FieldStart("network_count")
		s.NetworkCount.Encode(e)
	}
	if s.CodeOfConduct.Set {
		e.FieldStart("code_of_conduct")
		s.CodeOfConduct.Encode(e)
	}
	if s.License.Set {
		e.FieldStart("license")
		s.License.Encode(e)
	}
	if s.Forks.Set {
		e.FieldStart("forks")
		s.Forks.Encode(e)
	}
	if s.OpenIssues.Set {
		e.FieldStart("open_issues")
		s.OpenIssues.Encode(e)
	}
	if s.Watchers.Set {
		e.FieldStart("watchers")
		s.Watchers.Encode(e)
	}
	if s.AllowForking.Set {
		e.FieldStart("allow_forking")
		s.AllowForking.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableMinimalRepository from json.
func (s *NullableMinimalRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableMinimalRepository to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "git_url":
			s.GitURL.Reset()
			if err := s.GitURL.Decode(d); err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			s.SSHURL.Reset()
			if err := s.SSHURL.Decode(d); err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "clone_url":
			s.CloneURL.Reset()
			if err := s.CloneURL.Decode(d); err != nil {
				return err
			}
		case "mirror_url":
			s.MirrorURL.Reset()
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "svn_url":
			s.SvnURL.Reset()
			if err := s.SvnURL.Decode(d); err != nil {
				return err
			}
		case "homepage":
			s.Homepage.Reset()
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			s.Language.Reset()
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			s.ForksCount.Reset()
			if err := s.ForksCount.Decode(d); err != nil {
				return err
			}
		case "stargazers_count":
			s.StargazersCount.Reset()
			if err := s.StargazersCount.Decode(d); err != nil {
				return err
			}
		case "watchers_count":
			s.WatchersCount.Reset()
			if err := s.WatchersCount.Decode(d); err != nil {
				return err
			}
		case "size":
			s.Size.Reset()
			if err := s.Size.Decode(d); err != nil {
				return err
			}
		case "default_branch":
			s.DefaultBranch.Reset()
			if err := s.DefaultBranch.Decode(d); err != nil {
				return err
			}
		case "open_issues_count":
			s.OpenIssuesCount.Reset()
			if err := s.OpenIssuesCount.Decode(d); err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "has_issues":
			s.HasIssues.Reset()
			if err := s.HasIssues.Decode(d); err != nil {
				return err
			}
		case "has_projects":
			s.HasProjects.Reset()
			if err := s.HasProjects.Decode(d); err != nil {
				return err
			}
		case "has_wiki":
			s.HasWiki.Reset()
			if err := s.HasWiki.Decode(d); err != nil {
				return err
			}
		case "has_pages":
			s.HasPages.Reset()
			if err := s.HasPages.Decode(d); err != nil {
				return err
			}
		case "has_downloads":
			s.HasDownloads.Reset()
			if err := s.HasDownloads.Decode(d); err != nil {
				return err
			}
		case "archived":
			s.Archived.Reset()
			if err := s.Archived.Decode(d); err != nil {
				return err
			}
		case "disabled":
			s.Disabled.Reset()
			if err := s.Disabled.Decode(d); err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			s.PushedAt.Reset()
			if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "template_repository":
			s.TemplateRepository.Reset()
			if err := s.TemplateRepository.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "subscribers_count":
			s.SubscribersCount.Reset()
			if err := s.SubscribersCount.Decode(d); err != nil {
				return err
			}
		case "network_count":
			s.NetworkCount.Reset()
			if err := s.NetworkCount.Decode(d); err != nil {
				return err
			}
		case "code_of_conduct":
			s.CodeOfConduct.Reset()
			if err := s.CodeOfConduct.Decode(d); err != nil {
				return err
			}
		case "license":
			s.License.Reset()
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "forks":
			s.Forks.Reset()
			if err := s.Forks.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			s.OpenIssues.Reset()
			if err := s.OpenIssues.Decode(d); err != nil {
				return err
			}
		case "watchers":
			s.Watchers.Reset()
			if err := s.Watchers.Decode(d); err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableMinimalRepositoryLicense) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Key.Set {
		e.FieldStart("key")
		s.Key.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.SpdxID.Set {
		e.FieldStart("spdx_id")
		s.SpdxID.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableMinimalRepositoryLicense from json.
func (s *NullableMinimalRepositoryLicense) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableMinimalRepositoryLicense to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			s.Key.Reset()
			if err := s.Key.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "spdx_id":
			s.SpdxID.Reset()
			if err := s.SpdxID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableMinimalRepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Admin.Set {
		e.FieldStart("admin")
		s.Admin.Encode(e)
	}
	if s.Maintain.Set {
		e.FieldStart("maintain")
		s.Maintain.Encode(e)
	}
	if s.Push.Set {
		e.FieldStart("push")
		s.Push.Encode(e)
	}
	if s.Triage.Set {
		e.FieldStart("triage")
		s.Triage.Encode(e)
	}
	if s.Pull.Set {
		e.FieldStart("pull")
		s.Pull.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableMinimalRepositoryPermissions from json.
func (s *NullableMinimalRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableMinimalRepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			s.Admin.Reset()
			if err := s.Admin.Decode(d); err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "push":
			s.Push.Reset()
			if err := s.Push.Decode(d); err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "pull":
			s.Pull.Reset()
			if err := s.Pull.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableRepository) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("full_name")
	e.Str(s.FullName)

	e.FieldStart("license")
	s.License.Encode(e)
	if s.Organization.Set {
		e.FieldStart("organization")
		s.Organization.Encode(e)
	}

	e.FieldStart("forks")
	e.Int(s.Forks)
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}

	e.FieldStart("owner")
	s.Owner.Encode(e)

	e.FieldStart("private")
	e.Bool(s.Private)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("fork")
	e.Bool(s.Fork)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("archive_url")
	e.Str(s.ArchiveURL)

	e.FieldStart("assignees_url")
	e.Str(s.AssigneesURL)

	e.FieldStart("blobs_url")
	e.Str(s.BlobsURL)

	e.FieldStart("branches_url")
	e.Str(s.BranchesURL)

	e.FieldStart("collaborators_url")
	e.Str(s.CollaboratorsURL)

	e.FieldStart("comments_url")
	e.Str(s.CommentsURL)

	e.FieldStart("commits_url")
	e.Str(s.CommitsURL)

	e.FieldStart("compare_url")
	e.Str(s.CompareURL)

	e.FieldStart("contents_url")
	e.Str(s.ContentsURL)

	e.FieldStart("contributors_url")
	json.EncodeURI(e, s.ContributorsURL)

	e.FieldStart("deployments_url")
	json.EncodeURI(e, s.DeploymentsURL)

	e.FieldStart("downloads_url")
	json.EncodeURI(e, s.DownloadsURL)

	e.FieldStart("events_url")
	json.EncodeURI(e, s.EventsURL)

	e.FieldStart("forks_url")
	json.EncodeURI(e, s.ForksURL)

	e.FieldStart("git_commits_url")
	e.Str(s.GitCommitsURL)

	e.FieldStart("git_refs_url")
	e.Str(s.GitRefsURL)

	e.FieldStart("git_tags_url")
	e.Str(s.GitTagsURL)

	e.FieldStart("git_url")
	e.Str(s.GitURL)

	e.FieldStart("issue_comment_url")
	e.Str(s.IssueCommentURL)

	e.FieldStart("issue_events_url")
	e.Str(s.IssueEventsURL)

	e.FieldStart("issues_url")
	e.Str(s.IssuesURL)

	e.FieldStart("keys_url")
	e.Str(s.KeysURL)

	e.FieldStart("labels_url")
	e.Str(s.LabelsURL)

	e.FieldStart("languages_url")
	json.EncodeURI(e, s.LanguagesURL)

	e.FieldStart("merges_url")
	json.EncodeURI(e, s.MergesURL)

	e.FieldStart("milestones_url")
	e.Str(s.MilestonesURL)

	e.FieldStart("notifications_url")
	e.Str(s.NotificationsURL)

	e.FieldStart("pulls_url")
	e.Str(s.PullsURL)

	e.FieldStart("releases_url")
	e.Str(s.ReleasesURL)

	e.FieldStart("ssh_url")
	e.Str(s.SSHURL)

	e.FieldStart("stargazers_url")
	json.EncodeURI(e, s.StargazersURL)

	e.FieldStart("statuses_url")
	e.Str(s.StatusesURL)

	e.FieldStart("subscribers_url")
	json.EncodeURI(e, s.SubscribersURL)

	e.FieldStart("subscription_url")
	json.EncodeURI(e, s.SubscriptionURL)

	e.FieldStart("tags_url")
	json.EncodeURI(e, s.TagsURL)

	e.FieldStart("teams_url")
	json.EncodeURI(e, s.TeamsURL)

	e.FieldStart("trees_url")
	e.Str(s.TreesURL)

	e.FieldStart("clone_url")
	e.Str(s.CloneURL)

	e.FieldStart("mirror_url")
	s.MirrorURL.Encode(e)

	e.FieldStart("hooks_url")
	json.EncodeURI(e, s.HooksURL)

	e.FieldStart("svn_url")
	json.EncodeURI(e, s.SvnURL)

	e.FieldStart("homepage")
	s.Homepage.Encode(e)

	e.FieldStart("language")
	s.Language.Encode(e)

	e.FieldStart("forks_count")
	e.Int(s.ForksCount)

	e.FieldStart("stargazers_count")
	e.Int(s.StargazersCount)

	e.FieldStart("watchers_count")
	e.Int(s.WatchersCount)

	e.FieldStart("size")
	e.Int(s.Size)

	e.FieldStart("default_branch")
	e.Str(s.DefaultBranch)

	e.FieldStart("open_issues_count")
	e.Int(s.OpenIssuesCount)
	if s.IsTemplate.Set {
		e.FieldStart("is_template")
		s.IsTemplate.Encode(e)
	}
	if s.Topics != nil {
		e.FieldStart("topics")
		e.ArrStart()
		for _, elem := range s.Topics {
			e.Str(elem)
		}
		e.ArrEnd()
	}

	e.FieldStart("has_issues")
	e.Bool(s.HasIssues)

	e.FieldStart("has_projects")
	e.Bool(s.HasProjects)

	e.FieldStart("has_wiki")
	e.Bool(s.HasWiki)

	e.FieldStart("has_pages")
	e.Bool(s.HasPages)

	e.FieldStart("has_downloads")
	e.Bool(s.HasDownloads)

	e.FieldStart("archived")
	e.Bool(s.Archived)

	e.FieldStart("disabled")
	e.Bool(s.Disabled)
	if s.Visibility.Set {
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}

	e.FieldStart("pushed_at")
	s.PushedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("created_at")
	s.CreatedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("updated_at")
	s.UpdatedAt.Encode(e, json.EncodeDateTime)
	if s.AllowRebaseMerge.Set {
		e.FieldStart("allow_rebase_merge")
		s.AllowRebaseMerge.Encode(e)
	}
	if s.TemplateRepository.Set {
		e.FieldStart("template_repository")
		s.TemplateRepository.Encode(e)
	}
	if s.TempCloneToken.Set {
		e.FieldStart("temp_clone_token")
		s.TempCloneToken.Encode(e)
	}
	if s.AllowSquashMerge.Set {
		e.FieldStart("allow_squash_merge")
		s.AllowSquashMerge.Encode(e)
	}
	if s.AllowAutoMerge.Set {
		e.FieldStart("allow_auto_merge")
		s.AllowAutoMerge.Encode(e)
	}
	if s.DeleteBranchOnMerge.Set {
		e.FieldStart("delete_branch_on_merge")
		s.DeleteBranchOnMerge.Encode(e)
	}
	if s.AllowMergeCommit.Set {
		e.FieldStart("allow_merge_commit")
		s.AllowMergeCommit.Encode(e)
	}
	if s.AllowForking.Set {
		e.FieldStart("allow_forking")
		s.AllowForking.Encode(e)
	}
	if s.SubscribersCount.Set {
		e.FieldStart("subscribers_count")
		s.SubscribersCount.Encode(e)
	}
	if s.NetworkCount.Set {
		e.FieldStart("network_count")
		s.NetworkCount.Encode(e)
	}

	e.FieldStart("open_issues")
	e.Int(s.OpenIssues)

	e.FieldStart("watchers")
	e.Int(s.Watchers)
	if s.MasterBranch.Set {
		e.FieldStart("master_branch")
		s.MasterBranch.Encode(e)
	}
	if s.StarredAt.Set {
		e.FieldStart("starred_at")
		s.StarredAt.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableRepository from json.
func (s *NullableRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableRepository to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "organization":
			s.Organization.Reset()
			if err := s.Organization.Decode(d); err != nil {
				return err
			}
		case "forks":
			v, err := d.Int()
			s.Forks = int(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "git_url":
			v, err := d.Str()
			s.GitURL = string(v)
			if err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			v, err := d.Str()
			s.SSHURL = string(v)
			if err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "clone_url":
			v, err := d.Str()
			s.CloneURL = string(v)
			if err != nil {
				return err
			}
		case "mirror_url":
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "svn_url":
			v, err := json.DecodeURI(d)
			s.SvnURL = v
			if err != nil {
				return err
			}
		case "homepage":
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			v, err := d.Int()
			s.ForksCount = int(v)
			if err != nil {
				return err
			}
		case "stargazers_count":
			v, err := d.Int()
			s.StargazersCount = int(v)
			if err != nil {
				return err
			}
		case "watchers_count":
			v, err := d.Int()
			s.WatchersCount = int(v)
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "default_branch":
			v, err := d.Str()
			s.DefaultBranch = string(v)
			if err != nil {
				return err
			}
		case "open_issues_count":
			v, err := d.Int()
			s.OpenIssuesCount = int(v)
			if err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "has_issues":
			v, err := d.Bool()
			s.HasIssues = bool(v)
			if err != nil {
				return err
			}
		case "has_projects":
			v, err := d.Bool()
			s.HasProjects = bool(v)
			if err != nil {
				return err
			}
		case "has_wiki":
			v, err := d.Bool()
			s.HasWiki = bool(v)
			if err != nil {
				return err
			}
		case "has_pages":
			v, err := d.Bool()
			s.HasPages = bool(v)
			if err != nil {
				return err
			}
		case "has_downloads":
			v, err := d.Bool()
			s.HasDownloads = bool(v)
			if err != nil {
				return err
			}
		case "archived":
			v, err := d.Bool()
			s.Archived = bool(v)
			if err != nil {
				return err
			}
		case "disabled":
			v, err := d.Bool()
			s.Disabled = bool(v)
			if err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "created_at":
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "template_repository":
			s.TemplateRepository.Reset()
			if err := s.TemplateRepository.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		case "subscribers_count":
			s.SubscribersCount.Reset()
			if err := s.SubscribersCount.Decode(d); err != nil {
				return err
			}
		case "network_count":
			s.NetworkCount.Reset()
			if err := s.NetworkCount.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "watchers":
			v, err := d.Int()
			s.Watchers = int(v)
			if err != nil {
				return err
			}
		case "master_branch":
			s.MasterBranch.Reset()
			if err := s.MasterBranch.Decode(d); err != nil {
				return err
			}
		case "starred_at":
			s.StarredAt.Reset()
			if err := s.StarredAt.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableRepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("admin")
	e.Bool(s.Admin)

	e.FieldStart("pull")
	e.Bool(s.Pull)
	if s.Triage.Set {
		e.FieldStart("triage")
		s.Triage.Encode(e)
	}

	e.FieldStart("push")
	e.Bool(s.Push)
	if s.Maintain.Set {
		e.FieldStart("maintain")
		s.Maintain.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableRepositoryPermissions from json.
func (s *NullableRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableRepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableRepositoryTemplateRepository) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.FullName.Set {
		e.FieldStart("full_name")
		s.FullName.Encode(e)
	}
	if s.Owner.Set {
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	if s.Private.Set {
		e.FieldStart("private")
		s.Private.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.Fork.Set {
		e.FieldStart("fork")
		s.Fork.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.ArchiveURL.Set {
		e.FieldStart("archive_url")
		s.ArchiveURL.Encode(e)
	}
	if s.AssigneesURL.Set {
		e.FieldStart("assignees_url")
		s.AssigneesURL.Encode(e)
	}
	if s.BlobsURL.Set {
		e.FieldStart("blobs_url")
		s.BlobsURL.Encode(e)
	}
	if s.BranchesURL.Set {
		e.FieldStart("branches_url")
		s.BranchesURL.Encode(e)
	}
	if s.CollaboratorsURL.Set {
		e.FieldStart("collaborators_url")
		s.CollaboratorsURL.Encode(e)
	}
	if s.CommentsURL.Set {
		e.FieldStart("comments_url")
		s.CommentsURL.Encode(e)
	}
	if s.CommitsURL.Set {
		e.FieldStart("commits_url")
		s.CommitsURL.Encode(e)
	}
	if s.CompareURL.Set {
		e.FieldStart("compare_url")
		s.CompareURL.Encode(e)
	}
	if s.ContentsURL.Set {
		e.FieldStart("contents_url")
		s.ContentsURL.Encode(e)
	}
	if s.ContributorsURL.Set {
		e.FieldStart("contributors_url")
		s.ContributorsURL.Encode(e)
	}
	if s.DeploymentsURL.Set {
		e.FieldStart("deployments_url")
		s.DeploymentsURL.Encode(e)
	}
	if s.DownloadsURL.Set {
		e.FieldStart("downloads_url")
		s.DownloadsURL.Encode(e)
	}
	if s.EventsURL.Set {
		e.FieldStart("events_url")
		s.EventsURL.Encode(e)
	}
	if s.ForksURL.Set {
		e.FieldStart("forks_url")
		s.ForksURL.Encode(e)
	}
	if s.GitCommitsURL.Set {
		e.FieldStart("git_commits_url")
		s.GitCommitsURL.Encode(e)
	}
	if s.GitRefsURL.Set {
		e.FieldStart("git_refs_url")
		s.GitRefsURL.Encode(e)
	}
	if s.GitTagsURL.Set {
		e.FieldStart("git_tags_url")
		s.GitTagsURL.Encode(e)
	}
	if s.GitURL.Set {
		e.FieldStart("git_url")
		s.GitURL.Encode(e)
	}
	if s.IssueCommentURL.Set {
		e.FieldStart("issue_comment_url")
		s.IssueCommentURL.Encode(e)
	}
	if s.IssueEventsURL.Set {
		e.FieldStart("issue_events_url")
		s.IssueEventsURL.Encode(e)
	}
	if s.IssuesURL.Set {
		e.FieldStart("issues_url")
		s.IssuesURL.Encode(e)
	}
	if s.KeysURL.Set {
		e.FieldStart("keys_url")
		s.KeysURL.Encode(e)
	}
	if s.LabelsURL.Set {
		e.FieldStart("labels_url")
		s.LabelsURL.Encode(e)
	}
	if s.LanguagesURL.Set {
		e.FieldStart("languages_url")
		s.LanguagesURL.Encode(e)
	}
	if s.MergesURL.Set {
		e.FieldStart("merges_url")
		s.MergesURL.Encode(e)
	}
	if s.MilestonesURL.Set {
		e.FieldStart("milestones_url")
		s.MilestonesURL.Encode(e)
	}
	if s.NotificationsURL.Set {
		e.FieldStart("notifications_url")
		s.NotificationsURL.Encode(e)
	}
	if s.PullsURL.Set {
		e.FieldStart("pulls_url")
		s.PullsURL.Encode(e)
	}
	if s.ReleasesURL.Set {
		e.FieldStart("releases_url")
		s.ReleasesURL.Encode(e)
	}
	if s.SSHURL.Set {
		e.FieldStart("ssh_url")
		s.SSHURL.Encode(e)
	}
	if s.StargazersURL.Set {
		e.FieldStart("stargazers_url")
		s.StargazersURL.Encode(e)
	}
	if s.StatusesURL.Set {
		e.FieldStart("statuses_url")
		s.StatusesURL.Encode(e)
	}
	if s.SubscribersURL.Set {
		e.FieldStart("subscribers_url")
		s.SubscribersURL.Encode(e)
	}
	if s.SubscriptionURL.Set {
		e.FieldStart("subscription_url")
		s.SubscriptionURL.Encode(e)
	}
	if s.TagsURL.Set {
		e.FieldStart("tags_url")
		s.TagsURL.Encode(e)
	}
	if s.TeamsURL.Set {
		e.FieldStart("teams_url")
		s.TeamsURL.Encode(e)
	}
	if s.TreesURL.Set {
		e.FieldStart("trees_url")
		s.TreesURL.Encode(e)
	}
	if s.CloneURL.Set {
		e.FieldStart("clone_url")
		s.CloneURL.Encode(e)
	}
	if s.MirrorURL.Set {
		e.FieldStart("mirror_url")
		s.MirrorURL.Encode(e)
	}
	if s.HooksURL.Set {
		e.FieldStart("hooks_url")
		s.HooksURL.Encode(e)
	}
	if s.SvnURL.Set {
		e.FieldStart("svn_url")
		s.SvnURL.Encode(e)
	}
	if s.Homepage.Set {
		e.FieldStart("homepage")
		s.Homepage.Encode(e)
	}
	if s.Language.Set {
		e.FieldStart("language")
		s.Language.Encode(e)
	}
	if s.ForksCount.Set {
		e.FieldStart("forks_count")
		s.ForksCount.Encode(e)
	}
	if s.StargazersCount.Set {
		e.FieldStart("stargazers_count")
		s.StargazersCount.Encode(e)
	}
	if s.WatchersCount.Set {
		e.FieldStart("watchers_count")
		s.WatchersCount.Encode(e)
	}
	if s.Size.Set {
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	if s.DefaultBranch.Set {
		e.FieldStart("default_branch")
		s.DefaultBranch.Encode(e)
	}
	if s.OpenIssuesCount.Set {
		e.FieldStart("open_issues_count")
		s.OpenIssuesCount.Encode(e)
	}
	if s.IsTemplate.Set {
		e.FieldStart("is_template")
		s.IsTemplate.Encode(e)
	}
	if s.Topics != nil {
		e.FieldStart("topics")
		e.ArrStart()
		for _, elem := range s.Topics {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.HasIssues.Set {
		e.FieldStart("has_issues")
		s.HasIssues.Encode(e)
	}
	if s.HasProjects.Set {
		e.FieldStart("has_projects")
		s.HasProjects.Encode(e)
	}
	if s.HasWiki.Set {
		e.FieldStart("has_wiki")
		s.HasWiki.Encode(e)
	}
	if s.HasPages.Set {
		e.FieldStart("has_pages")
		s.HasPages.Encode(e)
	}
	if s.HasDownloads.Set {
		e.FieldStart("has_downloads")
		s.HasDownloads.Encode(e)
	}
	if s.Archived.Set {
		e.FieldStart("archived")
		s.Archived.Encode(e)
	}
	if s.Disabled.Set {
		e.FieldStart("disabled")
		s.Disabled.Encode(e)
	}
	if s.Visibility.Set {
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
	if s.PushedAt.Set {
		e.FieldStart("pushed_at")
		s.PushedAt.Encode(e)
	}
	if s.CreatedAt.Set {
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e)
	}
	if s.UpdatedAt.Set {
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e)
	}
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	if s.AllowRebaseMerge.Set {
		e.FieldStart("allow_rebase_merge")
		s.AllowRebaseMerge.Encode(e)
	}
	if s.TempCloneToken.Set {
		e.FieldStart("temp_clone_token")
		s.TempCloneToken.Encode(e)
	}
	if s.AllowSquashMerge.Set {
		e.FieldStart("allow_squash_merge")
		s.AllowSquashMerge.Encode(e)
	}
	if s.AllowAutoMerge.Set {
		e.FieldStart("allow_auto_merge")
		s.AllowAutoMerge.Encode(e)
	}
	if s.DeleteBranchOnMerge.Set {
		e.FieldStart("delete_branch_on_merge")
		s.DeleteBranchOnMerge.Encode(e)
	}
	if s.AllowMergeCommit.Set {
		e.FieldStart("allow_merge_commit")
		s.AllowMergeCommit.Encode(e)
	}
	if s.SubscribersCount.Set {
		e.FieldStart("subscribers_count")
		s.SubscribersCount.Encode(e)
	}
	if s.NetworkCount.Set {
		e.FieldStart("network_count")
		s.NetworkCount.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableRepositoryTemplateRepository from json.
func (s *NullableRepositoryTemplateRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableRepositoryTemplateRepository to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "full_name":
			s.FullName.Reset()
			if err := s.FullName.Decode(d); err != nil {
				return err
			}
		case "owner":
			s.Owner.Reset()
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			s.Fork.Reset()
			if err := s.Fork.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "archive_url":
			s.ArchiveURL.Reset()
			if err := s.ArchiveURL.Decode(d); err != nil {
				return err
			}
		case "assignees_url":
			s.AssigneesURL.Reset()
			if err := s.AssigneesURL.Decode(d); err != nil {
				return err
			}
		case "blobs_url":
			s.BlobsURL.Reset()
			if err := s.BlobsURL.Decode(d); err != nil {
				return err
			}
		case "branches_url":
			s.BranchesURL.Reset()
			if err := s.BranchesURL.Decode(d); err != nil {
				return err
			}
		case "collaborators_url":
			s.CollaboratorsURL.Reset()
			if err := s.CollaboratorsURL.Decode(d); err != nil {
				return err
			}
		case "comments_url":
			s.CommentsURL.Reset()
			if err := s.CommentsURL.Decode(d); err != nil {
				return err
			}
		case "commits_url":
			s.CommitsURL.Reset()
			if err := s.CommitsURL.Decode(d); err != nil {
				return err
			}
		case "compare_url":
			s.CompareURL.Reset()
			if err := s.CompareURL.Decode(d); err != nil {
				return err
			}
		case "contents_url":
			s.ContentsURL.Reset()
			if err := s.ContentsURL.Decode(d); err != nil {
				return err
			}
		case "contributors_url":
			s.ContributorsURL.Reset()
			if err := s.ContributorsURL.Decode(d); err != nil {
				return err
			}
		case "deployments_url":
			s.DeploymentsURL.Reset()
			if err := s.DeploymentsURL.Decode(d); err != nil {
				return err
			}
		case "downloads_url":
			s.DownloadsURL.Reset()
			if err := s.DownloadsURL.Decode(d); err != nil {
				return err
			}
		case "events_url":
			s.EventsURL.Reset()
			if err := s.EventsURL.Decode(d); err != nil {
				return err
			}
		case "forks_url":
			s.ForksURL.Reset()
			if err := s.ForksURL.Decode(d); err != nil {
				return err
			}
		case "git_commits_url":
			s.GitCommitsURL.Reset()
			if err := s.GitCommitsURL.Decode(d); err != nil {
				return err
			}
		case "git_refs_url":
			s.GitRefsURL.Reset()
			if err := s.GitRefsURL.Decode(d); err != nil {
				return err
			}
		case "git_tags_url":
			s.GitTagsURL.Reset()
			if err := s.GitTagsURL.Decode(d); err != nil {
				return err
			}
		case "git_url":
			s.GitURL.Reset()
			if err := s.GitURL.Decode(d); err != nil {
				return err
			}
		case "issue_comment_url":
			s.IssueCommentURL.Reset()
			if err := s.IssueCommentURL.Decode(d); err != nil {
				return err
			}
		case "issue_events_url":
			s.IssueEventsURL.Reset()
			if err := s.IssueEventsURL.Decode(d); err != nil {
				return err
			}
		case "issues_url":
			s.IssuesURL.Reset()
			if err := s.IssuesURL.Decode(d); err != nil {
				return err
			}
		case "keys_url":
			s.KeysURL.Reset()
			if err := s.KeysURL.Decode(d); err != nil {
				return err
			}
		case "labels_url":
			s.LabelsURL.Reset()
			if err := s.LabelsURL.Decode(d); err != nil {
				return err
			}
		case "languages_url":
			s.LanguagesURL.Reset()
			if err := s.LanguagesURL.Decode(d); err != nil {
				return err
			}
		case "merges_url":
			s.MergesURL.Reset()
			if err := s.MergesURL.Decode(d); err != nil {
				return err
			}
		case "milestones_url":
			s.MilestonesURL.Reset()
			if err := s.MilestonesURL.Decode(d); err != nil {
				return err
			}
		case "notifications_url":
			s.NotificationsURL.Reset()
			if err := s.NotificationsURL.Decode(d); err != nil {
				return err
			}
		case "pulls_url":
			s.PullsURL.Reset()
			if err := s.PullsURL.Decode(d); err != nil {
				return err
			}
		case "releases_url":
			s.ReleasesURL.Reset()
			if err := s.ReleasesURL.Decode(d); err != nil {
				return err
			}
		case "ssh_url":
			s.SSHURL.Reset()
			if err := s.SSHURL.Decode(d); err != nil {
				return err
			}
		case "stargazers_url":
			s.StargazersURL.Reset()
			if err := s.StargazersURL.Decode(d); err != nil {
				return err
			}
		case "statuses_url":
			s.StatusesURL.Reset()
			if err := s.StatusesURL.Decode(d); err != nil {
				return err
			}
		case "subscribers_url":
			s.SubscribersURL.Reset()
			if err := s.SubscribersURL.Decode(d); err != nil {
				return err
			}
		case "subscription_url":
			s.SubscriptionURL.Reset()
			if err := s.SubscriptionURL.Decode(d); err != nil {
				return err
			}
		case "tags_url":
			s.TagsURL.Reset()
			if err := s.TagsURL.Decode(d); err != nil {
				return err
			}
		case "teams_url":
			s.TeamsURL.Reset()
			if err := s.TeamsURL.Decode(d); err != nil {
				return err
			}
		case "trees_url":
			s.TreesURL.Reset()
			if err := s.TreesURL.Decode(d); err != nil {
				return err
			}
		case "clone_url":
			s.CloneURL.Reset()
			if err := s.CloneURL.Decode(d); err != nil {
				return err
			}
		case "mirror_url":
			s.MirrorURL.Reset()
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			s.HooksURL.Reset()
			if err := s.HooksURL.Decode(d); err != nil {
				return err
			}
		case "svn_url":
			s.SvnURL.Reset()
			if err := s.SvnURL.Decode(d); err != nil {
				return err
			}
		case "homepage":
			s.Homepage.Reset()
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			s.Language.Reset()
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			s.ForksCount.Reset()
			if err := s.ForksCount.Decode(d); err != nil {
				return err
			}
		case "stargazers_count":
			s.StargazersCount.Reset()
			if err := s.StargazersCount.Decode(d); err != nil {
				return err
			}
		case "watchers_count":
			s.WatchersCount.Reset()
			if err := s.WatchersCount.Decode(d); err != nil {
				return err
			}
		case "size":
			s.Size.Reset()
			if err := s.Size.Decode(d); err != nil {
				return err
			}
		case "default_branch":
			s.DefaultBranch.Reset()
			if err := s.DefaultBranch.Decode(d); err != nil {
				return err
			}
		case "open_issues_count":
			s.OpenIssuesCount.Reset()
			if err := s.OpenIssuesCount.Decode(d); err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "has_issues":
			s.HasIssues.Reset()
			if err := s.HasIssues.Decode(d); err != nil {
				return err
			}
		case "has_projects":
			s.HasProjects.Reset()
			if err := s.HasProjects.Decode(d); err != nil {
				return err
			}
		case "has_wiki":
			s.HasWiki.Reset()
			if err := s.HasWiki.Decode(d); err != nil {
				return err
			}
		case "has_pages":
			s.HasPages.Reset()
			if err := s.HasPages.Decode(d); err != nil {
				return err
			}
		case "has_downloads":
			s.HasDownloads.Reset()
			if err := s.HasDownloads.Decode(d); err != nil {
				return err
			}
		case "archived":
			s.Archived.Reset()
			if err := s.Archived.Decode(d); err != nil {
				return err
			}
		case "disabled":
			s.Disabled.Reset()
			if err := s.Disabled.Decode(d); err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			s.PushedAt.Reset()
			if err := s.PushedAt.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "subscribers_count":
			s.SubscribersCount.Reset()
			if err := s.SubscribersCount.Decode(d); err != nil {
				return err
			}
		case "network_count":
			s.NetworkCount.Reset()
			if err := s.NetworkCount.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableRepositoryTemplateRepositoryOwner) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Login.Set {
		e.FieldStart("login")
		s.Login.Encode(e)
	}
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	if s.AvatarURL.Set {
		e.FieldStart("avatar_url")
		s.AvatarURL.Encode(e)
	}
	if s.GravatarID.Set {
		e.FieldStart("gravatar_id")
		s.GravatarID.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.FollowersURL.Set {
		e.FieldStart("followers_url")
		s.FollowersURL.Encode(e)
	}
	if s.FollowingURL.Set {
		e.FieldStart("following_url")
		s.FollowingURL.Encode(e)
	}
	if s.GistsURL.Set {
		e.FieldStart("gists_url")
		s.GistsURL.Encode(e)
	}
	if s.StarredURL.Set {
		e.FieldStart("starred_url")
		s.StarredURL.Encode(e)
	}
	if s.SubscriptionsURL.Set {
		e.FieldStart("subscriptions_url")
		s.SubscriptionsURL.Encode(e)
	}
	if s.OrganizationsURL.Set {
		e.FieldStart("organizations_url")
		s.OrganizationsURL.Encode(e)
	}
	if s.ReposURL.Set {
		e.FieldStart("repos_url")
		s.ReposURL.Encode(e)
	}
	if s.EventsURL.Set {
		e.FieldStart("events_url")
		s.EventsURL.Encode(e)
	}
	if s.ReceivedEventsURL.Set {
		e.FieldStart("received_events_url")
		s.ReceivedEventsURL.Encode(e)
	}
	if s.Type.Set {
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	if s.SiteAdmin.Set {
		e.FieldStart("site_admin")
		s.SiteAdmin.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableRepositoryTemplateRepositoryOwner from json.
func (s *NullableRepositoryTemplateRepositoryOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableRepositoryTemplateRepositoryOwner to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			s.Login.Reset()
			if err := s.Login.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "avatar_url":
			s.AvatarURL.Reset()
			if err := s.AvatarURL.Decode(d); err != nil {
				return err
			}
		case "gravatar_id":
			s.GravatarID.Reset()
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "followers_url":
			s.FollowersURL.Reset()
			if err := s.FollowersURL.Decode(d); err != nil {
				return err
			}
		case "following_url":
			s.FollowingURL.Reset()
			if err := s.FollowingURL.Decode(d); err != nil {
				return err
			}
		case "gists_url":
			s.GistsURL.Reset()
			if err := s.GistsURL.Decode(d); err != nil {
				return err
			}
		case "starred_url":
			s.StarredURL.Reset()
			if err := s.StarredURL.Decode(d); err != nil {
				return err
			}
		case "subscriptions_url":
			s.SubscriptionsURL.Reset()
			if err := s.SubscriptionsURL.Decode(d); err != nil {
				return err
			}
		case "organizations_url":
			s.OrganizationsURL.Reset()
			if err := s.OrganizationsURL.Decode(d); err != nil {
				return err
			}
		case "repos_url":
			s.ReposURL.Reset()
			if err := s.ReposURL.Decode(d); err != nil {
				return err
			}
		case "events_url":
			s.EventsURL.Reset()
			if err := s.EventsURL.Decode(d); err != nil {
				return err
			}
		case "received_events_url":
			s.ReceivedEventsURL.Reset()
			if err := s.ReceivedEventsURL.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "site_admin":
			s.SiteAdmin.Reset()
			if err := s.SiteAdmin.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableRepositoryTemplateRepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Admin.Set {
		e.FieldStart("admin")
		s.Admin.Encode(e)
	}
	if s.Maintain.Set {
		e.FieldStart("maintain")
		s.Maintain.Encode(e)
	}
	if s.Push.Set {
		e.FieldStart("push")
		s.Push.Encode(e)
	}
	if s.Triage.Set {
		e.FieldStart("triage")
		s.Triage.Encode(e)
	}
	if s.Pull.Set {
		e.FieldStart("pull")
		s.Pull.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableRepositoryTemplateRepositoryPermissions from json.
func (s *NullableRepositoryTemplateRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableRepositoryTemplateRepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			s.Admin.Reset()
			if err := s.Admin.Decode(d); err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "push":
			s.Push.Reset()
			if err := s.Push.Decode(d); err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "pull":
			s.Pull.Reset()
			if err := s.Pull.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableScopedInstallation) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("permissions")
	s.Permissions.Encode(e)

	e.FieldStart("repository_selection")
	s.RepositorySelection.Encode(e)

	e.FieldStart("single_file_name")
	s.SingleFileName.Encode(e)
	if s.HasMultipleSingleFiles.Set {
		e.FieldStart("has_multiple_single_files")
		s.HasMultipleSingleFiles.Encode(e)
	}
	if s.SingleFilePaths != nil {
		e.FieldStart("single_file_paths")
		e.ArrStart()
		for _, elem := range s.SingleFilePaths {
			e.Str(elem)
		}
		e.ArrEnd()
	}

	e.FieldStart("repositories_url")
	json.EncodeURI(e, s.RepositoriesURL)

	e.FieldStart("account")
	s.Account.Encode(e)
	e.ObjEnd()
}

// Decode decodes NullableScopedInstallation from json.
func (s *NullableScopedInstallation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableScopedInstallation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permissions":
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "repository_selection":
			if err := s.RepositorySelection.Decode(d); err != nil {
				return err
			}
		case "single_file_name":
			if err := s.SingleFileName.Decode(d); err != nil {
				return err
			}
		case "has_multiple_single_files":
			s.HasMultipleSingleFiles.Reset()
			if err := s.HasMultipleSingleFiles.Decode(d); err != nil {
				return err
			}
		case "single_file_paths":
			s.SingleFilePaths = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.SingleFilePaths = append(s.SingleFilePaths, elem)
				return nil
			}); err != nil {
				return err
			}
		case "repositories_url":
			v, err := json.DecodeURI(d)
			s.RepositoriesURL = v
			if err != nil {
				return err
			}
		case "account":
			if err := s.Account.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes NullableScopedInstallationRepositorySelection as json.
func (s NullableScopedInstallationRepositorySelection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NullableScopedInstallationRepositorySelection from json.
func (s *NullableScopedInstallationRepositorySelection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableScopedInstallationRepositorySelection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = NullableScopedInstallationRepositorySelection(v)
	return nil
}

// Encode implements json.Marshaler.
func (s NullableSimpleCommit) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Str(s.ID)

	e.FieldStart("tree_id")
	e.Str(s.TreeID)

	e.FieldStart("message")
	e.Str(s.Message)

	e.FieldStart("timestamp")
	json.EncodeDateTime(e, s.Timestamp)

	e.FieldStart("author")
	s.Author.Encode(e)

	e.FieldStart("committer")
	s.Committer.Encode(e)
	e.ObjEnd()
}

// Decode decodes NullableSimpleCommit from json.
func (s *NullableSimpleCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableSimpleCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "tree_id":
			v, err := d.Str()
			s.TreeID = string(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "timestamp":
			v, err := json.DecodeDateTime(d)
			s.Timestamp = v
			if err != nil {
				return err
			}
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableSimpleCommitAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("email")
	e.Str(s.Email)
	e.ObjEnd()
}

// Decode decodes NullableSimpleCommitAuthor from json.
func (s *NullableSimpleCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableSimpleCommitAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableSimpleCommitCommitter) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("email")
	e.Str(s.Email)
	e.ObjEnd()
}

// Decode decodes NullableSimpleCommitCommitter from json.
func (s *NullableSimpleCommitCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableSimpleCommitCommitter to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableSimpleUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}

	e.FieldStart("login")
	e.Str(s.Login)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("avatar_url")
	json.EncodeURI(e, s.AvatarURL)

	e.FieldStart("gravatar_id")
	s.GravatarID.Encode(e)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("followers_url")
	json.EncodeURI(e, s.FollowersURL)

	e.FieldStart("following_url")
	e.Str(s.FollowingURL)

	e.FieldStart("gists_url")
	e.Str(s.GistsURL)

	e.FieldStart("starred_url")
	e.Str(s.StarredURL)

	e.FieldStart("subscriptions_url")
	json.EncodeURI(e, s.SubscriptionsURL)

	e.FieldStart("organizations_url")
	json.EncodeURI(e, s.OrganizationsURL)

	e.FieldStart("repos_url")
	json.EncodeURI(e, s.ReposURL)

	e.FieldStart("events_url")
	e.Str(s.EventsURL)

	e.FieldStart("received_events_url")
	json.EncodeURI(e, s.ReceivedEventsURL)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("site_admin")
	e.Bool(s.SiteAdmin)
	if s.StarredAt.Set {
		e.FieldStart("starred_at")
		s.StarredAt.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableSimpleUser from json.
func (s *NullableSimpleUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableSimpleUser to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "starred_at":
			s.StarredAt.Reset()
			if err := s.StarredAt.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s NullableTeamSimple) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("members_url")
	e.Str(s.MembersURL)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("permission")
	e.Str(s.Permission)
	if s.Privacy.Set {
		e.FieldStart("privacy")
		s.Privacy.Encode(e)
	}

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("repositories_url")
	json.EncodeURI(e, s.RepositoriesURL)

	e.FieldStart("slug")
	e.Str(s.Slug)
	if s.LdapDn.Set {
		e.FieldStart("ldap_dn")
		s.LdapDn.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes NullableTeamSimple from json.
func (s *NullableTeamSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode NullableTeamSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "members_url":
			v, err := d.Str()
			s.MembersURL = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "permission":
			v, err := d.Str()
			s.Permission = string(v)
			if err != nil {
				return err
			}
		case "privacy":
			s.Privacy.Reset()
			if err := s.Privacy.Decode(d); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "repositories_url":
			v, err := json.DecodeURI(d)
			s.RepositoriesURL = v
			if err != nil {
				return err
			}
		case "slug":
			v, err := d.Str()
			s.Slug = string(v)
			if err != nil {
				return err
			}
		case "ldap_dn":
			s.LdapDn.Reset()
			if err := s.LdapDn.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OAuthAuthorizationsCreateAuthorizationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Scopes.Set {
		e.FieldStart("scopes")
		s.Scopes.Encode(e)
	}
	if s.Note.Set {
		e.FieldStart("note")
		s.Note.Encode(e)
	}
	if s.NoteURL.Set {
		e.FieldStart("note_url")
		s.NoteURL.Encode(e)
	}
	if s.ClientID.Set {
		e.FieldStart("client_id")
		s.ClientID.Encode(e)
	}
	if s.ClientSecret.Set {
		e.FieldStart("client_secret")
		s.ClientSecret.Encode(e)
	}
	if s.Fingerprint.Set {
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OAuthAuthorizationsCreateAuthorizationReq from json.
func (s *OAuthAuthorizationsCreateAuthorizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsCreateAuthorizationReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scopes":
			s.Scopes.Reset()
			if err := s.Scopes.Decode(d); err != nil {
				return err
			}
		case "note":
			s.Note.Reset()
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		case "note_url":
			s.NoteURL.Reset()
			if err := s.NoteURL.Decode(d); err != nil {
				return err
			}
		case "client_id":
			s.ClientID.Reset()
			if err := s.ClientID.Decode(d); err != nil {
				return err
			}
		case "client_secret":
			s.ClientSecret.Reset()
			if err := s.ClientSecret.Decode(d); err != nil {
				return err
			}
		case "fingerprint":
			s.Fingerprint.Reset()
			if err := s.Fingerprint.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden as json.
func (s OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsDeleteAuthorizationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsDeleteAuthorizationApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OAuthAuthorizationsDeleteAuthorizationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OAuthAuthorizationsDeleteAuthorizationNoContent from json.
func (s *OAuthAuthorizationsDeleteAuthorizationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsDeleteAuthorizationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OAuthAuthorizationsDeleteGrantApplicationJSONForbidden as json.
func (s OAuthAuthorizationsDeleteGrantApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsDeleteGrantApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsDeleteGrantApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsDeleteGrantApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsDeleteGrantApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsDeleteGrantApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OAuthAuthorizationsDeleteGrantNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OAuthAuthorizationsDeleteGrantNoContent from json.
func (s *OAuthAuthorizationsDeleteGrantNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsDeleteGrantNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden as json.
func (s OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetAuthorizationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetAuthorizationApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetGrantApplicationJSONForbidden as json.
func (s OAuthAuthorizationsGetGrantApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetGrantApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsGetGrantApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetGrantApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetGrantApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsGetGrantApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsGetGrantApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsGetGrantApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsGetGrantApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetGrantApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsGetGrantApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("client_secret")
	e.Str(s.ClientSecret)
	if s.Scopes.Set {
		e.FieldStart("scopes")
		s.Scopes.Encode(e)
	}
	if s.Note.Set {
		e.FieldStart("note")
		s.Note.Encode(e)
	}
	if s.NoteURL.Set {
		e.FieldStart("note_url")
		s.NoteURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_secret":
			v, err := d.Str()
			s.ClientSecret = string(v)
			if err != nil {
				return err
			}
		case "scopes":
			s.Scopes.Reset()
			if err := s.Scopes.Decode(d); err != nil {
				return err
			}
		case "note":
			s.Note.Reset()
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		case "note_url":
			s.NoteURL.Reset()
			if err := s.NoteURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OAuthAuthorizationsGetOrCreateAuthorizationForAppReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("client_secret")
	e.Str(s.ClientSecret)
	if s.Scopes.Set {
		e.FieldStart("scopes")
		s.Scopes.Encode(e)
	}
	if s.Note.Set {
		e.FieldStart("note")
		s.Note.Encode(e)
	}
	if s.NoteURL.Set {
		e.FieldStart("note_url")
		s.NoteURL.Encode(e)
	}
	if s.Fingerprint.Set {
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OAuthAuthorizationsGetOrCreateAuthorizationForAppReq from json.
func (s *OAuthAuthorizationsGetOrCreateAuthorizationForAppReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsGetOrCreateAuthorizationForAppReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client_secret":
			v, err := d.Str()
			s.ClientSecret = string(v)
			if err != nil {
				return err
			}
		case "scopes":
			s.Scopes.Reset()
			if err := s.Scopes.Decode(d); err != nil {
				return err
			}
		case "note":
			s.Note.Reset()
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		case "note_url":
			s.NoteURL.Reset()
			if err := s.NoteURL.Decode(d); err != nil {
				return err
			}
		case "fingerprint":
			s.Fingerprint.Reset()
			if err := s.Fingerprint.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden as json.
func (s OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListAuthorizationsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound as json.
func (s OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound from json.
func (s *OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListAuthorizationsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListAuthorizationsApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListAuthorizationsOKApplicationJSON as json.
func (s OAuthAuthorizationsListAuthorizationsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Authorization(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes OAuthAuthorizationsListAuthorizationsOKApplicationJSON from json.
func (s *OAuthAuthorizationsListAuthorizationsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsListAuthorizationsOKApplicationJSON to nil`)
	}
	var unwrapped []Authorization
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Authorization
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListAuthorizationsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListGrantsApplicationJSONForbidden as json.
func (s OAuthAuthorizationsListGrantsApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListGrantsApplicationJSONForbidden from json.
func (s *OAuthAuthorizationsListGrantsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsListGrantsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListGrantsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListGrantsApplicationJSONNotFound as json.
func (s OAuthAuthorizationsListGrantsApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListGrantsApplicationJSONNotFound from json.
func (s *OAuthAuthorizationsListGrantsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsListGrantsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListGrantsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListGrantsApplicationJSONUnauthorized as json.
func (s OAuthAuthorizationsListGrantsApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OAuthAuthorizationsListGrantsApplicationJSONUnauthorized from json.
func (s *OAuthAuthorizationsListGrantsApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsListGrantsApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListGrantsApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OAuthAuthorizationsListGrantsOKApplicationJSON as json.
func (s OAuthAuthorizationsListGrantsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ApplicationGrant(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes OAuthAuthorizationsListGrantsOKApplicationJSON from json.
func (s *OAuthAuthorizationsListGrantsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsListGrantsOKApplicationJSON to nil`)
	}
	var unwrapped []ApplicationGrant
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ApplicationGrant
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OAuthAuthorizationsListGrantsOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OAuthAuthorizationsUpdateAuthorizationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Scopes.Set {
		e.FieldStart("scopes")
		s.Scopes.Encode(e)
	}
	if s.AddScopes != nil {
		e.FieldStart("add_scopes")
		e.ArrStart()
		for _, elem := range s.AddScopes {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.RemoveScopes != nil {
		e.FieldStart("remove_scopes")
		e.ArrStart()
		for _, elem := range s.RemoveScopes {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Note.Set {
		e.FieldStart("note")
		s.Note.Encode(e)
	}
	if s.NoteURL.Set {
		e.FieldStart("note_url")
		s.NoteURL.Encode(e)
	}
	if s.Fingerprint.Set {
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OAuthAuthorizationsUpdateAuthorizationReq from json.
func (s *OAuthAuthorizationsUpdateAuthorizationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OAuthAuthorizationsUpdateAuthorizationReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scopes":
			s.Scopes.Reset()
			if err := s.Scopes.Decode(d); err != nil {
				return err
			}
		case "add_scopes":
			s.AddScopes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AddScopes = append(s.AddScopes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "remove_scopes":
			s.RemoveScopes = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.RemoveScopes = append(s.RemoveScopes, elem)
				return nil
			}); err != nil {
				return err
			}
		case "note":
			s.Note.Reset()
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		case "note_url":
			s.NoteURL.Reset()
			if err := s.NoteURL.Decode(d); err != nil {
				return err
			}
		case "fingerprint":
			s.Fingerprint.Reset()
			if err := s.Fingerprint.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes APIOverviewSSHKeyFingerprints as json.
func (o OptAPIOverviewSSHKeyFingerprints) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes APIOverviewSSHKeyFingerprints from json.
func (o *OptAPIOverviewSSHKeyFingerprints) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAPIOverviewSSHKeyFingerprints to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAPIOverviewSSHKeyFingerprints`, d.Next())
	}
}

// Encode encodes ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility as json.
func (o OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility from json.
func (o *OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ActionsCreateSelfHostedRunnerGroupForOrgReqVisibility(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActionsCreateSelfHostedRunnerGroupForOrgReqVisibility`, d.Next())
	}
}

// Encode encodes ActionsListJobsForWorkflowRunFilter as json.
func (o OptActionsListJobsForWorkflowRunFilter) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ActionsListJobsForWorkflowRunFilter from json.
func (o *OptActionsListJobsForWorkflowRunFilter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActionsListJobsForWorkflowRunFilter to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ActionsListJobsForWorkflowRunFilter(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActionsListJobsForWorkflowRunFilter`, d.Next())
	}
}

// Encode encodes ActionsListWorkflowRunsForRepoStatus as json.
func (o OptActionsListWorkflowRunsForRepoStatus) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ActionsListWorkflowRunsForRepoStatus from json.
func (o *OptActionsListWorkflowRunsForRepoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActionsListWorkflowRunsForRepoStatus to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ActionsListWorkflowRunsForRepoStatus(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActionsListWorkflowRunsForRepoStatus`, d.Next())
	}
}

// Encode encodes ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility as json.
func (o OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility from json.
func (o *OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActionsUpdateSelfHostedRunnerGroupForOrgReqVisibility`, d.Next())
	}
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserDirection as json.
func (o OptActivityListReposStarredByAuthenticatedUserDirection) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserDirection from json.
func (o *OptActivityListReposStarredByAuthenticatedUserDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActivityListReposStarredByAuthenticatedUserDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ActivityListReposStarredByAuthenticatedUserDirection(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActivityListReposStarredByAuthenticatedUserDirection`, d.Next())
	}
}

// Encode encodes ActivityListReposStarredByAuthenticatedUserSort as json.
func (o OptActivityListReposStarredByAuthenticatedUserSort) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ActivityListReposStarredByAuthenticatedUserSort from json.
func (o *OptActivityListReposStarredByAuthenticatedUserSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActivityListReposStarredByAuthenticatedUserSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ActivityListReposStarredByAuthenticatedUserSort(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActivityListReposStarredByAuthenticatedUserSort`, d.Next())
	}
}

// Encode encodes Actor as json.
func (o OptActor) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Actor from json.
func (o *OptActor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptActor to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptActor`, d.Next())
	}
}

// Encode encodes AlertCreatedAt as json.
func (o OptAlertCreatedAt) Encode(e *jx.Encoder) {
}

// Decode decodes AlertCreatedAt from json.
func (o *OptAlertCreatedAt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAlertCreatedAt to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAlertCreatedAt`, d.Next())
	}
}

// Encode encodes AlertHTMLURL as json.
func (o OptAlertHTMLURL) Encode(e *jx.Encoder) {
}

// Decode decodes AlertHTMLURL from json.
func (o *OptAlertHTMLURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAlertHTMLURL to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAlertHTMLURL`, d.Next())
	}
}

// Encode encodes AlertNumber as json.
func (o OptAlertNumber) Encode(e *jx.Encoder) {
}

// Decode decodes AlertNumber from json.
func (o *OptAlertNumber) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAlertNumber to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAlertNumber`, d.Next())
	}
}

// Encode encodes AlertURL as json.
func (o OptAlertURL) Encode(e *jx.Encoder) {
}

// Decode decodes AlertURL from json.
func (o *OptAlertURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAlertURL to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAlertURL`, d.Next())
	}
}

// Encode encodes AllowedActions as json.
func (o OptAllowedActions) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AllowedActions from json.
func (o *OptAllowedActions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAllowedActions to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AllowedActions(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAllowedActions`, d.Next())
	}
}

// Encode encodes AppPermissions as json.
func (o OptAppPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes AppPermissions from json.
func (o *OptAppPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissions`, d.Next())
	}
}

// Encode encodes AppPermissionsActions as json.
func (o OptAppPermissionsActions) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsActions from json.
func (o *OptAppPermissionsActions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsActions to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsActions(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsActions`, d.Next())
	}
}

// Encode encodes AppPermissionsAdministration as json.
func (o OptAppPermissionsAdministration) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsAdministration from json.
func (o *OptAppPermissionsAdministration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsAdministration to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsAdministration(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsAdministration`, d.Next())
	}
}

// Encode encodes AppPermissionsChecks as json.
func (o OptAppPermissionsChecks) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsChecks from json.
func (o *OptAppPermissionsChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsChecks to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsChecks(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsChecks`, d.Next())
	}
}

// Encode encodes AppPermissionsContentReferences as json.
func (o OptAppPermissionsContentReferences) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsContentReferences from json.
func (o *OptAppPermissionsContentReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsContentReferences to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsContentReferences(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsContentReferences`, d.Next())
	}
}

// Encode encodes AppPermissionsContents as json.
func (o OptAppPermissionsContents) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsContents from json.
func (o *OptAppPermissionsContents) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsContents to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsContents(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsContents`, d.Next())
	}
}

// Encode encodes AppPermissionsDeployments as json.
func (o OptAppPermissionsDeployments) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsDeployments from json.
func (o *OptAppPermissionsDeployments) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsDeployments to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsDeployments(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsDeployments`, d.Next())
	}
}

// Encode encodes AppPermissionsEnvironments as json.
func (o OptAppPermissionsEnvironments) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsEnvironments from json.
func (o *OptAppPermissionsEnvironments) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsEnvironments to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsEnvironments(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsEnvironments`, d.Next())
	}
}

// Encode encodes AppPermissionsIssues as json.
func (o OptAppPermissionsIssues) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsIssues from json.
func (o *OptAppPermissionsIssues) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsIssues to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsIssues(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsIssues`, d.Next())
	}
}

// Encode encodes AppPermissionsMembers as json.
func (o OptAppPermissionsMembers) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsMembers from json.
func (o *OptAppPermissionsMembers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsMembers to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsMembers(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsMembers`, d.Next())
	}
}

// Encode encodes AppPermissionsMetadata as json.
func (o OptAppPermissionsMetadata) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsMetadata from json.
func (o *OptAppPermissionsMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsMetadata to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsMetadata(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsMetadata`, d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationAdministration as json.
func (o OptAppPermissionsOrganizationAdministration) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationAdministration from json.
func (o *OptAppPermissionsOrganizationAdministration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsOrganizationAdministration to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsOrganizationAdministration(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsOrganizationAdministration`, d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationHooks as json.
func (o OptAppPermissionsOrganizationHooks) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationHooks from json.
func (o *OptAppPermissionsOrganizationHooks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsOrganizationHooks to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsOrganizationHooks(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsOrganizationHooks`, d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationPackages as json.
func (o OptAppPermissionsOrganizationPackages) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationPackages from json.
func (o *OptAppPermissionsOrganizationPackages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsOrganizationPackages to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsOrganizationPackages(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsOrganizationPackages`, d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationPlan as json.
func (o OptAppPermissionsOrganizationPlan) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationPlan from json.
func (o *OptAppPermissionsOrganizationPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsOrganizationPlan to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsOrganizationPlan(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsOrganizationPlan`, d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationProjects as json.
func (o OptAppPermissionsOrganizationProjects) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationProjects from json.
func (o *OptAppPermissionsOrganizationProjects) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsOrganizationProjects to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsOrganizationProjects(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsOrganizationProjects`, d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationSecrets as json.
func (o OptAppPermissionsOrganizationSecrets) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationSecrets from json.
func (o *OptAppPermissionsOrganizationSecrets) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsOrganizationSecrets to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsOrganizationSecrets(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsOrganizationSecrets`, d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationSelfHostedRunners as json.
func (o OptAppPermissionsOrganizationSelfHostedRunners) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationSelfHostedRunners from json.
func (o *OptAppPermissionsOrganizationSelfHostedRunners) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsOrganizationSelfHostedRunners to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsOrganizationSelfHostedRunners(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsOrganizationSelfHostedRunners`, d.Next())
	}
}

// Encode encodes AppPermissionsOrganizationUserBlocking as json.
func (o OptAppPermissionsOrganizationUserBlocking) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsOrganizationUserBlocking from json.
func (o *OptAppPermissionsOrganizationUserBlocking) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsOrganizationUserBlocking to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsOrganizationUserBlocking(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsOrganizationUserBlocking`, d.Next())
	}
}

// Encode encodes AppPermissionsPackages as json.
func (o OptAppPermissionsPackages) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsPackages from json.
func (o *OptAppPermissionsPackages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsPackages to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsPackages(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsPackages`, d.Next())
	}
}

// Encode encodes AppPermissionsPages as json.
func (o OptAppPermissionsPages) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsPages from json.
func (o *OptAppPermissionsPages) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsPages to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsPages(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsPages`, d.Next())
	}
}

// Encode encodes AppPermissionsPullRequests as json.
func (o OptAppPermissionsPullRequests) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsPullRequests from json.
func (o *OptAppPermissionsPullRequests) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsPullRequests to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsPullRequests(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsPullRequests`, d.Next())
	}
}

// Encode encodes AppPermissionsRepositoryHooks as json.
func (o OptAppPermissionsRepositoryHooks) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsRepositoryHooks from json.
func (o *OptAppPermissionsRepositoryHooks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsRepositoryHooks to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsRepositoryHooks(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsRepositoryHooks`, d.Next())
	}
}

// Encode encodes AppPermissionsRepositoryProjects as json.
func (o OptAppPermissionsRepositoryProjects) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsRepositoryProjects from json.
func (o *OptAppPermissionsRepositoryProjects) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsRepositoryProjects to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsRepositoryProjects(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsRepositoryProjects`, d.Next())
	}
}

// Encode encodes AppPermissionsSecretScanningAlerts as json.
func (o OptAppPermissionsSecretScanningAlerts) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsSecretScanningAlerts from json.
func (o *OptAppPermissionsSecretScanningAlerts) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsSecretScanningAlerts to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsSecretScanningAlerts(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsSecretScanningAlerts`, d.Next())
	}
}

// Encode encodes AppPermissionsSecrets as json.
func (o OptAppPermissionsSecrets) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsSecrets from json.
func (o *OptAppPermissionsSecrets) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsSecrets to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsSecrets(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsSecrets`, d.Next())
	}
}

// Encode encodes AppPermissionsSecurityEvents as json.
func (o OptAppPermissionsSecurityEvents) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsSecurityEvents from json.
func (o *OptAppPermissionsSecurityEvents) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsSecurityEvents to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsSecurityEvents(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsSecurityEvents`, d.Next())
	}
}

// Encode encodes AppPermissionsSingleFile as json.
func (o OptAppPermissionsSingleFile) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsSingleFile from json.
func (o *OptAppPermissionsSingleFile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsSingleFile to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsSingleFile(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsSingleFile`, d.Next())
	}
}

// Encode encodes AppPermissionsStatuses as json.
func (o OptAppPermissionsStatuses) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsStatuses from json.
func (o *OptAppPermissionsStatuses) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsStatuses to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsStatuses(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsStatuses`, d.Next())
	}
}

// Encode encodes AppPermissionsTeamDiscussions as json.
func (o OptAppPermissionsTeamDiscussions) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsTeamDiscussions from json.
func (o *OptAppPermissionsTeamDiscussions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsTeamDiscussions to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsTeamDiscussions(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsTeamDiscussions`, d.Next())
	}
}

// Encode encodes AppPermissionsVulnerabilityAlerts as json.
func (o OptAppPermissionsVulnerabilityAlerts) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsVulnerabilityAlerts from json.
func (o *OptAppPermissionsVulnerabilityAlerts) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsVulnerabilityAlerts to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsVulnerabilityAlerts(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsVulnerabilityAlerts`, d.Next())
	}
}

// Encode encodes AppPermissionsWorkflows as json.
func (o OptAppPermissionsWorkflows) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppPermissionsWorkflows from json.
func (o *OptAppPermissionsWorkflows) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppPermissionsWorkflows to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppPermissionsWorkflows(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppPermissionsWorkflows`, d.Next())
	}
}

// Encode encodes AppsListAccountsForPlanStubbedDirection as json.
func (o OptAppsListAccountsForPlanStubbedDirection) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppsListAccountsForPlanStubbedDirection from json.
func (o *OptAppsListAccountsForPlanStubbedDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppsListAccountsForPlanStubbedDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppsListAccountsForPlanStubbedDirection(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppsListAccountsForPlanStubbedDirection`, d.Next())
	}
}

// Encode encodes AppsListAccountsForPlanStubbedSort as json.
func (o OptAppsListAccountsForPlanStubbedSort) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AppsListAccountsForPlanStubbedSort from json.
func (o *OptAppsListAccountsForPlanStubbedSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAppsListAccountsForPlanStubbedSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AppsListAccountsForPlanStubbedSort(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAppsListAccountsForPlanStubbedSort`, d.Next())
	}
}

// Encode encodes AuditLogEventActorLocation as json.
func (o OptAuditLogEventActorLocation) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes AuditLogEventActorLocation from json.
func (o *OptAuditLogEventActorLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAuditLogEventActorLocation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAuditLogEventActorLocation`, d.Next())
	}
}

// Encode encodes AuthenticationTokenRepositorySelection as json.
func (o OptAuthenticationTokenRepositorySelection) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AuthenticationTokenRepositorySelection from json.
func (o *OptAuthenticationTokenRepositorySelection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAuthenticationTokenRepositorySelection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AuthenticationTokenRepositorySelection(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAuthenticationTokenRepositorySelection`, d.Next())
	}
}

// Encode encodes AuthorAssociation as json.
func (o OptAuthorAssociation) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes AuthorAssociation from json.
func (o *OptAuthorAssociation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptAuthorAssociation to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = AuthorAssociation(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptAuthorAssociation`, d.Next())
	}
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBool to nil`)
	}
	switch d.Next() {
	case jx.Bool:
		o.Set = true
		v, err := d.Bool()
		if err != nil {
			return err
		}
		o.Value = bool(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBool`, d.Next())
	}
}

// Encode encodes BranchProtection as json.
func (o OptBranchProtection) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes BranchProtection from json.
func (o *OptBranchProtection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchProtection to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchProtection`, d.Next())
	}
}

// Encode encodes BranchProtectionAllowDeletions as json.
func (o OptBranchProtectionAllowDeletions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionAllowDeletions from json.
func (o *OptBranchProtectionAllowDeletions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchProtectionAllowDeletions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchProtectionAllowDeletions`, d.Next())
	}
}

// Encode encodes BranchProtectionAllowForcePushes as json.
func (o OptBranchProtectionAllowForcePushes) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionAllowForcePushes from json.
func (o *OptBranchProtectionAllowForcePushes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchProtectionAllowForcePushes to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchProtectionAllowForcePushes`, d.Next())
	}
}

// Encode encodes BranchProtectionRequiredConversationResolution as json.
func (o OptBranchProtectionRequiredConversationResolution) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionRequiredConversationResolution from json.
func (o *OptBranchProtectionRequiredConversationResolution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchProtectionRequiredConversationResolution to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchProtectionRequiredConversationResolution`, d.Next())
	}
}

// Encode encodes BranchProtectionRequiredLinearHistory as json.
func (o OptBranchProtectionRequiredLinearHistory) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionRequiredLinearHistory from json.
func (o *OptBranchProtectionRequiredLinearHistory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchProtectionRequiredLinearHistory to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchProtectionRequiredLinearHistory`, d.Next())
	}
}

// Encode encodes BranchProtectionRequiredSignatures as json.
func (o OptBranchProtectionRequiredSignatures) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionRequiredSignatures from json.
func (o *OptBranchProtectionRequiredSignatures) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchProtectionRequiredSignatures to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchProtectionRequiredSignatures`, d.Next())
	}
}

// Encode encodes BranchProtectionRequiredStatusChecks as json.
func (o OptBranchProtectionRequiredStatusChecks) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes BranchProtectionRequiredStatusChecks from json.
func (o *OptBranchProtectionRequiredStatusChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchProtectionRequiredStatusChecks to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchProtectionRequiredStatusChecks`, d.Next())
	}
}

// Encode encodes BranchRestrictionPolicy as json.
func (o OptBranchRestrictionPolicy) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes BranchRestrictionPolicy from json.
func (o *OptBranchRestrictionPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchRestrictionPolicy to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchRestrictionPolicy`, d.Next())
	}
}

// Encode encodes BranchRestrictionPolicyAppsItemOwner as json.
func (o OptBranchRestrictionPolicyAppsItemOwner) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes BranchRestrictionPolicyAppsItemOwner from json.
func (o *OptBranchRestrictionPolicyAppsItemOwner) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchRestrictionPolicyAppsItemOwner to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchRestrictionPolicyAppsItemOwner`, d.Next())
	}
}

// Encode encodes BranchRestrictionPolicyAppsItemPermissions as json.
func (o OptBranchRestrictionPolicyAppsItemPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes BranchRestrictionPolicyAppsItemPermissions from json.
func (o *OptBranchRestrictionPolicyAppsItemPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptBranchRestrictionPolicyAppsItemPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptBranchRestrictionPolicyAppsItemPermissions`, d.Next())
	}
}

// Encode encodes ChecksListForRefFilter as json.
func (o OptChecksListForRefFilter) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ChecksListForRefFilter from json.
func (o *OptChecksListForRefFilter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChecksListForRefFilter to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ChecksListForRefFilter(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChecksListForRefFilter`, d.Next())
	}
}

// Encode encodes ChecksListForRefStatus as json.
func (o OptChecksListForRefStatus) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ChecksListForRefStatus from json.
func (o *OptChecksListForRefStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChecksListForRefStatus to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ChecksListForRefStatus(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChecksListForRefStatus`, d.Next())
	}
}

// Encode encodes ChecksListForSuiteFilter as json.
func (o OptChecksListForSuiteFilter) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ChecksListForSuiteFilter from json.
func (o *OptChecksListForSuiteFilter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChecksListForSuiteFilter to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ChecksListForSuiteFilter(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChecksListForSuiteFilter`, d.Next())
	}
}

// Encode encodes ChecksListForSuiteStatus as json.
func (o OptChecksListForSuiteStatus) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ChecksListForSuiteStatus from json.
func (o *OptChecksListForSuiteStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptChecksListForSuiteStatus to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ChecksListForSuiteStatus(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptChecksListForSuiteStatus`, d.Next())
	}
}

// Encode encodes CodeOfConduct as json.
func (o OptCodeOfConduct) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes CodeOfConduct from json.
func (o *OptCodeOfConduct) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeOfConduct to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeOfConduct`, d.Next())
	}
}

// Encode encodes CodeOfConductSimple as json.
func (o OptCodeOfConductSimple) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes CodeOfConductSimple from json.
func (o *OptCodeOfConductSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeOfConductSimple to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeOfConductSimple`, d.Next())
	}
}

// Encode encodes CodeScanningAlertEnvironment as json.
func (o OptCodeScanningAlertEnvironment) Encode(e *jx.Encoder) {
}

// Decode decodes CodeScanningAlertEnvironment from json.
func (o *OptCodeScanningAlertEnvironment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningAlertEnvironment to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningAlertEnvironment`, d.Next())
	}
}

// Encode encodes CodeScanningAlertInstanceMessage as json.
func (o OptCodeScanningAlertInstanceMessage) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAlertInstanceMessage from json.
func (o *OptCodeScanningAlertInstanceMessage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningAlertInstanceMessage to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningAlertInstanceMessage`, d.Next())
	}
}

// Encode encodes CodeScanningAlertLocation as json.
func (o OptCodeScanningAlertLocation) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes CodeScanningAlertLocation from json.
func (o *OptCodeScanningAlertLocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningAlertLocation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningAlertLocation`, d.Next())
	}
}

// Encode encodes CodeScanningAlertState as json.
func (o OptCodeScanningAlertState) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertState from json.
func (o *OptCodeScanningAlertState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningAlertState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = CodeScanningAlertState(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningAlertState`, d.Next())
	}
}

// Encode encodes CodeScanningAnalysisAnalysisKey as json.
func (o OptCodeScanningAnalysisAnalysisKey) Encode(e *jx.Encoder) {
}

// Decode decodes CodeScanningAnalysisAnalysisKey from json.
func (o *OptCodeScanningAnalysisAnalysisKey) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningAnalysisAnalysisKey to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningAnalysisAnalysisKey`, d.Next())
	}
}

// Encode encodes CodeScanningAnalysisCategory as json.
func (o OptCodeScanningAnalysisCategory) Encode(e *jx.Encoder) {
}

// Decode decodes CodeScanningAnalysisCategory from json.
func (o *OptCodeScanningAnalysisCategory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningAnalysisCategory to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningAnalysisCategory`, d.Next())
	}
}

// Encode encodes CodeScanningAnalysisSarifID as json.
func (o OptCodeScanningAnalysisSarifID) Encode(e *jx.Encoder) {
}

// Decode decodes CodeScanningAnalysisSarifID from json.
func (o *OptCodeScanningAnalysisSarifID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningAnalysisSarifID to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningAnalysisSarifID`, d.Next())
	}
}

// Encode encodes CodeScanningAnalysisToolName as json.
func (o OptCodeScanningAnalysisToolName) Encode(e *jx.Encoder) {
}

// Decode decodes CodeScanningAnalysisToolName from json.
func (o *OptCodeScanningAnalysisToolName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningAnalysisToolName to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningAnalysisToolName`, d.Next())
	}
}

// Encode encodes CodeScanningRef as json.
func (o OptCodeScanningRef) Encode(e *jx.Encoder) {
}

// Decode decodes CodeScanningRef from json.
func (o *OptCodeScanningRef) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningRef to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningRef`, d.Next())
	}
}

// Encode encodes CodeScanningSarifsStatusProcessingStatus as json.
func (o OptCodeScanningSarifsStatusProcessingStatus) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningSarifsStatusProcessingStatus from json.
func (o *OptCodeScanningSarifsStatusProcessingStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCodeScanningSarifsStatusProcessingStatus to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = CodeScanningSarifsStatusProcessingStatus(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCodeScanningSarifsStatusProcessingStatus`, d.Next())
	}
}

// Encode encodes CollaboratorPermissions as json.
func (o OptCollaboratorPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes CollaboratorPermissions from json.
func (o *OptCollaboratorPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCollaboratorPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCollaboratorPermissions`, d.Next())
	}
}

// Encode encodes CommitStats as json.
func (o OptCommitStats) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes CommitStats from json.
func (o *OptCommitStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptCommitStats to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptCommitStats`, d.Next())
	}
}

// Encode encodes DeploymentReviewerType as json.
func (o OptDeploymentReviewerType) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes DeploymentReviewerType from json.
func (o *OptDeploymentReviewerType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptDeploymentReviewerType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = DeploymentReviewerType(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptDeploymentReviewerType`, d.Next())
	}
}

// Encode encodes DeploymentSimple as json.
func (o OptDeploymentSimple) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes DeploymentSimple from json.
func (o *OptDeploymentSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptDeploymentSimple to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptDeploymentSimple`, d.Next())
	}
}

// Encode encodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility as json.
func (o OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility from json.
func (o *OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseReqVisibility`, d.Next())
	}
}

// Encode encodes EnterpriseAdminGetAuditLogInclude as json.
func (o OptEnterpriseAdminGetAuditLogInclude) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes EnterpriseAdminGetAuditLogInclude from json.
func (o *OptEnterpriseAdminGetAuditLogInclude) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptEnterpriseAdminGetAuditLogInclude to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = EnterpriseAdminGetAuditLogInclude(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptEnterpriseAdminGetAuditLogInclude`, d.Next())
	}
}

// Encode encodes EnterpriseAdminGetAuditLogOrder as json.
func (o OptEnterpriseAdminGetAuditLogOrder) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes EnterpriseAdminGetAuditLogOrder from json.
func (o *OptEnterpriseAdminGetAuditLogOrder) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptEnterpriseAdminGetAuditLogOrder to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = EnterpriseAdminGetAuditLogOrder(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptEnterpriseAdminGetAuditLogOrder`, d.Next())
	}
}

// Encode encodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility as json.
func (o OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility from json.
func (o *OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseReqVisibility`, d.Next())
	}
}

// Encode encodes FileCommitCommitAuthor as json.
func (o OptFileCommitCommitAuthor) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes FileCommitCommitAuthor from json.
func (o *OptFileCommitCommitAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFileCommitCommitAuthor to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFileCommitCommitAuthor`, d.Next())
	}
}

// Encode encodes FileCommitCommitCommitter as json.
func (o OptFileCommitCommitCommitter) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes FileCommitCommitCommitter from json.
func (o *OptFileCommitCommitCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFileCommitCommitCommitter to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFileCommitCommitCommitter`, d.Next())
	}
}

// Encode encodes FileCommitCommitTree as json.
func (o OptFileCommitCommitTree) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes FileCommitCommitTree from json.
func (o *OptFileCommitCommitTree) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFileCommitCommitTree to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFileCommitCommitTree`, d.Next())
	}
}

// Encode encodes FileCommitCommitVerification as json.
func (o OptFileCommitCommitVerification) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes FileCommitCommitVerification from json.
func (o *OptFileCommitCommitVerification) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFileCommitCommitVerification to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFileCommitCommitVerification`, d.Next())
	}
}

// Encode encodes FileCommitContentLinks as json.
func (o OptFileCommitContentLinks) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes FileCommitContentLinks from json.
func (o *OptFileCommitContentLinks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFileCommitContentLinks to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFileCommitContentLinks`, d.Next())
	}
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFloat64 to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Float64()
		if err != nil {
			return err
		}
		o.Value = float64(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFloat64`, d.Next())
	}
}

// Encode encodes ForbiddenGistBlock as json.
func (o OptForbiddenGistBlock) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ForbiddenGistBlock from json.
func (o *OptForbiddenGistBlock) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptForbiddenGistBlock to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptForbiddenGistBlock`, d.Next())
	}
}

// Encode encodes FullRepositoryPermissions as json.
func (o OptFullRepositoryPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes FullRepositoryPermissions from json.
func (o *OptFullRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFullRepositoryPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFullRepositoryPermissions`, d.Next())
	}
}

// Encode encodes FullRepositorySecurityAndAnalysisAdvancedSecurity as json.
func (o OptFullRepositorySecurityAndAnalysisAdvancedSecurity) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes FullRepositorySecurityAndAnalysisAdvancedSecurity from json.
func (o *OptFullRepositorySecurityAndAnalysisAdvancedSecurity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFullRepositorySecurityAndAnalysisAdvancedSecurity to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFullRepositorySecurityAndAnalysisAdvancedSecurity`, d.Next())
	}
}

// Encode encodes FullRepositorySecurityAndAnalysisAdvancedSecurityStatus as json.
func (o OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes FullRepositorySecurityAndAnalysisAdvancedSecurityStatus from json.
func (o *OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = FullRepositorySecurityAndAnalysisAdvancedSecurityStatus(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFullRepositorySecurityAndAnalysisAdvancedSecurityStatus`, d.Next())
	}
}

// Encode encodes FullRepositorySecurityAndAnalysisSecretScanning as json.
func (o OptFullRepositorySecurityAndAnalysisSecretScanning) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes FullRepositorySecurityAndAnalysisSecretScanning from json.
func (o *OptFullRepositorySecurityAndAnalysisSecretScanning) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFullRepositorySecurityAndAnalysisSecretScanning to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFullRepositorySecurityAndAnalysisSecretScanning`, d.Next())
	}
}

// Encode encodes FullRepositorySecurityAndAnalysisSecretScanningStatus as json.
func (o OptFullRepositorySecurityAndAnalysisSecretScanningStatus) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes FullRepositorySecurityAndAnalysisSecretScanningStatus from json.
func (o *OptFullRepositorySecurityAndAnalysisSecretScanningStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptFullRepositorySecurityAndAnalysisSecretScanningStatus to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = FullRepositorySecurityAndAnalysisSecretScanningStatus(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptFullRepositorySecurityAndAnalysisSecretScanningStatus`, d.Next())
	}
}

// Encode encodes GistHistoryChangeStatus as json.
func (o OptGistHistoryChangeStatus) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes GistHistoryChangeStatus from json.
func (o *OptGistHistoryChangeStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGistHistoryChangeStatus to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGistHistoryChangeStatus`, d.Next())
	}
}

// Encode encodes GitCreateCommitReqAuthor as json.
func (o OptGitCreateCommitReqAuthor) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes GitCreateCommitReqAuthor from json.
func (o *OptGitCreateCommitReqAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGitCreateCommitReqAuthor to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGitCreateCommitReqAuthor`, d.Next())
	}
}

// Encode encodes GitCreateCommitReqCommitter as json.
func (o OptGitCreateCommitReqCommitter) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes GitCreateCommitReqCommitter from json.
func (o *OptGitCreateCommitReqCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGitCreateCommitReqCommitter to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGitCreateCommitReqCommitter`, d.Next())
	}
}

// Encode encodes GitCreateTagReqTagger as json.
func (o OptGitCreateTagReqTagger) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes GitCreateTagReqTagger from json.
func (o *OptGitCreateTagReqTagger) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGitCreateTagReqTagger to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGitCreateTagReqTagger`, d.Next())
	}
}

// Encode encodes GitCreateTreeReqTreeItemMode as json.
func (o OptGitCreateTreeReqTreeItemMode) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes GitCreateTreeReqTreeItemMode from json.
func (o *OptGitCreateTreeReqTreeItemMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGitCreateTreeReqTreeItemMode to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = GitCreateTreeReqTreeItemMode(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGitCreateTreeReqTreeItemMode`, d.Next())
	}
}

// Encode encodes GitCreateTreeReqTreeItemType as json.
func (o OptGitCreateTreeReqTreeItemType) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes GitCreateTreeReqTreeItemType from json.
func (o *OptGitCreateTreeReqTreeItemType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptGitCreateTreeReqTreeItemType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = GitCreateTreeReqTreeItemType(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptGitCreateTreeReqTreeItemType`, d.Next())
	}
}

// Encode encodes InstallationTokenRepositorySelection as json.
func (o OptInstallationTokenRepositorySelection) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes InstallationTokenRepositorySelection from json.
func (o *OptInstallationTokenRepositorySelection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInstallationTokenRepositorySelection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = InstallationTokenRepositorySelection(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInstallationTokenRepositorySelection`, d.Next())
	}
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInt to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int()
		if err != nil {
			return err
		}
		o.Value = int(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInt`, d.Next())
	}
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInt64 to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		v, err := d.Int64()
		if err != nil {
			return err
		}
		o.Value = int64(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInt64`, d.Next())
	}
}

// Encode encodes InteractionExpiry as json.
func (o OptInteractionExpiry) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes InteractionExpiry from json.
func (o *OptInteractionExpiry) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptInteractionExpiry to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = InteractionExpiry(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptInteractionExpiry`, d.Next())
	}
}

// Encode encodes IssueComment as json.
func (o OptIssueComment) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes IssueComment from json.
func (o *OptIssueComment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueComment to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueComment`, d.Next())
	}
}

// Encode encodes IssueEventDismissedReview as json.
func (o OptIssueEventDismissedReview) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes IssueEventDismissedReview from json.
func (o *OptIssueEventDismissedReview) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueEventDismissedReview to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueEventDismissedReview`, d.Next())
	}
}

// Encode encodes IssueEventLabel as json.
func (o OptIssueEventLabel) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes IssueEventLabel from json.
func (o *OptIssueEventLabel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueEventLabel to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueEventLabel`, d.Next())
	}
}

// Encode encodes IssueEventMilestone as json.
func (o OptIssueEventMilestone) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes IssueEventMilestone from json.
func (o *OptIssueEventMilestone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueEventMilestone to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueEventMilestone`, d.Next())
	}
}

// Encode encodes IssueEventProjectCard as json.
func (o OptIssueEventProjectCard) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes IssueEventProjectCard from json.
func (o *OptIssueEventProjectCard) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueEventProjectCard to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueEventProjectCard`, d.Next())
	}
}

// Encode encodes IssueEventRename as json.
func (o OptIssueEventRename) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes IssueEventRename from json.
func (o *OptIssueEventRename) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueEventRename to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueEventRename`, d.Next())
	}
}

// Encode encodes IssueSearchResultItemPullRequest as json.
func (o OptIssueSearchResultItemPullRequest) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes IssueSearchResultItemPullRequest from json.
func (o *OptIssueSearchResultItemPullRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueSearchResultItemPullRequest to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueSearchResultItemPullRequest`, d.Next())
	}
}

// Encode encodes IssueSimple as json.
func (o OptIssueSimple) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes IssueSimple from json.
func (o *OptIssueSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueSimple to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueSimple`, d.Next())
	}
}

// Encode encodes IssueSimplePullRequest as json.
func (o OptIssueSimplePullRequest) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes IssueSimplePullRequest from json.
func (o *OptIssueSimplePullRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssueSimplePullRequest to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssueSimplePullRequest`, d.Next())
	}
}

// Encode encodes IssuesCreateMilestoneReqState as json.
func (o OptIssuesCreateMilestoneReqState) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesCreateMilestoneReqState from json.
func (o *OptIssuesCreateMilestoneReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesCreateMilestoneReqState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = IssuesCreateMilestoneReqState(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesCreateMilestoneReqState`, d.Next())
	}
}

// Encode encodes IssuesListMilestonesDirection as json.
func (o OptIssuesListMilestonesDirection) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListMilestonesDirection from json.
func (o *OptIssuesListMilestonesDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListMilestonesDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = IssuesListMilestonesDirection(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListMilestonesDirection`, d.Next())
	}
}

// Encode encodes IssuesListMilestonesSort as json.
func (o OptIssuesListMilestonesSort) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListMilestonesSort from json.
func (o *OptIssuesListMilestonesSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListMilestonesSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = IssuesListMilestonesSort(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListMilestonesSort`, d.Next())
	}
}

// Encode encodes IssuesListMilestonesState as json.
func (o OptIssuesListMilestonesState) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesListMilestonesState from json.
func (o *OptIssuesListMilestonesState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesListMilestonesState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = IssuesListMilestonesState(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesListMilestonesState`, d.Next())
	}
}

// Encode encodes IssuesLockReqLockReason as json.
func (o OptIssuesLockReqLockReason) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesLockReqLockReason from json.
func (o *OptIssuesLockReqLockReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesLockReqLockReason to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = IssuesLockReqLockReason(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesLockReqLockReason`, d.Next())
	}
}

// Encode encodes IssuesUpdateMilestoneReqState as json.
func (o OptIssuesUpdateMilestoneReqState) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes IssuesUpdateMilestoneReqState from json.
func (o *OptIssuesUpdateMilestoneReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptIssuesUpdateMilestoneReqState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = IssuesUpdateMilestoneReqState(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptIssuesUpdateMilestoneReqState`, d.Next())
	}
}

// Encode encodes LinkWithType as json.
func (o OptLinkWithType) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes LinkWithType from json.
func (o *OptLinkWithType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptLinkWithType to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptLinkWithType`, d.Next())
	}
}

// Encode encodes MarkdownRenderReqMode as json.
func (o OptMarkdownRenderReqMode) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes MarkdownRenderReqMode from json.
func (o *OptMarkdownRenderReqMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMarkdownRenderReqMode to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = MarkdownRenderReqMode(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMarkdownRenderReqMode`, d.Next())
	}
}

// Encode encodes MarketplaceListingPlan as json.
func (o OptMarketplaceListingPlan) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes MarketplaceListingPlan from json.
func (o *OptMarketplaceListingPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMarketplaceListingPlan to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMarketplaceListingPlan`, d.Next())
	}
}

// Encode encodes MergedUpstreamMergeType as json.
func (o OptMergedUpstreamMergeType) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes MergedUpstreamMergeType from json.
func (o *OptMergedUpstreamMergeType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMergedUpstreamMergeType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = MergedUpstreamMergeType(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMergedUpstreamMergeType`, d.Next())
	}
}

// Encode encodes MigrationsStartImportReqVcs as json.
func (o OptMigrationsStartImportReqVcs) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes MigrationsStartImportReqVcs from json.
func (o *OptMigrationsStartImportReqVcs) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMigrationsStartImportReqVcs to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = MigrationsStartImportReqVcs(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMigrationsStartImportReqVcs`, d.Next())
	}
}

// Encode encodes MinimalRepository as json.
func (o OptMinimalRepository) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes MinimalRepository from json.
func (o *OptMinimalRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMinimalRepository to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMinimalRepository`, d.Next())
	}
}

// Encode encodes MinimalRepositoryPermissions as json.
func (o OptMinimalRepositoryPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes MinimalRepositoryPermissions from json.
func (o *OptMinimalRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptMinimalRepositoryPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptMinimalRepositoryPermissions`, d.Next())
	}
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilBool to nil`)
	}
	switch d.Next() {
	case jx.Bool:
		o.Set = true
		o.Null = false
		v, err := d.Bool()
		if err != nil {
			return err
		}
		o.Value = bool(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilBool`, d.Next())
	}
}

// Encode encodes CodeScanningAlertDismissedReason as json.
func (o OptNilCodeScanningAlertDismissedReason) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertDismissedReason from json.
func (o *OptNilCodeScanningAlertDismissedReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilCodeScanningAlertDismissedReason to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = CodeScanningAlertDismissedReason(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertDismissedReason
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilCodeScanningAlertDismissedReason`, d.Next())
	}
}

// Encode encodes CodeScanningAlertRuleSecuritySeverityLevel as json.
func (o OptNilCodeScanningAlertRuleSecuritySeverityLevel) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertRuleSecuritySeverityLevel from json.
func (o *OptNilCodeScanningAlertRuleSecuritySeverityLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilCodeScanningAlertRuleSecuritySeverityLevel to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = CodeScanningAlertRuleSecuritySeverityLevel(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertRuleSecuritySeverityLevel
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilCodeScanningAlertRuleSecuritySeverityLevel`, d.Next())
	}
}

// Encode encodes CodeScanningAlertRuleSeverity as json.
func (o OptNilCodeScanningAlertRuleSeverity) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertRuleSeverity from json.
func (o *OptNilCodeScanningAlertRuleSeverity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilCodeScanningAlertRuleSeverity to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = CodeScanningAlertRuleSeverity(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertRuleSeverity
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilCodeScanningAlertRuleSeverity`, d.Next())
	}
}

// Encode encodes CodeScanningAlertRuleSummarySeverity as json.
func (o OptNilCodeScanningAlertRuleSummarySeverity) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CodeScanningAlertRuleSummarySeverity from json.
func (o *OptNilCodeScanningAlertRuleSummarySeverity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilCodeScanningAlertRuleSummarySeverity to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = CodeScanningAlertRuleSummarySeverity(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAlertRuleSummarySeverity
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilCodeScanningAlertRuleSummarySeverity`, d.Next())
	}
}

// Encode encodes CodeScanningAnalysisToolGUID as json.
func (o OptNilCodeScanningAnalysisToolGUID) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes CodeScanningAnalysisToolGUID from json.
func (o *OptNilCodeScanningAnalysisToolGUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilCodeScanningAnalysisToolGUID to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAnalysisToolGUID
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilCodeScanningAnalysisToolGUID`, d.Next())
	}
}

// Encode encodes CodeScanningAnalysisToolVersion as json.
func (o OptNilCodeScanningAnalysisToolVersion) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes CodeScanningAnalysisToolVersion from json.
func (o *OptNilCodeScanningAnalysisToolVersion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilCodeScanningAnalysisToolVersion to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v CodeScanningAnalysisToolVersion
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilCodeScanningAnalysisToolVersion`, d.Next())
	}
}

// Encode encodes DeploymentBranchPolicy as json.
func (o OptNilDeploymentBranchPolicy) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeploymentBranchPolicy from json.
func (o *OptNilDeploymentBranchPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilDeploymentBranchPolicy to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v DeploymentBranchPolicy
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilDeploymentBranchPolicy`, d.Next())
	}
}

// Encode encodes FullRepositorySecurityAndAnalysis as json.
func (o OptNilFullRepositorySecurityAndAnalysis) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FullRepositorySecurityAndAnalysis from json.
func (o *OptNilFullRepositorySecurityAndAnalysis) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilFullRepositorySecurityAndAnalysis to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v FullRepositorySecurityAndAnalysis
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilFullRepositorySecurityAndAnalysis`, d.Next())
	}
}

// Encode encodes []GistHistory as json.
func (o OptNilGistHistoryArray) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []GistHistory from json.
func (o *OptNilGistHistoryArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilGistHistoryArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []GistHistory
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilGistHistoryArray`, d.Next())
	}
}

// Encode encodes GistSimpleForkOf as json.
func (o OptNilGistSimpleForkOf) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GistSimpleForkOf from json.
func (o *OptNilGistSimpleForkOf) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilGistSimpleForkOf to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v GistSimpleForkOf
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilGistSimpleForkOf`, d.Next())
	}
}

// Encode encodes []GistSimpleForksItem as json.
func (o OptNilGistSimpleForksItemArray) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []GistSimpleForksItem from json.
func (o *OptNilGistSimpleForksItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilGistSimpleForksItemArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []GistSimpleForksItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilGistSimpleForksItemArray`, d.Next())
	}
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilInt to nil`)
	}
	switch d.Next() {
	case jx.Number:
		o.Set = true
		o.Null = false
		v, err := d.Int()
		if err != nil {
			return err
		}
		o.Value = int(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilInt`, d.Next())
	}
}

// Encode encodes MarketplacePurchaseMarketplacePendingChange as json.
func (o OptNilMarketplacePurchaseMarketplacePendingChange) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MarketplacePurchaseMarketplacePendingChange from json.
func (o *OptNilMarketplacePurchaseMarketplacePendingChange) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilMarketplacePurchaseMarketplacePendingChange to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v MarketplacePurchaseMarketplacePendingChange
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilMarketplacePurchaseMarketplacePendingChange`, d.Next())
	}
}

// Encode encodes MinimalRepositoryLicense as json.
func (o OptNilMinimalRepositoryLicense) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MinimalRepositoryLicense from json.
func (o *OptNilMinimalRepositoryLicense) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilMinimalRepositoryLicense to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v MinimalRepositoryLicense
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilMinimalRepositoryLicense`, d.Next())
	}
}

// Encode encodes NullableIntegration as json.
func (o OptNilNullableIntegration) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableIntegration from json.
func (o *OptNilNullableIntegration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilNullableIntegration to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableIntegration
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilNullableIntegration`, d.Next())
	}
}

// Encode encodes NullableMinimalRepository as json.
func (o OptNilNullableMinimalRepository) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableMinimalRepository from json.
func (o *OptNilNullableMinimalRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilNullableMinimalRepository to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableMinimalRepository
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilNullableMinimalRepository`, d.Next())
	}
}

// Encode encodes NullableMinimalRepositoryLicense as json.
func (o OptNilNullableMinimalRepositoryLicense) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableMinimalRepositoryLicense from json.
func (o *OptNilNullableMinimalRepositoryLicense) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilNullableMinimalRepositoryLicense to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableMinimalRepositoryLicense
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilNullableMinimalRepositoryLicense`, d.Next())
	}
}

// Encode encodes NullableRepository as json.
func (o OptNilNullableRepository) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableRepository from json.
func (o *OptNilNullableRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilNullableRepository to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableRepository
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilNullableRepository`, d.Next())
	}
}

// Encode encodes NullableRepositoryTemplateRepository as json.
func (o OptNilNullableRepositoryTemplateRepository) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableRepositoryTemplateRepository from json.
func (o *OptNilNullableRepositoryTemplateRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilNullableRepositoryTemplateRepository to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableRepositoryTemplateRepository
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilNullableRepositoryTemplateRepository`, d.Next())
	}
}

// Encode encodes NullableScopedInstallation as json.
func (o OptNilNullableScopedInstallation) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableScopedInstallation from json.
func (o *OptNilNullableScopedInstallation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilNullableScopedInstallation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableScopedInstallation
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilNullableScopedInstallation`, d.Next())
	}
}

// Encode encodes NullableSimpleUser as json.
func (o OptNilNullableSimpleUser) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableSimpleUser from json.
func (o *OptNilNullableSimpleUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilNullableSimpleUser to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableSimpleUser
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilNullableSimpleUser`, d.Next())
	}
}

// Encode encodes NullableTeamSimple as json.
func (o OptNilNullableTeamSimple) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NullableTeamSimple from json.
func (o *OptNilNullableTeamSimple) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilNullableTeamSimple to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v NullableTeamSimple
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilNullableTeamSimple`, d.Next())
	}
}

// Encode encodes PageProtectedDomainState as json.
func (o OptNilPageProtectedDomainState) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PageProtectedDomainState from json.
func (o *OptNilPageProtectedDomainState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilPageProtectedDomainState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PageProtectedDomainState(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PageProtectedDomainState
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilPageProtectedDomainState`, d.Next())
	}
}

// Encode encodes PagesHealthCheckAltDomain as json.
func (o OptNilPagesHealthCheckAltDomain) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PagesHealthCheckAltDomain from json.
func (o *OptNilPagesHealthCheckAltDomain) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilPagesHealthCheckAltDomain to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PagesHealthCheckAltDomain
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilPagesHealthCheckAltDomain`, d.Next())
	}
}

// Encode encodes PullRequestReviewCommentStartSide as json.
func (o OptNilPullRequestReviewCommentStartSide) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PullRequestReviewCommentStartSide from json.
func (o *OptNilPullRequestReviewCommentStartSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilPullRequestReviewCommentStartSide to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PullRequestReviewCommentStartSide(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v PullRequestReviewCommentStartSide
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilPullRequestReviewCommentStartSide`, d.Next())
	}
}

// Encode encodes []ReposCreateOrUpdateEnvironmentReqReviewersItem as json.
func (o OptNilReposCreateOrUpdateEnvironmentReqReviewersItemArray) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []ReposCreateOrUpdateEnvironmentReqReviewersItem from json.
func (o *OptNilReposCreateOrUpdateEnvironmentReqReviewersItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilReposCreateOrUpdateEnvironmentReqReviewersItemArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []ReposCreateOrUpdateEnvironmentReqReviewersItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilReposCreateOrUpdateEnvironmentReqReviewersItemArray`, d.Next())
	}
}

// Encode encodes ReposUpdateReqSecurityAndAnalysis as json.
func (o OptNilReposUpdateReqSecurityAndAnalysis) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReqSecurityAndAnalysis from json.
func (o *OptNilReposUpdateReqSecurityAndAnalysis) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilReposUpdateReqSecurityAndAnalysis to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v ReposUpdateReqSecurityAndAnalysis
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilReposUpdateReqSecurityAndAnalysis`, d.Next())
	}
}

// Encode encodes RepositoryTemplateRepository as json.
func (o OptNilRepositoryTemplateRepository) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RepositoryTemplateRepository from json.
func (o *OptNilRepositoryTemplateRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilRepositoryTemplateRepository to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		o.Null = false
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v RepositoryTemplateRepository
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilRepositoryTemplateRepository`, d.Next())
	}
}

// Encode encodes ReviewCommentStartSide as json.
func (o OptNilReviewCommentStartSide) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ReviewCommentStartSide from json.
func (o *OptNilReviewCommentStartSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilReviewCommentStartSide to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReviewCommentStartSide(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v ReviewCommentStartSide
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilReviewCommentStartSide`, d.Next())
	}
}

// Encode encodes SecretScanningAlertResolution as json.
func (o OptNilSecretScanningAlertResolution) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SecretScanningAlertResolution from json.
func (o *OptNilSecretScanningAlertResolution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilSecretScanningAlertResolution to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = SecretScanningAlertResolution(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v SecretScanningAlertResolution
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilSecretScanningAlertResolution`, d.Next())
	}
}

// Encode encodes []SimpleUser as json.
func (o OptNilSimpleUserArray) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []SimpleUser from json.
func (o *OptNilSimpleUserArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilSimpleUserArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []SimpleUser
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilSimpleUserArray`, d.Next())
	}
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilString to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilString`, d.Next())
	}
}

// Encode encodes []string as json.
func (o OptNilStringArray) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []string from json.
func (o *OptNilStringArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilStringArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilStringArray`, d.Next())
	}
}

// Encode encodes []Team as json.
func (o OptNilTeamArray) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []Team from json.
func (o *OptNilTeamArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilTeamArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []Team
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilTeamArray`, d.Next())
	}
}

// Encode encodes []TeamSimple as json.
func (o OptNilTeamSimpleArray) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []TeamSimple from json.
func (o *OptNilTeamSimpleArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilTeamSimpleArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []TeamSimple
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilTeamSimpleArray`, d.Next())
	}
}

// Encode encodes time.Time as json.
func (o OptNilTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilTime to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := format(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilTime`, d.Next())
	}
}

// Encode encodes []TopicSearchResultItemAliasesItem as json.
func (o OptNilTopicSearchResultItemAliasesItemArray) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []TopicSearchResultItemAliasesItem from json.
func (o *OptNilTopicSearchResultItemAliasesItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilTopicSearchResultItemAliasesItemArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []TopicSearchResultItemAliasesItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilTopicSearchResultItemAliasesItemArray`, d.Next())
	}
}

// Encode encodes []TopicSearchResultItemRelatedItem as json.
func (o OptNilTopicSearchResultItemRelatedItemArray) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
}

// Decode decodes []TopicSearchResultItemRelatedItem from json.
func (o *OptNilTopicSearchResultItemRelatedItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilTopicSearchResultItemRelatedItemArray to nil`)
	}
	switch d.Next() {
	case jx.Array:
		o.Set = true
		o.Null = false
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v []TopicSearchResultItemRelatedItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilTopicSearchResultItemRelatedItemArray`, d.Next())
	}
}

// Encode encodes url.URL as json.
func (o OptNilURL) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptNilURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNilURL to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		o.Null = false
		v, err := json.DecodeURI(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	case jx.Null:
		if err := d.Null(); err != nil {
			return err
		}
		var v url.URL
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNilURL`, d.Next())
	}
}

// Encode encodes NullableMinimalRepositoryPermissions as json.
func (o OptNullableMinimalRepositoryPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes NullableMinimalRepositoryPermissions from json.
func (o *OptNullableMinimalRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNullableMinimalRepositoryPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNullableMinimalRepositoryPermissions`, d.Next())
	}
}

// Encode encodes NullableRepositoryPermissions as json.
func (o OptNullableRepositoryPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes NullableRepositoryPermissions from json.
func (o *OptNullableRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNullableRepositoryPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNullableRepositoryPermissions`, d.Next())
	}
}

// Encode encodes NullableRepositoryTemplateRepositoryOwner as json.
func (o OptNullableRepositoryTemplateRepositoryOwner) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes NullableRepositoryTemplateRepositoryOwner from json.
func (o *OptNullableRepositoryTemplateRepositoryOwner) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNullableRepositoryTemplateRepositoryOwner to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNullableRepositoryTemplateRepositoryOwner`, d.Next())
	}
}

// Encode encodes NullableRepositoryTemplateRepositoryPermissions as json.
func (o OptNullableRepositoryTemplateRepositoryPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes NullableRepositoryTemplateRepositoryPermissions from json.
func (o *OptNullableRepositoryTemplateRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptNullableRepositoryTemplateRepositoryPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptNullableRepositoryTemplateRepositoryPermissions`, d.Next())
	}
}

// Encode encodes OrgMembershipPermissions as json.
func (o OptOrgMembershipPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes OrgMembershipPermissions from json.
func (o *OptOrgMembershipPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgMembershipPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgMembershipPermissions`, d.Next())
	}
}

// Encode encodes OrganizationFullPlan as json.
func (o OptOrganizationFullPlan) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes OrganizationFullPlan from json.
func (o *OptOrganizationFullPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrganizationFullPlan to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrganizationFullPlan`, d.Next())
	}
}

// Encode encodes OrgsCreateInvitationReqRole as json.
func (o OptOrgsCreateInvitationReqRole) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsCreateInvitationReqRole from json.
func (o *OptOrgsCreateInvitationReqRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsCreateInvitationReqRole to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = OrgsCreateInvitationReqRole(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsCreateInvitationReqRole`, d.Next())
	}
}

// Encode encodes OrgsGetAuditLogInclude as json.
func (o OptOrgsGetAuditLogInclude) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsGetAuditLogInclude from json.
func (o *OptOrgsGetAuditLogInclude) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsGetAuditLogInclude to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = OrgsGetAuditLogInclude(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsGetAuditLogInclude`, d.Next())
	}
}

// Encode encodes OrgsGetAuditLogOrder as json.
func (o OptOrgsGetAuditLogOrder) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsGetAuditLogOrder from json.
func (o *OptOrgsGetAuditLogOrder) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsGetAuditLogOrder to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = OrgsGetAuditLogOrder(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsGetAuditLogOrder`, d.Next())
	}
}

// Encode encodes OrgsListOutsideCollaboratorsFilter as json.
func (o OptOrgsListOutsideCollaboratorsFilter) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsListOutsideCollaboratorsFilter from json.
func (o *OptOrgsListOutsideCollaboratorsFilter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsListOutsideCollaboratorsFilter to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = OrgsListOutsideCollaboratorsFilter(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsListOutsideCollaboratorsFilter`, d.Next())
	}
}

// Encode encodes OrgsSetMembershipForUserReqRole as json.
func (o OptOrgsSetMembershipForUserReqRole) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsSetMembershipForUserReqRole from json.
func (o *OptOrgsSetMembershipForUserReqRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsSetMembershipForUserReqRole to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = OrgsSetMembershipForUserReqRole(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsSetMembershipForUserReqRole`, d.Next())
	}
}

// Encode encodes OrgsUpdateReqDefaultRepositoryPermission as json.
func (o OptOrgsUpdateReqDefaultRepositoryPermission) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsUpdateReqDefaultRepositoryPermission from json.
func (o *OptOrgsUpdateReqDefaultRepositoryPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsUpdateReqDefaultRepositoryPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = OrgsUpdateReqDefaultRepositoryPermission(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsUpdateReqDefaultRepositoryPermission`, d.Next())
	}
}

// Encode encodes OrgsUpdateReqMembersAllowedRepositoryCreationType as json.
func (o OptOrgsUpdateReqMembersAllowedRepositoryCreationType) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes OrgsUpdateReqMembersAllowedRepositoryCreationType from json.
func (o *OptOrgsUpdateReqMembersAllowedRepositoryCreationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsUpdateReqMembersAllowedRepositoryCreationType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = OrgsUpdateReqMembersAllowedRepositoryCreationType(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsUpdateReqMembersAllowedRepositoryCreationType`, d.Next())
	}
}

// Encode encodes OrgsUpdateWebhookReqConfig as json.
func (o OptOrgsUpdateWebhookReqConfig) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes OrgsUpdateWebhookReqConfig from json.
func (o *OptOrgsUpdateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptOrgsUpdateWebhookReqConfig to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptOrgsUpdateWebhookReqConfig`, d.Next())
	}
}

// Encode encodes PackageVersionMetadata as json.
func (o OptPackageVersionMetadata) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes PackageVersionMetadata from json.
func (o *OptPackageVersionMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPackageVersionMetadata to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPackageVersionMetadata`, d.Next())
	}
}

// Encode encodes PackageVersionMetadataContainer as json.
func (o OptPackageVersionMetadataContainer) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes PackageVersionMetadataContainer from json.
func (o *OptPackageVersionMetadataContainer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPackageVersionMetadataContainer to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPackageVersionMetadataContainer`, d.Next())
	}
}

// Encode encodes PackageVersionMetadataDocker as json.
func (o OptPackageVersionMetadataDocker) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes PackageVersionMetadataDocker from json.
func (o *OptPackageVersionMetadataDocker) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPackageVersionMetadataDocker to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPackageVersionMetadataDocker`, d.Next())
	}
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState as json.
func (o OptPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState from json.
func (o *OptPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState`, d.Next())
	}
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgState as json.
func (o OptPackagesGetAllPackageVersionsForPackageOwnedByOrgState) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgState from json.
func (o *OptPackagesGetAllPackageVersionsForPackageOwnedByOrgState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPackagesGetAllPackageVersionsForPackageOwnedByOrgState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PackagesGetAllPackageVersionsForPackageOwnedByOrgState(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPackagesGetAllPackageVersionsForPackageOwnedByOrgState`, d.Next())
	}
}

// Encode encodes PackagesListPackagesForAuthenticatedUserVisibility as json.
func (o OptPackagesListPackagesForAuthenticatedUserVisibility) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes PackagesListPackagesForAuthenticatedUserVisibility from json.
func (o *OptPackagesListPackagesForAuthenticatedUserVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPackagesListPackagesForAuthenticatedUserVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PackagesListPackagesForAuthenticatedUserVisibility(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPackagesListPackagesForAuthenticatedUserVisibility`, d.Next())
	}
}

// Encode encodes PackagesListPackagesForOrganizationVisibility as json.
func (o OptPackagesListPackagesForOrganizationVisibility) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes PackagesListPackagesForOrganizationVisibility from json.
func (o *OptPackagesListPackagesForOrganizationVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPackagesListPackagesForOrganizationVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PackagesListPackagesForOrganizationVisibility(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPackagesListPackagesForOrganizationVisibility`, d.Next())
	}
}

// Encode encodes PackagesListPackagesForUserVisibility as json.
func (o OptPackagesListPackagesForUserVisibility) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes PackagesListPackagesForUserVisibility from json.
func (o *OptPackagesListPackagesForUserVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPackagesListPackagesForUserVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PackagesListPackagesForUserVisibility(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPackagesListPackagesForUserVisibility`, d.Next())
	}
}

// Encode encodes PagesHTTPSCertificate as json.
func (o OptPagesHTTPSCertificate) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes PagesHTTPSCertificate from json.
func (o *OptPagesHTTPSCertificate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPagesHTTPSCertificate to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPagesHTTPSCertificate`, d.Next())
	}
}

// Encode encodes PagesHealthCheckDomain as json.
func (o OptPagesHealthCheckDomain) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes PagesHealthCheckDomain from json.
func (o *OptPagesHealthCheckDomain) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPagesHealthCheckDomain to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPagesHealthCheckDomain`, d.Next())
	}
}

// Encode encodes PagesSourceHash as json.
func (o OptPagesSourceHash) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes PagesSourceHash from json.
func (o *OptPagesSourceHash) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPagesSourceHash to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPagesSourceHash`, d.Next())
	}
}

// Encode encodes PrivateUserPlan as json.
func (o OptPrivateUserPlan) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes PrivateUserPlan from json.
func (o *OptPrivateUserPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPrivateUserPlan to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPrivateUserPlan`, d.Next())
	}
}

// Encode encodes ProjectOrganizationPermission as json.
func (o OptProjectOrganizationPermission) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ProjectOrganizationPermission from json.
func (o *OptProjectOrganizationPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectOrganizationPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ProjectOrganizationPermission(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectOrganizationPermission`, d.Next())
	}
}

// Encode encodes ProjectsAddCollaboratorReqPermission as json.
func (o OptProjectsAddCollaboratorReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ProjectsAddCollaboratorReqPermission from json.
func (o *OptProjectsAddCollaboratorReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectsAddCollaboratorReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ProjectsAddCollaboratorReqPermission(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectsAddCollaboratorReqPermission`, d.Next())
	}
}

// Encode encodes ProjectsListCardsArchivedState as json.
func (o OptProjectsListCardsArchivedState) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ProjectsListCardsArchivedState from json.
func (o *OptProjectsListCardsArchivedState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectsListCardsArchivedState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ProjectsListCardsArchivedState(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectsListCardsArchivedState`, d.Next())
	}
}

// Encode encodes ProjectsListForOrgState as json.
func (o OptProjectsListForOrgState) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ProjectsListForOrgState from json.
func (o *OptProjectsListForOrgState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectsListForOrgState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ProjectsListForOrgState(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectsListForOrgState`, d.Next())
	}
}

// Encode encodes ProjectsListForRepoState as json.
func (o OptProjectsListForRepoState) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ProjectsListForRepoState from json.
func (o *OptProjectsListForRepoState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectsListForRepoState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ProjectsListForRepoState(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectsListForRepoState`, d.Next())
	}
}

// Encode encodes ProjectsUpdateReqOrganizationPermission as json.
func (o OptProjectsUpdateReqOrganizationPermission) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ProjectsUpdateReqOrganizationPermission from json.
func (o *OptProjectsUpdateReqOrganizationPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProjectsUpdateReqOrganizationPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ProjectsUpdateReqOrganizationPermission(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProjectsUpdateReqOrganizationPermission`, d.Next())
	}
}

// Encode encodes ProtectedBranchAdminEnforced as json.
func (o OptProtectedBranchAdminEnforced) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchAdminEnforced from json.
func (o *OptProtectedBranchAdminEnforced) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchAdminEnforced to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchAdminEnforced`, d.Next())
	}
}

// Encode encodes ProtectedBranchAllowDeletions as json.
func (o OptProtectedBranchAllowDeletions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchAllowDeletions from json.
func (o *OptProtectedBranchAllowDeletions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchAllowDeletions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchAllowDeletions`, d.Next())
	}
}

// Encode encodes ProtectedBranchAllowForcePushes as json.
func (o OptProtectedBranchAllowForcePushes) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchAllowForcePushes from json.
func (o *OptProtectedBranchAllowForcePushes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchAllowForcePushes to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchAllowForcePushes`, d.Next())
	}
}

// Encode encodes ProtectedBranchEnforceAdmins as json.
func (o OptProtectedBranchEnforceAdmins) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchEnforceAdmins from json.
func (o *OptProtectedBranchEnforceAdmins) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchEnforceAdmins to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchEnforceAdmins`, d.Next())
	}
}

// Encode encodes ProtectedBranchPullRequestReview as json.
func (o OptProtectedBranchPullRequestReview) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchPullRequestReview from json.
func (o *OptProtectedBranchPullRequestReview) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchPullRequestReview to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchPullRequestReview`, d.Next())
	}
}

// Encode encodes ProtectedBranchPullRequestReviewDismissalRestrictions as json.
func (o OptProtectedBranchPullRequestReviewDismissalRestrictions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchPullRequestReviewDismissalRestrictions from json.
func (o *OptProtectedBranchPullRequestReviewDismissalRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchPullRequestReviewDismissalRestrictions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchPullRequestReviewDismissalRestrictions`, d.Next())
	}
}

// Encode encodes ProtectedBranchRequiredConversationResolution as json.
func (o OptProtectedBranchRequiredConversationResolution) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredConversationResolution from json.
func (o *OptProtectedBranchRequiredConversationResolution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchRequiredConversationResolution to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchRequiredConversationResolution`, d.Next())
	}
}

// Encode encodes ProtectedBranchRequiredLinearHistory as json.
func (o OptProtectedBranchRequiredLinearHistory) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredLinearHistory from json.
func (o *OptProtectedBranchRequiredLinearHistory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchRequiredLinearHistory to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchRequiredLinearHistory`, d.Next())
	}
}

// Encode encodes ProtectedBranchRequiredPullRequestReviews as json.
func (o OptProtectedBranchRequiredPullRequestReviews) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredPullRequestReviews from json.
func (o *OptProtectedBranchRequiredPullRequestReviews) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchRequiredPullRequestReviews to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchRequiredPullRequestReviews`, d.Next())
	}
}

// Encode encodes ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions as json.
func (o OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions from json.
func (o *OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchRequiredPullRequestReviewsDismissalRestrictions`, d.Next())
	}
}

// Encode encodes ProtectedBranchRequiredSignatures as json.
func (o OptProtectedBranchRequiredSignatures) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ProtectedBranchRequiredSignatures from json.
func (o *OptProtectedBranchRequiredSignatures) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptProtectedBranchRequiredSignatures to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptProtectedBranchRequiredSignatures`, d.Next())
	}
}

// Encode encodes PublicUser as json.
func (o OptPublicUser) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes PublicUser from json.
func (o *OptPublicUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPublicUser to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPublicUser`, d.Next())
	}
}

// Encode encodes PublicUserPlan as json.
func (o OptPublicUserPlan) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes PublicUserPlan from json.
func (o *OptPublicUserPlan) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPublicUserPlan to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPublicUserPlan`, d.Next())
	}
}

// Encode encodes PullRequestBaseRepoPermissions as json.
func (o OptPullRequestBaseRepoPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes PullRequestBaseRepoPermissions from json.
func (o *OptPullRequestBaseRepoPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullRequestBaseRepoPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullRequestBaseRepoPermissions`, d.Next())
	}
}

// Encode encodes PullRequestHeadRepoPermissions as json.
func (o OptPullRequestHeadRepoPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes PullRequestHeadRepoPermissions from json.
func (o *OptPullRequestHeadRepoPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullRequestHeadRepoPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullRequestHeadRepoPermissions`, d.Next())
	}
}

// Encode encodes PullRequestReviewCommentSide as json.
func (o OptPullRequestReviewCommentSide) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes PullRequestReviewCommentSide from json.
func (o *OptPullRequestReviewCommentSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullRequestReviewCommentSide to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PullRequestReviewCommentSide(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullRequestReviewCommentSide`, d.Next())
	}
}

// Encode encodes PullsCreateReviewCommentReqSide as json.
func (o OptPullsCreateReviewCommentReqSide) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes PullsCreateReviewCommentReqSide from json.
func (o *OptPullsCreateReviewCommentReqSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsCreateReviewCommentReqSide to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PullsCreateReviewCommentReqSide(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsCreateReviewCommentReqSide`, d.Next())
	}
}

// Encode encodes PullsCreateReviewCommentReqStartSide as json.
func (o OptPullsCreateReviewCommentReqStartSide) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes PullsCreateReviewCommentReqStartSide from json.
func (o *OptPullsCreateReviewCommentReqStartSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsCreateReviewCommentReqStartSide to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PullsCreateReviewCommentReqStartSide(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsCreateReviewCommentReqStartSide`, d.Next())
	}
}

// Encode encodes PullsCreateReviewReqEvent as json.
func (o OptPullsCreateReviewReqEvent) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes PullsCreateReviewReqEvent from json.
func (o *OptPullsCreateReviewReqEvent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsCreateReviewReqEvent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PullsCreateReviewReqEvent(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsCreateReviewReqEvent`, d.Next())
	}
}

// Encode encodes PullsListReviewCommentsDirection as json.
func (o OptPullsListReviewCommentsDirection) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes PullsListReviewCommentsDirection from json.
func (o *OptPullsListReviewCommentsDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsListReviewCommentsDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PullsListReviewCommentsDirection(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsListReviewCommentsDirection`, d.Next())
	}
}

// Encode encodes PullsListReviewCommentsForRepoDirection as json.
func (o OptPullsListReviewCommentsForRepoDirection) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes PullsListReviewCommentsForRepoDirection from json.
func (o *OptPullsListReviewCommentsForRepoDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsListReviewCommentsForRepoDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PullsListReviewCommentsForRepoDirection(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsListReviewCommentsForRepoDirection`, d.Next())
	}
}

// Encode encodes PullsListReviewCommentsForRepoSort as json.
func (o OptPullsListReviewCommentsForRepoSort) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes PullsListReviewCommentsForRepoSort from json.
func (o *OptPullsListReviewCommentsForRepoSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsListReviewCommentsForRepoSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PullsListReviewCommentsForRepoSort(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsListReviewCommentsForRepoSort`, d.Next())
	}
}

// Encode encodes PullsListReviewCommentsSort as json.
func (o OptPullsListReviewCommentsSort) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes PullsListReviewCommentsSort from json.
func (o *OptPullsListReviewCommentsSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsListReviewCommentsSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PullsListReviewCommentsSort(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsListReviewCommentsSort`, d.Next())
	}
}

// Encode encodes PullsMergeReqMergeMethod as json.
func (o OptPullsMergeReqMergeMethod) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes PullsMergeReqMergeMethod from json.
func (o *OptPullsMergeReqMergeMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsMergeReqMergeMethod to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PullsMergeReqMergeMethod(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsMergeReqMergeMethod`, d.Next())
	}
}

// Encode encodes PullsUpdateReqState as json.
func (o OptPullsUpdateReqState) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes PullsUpdateReqState from json.
func (o *OptPullsUpdateReqState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptPullsUpdateReqState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = PullsUpdateReqState(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptPullsUpdateReqState`, d.Next())
	}
}

// Encode encodes RateLimit as json.
func (o OptRateLimit) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes RateLimit from json.
func (o *OptRateLimit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptRateLimit to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptRateLimit`, d.Next())
	}
}

// Encode encodes ReactionRollup as json.
func (o OptReactionRollup) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ReactionRollup from json.
func (o *OptReactionRollup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionRollup to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionRollup`, d.Next())
	}
}

// Encode encodes ReactionsListForCommitCommentContent as json.
func (o OptReactionsListForCommitCommentContent) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReactionsListForCommitCommentContent from json.
func (o *OptReactionsListForCommitCommentContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionsListForCommitCommentContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReactionsListForCommitCommentContent(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionsListForCommitCommentContent`, d.Next())
	}
}

// Encode encodes ReactionsListForIssueCommentContent as json.
func (o OptReactionsListForIssueCommentContent) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReactionsListForIssueCommentContent from json.
func (o *OptReactionsListForIssueCommentContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionsListForIssueCommentContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReactionsListForIssueCommentContent(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionsListForIssueCommentContent`, d.Next())
	}
}

// Encode encodes ReactionsListForIssueContent as json.
func (o OptReactionsListForIssueContent) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReactionsListForIssueContent from json.
func (o *OptReactionsListForIssueContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionsListForIssueContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReactionsListForIssueContent(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionsListForIssueContent`, d.Next())
	}
}

// Encode encodes ReactionsListForPullRequestReviewCommentContent as json.
func (o OptReactionsListForPullRequestReviewCommentContent) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReactionsListForPullRequestReviewCommentContent from json.
func (o *OptReactionsListForPullRequestReviewCommentContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionsListForPullRequestReviewCommentContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReactionsListForPullRequestReviewCommentContent(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionsListForPullRequestReviewCommentContent`, d.Next())
	}
}

// Encode encodes ReactionsListForTeamDiscussionCommentInOrgContent as json.
func (o OptReactionsListForTeamDiscussionCommentInOrgContent) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReactionsListForTeamDiscussionCommentInOrgContent from json.
func (o *OptReactionsListForTeamDiscussionCommentInOrgContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionsListForTeamDiscussionCommentInOrgContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReactionsListForTeamDiscussionCommentInOrgContent(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionsListForTeamDiscussionCommentInOrgContent`, d.Next())
	}
}

// Encode encodes ReactionsListForTeamDiscussionCommentLegacyContent as json.
func (o OptReactionsListForTeamDiscussionCommentLegacyContent) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReactionsListForTeamDiscussionCommentLegacyContent from json.
func (o *OptReactionsListForTeamDiscussionCommentLegacyContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionsListForTeamDiscussionCommentLegacyContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReactionsListForTeamDiscussionCommentLegacyContent(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionsListForTeamDiscussionCommentLegacyContent`, d.Next())
	}
}

// Encode encodes ReactionsListForTeamDiscussionInOrgContent as json.
func (o OptReactionsListForTeamDiscussionInOrgContent) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReactionsListForTeamDiscussionInOrgContent from json.
func (o *OptReactionsListForTeamDiscussionInOrgContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionsListForTeamDiscussionInOrgContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReactionsListForTeamDiscussionInOrgContent(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionsListForTeamDiscussionInOrgContent`, d.Next())
	}
}

// Encode encodes ReactionsListForTeamDiscussionLegacyContent as json.
func (o OptReactionsListForTeamDiscussionLegacyContent) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReactionsListForTeamDiscussionLegacyContent from json.
func (o *OptReactionsListForTeamDiscussionLegacyContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReactionsListForTeamDiscussionLegacyContent to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReactionsListForTeamDiscussionLegacyContent(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReactionsListForTeamDiscussionLegacyContent`, d.Next())
	}
}

// Encode encodes RepoSearchResultItemPermissions as json.
func (o OptRepoSearchResultItemPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes RepoSearchResultItemPermissions from json.
func (o *OptRepoSearchResultItemPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptRepoSearchResultItemPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptRepoSearchResultItemPermissions`, d.Next())
	}
}

// Encode encodes ReposAddCollaboratorReqPermission as json.
func (o OptReposAddCollaboratorReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReposAddCollaboratorReqPermission from json.
func (o *OptReposAddCollaboratorReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposAddCollaboratorReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReposAddCollaboratorReqPermission(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposAddCollaboratorReqPermission`, d.Next())
	}
}

// Encode encodes ReposCreateDeploymentStatusReqEnvironment as json.
func (o OptReposCreateDeploymentStatusReqEnvironment) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReposCreateDeploymentStatusReqEnvironment from json.
func (o *OptReposCreateDeploymentStatusReqEnvironment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposCreateDeploymentStatusReqEnvironment to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReposCreateDeploymentStatusReqEnvironment(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposCreateDeploymentStatusReqEnvironment`, d.Next())
	}
}

// Encode encodes ReposCreateInOrgReqVisibility as json.
func (o OptReposCreateInOrgReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReposCreateInOrgReqVisibility from json.
func (o *OptReposCreateInOrgReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposCreateInOrgReqVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReposCreateInOrgReqVisibility(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposCreateInOrgReqVisibility`, d.Next())
	}
}

// Encode encodes ReposCreateOrUpdateFileContentsReqAuthor as json.
func (o OptReposCreateOrUpdateFileContentsReqAuthor) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsReqAuthor from json.
func (o *OptReposCreateOrUpdateFileContentsReqAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposCreateOrUpdateFileContentsReqAuthor to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposCreateOrUpdateFileContentsReqAuthor`, d.Next())
	}
}

// Encode encodes ReposCreateOrUpdateFileContentsReqCommitter as json.
func (o OptReposCreateOrUpdateFileContentsReqCommitter) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ReposCreateOrUpdateFileContentsReqCommitter from json.
func (o *OptReposCreateOrUpdateFileContentsReqCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposCreateOrUpdateFileContentsReqCommitter to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposCreateOrUpdateFileContentsReqCommitter`, d.Next())
	}
}

// Encode encodes ReposCreatePagesSiteReqSourcePath as json.
func (o OptReposCreatePagesSiteReqSourcePath) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReposCreatePagesSiteReqSourcePath from json.
func (o *OptReposCreatePagesSiteReqSourcePath) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposCreatePagesSiteReqSourcePath to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReposCreatePagesSiteReqSourcePath(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposCreatePagesSiteReqSourcePath`, d.Next())
	}
}

// Encode encodes ReposCreateWebhookReqConfig as json.
func (o OptReposCreateWebhookReqConfig) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ReposCreateWebhookReqConfig from json.
func (o *OptReposCreateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposCreateWebhookReqConfig to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposCreateWebhookReqConfig`, d.Next())
	}
}

// Encode encodes ReposDeleteFileReqAuthor as json.
func (o OptReposDeleteFileReqAuthor) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ReposDeleteFileReqAuthor from json.
func (o *OptReposDeleteFileReqAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposDeleteFileReqAuthor to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposDeleteFileReqAuthor`, d.Next())
	}
}

// Encode encodes ReposDeleteFileReqCommitter as json.
func (o OptReposDeleteFileReqCommitter) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ReposDeleteFileReqCommitter from json.
func (o *OptReposDeleteFileReqCommitter) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposDeleteFileReqCommitter to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposDeleteFileReqCommitter`, d.Next())
	}
}

// Encode encodes ReposGetClonesPer as json.
func (o OptReposGetClonesPer) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReposGetClonesPer from json.
func (o *OptReposGetClonesPer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposGetClonesPer to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReposGetClonesPer(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposGetClonesPer`, d.Next())
	}
}

// Encode encodes ReposGetViewsPer as json.
func (o OptReposGetViewsPer) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReposGetViewsPer from json.
func (o *OptReposGetViewsPer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposGetViewsPer to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReposGetViewsPer(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposGetViewsPer`, d.Next())
	}
}

// Encode encodes ReposListCollaboratorsAffiliation as json.
func (o OptReposListCollaboratorsAffiliation) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListCollaboratorsAffiliation from json.
func (o *OptReposListCollaboratorsAffiliation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListCollaboratorsAffiliation to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReposListCollaboratorsAffiliation(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListCollaboratorsAffiliation`, d.Next())
	}
}

// Encode encodes ReposListForOrgDirection as json.
func (o OptReposListForOrgDirection) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForOrgDirection from json.
func (o *OptReposListForOrgDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForOrgDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReposListForOrgDirection(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForOrgDirection`, d.Next())
	}
}

// Encode encodes ReposListForOrgSort as json.
func (o OptReposListForOrgSort) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForOrgSort from json.
func (o *OptReposListForOrgSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForOrgSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReposListForOrgSort(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForOrgSort`, d.Next())
	}
}

// Encode encodes ReposListForOrgType as json.
func (o OptReposListForOrgType) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForOrgType from json.
func (o *OptReposListForOrgType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForOrgType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReposListForOrgType(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForOrgType`, d.Next())
	}
}

// Encode encodes ReposListForUserDirection as json.
func (o OptReposListForUserDirection) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForUserDirection from json.
func (o *OptReposListForUserDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForUserDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReposListForUserDirection(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForUserDirection`, d.Next())
	}
}

// Encode encodes ReposListForUserSort as json.
func (o OptReposListForUserSort) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForUserSort from json.
func (o *OptReposListForUserSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForUserSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReposListForUserSort(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForUserSort`, d.Next())
	}
}

// Encode encodes ReposListForUserType as json.
func (o OptReposListForUserType) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForUserType from json.
func (o *OptReposListForUserType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForUserType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReposListForUserType(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForUserType`, d.Next())
	}
}

// Encode encodes ReposListForksSort as json.
func (o OptReposListForksSort) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReposListForksSort from json.
func (o *OptReposListForksSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposListForksSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReposListForksSort(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposListForksSort`, d.Next())
	}
}

// Encode encodes ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions as json.
func (o OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions from json.
func (o *OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions`, d.Next())
	}
}

// Encode encodes ReposUpdateInvitationReqPermissions as json.
func (o OptReposUpdateInvitationReqPermissions) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReposUpdateInvitationReqPermissions from json.
func (o *OptReposUpdateInvitationReqPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateInvitationReqPermissions to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReposUpdateInvitationReqPermissions(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateInvitationReqPermissions`, d.Next())
	}
}

// Encode encodes ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions as json.
func (o OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions from json.
func (o *OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdatePullRequestReviewProtectionReqDismissalRestrictions`, d.Next())
	}
}

// Encode encodes ReposUpdateReqSecurityAndAnalysisAdvancedSecurity as json.
func (o OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReqSecurityAndAnalysisAdvancedSecurity from json.
func (o *OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateReqSecurityAndAnalysisAdvancedSecurity`, d.Next())
	}
}

// Encode encodes ReposUpdateReqSecurityAndAnalysisSecretScanning as json.
func (o OptReposUpdateReqSecurityAndAnalysisSecretScanning) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateReqSecurityAndAnalysisSecretScanning from json.
func (o *OptReposUpdateReqSecurityAndAnalysisSecretScanning) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateReqSecurityAndAnalysisSecretScanning to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateReqSecurityAndAnalysisSecretScanning`, d.Next())
	}
}

// Encode encodes ReposUpdateReqVisibility as json.
func (o OptReposUpdateReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReposUpdateReqVisibility from json.
func (o *OptReposUpdateReqVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateReqVisibility to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReposUpdateReqVisibility(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateReqVisibility`, d.Next())
	}
}

// Encode encodes ReposUpdateWebhookReqConfig as json.
func (o OptReposUpdateWebhookReqConfig) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ReposUpdateWebhookReqConfig from json.
func (o *OptReposUpdateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReposUpdateWebhookReqConfig to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReposUpdateWebhookReqConfig`, d.Next())
	}
}

// Encode encodes Repository as json.
func (o OptRepository) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Repository from json.
func (o *OptRepository) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptRepository to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptRepository`, d.Next())
	}
}

// Encode encodes RepositoryPermissions as json.
func (o OptRepositoryPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes RepositoryPermissions from json.
func (o *OptRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptRepositoryPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptRepositoryPermissions`, d.Next())
	}
}

// Encode encodes RepositoryTemplateRepositoryOwner as json.
func (o OptRepositoryTemplateRepositoryOwner) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes RepositoryTemplateRepositoryOwner from json.
func (o *OptRepositoryTemplateRepositoryOwner) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptRepositoryTemplateRepositoryOwner to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptRepositoryTemplateRepositoryOwner`, d.Next())
	}
}

// Encode encodes RepositoryTemplateRepositoryPermissions as json.
func (o OptRepositoryTemplateRepositoryPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes RepositoryTemplateRepositoryPermissions from json.
func (o *OptRepositoryTemplateRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptRepositoryTemplateRepositoryPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptRepositoryTemplateRepositoryPermissions`, d.Next())
	}
}

// Encode encodes ReviewCommentSide as json.
func (o OptReviewCommentSide) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes ReviewCommentSide from json.
func (o *OptReviewCommentSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptReviewCommentSide to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = ReviewCommentSide(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptReviewCommentSide`, d.Next())
	}
}

// Encode encodes RunnerLabelsItemType as json.
func (o OptRunnerLabelsItemType) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes RunnerLabelsItemType from json.
func (o *OptRunnerLabelsItemType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptRunnerLabelsItemType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = RunnerLabelsItemType(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptRunnerLabelsItemType`, d.Next())
	}
}

// Encode encodes ScimEnterpriseGroupMeta as json.
func (o OptScimEnterpriseGroupMeta) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ScimEnterpriseGroupMeta from json.
func (o *OptScimEnterpriseGroupMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptScimEnterpriseGroupMeta to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptScimEnterpriseGroupMeta`, d.Next())
	}
}

// Encode encodes ScimEnterpriseUserMeta as json.
func (o OptScimEnterpriseUserMeta) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ScimEnterpriseUserMeta from json.
func (o *OptScimEnterpriseUserMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptScimEnterpriseUserMeta to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptScimEnterpriseUserMeta`, d.Next())
	}
}

// Encode encodes ScimEnterpriseUserName as json.
func (o OptScimEnterpriseUserName) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ScimEnterpriseUserName from json.
func (o *OptScimEnterpriseUserName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptScimEnterpriseUserName to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptScimEnterpriseUserName`, d.Next())
	}
}

// Encode encodes ScimGroupListEnterpriseResourcesItemMeta as json.
func (o OptScimGroupListEnterpriseResourcesItemMeta) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ScimGroupListEnterpriseResourcesItemMeta from json.
func (o *OptScimGroupListEnterpriseResourcesItemMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptScimGroupListEnterpriseResourcesItemMeta to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptScimGroupListEnterpriseResourcesItemMeta`, d.Next())
	}
}

// Encode encodes ScimUserListEnterpriseResourcesItemMeta as json.
func (o OptScimUserListEnterpriseResourcesItemMeta) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ScimUserListEnterpriseResourcesItemMeta from json.
func (o *OptScimUserListEnterpriseResourcesItemMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptScimUserListEnterpriseResourcesItemMeta to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptScimUserListEnterpriseResourcesItemMeta`, d.Next())
	}
}

// Encode encodes ScimUserListEnterpriseResourcesItemName as json.
func (o OptScimUserListEnterpriseResourcesItemName) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes ScimUserListEnterpriseResourcesItemName from json.
func (o *OptScimUserListEnterpriseResourcesItemName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptScimUserListEnterpriseResourcesItemName to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptScimUserListEnterpriseResourcesItemName`, d.Next())
	}
}

// Encode encodes SearchCommitsOrder as json.
func (o OptSearchCommitsOrder) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes SearchCommitsOrder from json.
func (o *OptSearchCommitsOrder) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSearchCommitsOrder to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = SearchCommitsOrder(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSearchCommitsOrder`, d.Next())
	}
}

// Encode encodes SearchCommitsSort as json.
func (o OptSearchCommitsSort) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes SearchCommitsSort from json.
func (o *OptSearchCommitsSort) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSearchCommitsSort to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = SearchCommitsSort(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSearchCommitsSort`, d.Next())
	}
}

// Encode encodes SecretScanningAlertState as json.
func (o OptSecretScanningAlertState) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes SecretScanningAlertState from json.
func (o *OptSecretScanningAlertState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSecretScanningAlertState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = SecretScanningAlertState(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSecretScanningAlertState`, d.Next())
	}
}

// Encode encodes SecretScanningListAlertsForOrgState as json.
func (o OptSecretScanningListAlertsForOrgState) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes SecretScanningListAlertsForOrgState from json.
func (o *OptSecretScanningListAlertsForOrgState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSecretScanningListAlertsForOrgState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = SecretScanningListAlertsForOrgState(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSecretScanningListAlertsForOrgState`, d.Next())
	}
}

// Encode encodes SecretScanningListAlertsForRepoState as json.
func (o OptSecretScanningListAlertsForRepoState) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes SecretScanningListAlertsForRepoState from json.
func (o *OptSecretScanningListAlertsForRepoState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSecretScanningListAlertsForRepoState to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = SecretScanningListAlertsForRepoState(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSecretScanningListAlertsForRepoState`, d.Next())
	}
}

// Encode encodes SelectedActionsURL as json.
func (o OptSelectedActionsURL) Encode(e *jx.Encoder) {
}

// Decode decodes SelectedActionsURL from json.
func (o *OptSelectedActionsURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSelectedActionsURL to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSelectedActionsURL`, d.Next())
	}
}

// Encode encodes SimpleUser as json.
func (o OptSimpleUser) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes SimpleUser from json.
func (o *OptSimpleUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptSimpleUser to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptSimpleUser`, d.Next())
	}
}

// Encode encodes StatusCheckPolicy as json.
func (o OptStatusCheckPolicy) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes StatusCheckPolicy from json.
func (o *OptStatusCheckPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptStatusCheckPolicy to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptStatusCheckPolicy`, d.Next())
	}
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptString to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = string(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptString`, d.Next())
	}
}

// Encode encodes Team as json.
func (o OptTeam) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Team from json.
func (o *OptTeam) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeam to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeam`, d.Next())
	}
}

// Encode encodes TeamFullPrivacy as json.
func (o OptTeamFullPrivacy) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamFullPrivacy from json.
func (o *OptTeamFullPrivacy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamFullPrivacy to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamFullPrivacy(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamFullPrivacy`, d.Next())
	}
}

// Encode encodes TeamPermissions as json.
func (o OptTeamPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes TeamPermissions from json.
func (o *OptTeamPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamPermissions`, d.Next())
	}
}

// Encode encodes TeamRepositoryPermissions as json.
func (o OptTeamRepositoryPermissions) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes TeamRepositoryPermissions from json.
func (o *OptTeamRepositoryPermissions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamRepositoryPermissions to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamRepositoryPermissions`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateMembershipForUserInOrgReqRole as json.
func (o OptTeamsAddOrUpdateMembershipForUserInOrgReqRole) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgReqRole from json.
func (o *OptTeamsAddOrUpdateMembershipForUserInOrgReqRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateMembershipForUserInOrgReqRole to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsAddOrUpdateMembershipForUserInOrgReqRole(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateMembershipForUserInOrgReqRole`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateMembershipForUserLegacyReqRole as json.
func (o OptTeamsAddOrUpdateMembershipForUserLegacyReqRole) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyReqRole from json.
func (o *OptTeamsAddOrUpdateMembershipForUserLegacyReqRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateMembershipForUserLegacyReqRole to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsAddOrUpdateMembershipForUserLegacyReqRole(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateMembershipForUserLegacyReqRole`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsInOrgReqPermission as json.
func (o OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgReqPermission from json.
func (o *OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsAddOrUpdateProjectPermissionsInOrgReqPermission(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateProjectPermissionsInOrgReqPermission`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsLegacyReqPermission as json.
func (o OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyReqPermission from json.
func (o *OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsAddOrUpdateProjectPermissionsLegacyReqPermission(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateProjectPermissionsLegacyReqPermission`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsInOrgReqPermission as json.
func (o OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgReqPermission from json.
func (o *OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsAddOrUpdateRepoPermissionsInOrgReqPermission(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateRepoPermissionsInOrgReqPermission`, d.Next())
	}
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsLegacyReqPermission as json.
func (o OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyReqPermission from json.
func (o *OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsAddOrUpdateRepoPermissionsLegacyReqPermission(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsAddOrUpdateRepoPermissionsLegacyReqPermission`, d.Next())
	}
}

// Encode encodes TeamsCreateReqPermission as json.
func (o OptTeamsCreateReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsCreateReqPermission from json.
func (o *OptTeamsCreateReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsCreateReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsCreateReqPermission(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsCreateReqPermission`, d.Next())
	}
}

// Encode encodes TeamsCreateReqPrivacy as json.
func (o OptTeamsCreateReqPrivacy) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsCreateReqPrivacy from json.
func (o *OptTeamsCreateReqPrivacy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsCreateReqPrivacy to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsCreateReqPrivacy(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsCreateReqPrivacy`, d.Next())
	}
}

// Encode encodes TeamsListDiscussionCommentsInOrgDirection as json.
func (o OptTeamsListDiscussionCommentsInOrgDirection) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsListDiscussionCommentsInOrgDirection from json.
func (o *OptTeamsListDiscussionCommentsInOrgDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsListDiscussionCommentsInOrgDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsListDiscussionCommentsInOrgDirection(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsListDiscussionCommentsInOrgDirection`, d.Next())
	}
}

// Encode encodes TeamsListDiscussionCommentsLegacyDirection as json.
func (o OptTeamsListDiscussionCommentsLegacyDirection) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsListDiscussionCommentsLegacyDirection from json.
func (o *OptTeamsListDiscussionCommentsLegacyDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsListDiscussionCommentsLegacyDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsListDiscussionCommentsLegacyDirection(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsListDiscussionCommentsLegacyDirection`, d.Next())
	}
}

// Encode encodes TeamsListDiscussionsInOrgDirection as json.
func (o OptTeamsListDiscussionsInOrgDirection) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsListDiscussionsInOrgDirection from json.
func (o *OptTeamsListDiscussionsInOrgDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsListDiscussionsInOrgDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsListDiscussionsInOrgDirection(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsListDiscussionsInOrgDirection`, d.Next())
	}
}

// Encode encodes TeamsListDiscussionsLegacyDirection as json.
func (o OptTeamsListDiscussionsLegacyDirection) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsListDiscussionsLegacyDirection from json.
func (o *OptTeamsListDiscussionsLegacyDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsListDiscussionsLegacyDirection to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsListDiscussionsLegacyDirection(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsListDiscussionsLegacyDirection`, d.Next())
	}
}

// Encode encodes TeamsListMembersInOrgRole as json.
func (o OptTeamsListMembersInOrgRole) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsListMembersInOrgRole from json.
func (o *OptTeamsListMembersInOrgRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsListMembersInOrgRole to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsListMembersInOrgRole(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsListMembersInOrgRole`, d.Next())
	}
}

// Encode encodes TeamsListMembersLegacyRole as json.
func (o OptTeamsListMembersLegacyRole) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsListMembersLegacyRole from json.
func (o *OptTeamsListMembersLegacyRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsListMembersLegacyRole to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsListMembersLegacyRole(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsListMembersLegacyRole`, d.Next())
	}
}

// Encode encodes TeamsUpdateInOrgReqPermission as json.
func (o OptTeamsUpdateInOrgReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsUpdateInOrgReqPermission from json.
func (o *OptTeamsUpdateInOrgReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsUpdateInOrgReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsUpdateInOrgReqPermission(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsUpdateInOrgReqPermission`, d.Next())
	}
}

// Encode encodes TeamsUpdateInOrgReqPrivacy as json.
func (o OptTeamsUpdateInOrgReqPrivacy) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsUpdateInOrgReqPrivacy from json.
func (o *OptTeamsUpdateInOrgReqPrivacy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsUpdateInOrgReqPrivacy to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsUpdateInOrgReqPrivacy(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsUpdateInOrgReqPrivacy`, d.Next())
	}
}

// Encode encodes TeamsUpdateLegacyReqPermission as json.
func (o OptTeamsUpdateLegacyReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsUpdateLegacyReqPermission from json.
func (o *OptTeamsUpdateLegacyReqPermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsUpdateLegacyReqPermission to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsUpdateLegacyReqPermission(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsUpdateLegacyReqPermission`, d.Next())
	}
}

// Encode encodes TeamsUpdateLegacyReqPrivacy as json.
func (o OptTeamsUpdateLegacyReqPrivacy) Encode(e *jx.Encoder) {
	e.Str(string(o.Value))
}

// Decode decodes TeamsUpdateLegacyReqPrivacy from json.
func (o *OptTeamsUpdateLegacyReqPrivacy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTeamsUpdateLegacyReqPrivacy to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := d.Str()
		if err != nil {
			return err
		}
		o.Value = TeamsUpdateLegacyReqPrivacy(v)
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTeamsUpdateLegacyReqPrivacy`, d.Next())
	}
}

// Encode encodes time.Time as json.
func (o OptTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTime to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := format(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTime`, d.Next())
	}
}

// Encode encodes TopicSearchResultItemAliasesItemTopicRelation as json.
func (o OptTopicSearchResultItemAliasesItemTopicRelation) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes TopicSearchResultItemAliasesItemTopicRelation from json.
func (o *OptTopicSearchResultItemAliasesItemTopicRelation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTopicSearchResultItemAliasesItemTopicRelation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTopicSearchResultItemAliasesItemTopicRelation`, d.Next())
	}
}

// Encode encodes TopicSearchResultItemRelatedItemTopicRelation as json.
func (o OptTopicSearchResultItemRelatedItemTopicRelation) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes TopicSearchResultItemRelatedItemTopicRelation from json.
func (o *OptTopicSearchResultItemRelatedItemTopicRelation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptTopicSearchResultItemRelatedItemTopicRelation to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptTopicSearchResultItemRelatedItemTopicRelation`, d.Next())
	}
}

// Encode encodes url.URL as json.
func (o OptURL) Encode(e *jx.Encoder) {
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptURL to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		v, err := json.DecodeURI(d)
		if err != nil {
			return err
		}
		o.Value = v
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptURL`, d.Next())
	}
}

// Encode encodes Verification as json.
func (o OptVerification) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes Verification from json.
func (o *OptVerification) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptVerification to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptVerification`, d.Next())
	}
}

// Encode encodes WaitTimer as json.
func (o OptWaitTimer) Encode(e *jx.Encoder) {
}

// Decode decodes WaitTimer from json.
func (o *OptWaitTimer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptWaitTimer to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptWaitTimer`, d.Next())
	}
}

// Encode encodes WebhookConfigContentType as json.
func (o OptWebhookConfigContentType) Encode(e *jx.Encoder) {
}

// Decode decodes WebhookConfigContentType from json.
func (o *OptWebhookConfigContentType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptWebhookConfigContentType to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptWebhookConfigContentType`, d.Next())
	}
}

// Encode encodes WebhookConfigSecret as json.
func (o OptWebhookConfigSecret) Encode(e *jx.Encoder) {
}

// Decode decodes WebhookConfigSecret from json.
func (o *OptWebhookConfigSecret) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptWebhookConfigSecret to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptWebhookConfigSecret`, d.Next())
	}
}

// Encode encodes WebhookConfigURL as json.
func (o OptWebhookConfigURL) Encode(e *jx.Encoder) {
}

// Decode decodes WebhookConfigURL from json.
func (o *OptWebhookConfigURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptWebhookConfigURL to nil`)
	}
	switch d.Next() {
	case jx.String:
		o.Set = true
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptWebhookConfigURL`, d.Next())
	}
}

// Encode encodes WorkflowRunUsageBillableMACOS as json.
func (o OptWorkflowRunUsageBillableMACOS) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes WorkflowRunUsageBillableMACOS from json.
func (o *OptWorkflowRunUsageBillableMACOS) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptWorkflowRunUsageBillableMACOS to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptWorkflowRunUsageBillableMACOS`, d.Next())
	}
}

// Encode encodes WorkflowRunUsageBillableUBUNTU as json.
func (o OptWorkflowRunUsageBillableUBUNTU) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes WorkflowRunUsageBillableUBUNTU from json.
func (o *OptWorkflowRunUsageBillableUBUNTU) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptWorkflowRunUsageBillableUBUNTU to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptWorkflowRunUsageBillableUBUNTU`, d.Next())
	}
}

// Encode encodes WorkflowRunUsageBillableWINDOWS as json.
func (o OptWorkflowRunUsageBillableWINDOWS) Encode(e *jx.Encoder) {
	o.Value.Encode(e)
}

// Decode decodes WorkflowRunUsageBillableWINDOWS from json.
func (o *OptWorkflowRunUsageBillableWINDOWS) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New(`invalid: unable to decode OptWorkflowRunUsageBillableWINDOWS to nil`)
	}
	switch d.Next() {
	case jx.Object:
		o.Set = true
		if err := o.Value.Decode(d); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf(`unexpected type %q while reading OptWorkflowRunUsageBillableWINDOWS`, d.Next())
	}
}

// Encode implements json.Marshaler.
func (s OrgHook) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("ping_url")
	json.EncodeURI(e, s.PingURL)
	if s.DeliveriesURL.Set {
		e.FieldStart("deliveries_url")
		s.DeliveriesURL.Encode(e)
	}

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("events")
	e.ArrStart()
	for _, elem := range s.Events {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("active")
	e.Bool(s.Active)

	e.FieldStart("config")
	s.Config.Encode(e)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("type")
	e.Str(s.Type)
	e.ObjEnd()
}

// Decode decodes OrgHook from json.
func (s *OrgHook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgHook to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "ping_url":
			v, err := json.DecodeURI(d)
			s.PingURL = v
			if err != nil {
				return err
			}
		case "deliveries_url":
			s.DeliveriesURL.Reset()
			if err := s.DeliveriesURL.Decode(d); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			v, err := d.Bool()
			s.Active = bool(v)
			if err != nil {
				return err
			}
		case "config":
			if err := s.Config.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgHookConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.InsecureSsl.Set {
		e.FieldStart("insecure_ssl")
		s.InsecureSsl.Encode(e)
	}
	if s.ContentType.Set {
		e.FieldStart("content_type")
		s.ContentType.Encode(e)
	}
	if s.Secret.Set {
		e.FieldStart("secret")
		s.Secret.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrgHookConfig from json.
func (s *OrgHookConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgHookConfig to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl.Reset()
			if err := s.InsecureSsl.Decode(d); err != nil {
				return err
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgMembership) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("state")
	s.State.Encode(e)

	e.FieldStart("role")
	s.Role.Encode(e)

	e.FieldStart("organization_url")
	json.EncodeURI(e, s.OrganizationURL)

	e.FieldStart("organization")
	s.Organization.Encode(e)

	e.FieldStart("user")
	s.User.Encode(e)
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrgMembership from json.
func (s *OrgMembership) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgMembership to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "role":
			if err := s.Role.Decode(d); err != nil {
				return err
			}
		case "organization_url":
			v, err := json.DecodeURI(d)
			s.OrganizationURL = v
			if err != nil {
				return err
			}
		case "organization":
			if err := s.Organization.Decode(d); err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgMembershipPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("can_create_repository")
	e.Bool(s.CanCreateRepository)
	e.ObjEnd()
}

// Decode decodes OrgMembershipPermissions from json.
func (s *OrgMembershipPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgMembershipPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "can_create_repository":
			v, err := d.Bool()
			s.CanCreateRepository = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgMembershipRole as json.
func (s OrgMembershipRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgMembershipRole from json.
func (s *OrgMembershipRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgMembershipRole to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = OrgMembershipRole(v)
	return nil
}

// Encode encodes OrgMembershipState as json.
func (s OrgMembershipState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgMembershipState from json.
func (s *OrgMembershipState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgMembershipState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = OrgMembershipState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s OrganizationActionsSecret) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("visibility")
	s.Visibility.Encode(e)
	if s.SelectedRepositoriesURL.Set {
		e.FieldStart("selected_repositories_url")
		s.SelectedRepositoriesURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrganizationActionsSecret from json.
func (s *OrganizationActionsSecret) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrganizationActionsSecret to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "visibility":
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "selected_repositories_url":
			s.SelectedRepositoriesURL.Reset()
			if err := s.SelectedRepositoriesURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrganizationActionsSecretVisibility as json.
func (s OrganizationActionsSecretVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrganizationActionsSecretVisibility from json.
func (s *OrganizationActionsSecretVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrganizationActionsSecretVisibility to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = OrganizationActionsSecretVisibility(v)
	return nil
}

// Encode implements json.Marshaler.
func (s OrganizationFull) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("login")
	e.Str(s.Login)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("repos_url")
	json.EncodeURI(e, s.ReposURL)

	e.FieldStart("events_url")
	json.EncodeURI(e, s.EventsURL)

	e.FieldStart("hooks_url")
	e.Str(s.HooksURL)

	e.FieldStart("issues_url")
	e.Str(s.IssuesURL)

	e.FieldStart("members_url")
	e.Str(s.MembersURL)

	e.FieldStart("public_members_url")
	e.Str(s.PublicMembersURL)

	e.FieldStart("avatar_url")
	e.Str(s.AvatarURL)

	e.FieldStart("description")
	s.Description.Encode(e)
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Company.Set {
		e.FieldStart("company")
		s.Company.Encode(e)
	}
	if s.Blog.Set {
		e.FieldStart("blog")
		s.Blog.Encode(e)
	}
	if s.Location.Set {
		e.FieldStart("location")
		s.Location.Encode(e)
	}
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	if s.TwitterUsername.Set {
		e.FieldStart("twitter_username")
		s.TwitterUsername.Encode(e)
	}
	if s.IsVerified.Set {
		e.FieldStart("is_verified")
		s.IsVerified.Encode(e)
	}

	e.FieldStart("has_organization_projects")
	e.Bool(s.HasOrganizationProjects)

	e.FieldStart("has_repository_projects")
	e.Bool(s.HasRepositoryProjects)

	e.FieldStart("public_repos")
	e.Int(s.PublicRepos)

	e.FieldStart("public_gists")
	e.Int(s.PublicGists)

	e.FieldStart("followers")
	e.Int(s.Followers)

	e.FieldStart("following")
	e.Int(s.Following)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("type")
	e.Str(s.Type)
	if s.TotalPrivateRepos.Set {
		e.FieldStart("total_private_repos")
		s.TotalPrivateRepos.Encode(e)
	}
	if s.OwnedPrivateRepos.Set {
		e.FieldStart("owned_private_repos")
		s.OwnedPrivateRepos.Encode(e)
	}
	if s.PrivateGists.Set {
		e.FieldStart("private_gists")
		s.PrivateGists.Encode(e)
	}
	if s.DiskUsage.Set {
		e.FieldStart("disk_usage")
		s.DiskUsage.Encode(e)
	}
	if s.Collaborators.Set {
		e.FieldStart("collaborators")
		s.Collaborators.Encode(e)
	}
	if s.BillingEmail.Set {
		e.FieldStart("billing_email")
		s.BillingEmail.Encode(e)
	}
	if s.Plan.Set {
		e.FieldStart("plan")
		s.Plan.Encode(e)
	}
	if s.DefaultRepositoryPermission.Set {
		e.FieldStart("default_repository_permission")
		s.DefaultRepositoryPermission.Encode(e)
	}
	if s.MembersCanCreateRepositories.Set {
		e.FieldStart("members_can_create_repositories")
		s.MembersCanCreateRepositories.Encode(e)
	}
	if s.TwoFactorRequirementEnabled.Set {
		e.FieldStart("two_factor_requirement_enabled")
		s.TwoFactorRequirementEnabled.Encode(e)
	}
	if s.MembersAllowedRepositoryCreationType.Set {
		e.FieldStart("members_allowed_repository_creation_type")
		s.MembersAllowedRepositoryCreationType.Encode(e)
	}
	if s.MembersCanCreatePublicRepositories.Set {
		e.FieldStart("members_can_create_public_repositories")
		s.MembersCanCreatePublicRepositories.Encode(e)
	}
	if s.MembersCanCreatePrivateRepositories.Set {
		e.FieldStart("members_can_create_private_repositories")
		s.MembersCanCreatePrivateRepositories.Encode(e)
	}
	if s.MembersCanCreateInternalRepositories.Set {
		e.FieldStart("members_can_create_internal_repositories")
		s.MembersCanCreateInternalRepositories.Encode(e)
	}
	if s.MembersCanCreatePages.Set {
		e.FieldStart("members_can_create_pages")
		s.MembersCanCreatePages.Encode(e)
	}
	if s.MembersCanCreatePublicPages.Set {
		e.FieldStart("members_can_create_public_pages")
		s.MembersCanCreatePublicPages.Encode(e)
	}
	if s.MembersCanCreatePrivatePages.Set {
		e.FieldStart("members_can_create_private_pages")
		s.MembersCanCreatePrivatePages.Encode(e)
	}

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)
	e.ObjEnd()
}

// Decode decodes OrganizationFull from json.
func (s *OrganizationFull) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrganizationFull to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "hooks_url":
			v, err := d.Str()
			s.HooksURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "members_url":
			v, err := d.Str()
			s.MembersURL = string(v)
			if err != nil {
				return err
			}
		case "public_members_url":
			v, err := d.Str()
			s.PublicMembersURL = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := d.Str()
			s.AvatarURL = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "company":
			s.Company.Reset()
			if err := s.Company.Decode(d); err != nil {
				return err
			}
		case "blog":
			s.Blog.Reset()
			if err := s.Blog.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "twitter_username":
			s.TwitterUsername.Reset()
			if err := s.TwitterUsername.Decode(d); err != nil {
				return err
			}
		case "is_verified":
			s.IsVerified.Reset()
			if err := s.IsVerified.Decode(d); err != nil {
				return err
			}
		case "has_organization_projects":
			v, err := d.Bool()
			s.HasOrganizationProjects = bool(v)
			if err != nil {
				return err
			}
		case "has_repository_projects":
			v, err := d.Bool()
			s.HasRepositoryProjects = bool(v)
			if err != nil {
				return err
			}
		case "public_repos":
			v, err := d.Int()
			s.PublicRepos = int(v)
			if err != nil {
				return err
			}
		case "public_gists":
			v, err := d.Int()
			s.PublicGists = int(v)
			if err != nil {
				return err
			}
		case "followers":
			v, err := d.Int()
			s.Followers = int(v)
			if err != nil {
				return err
			}
		case "following":
			v, err := d.Int()
			s.Following = int(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "total_private_repos":
			s.TotalPrivateRepos.Reset()
			if err := s.TotalPrivateRepos.Decode(d); err != nil {
				return err
			}
		case "owned_private_repos":
			s.OwnedPrivateRepos.Reset()
			if err := s.OwnedPrivateRepos.Decode(d); err != nil {
				return err
			}
		case "private_gists":
			s.PrivateGists.Reset()
			if err := s.PrivateGists.Decode(d); err != nil {
				return err
			}
		case "disk_usage":
			s.DiskUsage.Reset()
			if err := s.DiskUsage.Decode(d); err != nil {
				return err
			}
		case "collaborators":
			s.Collaborators.Reset()
			if err := s.Collaborators.Decode(d); err != nil {
				return err
			}
		case "billing_email":
			s.BillingEmail.Reset()
			if err := s.BillingEmail.Decode(d); err != nil {
				return err
			}
		case "plan":
			s.Plan.Reset()
			if err := s.Plan.Decode(d); err != nil {
				return err
			}
		case "default_repository_permission":
			s.DefaultRepositoryPermission.Reset()
			if err := s.DefaultRepositoryPermission.Decode(d); err != nil {
				return err
			}
		case "members_can_create_repositories":
			s.MembersCanCreateRepositories.Reset()
			if err := s.MembersCanCreateRepositories.Decode(d); err != nil {
				return err
			}
		case "two_factor_requirement_enabled":
			s.TwoFactorRequirementEnabled.Reset()
			if err := s.TwoFactorRequirementEnabled.Decode(d); err != nil {
				return err
			}
		case "members_allowed_repository_creation_type":
			s.MembersAllowedRepositoryCreationType.Reset()
			if err := s.MembersAllowedRepositoryCreationType.Decode(d); err != nil {
				return err
			}
		case "members_can_create_public_repositories":
			s.MembersCanCreatePublicRepositories.Reset()
			if err := s.MembersCanCreatePublicRepositories.Decode(d); err != nil {
				return err
			}
		case "members_can_create_private_repositories":
			s.MembersCanCreatePrivateRepositories.Reset()
			if err := s.MembersCanCreatePrivateRepositories.Decode(d); err != nil {
				return err
			}
		case "members_can_create_internal_repositories":
			s.MembersCanCreateInternalRepositories.Reset()
			if err := s.MembersCanCreateInternalRepositories.Decode(d); err != nil {
				return err
			}
		case "members_can_create_pages":
			s.MembersCanCreatePages.Reset()
			if err := s.MembersCanCreatePages.Decode(d); err != nil {
				return err
			}
		case "members_can_create_public_pages":
			s.MembersCanCreatePublicPages.Reset()
			if err := s.MembersCanCreatePublicPages.Decode(d); err != nil {
				return err
			}
		case "members_can_create_private_pages":
			s.MembersCanCreatePrivatePages.Reset()
			if err := s.MembersCanCreatePrivatePages.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrganizationFullPlan) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("space")
	e.Int(s.Space)

	e.FieldStart("private_repos")
	e.Int(s.PrivateRepos)
	if s.FilledSeats.Set {
		e.FieldStart("filled_seats")
		s.FilledSeats.Encode(e)
	}
	if s.Seats.Set {
		e.FieldStart("seats")
		s.Seats.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrganizationFullPlan from json.
func (s *OrganizationFullPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrganizationFullPlan to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "space":
			v, err := d.Int()
			s.Space = int(v)
			if err != nil {
				return err
			}
		case "private_repos":
			v, err := d.Int()
			s.PrivateRepos = int(v)
			if err != nil {
				return err
			}
		case "filled_seats":
			s.FilledSeats.Reset()
			if err := s.FilledSeats.Decode(d); err != nil {
				return err
			}
		case "seats":
			s.Seats.Reset()
			if err := s.Seats.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrganizationInvitation) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("login")
	s.Login.Encode(e)

	e.FieldStart("email")
	s.Email.Encode(e)

	e.FieldStart("role")
	e.Str(s.Role)

	e.FieldStart("created_at")
	e.Str(s.CreatedAt)
	if s.FailedAt.Set {
		e.FieldStart("failed_at")
		s.FailedAt.Encode(e)
	}
	if s.FailedReason.Set {
		e.FieldStart("failed_reason")
		s.FailedReason.Encode(e)
	}

	e.FieldStart("inviter")
	s.Inviter.Encode(e)

	e.FieldStart("team_count")
	e.Int(s.TeamCount)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("invitation_teams_url")
	e.Str(s.InvitationTeamsURL)
	e.ObjEnd()
}

// Decode decodes OrganizationInvitation from json.
func (s *OrganizationInvitation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrganizationInvitation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "login":
			if err := s.Login.Decode(d); err != nil {
				return err
			}
		case "email":
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "role":
			v, err := d.Str()
			s.Role = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := d.Str()
			s.CreatedAt = string(v)
			if err != nil {
				return err
			}
		case "failed_at":
			s.FailedAt.Reset()
			if err := s.FailedAt.Decode(d); err != nil {
				return err
			}
		case "failed_reason":
			s.FailedReason.Reset()
			if err := s.FailedReason.Decode(d); err != nil {
				return err
			}
		case "inviter":
			if err := s.Inviter.Decode(d); err != nil {
				return err
			}
		case "team_count":
			v, err := d.Int()
			s.TeamCount = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "invitation_teams_url":
			v, err := d.Str()
			s.InvitationTeamsURL = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrganizationSecretScanningAlert) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Number.Set {
		e.FieldStart("number")
		s.Number.Encode(e)
	}
	if s.CreatedAt.Set {
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.LocationsURL.Set {
		e.FieldStart("locations_url")
		s.LocationsURL.Encode(e)
	}
	if s.State.Set {
		e.FieldStart("state")
		s.State.Encode(e)
	}
	if s.Resolution.Set {
		e.FieldStart("resolution")
		s.Resolution.Encode(e)
	}
	if s.ResolvedAt.Set {
		e.FieldStart("resolved_at")
		s.ResolvedAt.Encode(e, json.EncodeDateTime)
	}
	if s.ResolvedBy.Set {
		e.FieldStart("resolved_by")
		s.ResolvedBy.Encode(e)
	}
	if s.SecretType.Set {
		e.FieldStart("secret_type")
		s.SecretType.Encode(e)
	}
	if s.Secret.Set {
		e.FieldStart("secret")
		s.Secret.Encode(e)
	}
	if s.Repository.Set {
		e.FieldStart("repository")
		s.Repository.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrganizationSecretScanningAlert from json.
func (s *OrganizationSecretScanningAlert) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrganizationSecretScanningAlert to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			s.Number.Reset()
			if err := s.Number.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "locations_url":
			s.LocationsURL.Reset()
			if err := s.LocationsURL.Decode(d); err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "resolution":
			s.Resolution.Reset()
			if err := s.Resolution.Decode(d); err != nil {
				return err
			}
		case "resolved_at":
			s.ResolvedAt.Reset()
			if err := s.ResolvedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "resolved_by":
			s.ResolvedBy.Reset()
			if err := s.ResolvedBy.Decode(d); err != nil {
				return err
			}
		case "secret_type":
			s.SecretType.Reset()
			if err := s.SecretType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "repository":
			s.Repository.Reset()
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrganizationSimple) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("login")
	e.Str(s.Login)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("repos_url")
	json.EncodeURI(e, s.ReposURL)

	e.FieldStart("events_url")
	json.EncodeURI(e, s.EventsURL)

	e.FieldStart("hooks_url")
	e.Str(s.HooksURL)

	e.FieldStart("issues_url")
	e.Str(s.IssuesURL)

	e.FieldStart("members_url")
	e.Str(s.MembersURL)

	e.FieldStart("public_members_url")
	e.Str(s.PublicMembersURL)

	e.FieldStart("avatar_url")
	e.Str(s.AvatarURL)

	e.FieldStart("description")
	s.Description.Encode(e)
	e.ObjEnd()
}

// Decode decodes OrganizationSimple from json.
func (s *OrganizationSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrganizationSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "hooks_url":
			v, err := d.Str()
			s.HooksURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "members_url":
			v, err := d.Str()
			s.MembersURL = string(v)
			if err != nil {
				return err
			}
		case "public_members_url":
			v, err := d.Str()
			s.PublicMembersURL = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := d.Str()
			s.AvatarURL = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsBlockUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsBlockUserNoContent from json.
func (s *OrgsBlockUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsBlockUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCancelInvitationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsCancelInvitationNoContent from json.
func (s *OrgsCancelInvitationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCancelInvitationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCheckBlockedUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsCheckBlockedUserNoContent from json.
func (s *OrgsCheckBlockedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCheckBlockedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCheckMembershipForUserFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsCheckMembershipForUserFound from json.
func (s *OrgsCheckMembershipForUserFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCheckMembershipForUserFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCheckMembershipForUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsCheckMembershipForUserNoContent from json.
func (s *OrgsCheckMembershipForUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCheckMembershipForUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCheckMembershipForUserNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsCheckMembershipForUserNotFound from json.
func (s *OrgsCheckMembershipForUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCheckMembershipForUserNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCheckPublicMembershipForUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsCheckPublicMembershipForUserNoContent from json.
func (s *OrgsCheckPublicMembershipForUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCheckPublicMembershipForUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCheckPublicMembershipForUserNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsCheckPublicMembershipForUserNotFound from json.
func (s *OrgsCheckPublicMembershipForUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCheckPublicMembershipForUserNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsConvertMemberToOutsideCollaboratorAccepted) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsConvertMemberToOutsideCollaboratorAccepted from json.
func (s *OrgsConvertMemberToOutsideCollaboratorAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsConvertMemberToOutsideCollaboratorAccepted to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsConvertMemberToOutsideCollaboratorForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsConvertMemberToOutsideCollaboratorForbidden from json.
func (s *OrgsConvertMemberToOutsideCollaboratorForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsConvertMemberToOutsideCollaboratorForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsConvertMemberToOutsideCollaboratorNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsConvertMemberToOutsideCollaboratorNoContent from json.
func (s *OrgsConvertMemberToOutsideCollaboratorNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsConvertMemberToOutsideCollaboratorNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCreateInvitationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.InviteeID.Set {
		e.FieldStart("invitee_id")
		s.InviteeID.Encode(e)
	}
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	if s.Role.Set {
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	if s.TeamIds != nil {
		e.FieldStart("team_ids")
		e.ArrStart()
		for _, elem := range s.TeamIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes OrgsCreateInvitationReq from json.
func (s *OrgsCreateInvitationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCreateInvitationReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "invitee_id":
			s.InviteeID.Reset()
			if err := s.InviteeID.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "role":
			s.Role.Reset()
			if err := s.Role.Decode(d); err != nil {
				return err
			}
		case "team_ids":
			s.TeamIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.TeamIds = append(s.TeamIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgsCreateInvitationReqRole as json.
func (s OrgsCreateInvitationReqRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgsCreateInvitationReqRole from json.
func (s *OrgsCreateInvitationReqRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCreateInvitationReqRole to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = OrgsCreateInvitationReqRole(v)
	return nil
}

// Encode implements json.Marshaler.
func (s OrgsCreateWebhookReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("config")
	s.Config.Encode(e)
	if s.Events != nil {
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Active.Set {
		e.FieldStart("active")
		s.Active.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrgsCreateWebhookReq from json.
func (s *OrgsCreateWebhookReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCreateWebhookReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "config":
			if err := s.Config.Decode(d); err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsCreateWebhookReqConfig) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	s.URL.Encode(e)
	if s.ContentType.Set {
		e.FieldStart("content_type")
		s.ContentType.Encode(e)
	}
	if s.Secret.Set {
		e.FieldStart("secret")
		s.Secret.Encode(e)
	}
	if s.InsecureSsl != nil {
		e.FieldStart("insecure_ssl")
		s.InsecureSsl.Encode(e)
	}
	if s.Username.Set {
		e.FieldStart("username")
		s.Username.Encode(e)
	}
	if s.Password.Set {
		e.FieldStart("password")
		s.Password.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrgsCreateWebhookReqConfig from json.
func (s *OrgsCreateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsCreateWebhookReqConfig to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.URL = WebhookConfigURL(unwrapped)
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl = nil
			var elem WebhookConfigInsecureSsl
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.InsecureSsl = &elem
		case "username":
			s.Username.Reset()
			if err := s.Username.Decode(d); err != nil {
				return err
			}
		case "password":
			s.Password.Reset()
			if err := s.Password.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsDeleteWebhookNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsDeleteWebhookNoContent from json.
func (s *OrgsDeleteWebhookNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsDeleteWebhookNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgsGetAuditLogInclude as json.
func (s OrgsGetAuditLogInclude) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgsGetAuditLogInclude from json.
func (s *OrgsGetAuditLogInclude) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsGetAuditLogInclude to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = OrgsGetAuditLogInclude(v)
	return nil
}

// Encode encodes OrgsGetAuditLogOrder as json.
func (s OrgsGetAuditLogOrder) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgsGetAuditLogOrder from json.
func (s *OrgsGetAuditLogOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsGetAuditLogOrder to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = OrgsGetAuditLogOrder(v)
	return nil
}

// Encode encodes OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden as json.
func (s OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden from json.
func (s *OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsGetMembershipForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound as json.
func (s OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound from json.
func (s *OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsGetMembershipForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes OrgsGetMembershipForUserApplicationJSONForbidden as json.
func (s OrgsGetMembershipForUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsGetMembershipForUserApplicationJSONForbidden from json.
func (s *OrgsGetMembershipForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsGetMembershipForUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsGetMembershipForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OrgsGetMembershipForUserApplicationJSONNotFound as json.
func (s OrgsGetMembershipForUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsGetMembershipForUserApplicationJSONNotFound from json.
func (s *OrgsGetMembershipForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsGetMembershipForUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsGetMembershipForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes OrgsListBlockedUsersOKApplicationJSON as json.
func (s OrgsListBlockedUsersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes OrgsListBlockedUsersOKApplicationJSON from json.
func (s *OrgsListBlockedUsersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListBlockedUsersOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListBlockedUsersOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListFailedInvitationsOKApplicationJSON as json.
func (s OrgsListFailedInvitationsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []OrganizationInvitation(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes OrgsListFailedInvitationsOKApplicationJSON from json.
func (s *OrgsListFailedInvitationsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListFailedInvitationsOKApplicationJSON to nil`)
	}
	var unwrapped []OrganizationInvitation
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrganizationInvitation
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListFailedInvitationsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListForAuthenticatedUserApplicationJSONForbidden as json.
func (s OrgsListForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsListForAuthenticatedUserApplicationJSONForbidden from json.
func (s *OrgsListForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OrgsListForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s OrgsListForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsListForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *OrgsListForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes OrgsListForAuthenticatedUserOKApplicationJSON as json.
func (s OrgsListForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []OrganizationSimple(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes OrgsListForAuthenticatedUserOKApplicationJSON from json.
func (s *OrgsListForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []OrganizationSimple
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrganizationSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListInvitationTeamsOKApplicationJSON as json.
func (s OrgsListInvitationTeamsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Team(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes OrgsListInvitationTeamsOKApplicationJSON from json.
func (s *OrgsListInvitationTeamsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListInvitationTeamsOKApplicationJSON to nil`)
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListInvitationTeamsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListMembersFilter as json.
func (s OrgsListMembersFilter) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgsListMembersFilter from json.
func (s *OrgsListMembersFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListMembersFilter to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = OrgsListMembersFilter(v)
	return nil
}

// Encode implements json.Marshaler.
func (s OrgsListMembersFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsListMembersFound from json.
func (s *OrgsListMembersFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListMembersFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgsListMembersRole as json.
func (s OrgsListMembersRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgsListMembersRole from json.
func (s *OrgsListMembersRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListMembersRole to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = OrgsListMembersRole(v)
	return nil
}

// Encode encodes OrgsListMembershipsForAuthenticatedUserState as json.
func (s OrgsListMembershipsForAuthenticatedUserState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgsListMembershipsForAuthenticatedUserState from json.
func (s *OrgsListMembershipsForAuthenticatedUserState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListMembershipsForAuthenticatedUserState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = OrgsListMembershipsForAuthenticatedUserState(v)
	return nil
}

// Encode encodes OrgsListOKApplicationJSON as json.
func (s OrgsListOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []OrganizationSimple(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes OrgsListOKApplicationJSON from json.
func (s *OrgsListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListOKApplicationJSON to nil`)
	}
	var unwrapped []OrganizationSimple
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrganizationSimple
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListOutsideCollaboratorsFilter as json.
func (s OrgsListOutsideCollaboratorsFilter) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgsListOutsideCollaboratorsFilter from json.
func (s *OrgsListOutsideCollaboratorsFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListOutsideCollaboratorsFilter to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = OrgsListOutsideCollaboratorsFilter(v)
	return nil
}

// Encode encodes OrgsListPendingInvitationsOKApplicationJSON as json.
func (s OrgsListPendingInvitationsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []OrganizationInvitation(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes OrgsListPendingInvitationsOKApplicationJSON from json.
func (s *OrgsListPendingInvitationsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListPendingInvitationsOKApplicationJSON to nil`)
	}
	var unwrapped []OrganizationInvitation
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrganizationInvitation
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListPendingInvitationsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes OrgsListWebhooksOKApplicationJSON as json.
func (s OrgsListWebhooksOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []OrgHook(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes OrgsListWebhooksOKApplicationJSON from json.
func (s *OrgsListWebhooksOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsListWebhooksOKApplicationJSON to nil`)
	}
	var unwrapped []OrgHook
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrgHook
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsListWebhooksOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OrgsPingWebhookNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsPingWebhookNoContent from json.
func (s *OrgsPingWebhookNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsPingWebhookNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsRemoveMemberNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsRemoveMemberNoContent from json.
func (s *OrgsRemoveMemberNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsRemoveMemberNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgsRemoveMembershipForUserApplicationJSONForbidden as json.
func (s OrgsRemoveMembershipForUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsRemoveMembershipForUserApplicationJSONForbidden from json.
func (s *OrgsRemoveMembershipForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsRemoveMembershipForUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsRemoveMembershipForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes OrgsRemoveMembershipForUserApplicationJSONNotFound as json.
func (s OrgsRemoveMembershipForUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes OrgsRemoveMembershipForUserApplicationJSONNotFound from json.
func (s *OrgsRemoveMembershipForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsRemoveMembershipForUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = OrgsRemoveMembershipForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s OrgsRemoveMembershipForUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsRemoveMembershipForUserNoContent from json.
func (s *OrgsRemoveMembershipForUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsRemoveMembershipForUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsRemoveOutsideCollaboratorNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsRemoveOutsideCollaboratorNoContent from json.
func (s *OrgsRemoveOutsideCollaboratorNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsRemoveOutsideCollaboratorNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsRemoveOutsideCollaboratorUnprocessableEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.DocumentationURL.Set {
		e.FieldStart("documentation_url")
		s.DocumentationURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrgsRemoveOutsideCollaboratorUnprocessableEntity from json.
func (s *OrgsRemoveOutsideCollaboratorUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsRemoveOutsideCollaboratorUnprocessableEntity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsRemovePublicMembershipForAuthenticatedUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsRemovePublicMembershipForAuthenticatedUserNoContent from json.
func (s *OrgsRemovePublicMembershipForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsRemovePublicMembershipForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsRemoveSamlSSOAuthorizationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsRemoveSamlSSOAuthorizationNoContent from json.
func (s *OrgsRemoveSamlSSOAuthorizationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsRemoveSamlSSOAuthorizationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsSetMembershipForUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Role.Set {
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrgsSetMembershipForUserReq from json.
func (s *OrgsSetMembershipForUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsSetMembershipForUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			s.Role.Reset()
			if err := s.Role.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgsSetMembershipForUserReqRole as json.
func (s OrgsSetMembershipForUserReqRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgsSetMembershipForUserReqRole from json.
func (s *OrgsSetMembershipForUserReqRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsSetMembershipForUserReqRole to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = OrgsSetMembershipForUserReqRole(v)
	return nil
}

// Encode implements json.Marshaler.
func (s OrgsSetPublicMembershipForAuthenticatedUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsSetPublicMembershipForAuthenticatedUserNoContent from json.
func (s *OrgsSetPublicMembershipForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsSetPublicMembershipForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsUnblockUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes OrgsUnblockUserNoContent from json.
func (s *OrgsUnblockUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUnblockUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsUpdateMembershipForAuthenticatedUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("state")
	s.State.Encode(e)
	e.ObjEnd()
}

// Decode decodes OrgsUpdateMembershipForAuthenticatedUserReq from json.
func (s *OrgsUpdateMembershipForAuthenticatedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateMembershipForAuthenticatedUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgsUpdateMembershipForAuthenticatedUserReqState as json.
func (s OrgsUpdateMembershipForAuthenticatedUserReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgsUpdateMembershipForAuthenticatedUserReqState from json.
func (s *OrgsUpdateMembershipForAuthenticatedUserReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateMembershipForAuthenticatedUserReqState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = OrgsUpdateMembershipForAuthenticatedUserReqState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s OrgsUpdateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.BillingEmail.Set {
		e.FieldStart("billing_email")
		s.BillingEmail.Encode(e)
	}
	if s.Company.Set {
		e.FieldStart("company")
		s.Company.Encode(e)
	}
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	if s.TwitterUsername.Set {
		e.FieldStart("twitter_username")
		s.TwitterUsername.Encode(e)
	}
	if s.Location.Set {
		e.FieldStart("location")
		s.Location.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.HasOrganizationProjects.Set {
		e.FieldStart("has_organization_projects")
		s.HasOrganizationProjects.Encode(e)
	}
	if s.HasRepositoryProjects.Set {
		e.FieldStart("has_repository_projects")
		s.HasRepositoryProjects.Encode(e)
	}
	if s.DefaultRepositoryPermission.Set {
		e.FieldStart("default_repository_permission")
		s.DefaultRepositoryPermission.Encode(e)
	}
	if s.MembersCanCreateRepositories.Set {
		e.FieldStart("members_can_create_repositories")
		s.MembersCanCreateRepositories.Encode(e)
	}
	if s.MembersCanCreateInternalRepositories.Set {
		e.FieldStart("members_can_create_internal_repositories")
		s.MembersCanCreateInternalRepositories.Encode(e)
	}
	if s.MembersCanCreatePrivateRepositories.Set {
		e.FieldStart("members_can_create_private_repositories")
		s.MembersCanCreatePrivateRepositories.Encode(e)
	}
	if s.MembersCanCreatePublicRepositories.Set {
		e.FieldStart("members_can_create_public_repositories")
		s.MembersCanCreatePublicRepositories.Encode(e)
	}
	if s.MembersAllowedRepositoryCreationType.Set {
		e.FieldStart("members_allowed_repository_creation_type")
		s.MembersAllowedRepositoryCreationType.Encode(e)
	}
	if s.MembersCanCreatePages.Set {
		e.FieldStart("members_can_create_pages")
		s.MembersCanCreatePages.Encode(e)
	}
	if s.MembersCanCreatePublicPages.Set {
		e.FieldStart("members_can_create_public_pages")
		s.MembersCanCreatePublicPages.Encode(e)
	}
	if s.MembersCanCreatePrivatePages.Set {
		e.FieldStart("members_can_create_private_pages")
		s.MembersCanCreatePrivatePages.Encode(e)
	}
	if s.Blog.Set {
		e.FieldStart("blog")
		s.Blog.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrgsUpdateReq from json.
func (s *OrgsUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billing_email":
			s.BillingEmail.Reset()
			if err := s.BillingEmail.Decode(d); err != nil {
				return err
			}
		case "company":
			s.Company.Reset()
			if err := s.Company.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "twitter_username":
			s.TwitterUsername.Reset()
			if err := s.TwitterUsername.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "has_organization_projects":
			s.HasOrganizationProjects.Reset()
			if err := s.HasOrganizationProjects.Decode(d); err != nil {
				return err
			}
		case "has_repository_projects":
			s.HasRepositoryProjects.Reset()
			if err := s.HasRepositoryProjects.Decode(d); err != nil {
				return err
			}
		case "default_repository_permission":
			s.DefaultRepositoryPermission.Reset()
			if err := s.DefaultRepositoryPermission.Decode(d); err != nil {
				return err
			}
		case "members_can_create_repositories":
			s.MembersCanCreateRepositories.Reset()
			if err := s.MembersCanCreateRepositories.Decode(d); err != nil {
				return err
			}
		case "members_can_create_internal_repositories":
			s.MembersCanCreateInternalRepositories.Reset()
			if err := s.MembersCanCreateInternalRepositories.Decode(d); err != nil {
				return err
			}
		case "members_can_create_private_repositories":
			s.MembersCanCreatePrivateRepositories.Reset()
			if err := s.MembersCanCreatePrivateRepositories.Decode(d); err != nil {
				return err
			}
		case "members_can_create_public_repositories":
			s.MembersCanCreatePublicRepositories.Reset()
			if err := s.MembersCanCreatePublicRepositories.Decode(d); err != nil {
				return err
			}
		case "members_allowed_repository_creation_type":
			s.MembersAllowedRepositoryCreationType.Reset()
			if err := s.MembersAllowedRepositoryCreationType.Decode(d); err != nil {
				return err
			}
		case "members_can_create_pages":
			s.MembersCanCreatePages.Reset()
			if err := s.MembersCanCreatePages.Decode(d); err != nil {
				return err
			}
		case "members_can_create_public_pages":
			s.MembersCanCreatePublicPages.Reset()
			if err := s.MembersCanCreatePublicPages.Decode(d); err != nil {
				return err
			}
		case "members_can_create_private_pages":
			s.MembersCanCreatePrivatePages.Reset()
			if err := s.MembersCanCreatePrivatePages.Decode(d); err != nil {
				return err
			}
		case "blog":
			s.Blog.Reset()
			if err := s.Blog.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes OrgsUpdateReqDefaultRepositoryPermission as json.
func (s OrgsUpdateReqDefaultRepositoryPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgsUpdateReqDefaultRepositoryPermission from json.
func (s *OrgsUpdateReqDefaultRepositoryPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateReqDefaultRepositoryPermission to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = OrgsUpdateReqDefaultRepositoryPermission(v)
	return nil
}

// Encode encodes OrgsUpdateReqMembersAllowedRepositoryCreationType as json.
func (s OrgsUpdateReqMembersAllowedRepositoryCreationType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrgsUpdateReqMembersAllowedRepositoryCreationType from json.
func (s *OrgsUpdateReqMembersAllowedRepositoryCreationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateReqMembersAllowedRepositoryCreationType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = OrgsUpdateReqMembersAllowedRepositoryCreationType(v)
	return nil
}

// Encode implements json.Marshaler.
func (s OrgsUpdateWebhookConfigForOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.ContentType.Set {
		e.FieldStart("content_type")
		s.ContentType.Encode(e)
	}
	if s.Secret.Set {
		e.FieldStart("secret")
		s.Secret.Encode(e)
	}
	if s.InsecureSsl != nil {
		e.FieldStart("insecure_ssl")
		s.InsecureSsl.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrgsUpdateWebhookConfigForOrgReq from json.
func (s *OrgsUpdateWebhookConfigForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateWebhookConfigForOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl = nil
			var elem WebhookConfigInsecureSsl
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.InsecureSsl = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsUpdateWebhookReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Config.Set {
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	if s.Events != nil {
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Active.Set {
		e.FieldStart("active")
		s.Active.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrgsUpdateWebhookReq from json.
func (s *OrgsUpdateWebhookReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateWebhookReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			s.Config.Reset()
			if err := s.Config.Decode(d); err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s OrgsUpdateWebhookReqConfig) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	s.URL.Encode(e)
	if s.ContentType.Set {
		e.FieldStart("content_type")
		s.ContentType.Encode(e)
	}
	if s.Secret.Set {
		e.FieldStart("secret")
		s.Secret.Encode(e)
	}
	if s.InsecureSsl != nil {
		e.FieldStart("insecure_ssl")
		s.InsecureSsl.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes OrgsUpdateWebhookReqConfig from json.
func (s *OrgsUpdateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode OrgsUpdateWebhookReqConfig to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.URL = WebhookConfigURL(unwrapped)
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl = nil
			var elem WebhookConfigInsecureSsl
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.InsecureSsl = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Package) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("package_type")
	s.PackageType.Encode(e)

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("html_url")
	e.Str(s.HTMLURL)

	e.FieldStart("version_count")
	e.Int(s.VersionCount)

	e.FieldStart("visibility")
	s.Visibility.Encode(e)
	if s.Owner.Set {
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	if s.Repository.Set {
		e.FieldStart("repository")
		s.Repository.Encode(e)
	}

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)
	e.ObjEnd()
}

// Decode decodes Package from json.
func (s *Package) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Package to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "package_type":
			if err := s.PackageType.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := d.Str()
			s.HTMLURL = string(v)
			if err != nil {
				return err
			}
		case "version_count":
			v, err := d.Int()
			s.VersionCount = int(v)
			if err != nil {
				return err
			}
		case "visibility":
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "owner":
			s.Owner.Reset()
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "repository":
			s.Repository.Reset()
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagePackageType as json.
func (s PackagePackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagePackageType from json.
func (s *PackagePackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagePackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagePackageType(v)
	return nil
}

// Encode implements json.Marshaler.
func (s PackageVersion) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("package_html_url")
	e.Str(s.PackageHTMLURL)
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.License.Set {
		e.FieldStart("license")
		s.License.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)
	if s.DeletedAt.Set {
		e.FieldStart("deleted_at")
		s.DeletedAt.Encode(e, json.EncodeDateTime)
	}
	if s.Metadata.Set {
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PackageVersion from json.
func (s *PackageVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackageVersion to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "package_html_url":
			v, err := d.Str()
			s.PackageHTMLURL = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "license":
			s.License.Reset()
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "deleted_at":
			s.DeletedAt.Reset()
			if err := s.DeletedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "metadata":
			s.Metadata.Reset()
			if err := s.Metadata.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PackageVersionMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("package_type")
	s.PackageType.Encode(e)
	if s.Container.Set {
		e.FieldStart("container")
		s.Container.Encode(e)
	}
	if s.Docker.Set {
		e.FieldStart("docker")
		s.Docker.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PackageVersionMetadata from json.
func (s *PackageVersionMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackageVersionMetadata to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "package_type":
			if err := s.PackageType.Decode(d); err != nil {
				return err
			}
		case "container":
			s.Container.Reset()
			if err := s.Container.Decode(d); err != nil {
				return err
			}
		case "docker":
			s.Docker.Reset()
			if err := s.Docker.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PackageVersionMetadataContainer) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("tags")
	e.ArrStart()
	for _, elem := range s.Tags {
		e.Str(elem)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes PackageVersionMetadataContainer from json.
func (s *PackageVersionMetadataContainer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackageVersionMetadataContainer to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tags":
			s.Tags = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Tags = append(s.Tags, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PackageVersionMetadataDocker) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Tag != nil {
		e.FieldStart("tag")
		e.ArrStart()
		for _, elem := range s.Tag {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes PackageVersionMetadataDocker from json.
func (s *PackageVersionMetadataDocker) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackageVersionMetadataDocker to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			s.Tag = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Tag = append(s.Tag, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackageVersionMetadataPackageType as json.
func (s PackageVersionMetadataPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackageVersionMetadataPackageType from json.
func (s *PackageVersionMetadataPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackageVersionMetadataPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackageVersionMetadataPackageType(v)
	return nil
}

// Encode encodes PackageVisibility as json.
func (s PackageVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackageVisibility from json.
func (s *PackageVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackageVisibility to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackageVisibility(v)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesBillingUsage) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_gigabytes_bandwidth_used")
	e.Int(s.TotalGigabytesBandwidthUsed)

	e.FieldStart("total_paid_gigabytes_bandwidth_used")
	e.Int(s.TotalPaidGigabytesBandwidthUsed)

	e.FieldStart("included_gigabytes_bandwidth")
	e.Int(s.IncludedGigabytesBandwidth)
	e.ObjEnd()
}

// Decode decodes PackagesBillingUsage from json.
func (s *PackagesBillingUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesBillingUsage to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_gigabytes_bandwidth_used":
			v, err := d.Int()
			s.TotalGigabytesBandwidthUsed = int(v)
			if err != nil {
				return err
			}
		case "total_paid_gigabytes_bandwidth_used":
			v, err := d.Int()
			s.TotalPaidGigabytesBandwidthUsed = int(v)
			if err != nil {
				return err
			}
		case "included_gigabytes_bandwidth":
			v, err := d.Int()
			s.IncludedGigabytesBandwidth = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden as json.
func (s PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden from json.
func (s *PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound as json.
func (s PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound from json.
func (s *PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesDeletePackageForAuthenticatedUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes PackagesDeletePackageForAuthenticatedUserNoContent from json.
func (s *PackagesDeletePackageForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesDeletePackageForAuthenticatedUserPackageType as json.
func (s PackagesDeletePackageForAuthenticatedUserPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesDeletePackageForAuthenticatedUserPackageType from json.
func (s *PackagesDeletePackageForAuthenticatedUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForAuthenticatedUserPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesDeletePackageForAuthenticatedUserPackageType(v)
	return nil
}

// Encode encodes PackagesDeletePackageForOrgApplicationJSONForbidden as json.
func (s PackagesDeletePackageForOrgApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForOrgApplicationJSONForbidden from json.
func (s *PackagesDeletePackageForOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForOrgApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForOrgApplicationJSONNotFound as json.
func (s PackagesDeletePackageForOrgApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForOrgApplicationJSONNotFound from json.
func (s *PackagesDeletePackageForOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForOrgApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForOrgApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageForOrgApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForOrgApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageForOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForOrgApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesDeletePackageForOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes PackagesDeletePackageForOrgNoContent from json.
func (s *PackagesDeletePackageForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesDeletePackageForOrgPackageType as json.
func (s PackagesDeletePackageForOrgPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesDeletePackageForOrgPackageType from json.
func (s *PackagesDeletePackageForOrgPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForOrgPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesDeletePackageForOrgPackageType(v)
	return nil
}

// Encode encodes PackagesDeletePackageForUserApplicationJSONForbidden as json.
func (s PackagesDeletePackageForUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForUserApplicationJSONForbidden from json.
func (s *PackagesDeletePackageForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForUserApplicationJSONNotFound as json.
func (s PackagesDeletePackageForUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForUserApplicationJSONNotFound from json.
func (s *PackagesDeletePackageForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageForUserApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageForUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageForUserApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesDeletePackageForUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes PackagesDeletePackageForUserNoContent from json.
func (s *PackagesDeletePackageForUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesDeletePackageForUserPackageType as json.
func (s PackagesDeletePackageForUserPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesDeletePackageForUserPackageType from json.
func (s *PackagesDeletePackageForUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageForUserPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesDeletePackageForUserPackageType(v)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden as json.
func (s PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden from json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound as json.
func (s PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound from json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesDeletePackageVersionForAuthenticatedUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes PackagesDeletePackageVersionForAuthenticatedUserNoContent from json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesDeletePackageVersionForAuthenticatedUserPackageType as json.
func (s PackagesDeletePackageVersionForAuthenticatedUserPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesDeletePackageVersionForAuthenticatedUserPackageType from json.
func (s *PackagesDeletePackageVersionForAuthenticatedUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForAuthenticatedUserPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesDeletePackageVersionForAuthenticatedUserPackageType(v)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForOrgApplicationJSONForbidden as json.
func (s PackagesDeletePackageVersionForOrgApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForOrgApplicationJSONForbidden from json.
func (s *PackagesDeletePackageVersionForOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForOrgApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForOrgApplicationJSONNotFound as json.
func (s PackagesDeletePackageVersionForOrgApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForOrgApplicationJSONNotFound from json.
func (s *PackagesDeletePackageVersionForOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForOrgApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesDeletePackageVersionForOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes PackagesDeletePackageVersionForOrgNoContent from json.
func (s *PackagesDeletePackageVersionForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesDeletePackageVersionForOrgPackageType as json.
func (s PackagesDeletePackageVersionForOrgPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesDeletePackageVersionForOrgPackageType from json.
func (s *PackagesDeletePackageVersionForOrgPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForOrgPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesDeletePackageVersionForOrgPackageType(v)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForUserApplicationJSONForbidden as json.
func (s PackagesDeletePackageVersionForUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForUserApplicationJSONForbidden from json.
func (s *PackagesDeletePackageVersionForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForUserApplicationJSONNotFound as json.
func (s PackagesDeletePackageVersionForUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForUserApplicationJSONNotFound from json.
func (s *PackagesDeletePackageVersionForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesDeletePackageVersionForUserApplicationJSONUnauthorized as json.
func (s PackagesDeletePackageVersionForUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesDeletePackageVersionForUserApplicationJSONUnauthorized from json.
func (s *PackagesDeletePackageVersionForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesDeletePackageVersionForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesDeletePackageVersionForUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes PackagesDeletePackageVersionForUserNoContent from json.
func (s *PackagesDeletePackageVersionForUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesDeletePackageVersionForUserPackageType as json.
func (s PackagesDeletePackageVersionForUserPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesDeletePackageVersionForUserPackageType from json.
func (s *PackagesDeletePackageVersionForUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesDeletePackageVersionForUserPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesDeletePackageVersionForUserPackageType(v)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PackageVersion(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []PackageVersion
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PackageVersion
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType(v)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState(v)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PackageVersion(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON to nil`)
	}
	var unwrapped []PackageVersion
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PackageVersion
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType(v)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByOrgState as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByOrgState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByOrgState from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByOrgState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByOrgState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByOrgState(v)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PackageVersion(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON to nil`)
	}
	var unwrapped []PackageVersion
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PackageVersion
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType as json.
func (s PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType from json.
func (s *PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType(v)
	return nil
}

// Encode encodes PackagesGetPackageForAuthenticatedUserPackageType as json.
func (s PackagesGetPackageForAuthenticatedUserPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesGetPackageForAuthenticatedUserPackageType from json.
func (s *PackagesGetPackageForAuthenticatedUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetPackageForAuthenticatedUserPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesGetPackageForAuthenticatedUserPackageType(v)
	return nil
}

// Encode encodes PackagesGetPackageForOrganizationPackageType as json.
func (s PackagesGetPackageForOrganizationPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesGetPackageForOrganizationPackageType from json.
func (s *PackagesGetPackageForOrganizationPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetPackageForOrganizationPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesGetPackageForOrganizationPackageType(v)
	return nil
}

// Encode encodes PackagesGetPackageForUserPackageType as json.
func (s PackagesGetPackageForUserPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesGetPackageForUserPackageType from json.
func (s *PackagesGetPackageForUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetPackageForUserPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesGetPackageForUserPackageType(v)
	return nil
}

// Encode encodes PackagesGetPackageVersionForAuthenticatedUserPackageType as json.
func (s PackagesGetPackageVersionForAuthenticatedUserPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesGetPackageVersionForAuthenticatedUserPackageType from json.
func (s *PackagesGetPackageVersionForAuthenticatedUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetPackageVersionForAuthenticatedUserPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesGetPackageVersionForAuthenticatedUserPackageType(v)
	return nil
}

// Encode encodes PackagesGetPackageVersionForOrganizationPackageType as json.
func (s PackagesGetPackageVersionForOrganizationPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesGetPackageVersionForOrganizationPackageType from json.
func (s *PackagesGetPackageVersionForOrganizationPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetPackageVersionForOrganizationPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesGetPackageVersionForOrganizationPackageType(v)
	return nil
}

// Encode encodes PackagesGetPackageVersionForUserPackageType as json.
func (s PackagesGetPackageVersionForUserPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesGetPackageVersionForUserPackageType from json.
func (s *PackagesGetPackageVersionForUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesGetPackageVersionForUserPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesGetPackageVersionForUserPackageType(v)
	return nil
}

// Encode encodes PackagesListPackagesForAuthenticatedUserPackageType as json.
func (s PackagesListPackagesForAuthenticatedUserPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesListPackagesForAuthenticatedUserPackageType from json.
func (s *PackagesListPackagesForAuthenticatedUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForAuthenticatedUserPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesListPackagesForAuthenticatedUserPackageType(v)
	return nil
}

// Encode encodes PackagesListPackagesForAuthenticatedUserVisibility as json.
func (s PackagesListPackagesForAuthenticatedUserVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesListPackagesForAuthenticatedUserVisibility from json.
func (s *PackagesListPackagesForAuthenticatedUserVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForAuthenticatedUserVisibility to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesListPackagesForAuthenticatedUserVisibility(v)
	return nil
}

// Encode encodes PackagesListPackagesForOrganizationApplicationJSONForbidden as json.
func (s PackagesListPackagesForOrganizationApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesListPackagesForOrganizationApplicationJSONForbidden from json.
func (s *PackagesListPackagesForOrganizationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForOrganizationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForOrganizationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForOrganizationApplicationJSONUnauthorized as json.
func (s PackagesListPackagesForOrganizationApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesListPackagesForOrganizationApplicationJSONUnauthorized from json.
func (s *PackagesListPackagesForOrganizationApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForOrganizationApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForOrganizationApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForOrganizationOKApplicationJSON as json.
func (s PackagesListPackagesForOrganizationOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Package(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes PackagesListPackagesForOrganizationOKApplicationJSON from json.
func (s *PackagesListPackagesForOrganizationOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForOrganizationOKApplicationJSON to nil`)
	}
	var unwrapped []Package
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Package
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForOrganizationOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForOrganizationPackageType as json.
func (s PackagesListPackagesForOrganizationPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesListPackagesForOrganizationPackageType from json.
func (s *PackagesListPackagesForOrganizationPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForOrganizationPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesListPackagesForOrganizationPackageType(v)
	return nil
}

// Encode encodes PackagesListPackagesForOrganizationVisibility as json.
func (s PackagesListPackagesForOrganizationVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesListPackagesForOrganizationVisibility from json.
func (s *PackagesListPackagesForOrganizationVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForOrganizationVisibility to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesListPackagesForOrganizationVisibility(v)
	return nil
}

// Encode encodes PackagesListPackagesForUserApplicationJSONForbidden as json.
func (s PackagesListPackagesForUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesListPackagesForUserApplicationJSONForbidden from json.
func (s *PackagesListPackagesForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForUserApplicationJSONUnauthorized as json.
func (s PackagesListPackagesForUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesListPackagesForUserApplicationJSONUnauthorized from json.
func (s *PackagesListPackagesForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForUserOKApplicationJSON as json.
func (s PackagesListPackagesForUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Package(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes PackagesListPackagesForUserOKApplicationJSON from json.
func (s *PackagesListPackagesForUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForUserOKApplicationJSON to nil`)
	}
	var unwrapped []Package
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Package
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesListPackagesForUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PackagesListPackagesForUserPackageType as json.
func (s PackagesListPackagesForUserPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesListPackagesForUserPackageType from json.
func (s *PackagesListPackagesForUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForUserPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesListPackagesForUserPackageType(v)
	return nil
}

// Encode encodes PackagesListPackagesForUserVisibility as json.
func (s PackagesListPackagesForUserVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesListPackagesForUserVisibility from json.
func (s *PackagesListPackagesForUserVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesListPackagesForUserVisibility to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesListPackagesForUserVisibility(v)
	return nil
}

// Encode encodes PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden as json.
func (s PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden from json.
func (s *PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound as json.
func (s PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound from json.
func (s *PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesRestorePackageForAuthenticatedUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes PackagesRestorePackageForAuthenticatedUserNoContent from json.
func (s *PackagesRestorePackageForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesRestorePackageForAuthenticatedUserPackageType as json.
func (s PackagesRestorePackageForAuthenticatedUserPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesRestorePackageForAuthenticatedUserPackageType from json.
func (s *PackagesRestorePackageForAuthenticatedUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForAuthenticatedUserPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesRestorePackageForAuthenticatedUserPackageType(v)
	return nil
}

// Encode encodes PackagesRestorePackageForOrgApplicationJSONForbidden as json.
func (s PackagesRestorePackageForOrgApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForOrgApplicationJSONForbidden from json.
func (s *PackagesRestorePackageForOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForOrgApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForOrgApplicationJSONNotFound as json.
func (s PackagesRestorePackageForOrgApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForOrgApplicationJSONNotFound from json.
func (s *PackagesRestorePackageForOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForOrgApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForOrgApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageForOrgApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForOrgApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageForOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForOrgApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesRestorePackageForOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes PackagesRestorePackageForOrgNoContent from json.
func (s *PackagesRestorePackageForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesRestorePackageForOrgPackageType as json.
func (s PackagesRestorePackageForOrgPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesRestorePackageForOrgPackageType from json.
func (s *PackagesRestorePackageForOrgPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForOrgPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesRestorePackageForOrgPackageType(v)
	return nil
}

// Encode encodes PackagesRestorePackageForUserApplicationJSONForbidden as json.
func (s PackagesRestorePackageForUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForUserApplicationJSONForbidden from json.
func (s *PackagesRestorePackageForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForUserApplicationJSONNotFound as json.
func (s PackagesRestorePackageForUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForUserApplicationJSONNotFound from json.
func (s *PackagesRestorePackageForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageForUserApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageForUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageForUserApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesRestorePackageForUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes PackagesRestorePackageForUserNoContent from json.
func (s *PackagesRestorePackageForUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesRestorePackageForUserPackageType as json.
func (s PackagesRestorePackageForUserPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesRestorePackageForUserPackageType from json.
func (s *PackagesRestorePackageForUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageForUserPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesRestorePackageForUserPackageType(v)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden as json.
func (s PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden from json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound as json.
func (s PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound from json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesRestorePackageVersionForAuthenticatedUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes PackagesRestorePackageVersionForAuthenticatedUserNoContent from json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForAuthenticatedUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesRestorePackageVersionForAuthenticatedUserPackageType as json.
func (s PackagesRestorePackageVersionForAuthenticatedUserPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesRestorePackageVersionForAuthenticatedUserPackageType from json.
func (s *PackagesRestorePackageVersionForAuthenticatedUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForAuthenticatedUserPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesRestorePackageVersionForAuthenticatedUserPackageType(v)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForOrgApplicationJSONForbidden as json.
func (s PackagesRestorePackageVersionForOrgApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForOrgApplicationJSONForbidden from json.
func (s *PackagesRestorePackageVersionForOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForOrgApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForOrgApplicationJSONNotFound as json.
func (s PackagesRestorePackageVersionForOrgApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForOrgApplicationJSONNotFound from json.
func (s *PackagesRestorePackageVersionForOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForOrgApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesRestorePackageVersionForOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes PackagesRestorePackageVersionForOrgNoContent from json.
func (s *PackagesRestorePackageVersionForOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesRestorePackageVersionForOrgPackageType as json.
func (s PackagesRestorePackageVersionForOrgPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesRestorePackageVersionForOrgPackageType from json.
func (s *PackagesRestorePackageVersionForOrgPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForOrgPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesRestorePackageVersionForOrgPackageType(v)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForUserApplicationJSONForbidden as json.
func (s PackagesRestorePackageVersionForUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForUserApplicationJSONForbidden from json.
func (s *PackagesRestorePackageVersionForUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForUserApplicationJSONNotFound as json.
func (s PackagesRestorePackageVersionForUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForUserApplicationJSONNotFound from json.
func (s *PackagesRestorePackageVersionForUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PackagesRestorePackageVersionForUserApplicationJSONUnauthorized as json.
func (s PackagesRestorePackageVersionForUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PackagesRestorePackageVersionForUserApplicationJSONUnauthorized from json.
func (s *PackagesRestorePackageVersionForUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PackagesRestorePackageVersionForUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PackagesRestorePackageVersionForUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes PackagesRestorePackageVersionForUserNoContent from json.
func (s *PackagesRestorePackageVersionForUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PackagesRestorePackageVersionForUserPackageType as json.
func (s PackagesRestorePackageVersionForUserPackageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PackagesRestorePackageVersionForUserPackageType from json.
func (s *PackagesRestorePackageVersionForUserPackageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PackagesRestorePackageVersionForUserPackageType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PackagesRestorePackageVersionForUserPackageType(v)
	return nil
}

// Encode implements json.Marshaler.
func (s Page) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("status")
	s.Status.Encode(e)

	e.FieldStart("cname")
	s.Cname.Encode(e)
	if s.ProtectedDomainState.Set {
		e.FieldStart("protected_domain_state")
		s.ProtectedDomainState.Encode(e)
	}
	if s.PendingDomainUnverifiedAt.Set {
		e.FieldStart("pending_domain_unverified_at")
		s.PendingDomainUnverifiedAt.Encode(e, json.EncodeDateTime)
	}

	e.FieldStart("custom_404")
	e.Bool(s.Custom404)
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.Source.Set {
		e.FieldStart("source")
		s.Source.Encode(e)
	}

	e.FieldStart("public")
	e.Bool(s.Public)
	if s.HTTPSCertificate.Set {
		e.FieldStart("https_certificate")
		s.HTTPSCertificate.Encode(e)
	}
	if s.HTTPSEnforced.Set {
		e.FieldStart("https_enforced")
		s.HTTPSEnforced.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Page from json.
func (s *Page) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Page to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "cname":
			if err := s.Cname.Decode(d); err != nil {
				return err
			}
		case "protected_domain_state":
			s.ProtectedDomainState.Reset()
			if err := s.ProtectedDomainState.Decode(d); err != nil {
				return err
			}
		case "pending_domain_unverified_at":
			s.PendingDomainUnverifiedAt.Reset()
			if err := s.PendingDomainUnverifiedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "custom_404":
			v, err := d.Bool()
			s.Custom404 = bool(v)
			if err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "source":
			s.Source.Reset()
			if err := s.Source.Decode(d); err != nil {
				return err
			}
		case "public":
			v, err := d.Bool()
			s.Public = bool(v)
			if err != nil {
				return err
			}
		case "https_certificate":
			s.HTTPSCertificate.Reset()
			if err := s.HTTPSCertificate.Decode(d); err != nil {
				return err
			}
		case "https_enforced":
			s.HTTPSEnforced.Reset()
			if err := s.HTTPSEnforced.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PageBuild) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("status")
	e.Str(s.Status)

	e.FieldStart("error")
	s.Error.Encode(e)

	e.FieldStart("pusher")
	s.Pusher.Encode(e)

	e.FieldStart("commit")
	e.Str(s.Commit)

	e.FieldStart("duration")
	e.Int(s.Duration)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)
	e.ObjEnd()
}

// Decode decodes PageBuild from json.
func (s *PageBuild) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PageBuild to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "error":
			if err := s.Error.Decode(d); err != nil {
				return err
			}
		case "pusher":
			if err := s.Pusher.Decode(d); err != nil {
				return err
			}
		case "commit":
			v, err := d.Str()
			s.Commit = string(v)
			if err != nil {
				return err
			}
		case "duration":
			v, err := d.Int()
			s.Duration = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PageBuildError) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("message")
	s.Message.Encode(e)
	e.ObjEnd()
}

// Decode decodes PageBuildError from json.
func (s *PageBuildError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PageBuildError to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PageBuildStatus) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("status")
	e.Str(s.Status)
	e.ObjEnd()
}

// Decode decodes PageBuildStatus from json.
func (s *PageBuildStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PageBuildStatus to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PageProtectedDomainState as json.
func (s PageProtectedDomainState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PageProtectedDomainState from json.
func (s *PageProtectedDomainState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PageProtectedDomainState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PageProtectedDomainState(v)
	return nil
}

// Encode encodes PageStatus as json.
func (s PageStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PageStatus from json.
func (s *PageStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PageStatus to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PageStatus(v)
	return nil
}

// Encode implements json.Marshaler.
func (s PagesHTTPSCertificate) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("state")
	s.State.Encode(e)

	e.FieldStart("description")
	e.Str(s.Description)

	e.FieldStart("domains")
	e.ArrStart()
	for _, elem := range s.Domains {
		e.Str(elem)
	}
	e.ArrEnd()
	if s.ExpiresAt.Set {
		e.FieldStart("expires_at")
		s.ExpiresAt.Encode(e, json.EncodeDate)
	}
	e.ObjEnd()
}

// Decode decodes PagesHTTPSCertificate from json.
func (s *PagesHTTPSCertificate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PagesHTTPSCertificate to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "description":
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "domains":
			s.Domains = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Domains = append(s.Domains, elem)
				return nil
			}); err != nil {
				return err
			}
		case "expires_at":
			s.ExpiresAt.Reset()
			if err := s.ExpiresAt.Decode(d, json.DecodeDate); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PagesHTTPSCertificateState as json.
func (s PagesHTTPSCertificateState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PagesHTTPSCertificateState from json.
func (s *PagesHTTPSCertificateState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PagesHTTPSCertificateState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PagesHTTPSCertificateState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s PagesHealthCheck) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Domain.Set {
		e.FieldStart("domain")
		s.Domain.Encode(e)
	}
	if s.AltDomain.Set {
		e.FieldStart("alt_domain")
		s.AltDomain.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PagesHealthCheck from json.
func (s *PagesHealthCheck) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PagesHealthCheck to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domain":
			s.Domain.Reset()
			if err := s.Domain.Decode(d); err != nil {
				return err
			}
		case "alt_domain":
			s.AltDomain.Reset()
			if err := s.AltDomain.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PagesHealthCheckAltDomain) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Host.Set {
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	if s.URI.Set {
		e.FieldStart("uri")
		s.URI.Encode(e)
	}
	if s.Nameservers.Set {
		e.FieldStart("nameservers")
		s.Nameservers.Encode(e)
	}
	if s.DNSResolves.Set {
		e.FieldStart("dns_resolves")
		s.DNSResolves.Encode(e)
	}
	if s.IsProxied.Set {
		e.FieldStart("is_proxied")
		s.IsProxied.Encode(e)
	}
	if s.IsCloudflareIP.Set {
		e.FieldStart("is_cloudflare_ip")
		s.IsCloudflareIP.Encode(e)
	}
	if s.IsFastlyIP.Set {
		e.FieldStart("is_fastly_ip")
		s.IsFastlyIP.Encode(e)
	}
	if s.IsOldIPAddress.Set {
		e.FieldStart("is_old_ip_address")
		s.IsOldIPAddress.Encode(e)
	}
	if s.IsARecord.Set {
		e.FieldStart("is_a_record")
		s.IsARecord.Encode(e)
	}
	if s.HasCnameRecord.Set {
		e.FieldStart("has_cname_record")
		s.HasCnameRecord.Encode(e)
	}
	if s.HasMxRecordsPresent.Set {
		e.FieldStart("has_mx_records_present")
		s.HasMxRecordsPresent.Encode(e)
	}
	if s.IsValidDomain.Set {
		e.FieldStart("is_valid_domain")
		s.IsValidDomain.Encode(e)
	}
	if s.IsApexDomain.Set {
		e.FieldStart("is_apex_domain")
		s.IsApexDomain.Encode(e)
	}
	if s.ShouldBeARecord.Set {
		e.FieldStart("should_be_a_record")
		s.ShouldBeARecord.Encode(e)
	}
	if s.IsCnameToGithubUserDomain.Set {
		e.FieldStart("is_cname_to_github_user_domain")
		s.IsCnameToGithubUserDomain.Encode(e)
	}
	if s.IsCnameToPagesDotGithubDotCom.Set {
		e.FieldStart("is_cname_to_pages_dot_github_dot_com")
		s.IsCnameToPagesDotGithubDotCom.Encode(e)
	}
	if s.IsCnameToFastly.Set {
		e.FieldStart("is_cname_to_fastly")
		s.IsCnameToFastly.Encode(e)
	}
	if s.IsPointedToGithubPagesIP.Set {
		e.FieldStart("is_pointed_to_github_pages_ip")
		s.IsPointedToGithubPagesIP.Encode(e)
	}
	if s.IsNonGithubPagesIPPresent.Set {
		e.FieldStart("is_non_github_pages_ip_present")
		s.IsNonGithubPagesIPPresent.Encode(e)
	}
	if s.IsPagesDomain.Set {
		e.FieldStart("is_pages_domain")
		s.IsPagesDomain.Encode(e)
	}
	if s.IsServedByPages.Set {
		e.FieldStart("is_served_by_pages")
		s.IsServedByPages.Encode(e)
	}
	if s.IsValid.Set {
		e.FieldStart("is_valid")
		s.IsValid.Encode(e)
	}
	if s.Reason.Set {
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
	if s.RespondsToHTTPS.Set {
		e.FieldStart("responds_to_https")
		s.RespondsToHTTPS.Encode(e)
	}
	if s.EnforcesHTTPS.Set {
		e.FieldStart("enforces_https")
		s.EnforcesHTTPS.Encode(e)
	}
	if s.HTTPSError.Set {
		e.FieldStart("https_error")
		s.HTTPSError.Encode(e)
	}
	if s.IsHTTPSEligible.Set {
		e.FieldStart("is_https_eligible")
		s.IsHTTPSEligible.Encode(e)
	}
	if s.CaaError.Set {
		e.FieldStart("caa_error")
		s.CaaError.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PagesHealthCheckAltDomain from json.
func (s *PagesHealthCheckAltDomain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PagesHealthCheckAltDomain to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			s.Host.Reset()
			if err := s.Host.Decode(d); err != nil {
				return err
			}
		case "uri":
			s.URI.Reset()
			if err := s.URI.Decode(d); err != nil {
				return err
			}
		case "nameservers":
			s.Nameservers.Reset()
			if err := s.Nameservers.Decode(d); err != nil {
				return err
			}
		case "dns_resolves":
			s.DNSResolves.Reset()
			if err := s.DNSResolves.Decode(d); err != nil {
				return err
			}
		case "is_proxied":
			s.IsProxied.Reset()
			if err := s.IsProxied.Decode(d); err != nil {
				return err
			}
		case "is_cloudflare_ip":
			s.IsCloudflareIP.Reset()
			if err := s.IsCloudflareIP.Decode(d); err != nil {
				return err
			}
		case "is_fastly_ip":
			s.IsFastlyIP.Reset()
			if err := s.IsFastlyIP.Decode(d); err != nil {
				return err
			}
		case "is_old_ip_address":
			s.IsOldIPAddress.Reset()
			if err := s.IsOldIPAddress.Decode(d); err != nil {
				return err
			}
		case "is_a_record":
			s.IsARecord.Reset()
			if err := s.IsARecord.Decode(d); err != nil {
				return err
			}
		case "has_cname_record":
			s.HasCnameRecord.Reset()
			if err := s.HasCnameRecord.Decode(d); err != nil {
				return err
			}
		case "has_mx_records_present":
			s.HasMxRecordsPresent.Reset()
			if err := s.HasMxRecordsPresent.Decode(d); err != nil {
				return err
			}
		case "is_valid_domain":
			s.IsValidDomain.Reset()
			if err := s.IsValidDomain.Decode(d); err != nil {
				return err
			}
		case "is_apex_domain":
			s.IsApexDomain.Reset()
			if err := s.IsApexDomain.Decode(d); err != nil {
				return err
			}
		case "should_be_a_record":
			s.ShouldBeARecord.Reset()
			if err := s.ShouldBeARecord.Decode(d); err != nil {
				return err
			}
		case "is_cname_to_github_user_domain":
			s.IsCnameToGithubUserDomain.Reset()
			if err := s.IsCnameToGithubUserDomain.Decode(d); err != nil {
				return err
			}
		case "is_cname_to_pages_dot_github_dot_com":
			s.IsCnameToPagesDotGithubDotCom.Reset()
			if err := s.IsCnameToPagesDotGithubDotCom.Decode(d); err != nil {
				return err
			}
		case "is_cname_to_fastly":
			s.IsCnameToFastly.Reset()
			if err := s.IsCnameToFastly.Decode(d); err != nil {
				return err
			}
		case "is_pointed_to_github_pages_ip":
			s.IsPointedToGithubPagesIP.Reset()
			if err := s.IsPointedToGithubPagesIP.Decode(d); err != nil {
				return err
			}
		case "is_non_github_pages_ip_present":
			s.IsNonGithubPagesIPPresent.Reset()
			if err := s.IsNonGithubPagesIPPresent.Decode(d); err != nil {
				return err
			}
		case "is_pages_domain":
			s.IsPagesDomain.Reset()
			if err := s.IsPagesDomain.Decode(d); err != nil {
				return err
			}
		case "is_served_by_pages":
			s.IsServedByPages.Reset()
			if err := s.IsServedByPages.Decode(d); err != nil {
				return err
			}
		case "is_valid":
			s.IsValid.Reset()
			if err := s.IsValid.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "responds_to_https":
			s.RespondsToHTTPS.Reset()
			if err := s.RespondsToHTTPS.Decode(d); err != nil {
				return err
			}
		case "enforces_https":
			s.EnforcesHTTPS.Reset()
			if err := s.EnforcesHTTPS.Decode(d); err != nil {
				return err
			}
		case "https_error":
			s.HTTPSError.Reset()
			if err := s.HTTPSError.Decode(d); err != nil {
				return err
			}
		case "is_https_eligible":
			s.IsHTTPSEligible.Reset()
			if err := s.IsHTTPSEligible.Decode(d); err != nil {
				return err
			}
		case "caa_error":
			s.CaaError.Reset()
			if err := s.CaaError.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PagesHealthCheckDomain) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Host.Set {
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	if s.URI.Set {
		e.FieldStart("uri")
		s.URI.Encode(e)
	}
	if s.Nameservers.Set {
		e.FieldStart("nameservers")
		s.Nameservers.Encode(e)
	}
	if s.DNSResolves.Set {
		e.FieldStart("dns_resolves")
		s.DNSResolves.Encode(e)
	}
	if s.IsProxied.Set {
		e.FieldStart("is_proxied")
		s.IsProxied.Encode(e)
	}
	if s.IsCloudflareIP.Set {
		e.FieldStart("is_cloudflare_ip")
		s.IsCloudflareIP.Encode(e)
	}
	if s.IsFastlyIP.Set {
		e.FieldStart("is_fastly_ip")
		s.IsFastlyIP.Encode(e)
	}
	if s.IsOldIPAddress.Set {
		e.FieldStart("is_old_ip_address")
		s.IsOldIPAddress.Encode(e)
	}
	if s.IsARecord.Set {
		e.FieldStart("is_a_record")
		s.IsARecord.Encode(e)
	}
	if s.HasCnameRecord.Set {
		e.FieldStart("has_cname_record")
		s.HasCnameRecord.Encode(e)
	}
	if s.HasMxRecordsPresent.Set {
		e.FieldStart("has_mx_records_present")
		s.HasMxRecordsPresent.Encode(e)
	}
	if s.IsValidDomain.Set {
		e.FieldStart("is_valid_domain")
		s.IsValidDomain.Encode(e)
	}
	if s.IsApexDomain.Set {
		e.FieldStart("is_apex_domain")
		s.IsApexDomain.Encode(e)
	}
	if s.ShouldBeARecord.Set {
		e.FieldStart("should_be_a_record")
		s.ShouldBeARecord.Encode(e)
	}
	if s.IsCnameToGithubUserDomain.Set {
		e.FieldStart("is_cname_to_github_user_domain")
		s.IsCnameToGithubUserDomain.Encode(e)
	}
	if s.IsCnameToPagesDotGithubDotCom.Set {
		e.FieldStart("is_cname_to_pages_dot_github_dot_com")
		s.IsCnameToPagesDotGithubDotCom.Encode(e)
	}
	if s.IsCnameToFastly.Set {
		e.FieldStart("is_cname_to_fastly")
		s.IsCnameToFastly.Encode(e)
	}
	if s.IsPointedToGithubPagesIP.Set {
		e.FieldStart("is_pointed_to_github_pages_ip")
		s.IsPointedToGithubPagesIP.Encode(e)
	}
	if s.IsNonGithubPagesIPPresent.Set {
		e.FieldStart("is_non_github_pages_ip_present")
		s.IsNonGithubPagesIPPresent.Encode(e)
	}
	if s.IsPagesDomain.Set {
		e.FieldStart("is_pages_domain")
		s.IsPagesDomain.Encode(e)
	}
	if s.IsServedByPages.Set {
		e.FieldStart("is_served_by_pages")
		s.IsServedByPages.Encode(e)
	}
	if s.IsValid.Set {
		e.FieldStart("is_valid")
		s.IsValid.Encode(e)
	}
	if s.Reason.Set {
		e.FieldStart("reason")
		s.Reason.Encode(e)
	}
	if s.RespondsToHTTPS.Set {
		e.FieldStart("responds_to_https")
		s.RespondsToHTTPS.Encode(e)
	}
	if s.EnforcesHTTPS.Set {
		e.FieldStart("enforces_https")
		s.EnforcesHTTPS.Encode(e)
	}
	if s.HTTPSError.Set {
		e.FieldStart("https_error")
		s.HTTPSError.Encode(e)
	}
	if s.IsHTTPSEligible.Set {
		e.FieldStart("is_https_eligible")
		s.IsHTTPSEligible.Encode(e)
	}
	if s.CaaError.Set {
		e.FieldStart("caa_error")
		s.CaaError.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PagesHealthCheckDomain from json.
func (s *PagesHealthCheckDomain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PagesHealthCheckDomain to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			s.Host.Reset()
			if err := s.Host.Decode(d); err != nil {
				return err
			}
		case "uri":
			s.URI.Reset()
			if err := s.URI.Decode(d); err != nil {
				return err
			}
		case "nameservers":
			s.Nameservers.Reset()
			if err := s.Nameservers.Decode(d); err != nil {
				return err
			}
		case "dns_resolves":
			s.DNSResolves.Reset()
			if err := s.DNSResolves.Decode(d); err != nil {
				return err
			}
		case "is_proxied":
			s.IsProxied.Reset()
			if err := s.IsProxied.Decode(d); err != nil {
				return err
			}
		case "is_cloudflare_ip":
			s.IsCloudflareIP.Reset()
			if err := s.IsCloudflareIP.Decode(d); err != nil {
				return err
			}
		case "is_fastly_ip":
			s.IsFastlyIP.Reset()
			if err := s.IsFastlyIP.Decode(d); err != nil {
				return err
			}
		case "is_old_ip_address":
			s.IsOldIPAddress.Reset()
			if err := s.IsOldIPAddress.Decode(d); err != nil {
				return err
			}
		case "is_a_record":
			s.IsARecord.Reset()
			if err := s.IsARecord.Decode(d); err != nil {
				return err
			}
		case "has_cname_record":
			s.HasCnameRecord.Reset()
			if err := s.HasCnameRecord.Decode(d); err != nil {
				return err
			}
		case "has_mx_records_present":
			s.HasMxRecordsPresent.Reset()
			if err := s.HasMxRecordsPresent.Decode(d); err != nil {
				return err
			}
		case "is_valid_domain":
			s.IsValidDomain.Reset()
			if err := s.IsValidDomain.Decode(d); err != nil {
				return err
			}
		case "is_apex_domain":
			s.IsApexDomain.Reset()
			if err := s.IsApexDomain.Decode(d); err != nil {
				return err
			}
		case "should_be_a_record":
			s.ShouldBeARecord.Reset()
			if err := s.ShouldBeARecord.Decode(d); err != nil {
				return err
			}
		case "is_cname_to_github_user_domain":
			s.IsCnameToGithubUserDomain.Reset()
			if err := s.IsCnameToGithubUserDomain.Decode(d); err != nil {
				return err
			}
		case "is_cname_to_pages_dot_github_dot_com":
			s.IsCnameToPagesDotGithubDotCom.Reset()
			if err := s.IsCnameToPagesDotGithubDotCom.Decode(d); err != nil {
				return err
			}
		case "is_cname_to_fastly":
			s.IsCnameToFastly.Reset()
			if err := s.IsCnameToFastly.Decode(d); err != nil {
				return err
			}
		case "is_pointed_to_github_pages_ip":
			s.IsPointedToGithubPagesIP.Reset()
			if err := s.IsPointedToGithubPagesIP.Decode(d); err != nil {
				return err
			}
		case "is_non_github_pages_ip_present":
			s.IsNonGithubPagesIPPresent.Reset()
			if err := s.IsNonGithubPagesIPPresent.Decode(d); err != nil {
				return err
			}
		case "is_pages_domain":
			s.IsPagesDomain.Reset()
			if err := s.IsPagesDomain.Decode(d); err != nil {
				return err
			}
		case "is_served_by_pages":
			s.IsServedByPages.Reset()
			if err := s.IsServedByPages.Decode(d); err != nil {
				return err
			}
		case "is_valid":
			s.IsValid.Reset()
			if err := s.IsValid.Decode(d); err != nil {
				return err
			}
		case "reason":
			s.Reason.Reset()
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "responds_to_https":
			s.RespondsToHTTPS.Reset()
			if err := s.RespondsToHTTPS.Decode(d); err != nil {
				return err
			}
		case "enforces_https":
			s.EnforcesHTTPS.Reset()
			if err := s.EnforcesHTTPS.Decode(d); err != nil {
				return err
			}
		case "https_error":
			s.HTTPSError.Reset()
			if err := s.HTTPSError.Decode(d); err != nil {
				return err
			}
		case "is_https_eligible":
			s.IsHTTPSEligible.Reset()
			if err := s.IsHTTPSEligible.Decode(d); err != nil {
				return err
			}
		case "caa_error":
			s.CaaError.Reset()
			if err := s.CaaError.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PagesSourceHash) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("branch")
	e.Str(s.Branch)

	e.FieldStart("path")
	e.Str(s.Path)
	e.ObjEnd()
}

// Decode decodes PagesSourceHash from json.
func (s *PagesSourceHash) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PagesSourceHash to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "branch":
			v, err := d.Str()
			s.Branch = string(v)
			if err != nil {
				return err
			}
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ParticipationStats) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("all")
	e.ArrStart()
	for _, elem := range s.All {
		e.Int(elem)
	}
	e.ArrEnd()

	e.FieldStart("owner")
	e.ArrStart()
	for _, elem := range s.Owner {
		e.Int(elem)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ParticipationStats from json.
func (s *ParticipationStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ParticipationStats to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "all":
			s.All = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.All = append(s.All, elem)
				return nil
			}); err != nil {
				return err
			}
		case "owner":
			s.Owner = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Owner = append(s.Owner, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PorterAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("remote_id")
	e.Str(s.RemoteID)

	e.FieldStart("remote_name")
	e.Str(s.RemoteName)

	e.FieldStart("email")
	e.Str(s.Email)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("import_url")
	json.EncodeURI(e, s.ImportURL)
	e.ObjEnd()
}

// Decode decodes PorterAuthor from json.
func (s *PorterAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PorterAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "remote_id":
			v, err := d.Str()
			s.RemoteID = string(v)
			if err != nil {
				return err
			}
		case "remote_name":
			v, err := d.Str()
			s.RemoteName = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "import_url":
			v, err := json.DecodeURI(d)
			s.ImportURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PorterLargeFile) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("ref_name")
	e.Str(s.RefName)

	e.FieldStart("path")
	e.Str(s.Path)

	e.FieldStart("oid")
	e.Str(s.Oid)

	e.FieldStart("size")
	e.Int(s.Size)
	e.ObjEnd()
}

// Decode decodes PorterLargeFile from json.
func (s *PorterLargeFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PorterLargeFile to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref_name":
			v, err := d.Str()
			s.RefName = string(v)
			if err != nil {
				return err
			}
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "oid":
			v, err := d.Str()
			s.Oid = string(v)
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PreviewHeaderMissing) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("message")
	e.Str(s.Message)

	e.FieldStart("documentation_url")
	e.Str(s.DocumentationURL)
	e.ObjEnd()
}

// Decode decodes PreviewHeaderMissing from json.
func (s *PreviewHeaderMissing) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PreviewHeaderMissing to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "documentation_url":
			v, err := d.Str()
			s.DocumentationURL = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PrivateUser) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("login")
	e.Str(s.Login)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("avatar_url")
	json.EncodeURI(e, s.AvatarURL)

	e.FieldStart("gravatar_id")
	s.GravatarID.Encode(e)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("followers_url")
	json.EncodeURI(e, s.FollowersURL)

	e.FieldStart("following_url")
	e.Str(s.FollowingURL)

	e.FieldStart("gists_url")
	e.Str(s.GistsURL)

	e.FieldStart("starred_url")
	e.Str(s.StarredURL)

	e.FieldStart("subscriptions_url")
	json.EncodeURI(e, s.SubscriptionsURL)

	e.FieldStart("organizations_url")
	json.EncodeURI(e, s.OrganizationsURL)

	e.FieldStart("repos_url")
	json.EncodeURI(e, s.ReposURL)

	e.FieldStart("events_url")
	e.Str(s.EventsURL)

	e.FieldStart("received_events_url")
	json.EncodeURI(e, s.ReceivedEventsURL)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("site_admin")
	e.Bool(s.SiteAdmin)

	e.FieldStart("name")
	s.Name.Encode(e)

	e.FieldStart("company")
	s.Company.Encode(e)

	e.FieldStart("blog")
	s.Blog.Encode(e)

	e.FieldStart("location")
	s.Location.Encode(e)

	e.FieldStart("email")
	s.Email.Encode(e)

	e.FieldStart("hireable")
	s.Hireable.Encode(e)

	e.FieldStart("bio")
	s.Bio.Encode(e)
	if s.TwitterUsername.Set {
		e.FieldStart("twitter_username")
		s.TwitterUsername.Encode(e)
	}

	e.FieldStart("public_repos")
	e.Int(s.PublicRepos)

	e.FieldStart("public_gists")
	e.Int(s.PublicGists)

	e.FieldStart("followers")
	e.Int(s.Followers)

	e.FieldStart("following")
	e.Int(s.Following)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("private_gists")
	e.Int(s.PrivateGists)

	e.FieldStart("total_private_repos")
	e.Int(s.TotalPrivateRepos)

	e.FieldStart("owned_private_repos")
	e.Int(s.OwnedPrivateRepos)

	e.FieldStart("disk_usage")
	e.Int(s.DiskUsage)

	e.FieldStart("collaborators")
	e.Int(s.Collaborators)

	e.FieldStart("two_factor_authentication")
	e.Bool(s.TwoFactorAuthentication)
	if s.Plan.Set {
		e.FieldStart("plan")
		s.Plan.Encode(e)
	}
	if s.SuspendedAt.Set {
		e.FieldStart("suspended_at")
		s.SuspendedAt.Encode(e, json.EncodeDateTime)
	}
	if s.BusinessPlus.Set {
		e.FieldStart("business_plus")
		s.BusinessPlus.Encode(e)
	}
	if s.LdapDn.Set {
		e.FieldStart("ldap_dn")
		s.LdapDn.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PrivateUser from json.
func (s *PrivateUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PrivateUser to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "name":
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "company":
			if err := s.Company.Decode(d); err != nil {
				return err
			}
		case "blog":
			if err := s.Blog.Decode(d); err != nil {
				return err
			}
		case "location":
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "email":
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "hireable":
			if err := s.Hireable.Decode(d); err != nil {
				return err
			}
		case "bio":
			if err := s.Bio.Decode(d); err != nil {
				return err
			}
		case "twitter_username":
			s.TwitterUsername.Reset()
			if err := s.TwitterUsername.Decode(d); err != nil {
				return err
			}
		case "public_repos":
			v, err := d.Int()
			s.PublicRepos = int(v)
			if err != nil {
				return err
			}
		case "public_gists":
			v, err := d.Int()
			s.PublicGists = int(v)
			if err != nil {
				return err
			}
		case "followers":
			v, err := d.Int()
			s.Followers = int(v)
			if err != nil {
				return err
			}
		case "following":
			v, err := d.Int()
			s.Following = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "private_gists":
			v, err := d.Int()
			s.PrivateGists = int(v)
			if err != nil {
				return err
			}
		case "total_private_repos":
			v, err := d.Int()
			s.TotalPrivateRepos = int(v)
			if err != nil {
				return err
			}
		case "owned_private_repos":
			v, err := d.Int()
			s.OwnedPrivateRepos = int(v)
			if err != nil {
				return err
			}
		case "disk_usage":
			v, err := d.Int()
			s.DiskUsage = int(v)
			if err != nil {
				return err
			}
		case "collaborators":
			v, err := d.Int()
			s.Collaborators = int(v)
			if err != nil {
				return err
			}
		case "two_factor_authentication":
			v, err := d.Bool()
			s.TwoFactorAuthentication = bool(v)
			if err != nil {
				return err
			}
		case "plan":
			s.Plan.Reset()
			if err := s.Plan.Decode(d); err != nil {
				return err
			}
		case "suspended_at":
			s.SuspendedAt.Reset()
			if err := s.SuspendedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "business_plus":
			s.BusinessPlus.Reset()
			if err := s.BusinessPlus.Decode(d); err != nil {
				return err
			}
		case "ldap_dn":
			s.LdapDn.Reset()
			if err := s.LdapDn.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PrivateUserPlan) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("collaborators")
	e.Int(s.Collaborators)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("space")
	e.Int(s.Space)

	e.FieldStart("private_repos")
	e.Int(s.PrivateRepos)
	e.ObjEnd()
}

// Decode decodes PrivateUserPlan from json.
func (s *PrivateUserPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PrivateUserPlan to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "collaborators":
			v, err := d.Int()
			s.Collaborators = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "space":
			v, err := d.Int()
			s.Space = int(v)
			if err != nil {
				return err
			}
		case "private_repos":
			v, err := d.Int()
			s.PrivateRepos = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Project) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("owner_url")
	json.EncodeURI(e, s.OwnerURL)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("columns_url")
	json.EncodeURI(e, s.ColumnsURL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("body")
	s.Body.Encode(e)

	e.FieldStart("number")
	e.Int(s.Number)

	e.FieldStart("state")
	e.Str(s.State)

	e.FieldStart("creator")
	s.Creator.Encode(e)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)
	if s.OrganizationPermission.Set {
		e.FieldStart("organization_permission")
		s.OrganizationPermission.Encode(e)
	}
	if s.Private.Set {
		e.FieldStart("private")
		s.Private.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Project from json.
func (s *Project) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Project to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "owner_url":
			v, err := json.DecodeURI(d)
			s.OwnerURL = v
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "columns_url":
			v, err := json.DecodeURI(d)
			s.ColumnsURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "body":
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "creator":
			if err := s.Creator.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "organization_permission":
			s.OrganizationPermission.Reset()
			if err := s.OrganizationPermission.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectCard) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("note")
	s.Note.Encode(e)

	e.FieldStart("creator")
	s.Creator.Encode(e)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)
	if s.Archived.Set {
		e.FieldStart("archived")
		s.Archived.Encode(e)
	}
	if s.ColumnName.Set {
		e.FieldStart("column_name")
		s.ColumnName.Encode(e)
	}
	if s.ProjectID.Set {
		e.FieldStart("project_id")
		s.ProjectID.Encode(e)
	}

	e.FieldStart("column_url")
	json.EncodeURI(e, s.ColumnURL)
	if s.ContentURL.Set {
		e.FieldStart("content_url")
		s.ContentURL.Encode(e)
	}

	e.FieldStart("project_url")
	json.EncodeURI(e, s.ProjectURL)
	e.ObjEnd()
}

// Decode decodes ProjectCard from json.
func (s *ProjectCard) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectCard to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "note":
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		case "creator":
			if err := s.Creator.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "archived":
			s.Archived.Reset()
			if err := s.Archived.Decode(d); err != nil {
				return err
			}
		case "column_name":
			s.ColumnName.Reset()
			if err := s.ColumnName.Decode(d); err != nil {
				return err
			}
		case "project_id":
			s.ProjectID.Reset()
			if err := s.ProjectID.Decode(d); err != nil {
				return err
			}
		case "column_url":
			v, err := json.DecodeURI(d)
			s.ColumnURL = v
			if err != nil {
				return err
			}
		case "content_url":
			s.ContentURL.Reset()
			if err := s.ContentURL.Decode(d); err != nil {
				return err
			}
		case "project_url":
			v, err := json.DecodeURI(d)
			s.ProjectURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectColumn) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("project_url")
	json.EncodeURI(e, s.ProjectURL)

	e.FieldStart("cards_url")
	json.EncodeURI(e, s.CardsURL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)
	e.ObjEnd()
}

// Decode decodes ProjectColumn from json.
func (s *ProjectColumn) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectColumn to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "project_url":
			v, err := json.DecodeURI(d)
			s.ProjectURL = v
			if err != nil {
				return err
			}
		case "cards_url":
			v, err := json.DecodeURI(d)
			s.CardsURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectOrganizationPermission as json.
func (s ProjectOrganizationPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectOrganizationPermission from json.
func (s *ProjectOrganizationPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectOrganizationPermission to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ProjectOrganizationPermission(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsAddCollaboratorNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ProjectsAddCollaboratorNoContent from json.
func (s *ProjectsAddCollaboratorNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsAddCollaboratorNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsAddCollaboratorReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Permission.Set {
		e.FieldStart("permission")
		s.Permission.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ProjectsAddCollaboratorReq from json.
func (s *ProjectsAddCollaboratorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsAddCollaboratorReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsAddCollaboratorReqPermission as json.
func (s ProjectsAddCollaboratorReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectsAddCollaboratorReqPermission from json.
func (s *ProjectsAddCollaboratorReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsAddCollaboratorReqPermission to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ProjectsAddCollaboratorReqPermission(v)
	return nil
}

// Encode encodes ProjectsCreateCardReq as json.
func (s ProjectsCreateCardReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case ProjectsCreateCardReq0ProjectsCreateCardReq:
		s.ProjectsCreateCardReq0.Encode(e)
	case ProjectsCreateCardReq1ProjectsCreateCardReq:
		s.ProjectsCreateCardReq1.Encode(e)
	}
}

// Decode decodes ProjectsCreateCardReq from json.
func (s *ProjectsCreateCardReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateCardReq to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "note":
				found = true
				s.Type = ProjectsCreateCardReq0ProjectsCreateCardReq
			case "content_id":
				found = true
				s.Type = ProjectsCreateCardReq1ProjectsCreateCardReq
			case "content_type":
				found = true
				s.Type = ProjectsCreateCardReq1ProjectsCreateCardReq
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ProjectsCreateCardReq0ProjectsCreateCardReq:
		if err := s.ProjectsCreateCardReq0.Decode(d); err != nil {
			return err
		}
	case ProjectsCreateCardReq1ProjectsCreateCardReq:
		if err := s.ProjectsCreateCardReq1.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsCreateCardReq0) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("note")
	s.Note.Encode(e)
	e.ObjEnd()
}

// Decode decodes ProjectsCreateCardReq0 from json.
func (s *ProjectsCreateCardReq0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateCardReq0 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "note":
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsCreateCardReq1) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("content_id")
	e.Int(s.ContentID)

	e.FieldStart("content_type")
	e.Str(s.ContentType)
	e.ObjEnd()
}

// Decode decodes ProjectsCreateCardReq1 from json.
func (s *ProjectsCreateCardReq1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateCardReq1 to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content_id":
			v, err := d.Int()
			s.ContentID = int(v)
			if err != nil {
				return err
			}
		case "content_type":
			v, err := d.Str()
			s.ContentType = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsCreateColumnApplicationJSONForbidden as json.
func (s ProjectsCreateColumnApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateColumnApplicationJSONForbidden from json.
func (s *ProjectsCreateColumnApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateColumnApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateColumnApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateColumnApplicationJSONUnauthorized as json.
func (s ProjectsCreateColumnApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateColumnApplicationJSONUnauthorized from json.
func (s *ProjectsCreateColumnApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateColumnApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateColumnApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsCreateColumnReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)
	e.ObjEnd()
}

// Decode decodes ProjectsCreateColumnReq from json.
func (s *ProjectsCreateColumnReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateColumnReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsCreateForAuthenticatedUserApplicationJSONForbidden as json.
func (s ProjectsCreateForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ProjectsCreateForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsCreateForAuthenticatedUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ProjectsCreateForAuthenticatedUserReq from json.
func (s *ProjectsCreateForAuthenticatedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForAuthenticatedUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsCreateForOrgApplicationJSONForbidden as json.
func (s ProjectsCreateForOrgApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForOrgApplicationJSONForbidden from json.
func (s *ProjectsCreateForOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForOrgApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForOrgApplicationJSONGone as json.
func (s ProjectsCreateForOrgApplicationJSONGone) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForOrgApplicationJSONGone from json.
func (s *ProjectsCreateForOrgApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForOrgApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForOrgApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForOrgApplicationJSONNotFound as json.
func (s ProjectsCreateForOrgApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForOrgApplicationJSONNotFound from json.
func (s *ProjectsCreateForOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForOrgApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForOrgApplicationJSONUnauthorized as json.
func (s ProjectsCreateForOrgApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForOrgApplicationJSONUnauthorized from json.
func (s *ProjectsCreateForOrgApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForOrgApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForOrgApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsCreateForOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ProjectsCreateForOrgReq from json.
func (s *ProjectsCreateForOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsCreateForRepoApplicationJSONForbidden as json.
func (s ProjectsCreateForRepoApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForRepoApplicationJSONForbidden from json.
func (s *ProjectsCreateForRepoApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForRepoApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForRepoApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForRepoApplicationJSONGone as json.
func (s ProjectsCreateForRepoApplicationJSONGone) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForRepoApplicationJSONGone from json.
func (s *ProjectsCreateForRepoApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForRepoApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForRepoApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForRepoApplicationJSONNotFound as json.
func (s ProjectsCreateForRepoApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForRepoApplicationJSONNotFound from json.
func (s *ProjectsCreateForRepoApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForRepoApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForRepoApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsCreateForRepoApplicationJSONUnauthorized as json.
func (s ProjectsCreateForRepoApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsCreateForRepoApplicationJSONUnauthorized from json.
func (s *ProjectsCreateForRepoApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForRepoApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsCreateForRepoApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsCreateForRepoReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ProjectsCreateForRepoReq from json.
func (s *ProjectsCreateForRepoReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsCreateForRepoReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsDeleteApplicationJSONGone as json.
func (s ProjectsDeleteApplicationJSONGone) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteApplicationJSONGone from json.
func (s *ProjectsDeleteApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ProjectsDeleteApplicationJSONNotFound as json.
func (s ProjectsDeleteApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteApplicationJSONNotFound from json.
func (s *ProjectsDeleteApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsDeleteApplicationJSONUnauthorized as json.
func (s ProjectsDeleteApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteApplicationJSONUnauthorized from json.
func (s *ProjectsDeleteApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsDeleteCardApplicationJSONNotFound as json.
func (s ProjectsDeleteCardApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteCardApplicationJSONNotFound from json.
func (s *ProjectsDeleteCardApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteCardApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteCardApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsDeleteCardApplicationJSONUnauthorized as json.
func (s ProjectsDeleteCardApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteCardApplicationJSONUnauthorized from json.
func (s *ProjectsDeleteCardApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteCardApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteCardApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsDeleteCardForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.DocumentationURL.Set {
		e.FieldStart("documentation_url")
		s.DocumentationURL.Encode(e)
	}
	if s.Errors != nil {
		e.FieldStart("errors")
		e.ArrStart()
		for _, elem := range s.Errors {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ProjectsDeleteCardForbidden from json.
func (s *ProjectsDeleteCardForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteCardForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		case "errors":
			s.Errors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Errors = append(s.Errors, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsDeleteCardNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ProjectsDeleteCardNoContent from json.
func (s *ProjectsDeleteCardNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteCardNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsDeleteColumnApplicationJSONForbidden as json.
func (s ProjectsDeleteColumnApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteColumnApplicationJSONForbidden from json.
func (s *ProjectsDeleteColumnApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteColumnApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteColumnApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsDeleteColumnApplicationJSONUnauthorized as json.
func (s ProjectsDeleteColumnApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsDeleteColumnApplicationJSONUnauthorized from json.
func (s *ProjectsDeleteColumnApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteColumnApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsDeleteColumnApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsDeleteColumnNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ProjectsDeleteColumnNoContent from json.
func (s *ProjectsDeleteColumnNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteColumnNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsDeleteForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.DocumentationURL.Set {
		e.FieldStart("documentation_url")
		s.DocumentationURL.Encode(e)
	}
	if s.Errors != nil {
		e.FieldStart("errors")
		e.ArrStart()
		for _, elem := range s.Errors {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ProjectsDeleteForbidden from json.
func (s *ProjectsDeleteForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		case "errors":
			s.Errors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Errors = append(s.Errors, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsDeleteNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ProjectsDeleteNoContent from json.
func (s *ProjectsDeleteNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsDeleteNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsGetApplicationJSONForbidden as json.
func (s ProjectsGetApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetApplicationJSONForbidden from json.
func (s *ProjectsGetApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsGetApplicationJSONUnauthorized as json.
func (s ProjectsGetApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetApplicationJSONUnauthorized from json.
func (s *ProjectsGetApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsGetCardApplicationJSONForbidden as json.
func (s ProjectsGetCardApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetCardApplicationJSONForbidden from json.
func (s *ProjectsGetCardApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetCardApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetCardApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsGetCardApplicationJSONNotFound as json.
func (s ProjectsGetCardApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetCardApplicationJSONNotFound from json.
func (s *ProjectsGetCardApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetCardApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetCardApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsGetCardApplicationJSONUnauthorized as json.
func (s ProjectsGetCardApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetCardApplicationJSONUnauthorized from json.
func (s *ProjectsGetCardApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetCardApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetCardApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsGetColumnApplicationJSONForbidden as json.
func (s ProjectsGetColumnApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetColumnApplicationJSONForbidden from json.
func (s *ProjectsGetColumnApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetColumnApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetColumnApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsGetColumnApplicationJSONNotFound as json.
func (s ProjectsGetColumnApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetColumnApplicationJSONNotFound from json.
func (s *ProjectsGetColumnApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetColumnApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetColumnApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsGetColumnApplicationJSONUnauthorized as json.
func (s ProjectsGetColumnApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsGetColumnApplicationJSONUnauthorized from json.
func (s *ProjectsGetColumnApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsGetColumnApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsGetColumnApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsListCardsApplicationJSONForbidden as json.
func (s ProjectsListCardsApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCardsApplicationJSONForbidden from json.
func (s *ProjectsListCardsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListCardsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCardsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsListCardsApplicationJSONUnauthorized as json.
func (s ProjectsListCardsApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListCardsApplicationJSONUnauthorized from json.
func (s *ProjectsListCardsApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListCardsApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCardsApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsListCardsArchivedState as json.
func (s ProjectsListCardsArchivedState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectsListCardsArchivedState from json.
func (s *ProjectsListCardsArchivedState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListCardsArchivedState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ProjectsListCardsArchivedState(v)
	return nil
}

// Encode encodes ProjectsListCardsOKApplicationJSON as json.
func (s ProjectsListCardsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ProjectCard(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ProjectsListCardsOKApplicationJSON from json.
func (s *ProjectsListCardsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListCardsOKApplicationJSON to nil`)
	}
	var unwrapped []ProjectCard
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ProjectCard
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListCardsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ProjectsListCollaboratorsAffiliation as json.
func (s ProjectsListCollaboratorsAffiliation) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectsListCollaboratorsAffiliation from json.
func (s *ProjectsListCollaboratorsAffiliation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListCollaboratorsAffiliation to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ProjectsListCollaboratorsAffiliation(v)
	return nil
}

// Encode encodes ProjectsListColumnsApplicationJSONForbidden as json.
func (s ProjectsListColumnsApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListColumnsApplicationJSONForbidden from json.
func (s *ProjectsListColumnsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListColumnsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListColumnsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsListColumnsApplicationJSONUnauthorized as json.
func (s ProjectsListColumnsApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListColumnsApplicationJSONUnauthorized from json.
func (s *ProjectsListColumnsApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListColumnsApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListColumnsApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsListColumnsOKApplicationJSON as json.
func (s ProjectsListColumnsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ProjectColumn(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ProjectsListColumnsOKApplicationJSON from json.
func (s *ProjectsListColumnsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListColumnsOKApplicationJSON to nil`)
	}
	var unwrapped []ProjectColumn
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ProjectColumn
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListColumnsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ProjectsListForOrgOKApplicationJSON as json.
func (s ProjectsListForOrgOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Project(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ProjectsListForOrgOKApplicationJSON from json.
func (s *ProjectsListForOrgOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForOrgOKApplicationJSON to nil`)
	}
	var unwrapped []Project
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Project
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForOrgOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ProjectsListForOrgState as json.
func (s ProjectsListForOrgState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectsListForOrgState from json.
func (s *ProjectsListForOrgState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForOrgState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ProjectsListForOrgState(v)
	return nil
}

// Encode encodes ProjectsListForRepoApplicationJSONForbidden as json.
func (s ProjectsListForRepoApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListForRepoApplicationJSONForbidden from json.
func (s *ProjectsListForRepoApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForRepoApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsListForRepoApplicationJSONGone as json.
func (s ProjectsListForRepoApplicationJSONGone) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListForRepoApplicationJSONGone from json.
func (s *ProjectsListForRepoApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForRepoApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ProjectsListForRepoApplicationJSONNotFound as json.
func (s ProjectsListForRepoApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListForRepoApplicationJSONNotFound from json.
func (s *ProjectsListForRepoApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForRepoApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsListForRepoApplicationJSONUnauthorized as json.
func (s ProjectsListForRepoApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsListForRepoApplicationJSONUnauthorized from json.
func (s *ProjectsListForRepoApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForRepoApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsListForRepoOKApplicationJSON as json.
func (s ProjectsListForRepoOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Project(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ProjectsListForRepoOKApplicationJSON from json.
func (s *ProjectsListForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForRepoOKApplicationJSON to nil`)
	}
	var unwrapped []Project
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Project
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsListForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ProjectsListForRepoState as json.
func (s ProjectsListForRepoState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectsListForRepoState from json.
func (s *ProjectsListForRepoState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForRepoState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ProjectsListForRepoState(v)
	return nil
}

// Encode encodes ProjectsListForUserState as json.
func (s ProjectsListForUserState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectsListForUserState from json.
func (s *ProjectsListForUserState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsListForUserState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ProjectsListForUserState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsMoveCardCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ProjectsMoveCardCreated from json.
func (s *ProjectsMoveCardCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveCardCreated to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsMoveCardForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.DocumentationURL.Set {
		e.FieldStart("documentation_url")
		s.DocumentationURL.Encode(e)
	}
	if s.Errors != nil {
		e.FieldStart("errors")
		e.ArrStart()
		for _, elem := range s.Errors {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ProjectsMoveCardForbidden from json.
func (s *ProjectsMoveCardForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveCardForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		case "errors":
			s.Errors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ProjectsMoveCardForbiddenErrorsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Errors = append(s.Errors, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsMoveCardForbiddenErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Code.Set {
		e.FieldStart("code")
		s.Code.Encode(e)
	}
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.Resource.Set {
		e.FieldStart("resource")
		s.Resource.Encode(e)
	}
	if s.Field.Set {
		e.FieldStart("field")
		s.Field.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ProjectsMoveCardForbiddenErrorsItem from json.
func (s *ProjectsMoveCardForbiddenErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveCardForbiddenErrorsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			s.Code.Reset()
			if err := s.Code.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "resource":
			s.Resource.Reset()
			if err := s.Resource.Decode(d); err != nil {
				return err
			}
		case "field":
			s.Field.Reset()
			if err := s.Field.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsMoveCardReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("position")
	e.Str(s.Position)
	if s.ColumnID.Set {
		e.FieldStart("column_id")
		s.ColumnID.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ProjectsMoveCardReq from json.
func (s *ProjectsMoveCardReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveCardReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "position":
			v, err := d.Str()
			s.Position = string(v)
			if err != nil {
				return err
			}
		case "column_id":
			s.ColumnID.Reset()
			if err := s.ColumnID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsMoveColumnApplicationJSONForbidden as json.
func (s ProjectsMoveColumnApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsMoveColumnApplicationJSONForbidden from json.
func (s *ProjectsMoveColumnApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveColumnApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsMoveColumnApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsMoveColumnApplicationJSONUnauthorized as json.
func (s ProjectsMoveColumnApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsMoveColumnApplicationJSONUnauthorized from json.
func (s *ProjectsMoveColumnApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveColumnApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsMoveColumnApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsMoveColumnCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ProjectsMoveColumnCreated from json.
func (s *ProjectsMoveColumnCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveColumnCreated to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsMoveColumnReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("position")
	e.Str(s.Position)
	e.ObjEnd()
}

// Decode decodes ProjectsMoveColumnReq from json.
func (s *ProjectsMoveColumnReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsMoveColumnReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "position":
			v, err := d.Str()
			s.Position = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsRemoveCollaboratorNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ProjectsRemoveCollaboratorNoContent from json.
func (s *ProjectsRemoveCollaboratorNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsRemoveCollaboratorNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsUpdateApplicationJSONGone as json.
func (s ProjectsUpdateApplicationJSONGone) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateApplicationJSONGone from json.
func (s *ProjectsUpdateApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ProjectsUpdateApplicationJSONUnauthorized as json.
func (s ProjectsUpdateApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateApplicationJSONUnauthorized from json.
func (s *ProjectsUpdateApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ProjectsUpdateCardApplicationJSONForbidden as json.
func (s ProjectsUpdateCardApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateCardApplicationJSONForbidden from json.
func (s *ProjectsUpdateCardApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateCardApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateCardApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsUpdateCardApplicationJSONNotFound as json.
func (s ProjectsUpdateCardApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateCardApplicationJSONNotFound from json.
func (s *ProjectsUpdateCardApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateCardApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateCardApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ProjectsUpdateCardApplicationJSONUnauthorized as json.
func (s ProjectsUpdateCardApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateCardApplicationJSONUnauthorized from json.
func (s *ProjectsUpdateCardApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateCardApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateCardApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsUpdateCardReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Note.Set {
		e.FieldStart("note")
		s.Note.Encode(e)
	}
	if s.Archived.Set {
		e.FieldStart("archived")
		s.Archived.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ProjectsUpdateCardReq from json.
func (s *ProjectsUpdateCardReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateCardReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "note":
			s.Note.Reset()
			if err := s.Note.Decode(d); err != nil {
				return err
			}
		case "archived":
			s.Archived.Reset()
			if err := s.Archived.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsUpdateColumnApplicationJSONForbidden as json.
func (s ProjectsUpdateColumnApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateColumnApplicationJSONForbidden from json.
func (s *ProjectsUpdateColumnApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateColumnApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateColumnApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ProjectsUpdateColumnApplicationJSONUnauthorized as json.
func (s ProjectsUpdateColumnApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ProjectsUpdateColumnApplicationJSONUnauthorized from json.
func (s *ProjectsUpdateColumnApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateColumnApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectsUpdateColumnApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ProjectsUpdateColumnReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)
	e.ObjEnd()
}

// Decode decodes ProjectsUpdateColumnReq from json.
func (s *ProjectsUpdateColumnReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateColumnReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsUpdateForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.DocumentationURL.Set {
		e.FieldStart("documentation_url")
		s.DocumentationURL.Encode(e)
	}
	if s.Errors != nil {
		e.FieldStart("errors")
		e.ArrStart()
		for _, elem := range s.Errors {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ProjectsUpdateForbidden from json.
func (s *ProjectsUpdateForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		case "errors":
			s.Errors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Errors = append(s.Errors, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsUpdateNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ProjectsUpdateNotFound from json.
func (s *ProjectsUpdateNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProjectsUpdateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	if s.State.Set {
		e.FieldStart("state")
		s.State.Encode(e)
	}
	if s.OrganizationPermission.Set {
		e.FieldStart("organization_permission")
		s.OrganizationPermission.Encode(e)
	}
	if s.Private.Set {
		e.FieldStart("private")
		s.Private.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ProjectsUpdateReq from json.
func (s *ProjectsUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "organization_permission":
			s.OrganizationPermission.Reset()
			if err := s.OrganizationPermission.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ProjectsUpdateReqOrganizationPermission as json.
func (s ProjectsUpdateReqOrganizationPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectsUpdateReqOrganizationPermission from json.
func (s *ProjectsUpdateReqOrganizationPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProjectsUpdateReqOrganizationPermission to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ProjectsUpdateReqOrganizationPermission(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ProtectedBranch) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	if s.RequiredStatusChecks.Set {
		e.FieldStart("required_status_checks")
		s.RequiredStatusChecks.Encode(e)
	}
	if s.RequiredPullRequestReviews.Set {
		e.FieldStart("required_pull_request_reviews")
		s.RequiredPullRequestReviews.Encode(e)
	}
	if s.RequiredSignatures.Set {
		e.FieldStart("required_signatures")
		s.RequiredSignatures.Encode(e)
	}
	if s.EnforceAdmins.Set {
		e.FieldStart("enforce_admins")
		s.EnforceAdmins.Encode(e)
	}
	if s.RequiredLinearHistory.Set {
		e.FieldStart("required_linear_history")
		s.RequiredLinearHistory.Encode(e)
	}
	if s.AllowForcePushes.Set {
		e.FieldStart("allow_force_pushes")
		s.AllowForcePushes.Encode(e)
	}
	if s.AllowDeletions.Set {
		e.FieldStart("allow_deletions")
		s.AllowDeletions.Encode(e)
	}
	if s.Restrictions.Set {
		e.FieldStart("restrictions")
		s.Restrictions.Encode(e)
	}
	if s.RequiredConversationResolution.Set {
		e.FieldStart("required_conversation_resolution")
		s.RequiredConversationResolution.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranch from json.
func (s *ProtectedBranch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranch to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "required_status_checks":
			s.RequiredStatusChecks.Reset()
			if err := s.RequiredStatusChecks.Decode(d); err != nil {
				return err
			}
		case "required_pull_request_reviews":
			s.RequiredPullRequestReviews.Reset()
			if err := s.RequiredPullRequestReviews.Decode(d); err != nil {
				return err
			}
		case "required_signatures":
			s.RequiredSignatures.Reset()
			if err := s.RequiredSignatures.Decode(d); err != nil {
				return err
			}
		case "enforce_admins":
			s.EnforceAdmins.Reset()
			if err := s.EnforceAdmins.Decode(d); err != nil {
				return err
			}
		case "required_linear_history":
			s.RequiredLinearHistory.Reset()
			if err := s.RequiredLinearHistory.Decode(d); err != nil {
				return err
			}
		case "allow_force_pushes":
			s.AllowForcePushes.Reset()
			if err := s.AllowForcePushes.Decode(d); err != nil {
				return err
			}
		case "allow_deletions":
			s.AllowDeletions.Reset()
			if err := s.AllowDeletions.Decode(d); err != nil {
				return err
			}
		case "restrictions":
			s.Restrictions.Reset()
			if err := s.Restrictions.Decode(d); err != nil {
				return err
			}
		case "required_conversation_resolution":
			s.RequiredConversationResolution.Reset()
			if err := s.RequiredConversationResolution.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchAdminEnforced) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("enabled")
	e.Bool(s.Enabled)
	e.ObjEnd()
}

// Decode decodes ProtectedBranchAdminEnforced from json.
func (s *ProtectedBranchAdminEnforced) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchAdminEnforced to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "enabled":
			v, err := d.Bool()
			s.Enabled = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchAllowDeletions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("enabled")
	e.Bool(s.Enabled)
	e.ObjEnd()
}

// Decode decodes ProtectedBranchAllowDeletions from json.
func (s *ProtectedBranchAllowDeletions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchAllowDeletions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			v, err := d.Bool()
			s.Enabled = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchAllowForcePushes) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("enabled")
	e.Bool(s.Enabled)
	e.ObjEnd()
}

// Decode decodes ProtectedBranchAllowForcePushes from json.
func (s *ProtectedBranchAllowForcePushes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchAllowForcePushes to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			v, err := d.Bool()
			s.Enabled = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchEnforceAdmins) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("enabled")
	e.Bool(s.Enabled)
	e.ObjEnd()
}

// Decode decodes ProtectedBranchEnforceAdmins from json.
func (s *ProtectedBranchEnforceAdmins) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchEnforceAdmins to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "enabled":
			v, err := d.Bool()
			s.Enabled = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchPullRequestReview) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.DismissalRestrictions.Set {
		e.FieldStart("dismissal_restrictions")
		s.DismissalRestrictions.Encode(e)
	}

	e.FieldStart("dismiss_stale_reviews")
	e.Bool(s.DismissStaleReviews)

	e.FieldStart("require_code_owner_reviews")
	e.Bool(s.RequireCodeOwnerReviews)
	if s.RequiredApprovingReviewCount.Set {
		e.FieldStart("required_approving_review_count")
		s.RequiredApprovingReviewCount.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranchPullRequestReview from json.
func (s *ProtectedBranchPullRequestReview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchPullRequestReview to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "dismissal_restrictions":
			s.DismissalRestrictions.Reset()
			if err := s.DismissalRestrictions.Decode(d); err != nil {
				return err
			}
		case "dismiss_stale_reviews":
			v, err := d.Bool()
			s.DismissStaleReviews = bool(v)
			if err != nil {
				return err
			}
		case "require_code_owner_reviews":
			v, err := d.Bool()
			s.RequireCodeOwnerReviews = bool(v)
			if err != nil {
				return err
			}
		case "required_approving_review_count":
			s.RequiredApprovingReviewCount.Reset()
			if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchPullRequestReviewDismissalRestrictions) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Users != nil {
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Teams != nil {
		e.FieldStart("teams")
		e.ArrStart()
		for _, elem := range s.Teams {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.UsersURL.Set {
		e.FieldStart("users_url")
		s.UsersURL.Encode(e)
	}
	if s.TeamsURL.Set {
		e.FieldStart("teams_url")
		s.TeamsURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranchPullRequestReviewDismissalRestrictions from json.
func (s *ProtectedBranchPullRequestReviewDismissalRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchPullRequestReviewDismissalRestrictions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem SimpleUser
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Team
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "users_url":
			s.UsersURL.Reset()
			if err := s.UsersURL.Decode(d); err != nil {
				return err
			}
		case "teams_url":
			s.TeamsURL.Reset()
			if err := s.TeamsURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchRequiredConversationResolution) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Enabled.Set {
		e.FieldStart("enabled")
		s.Enabled.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranchRequiredConversationResolution from json.
func (s *ProtectedBranchRequiredConversationResolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchRequiredConversationResolution to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			s.Enabled.Reset()
			if err := s.Enabled.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchRequiredLinearHistory) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("enabled")
	e.Bool(s.Enabled)
	e.ObjEnd()
}

// Decode decodes ProtectedBranchRequiredLinearHistory from json.
func (s *ProtectedBranchRequiredLinearHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchRequiredLinearHistory to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			v, err := d.Bool()
			s.Enabled = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchRequiredPullRequestReviews) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	if s.DismissStaleReviews.Set {
		e.FieldStart("dismiss_stale_reviews")
		s.DismissStaleReviews.Encode(e)
	}
	if s.RequireCodeOwnerReviews.Set {
		e.FieldStart("require_code_owner_reviews")
		s.RequireCodeOwnerReviews.Encode(e)
	}
	if s.RequiredApprovingReviewCount.Set {
		e.FieldStart("required_approving_review_count")
		s.RequiredApprovingReviewCount.Encode(e)
	}
	if s.DismissalRestrictions.Set {
		e.FieldStart("dismissal_restrictions")
		s.DismissalRestrictions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ProtectedBranchRequiredPullRequestReviews from json.
func (s *ProtectedBranchRequiredPullRequestReviews) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchRequiredPullRequestReviews to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "dismiss_stale_reviews":
			s.DismissStaleReviews.Reset()
			if err := s.DismissStaleReviews.Decode(d); err != nil {
				return err
			}
		case "require_code_owner_reviews":
			s.RequireCodeOwnerReviews.Reset()
			if err := s.RequireCodeOwnerReviews.Decode(d); err != nil {
				return err
			}
		case "required_approving_review_count":
			s.RequiredApprovingReviewCount.Reset()
			if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
				return err
			}
		case "dismissal_restrictions":
			s.DismissalRestrictions.Reset()
			if err := s.DismissalRestrictions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("users_url")
	json.EncodeURI(e, s.UsersURL)

	e.FieldStart("teams_url")
	json.EncodeURI(e, s.TeamsURL)

	e.FieldStart("users")
	e.ArrStart()
	for _, elem := range s.Users {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("teams")
	e.ArrStart()
	for _, elem := range s.Teams {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions from json.
func (s *ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchRequiredPullRequestReviewsDismissalRestrictions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "users_url":
			v, err := json.DecodeURI(d)
			s.UsersURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem SimpleUser
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Team
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ProtectedBranchRequiredSignatures) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("enabled")
	e.Bool(s.Enabled)
	e.ObjEnd()
}

// Decode decodes ProtectedBranchRequiredSignatures from json.
func (s *ProtectedBranchRequiredSignatures) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ProtectedBranchRequiredSignatures to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "enabled":
			v, err := d.Bool()
			s.Enabled = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PublicUser) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("login")
	e.Str(s.Login)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("avatar_url")
	json.EncodeURI(e, s.AvatarURL)

	e.FieldStart("gravatar_id")
	s.GravatarID.Encode(e)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("followers_url")
	json.EncodeURI(e, s.FollowersURL)

	e.FieldStart("following_url")
	e.Str(s.FollowingURL)

	e.FieldStart("gists_url")
	e.Str(s.GistsURL)

	e.FieldStart("starred_url")
	e.Str(s.StarredURL)

	e.FieldStart("subscriptions_url")
	json.EncodeURI(e, s.SubscriptionsURL)

	e.FieldStart("organizations_url")
	json.EncodeURI(e, s.OrganizationsURL)

	e.FieldStart("repos_url")
	json.EncodeURI(e, s.ReposURL)

	e.FieldStart("events_url")
	e.Str(s.EventsURL)

	e.FieldStart("received_events_url")
	json.EncodeURI(e, s.ReceivedEventsURL)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("site_admin")
	e.Bool(s.SiteAdmin)

	e.FieldStart("name")
	s.Name.Encode(e)

	e.FieldStart("company")
	s.Company.Encode(e)

	e.FieldStart("blog")
	s.Blog.Encode(e)

	e.FieldStart("location")
	s.Location.Encode(e)

	e.FieldStart("email")
	s.Email.Encode(e)

	e.FieldStart("hireable")
	s.Hireable.Encode(e)

	e.FieldStart("bio")
	s.Bio.Encode(e)
	if s.TwitterUsername.Set {
		e.FieldStart("twitter_username")
		s.TwitterUsername.Encode(e)
	}

	e.FieldStart("public_repos")
	e.Int(s.PublicRepos)

	e.FieldStart("public_gists")
	e.Int(s.PublicGists)

	e.FieldStart("followers")
	e.Int(s.Followers)

	e.FieldStart("following")
	e.Int(s.Following)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)
	if s.Plan.Set {
		e.FieldStart("plan")
		s.Plan.Encode(e)
	}
	if s.SuspendedAt.Set {
		e.FieldStart("suspended_at")
		s.SuspendedAt.Encode(e, json.EncodeDateTime)
	}
	if s.PrivateGists.Set {
		e.FieldStart("private_gists")
		s.PrivateGists.Encode(e)
	}
	if s.TotalPrivateRepos.Set {
		e.FieldStart("total_private_repos")
		s.TotalPrivateRepos.Encode(e)
	}
	if s.OwnedPrivateRepos.Set {
		e.FieldStart("owned_private_repos")
		s.OwnedPrivateRepos.Encode(e)
	}
	if s.DiskUsage.Set {
		e.FieldStart("disk_usage")
		s.DiskUsage.Encode(e)
	}
	if s.Collaborators.Set {
		e.FieldStart("collaborators")
		s.Collaborators.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PublicUser from json.
func (s *PublicUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PublicUser to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "name":
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "company":
			if err := s.Company.Decode(d); err != nil {
				return err
			}
		case "blog":
			if err := s.Blog.Decode(d); err != nil {
				return err
			}
		case "location":
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "email":
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "hireable":
			if err := s.Hireable.Decode(d); err != nil {
				return err
			}
		case "bio":
			if err := s.Bio.Decode(d); err != nil {
				return err
			}
		case "twitter_username":
			s.TwitterUsername.Reset()
			if err := s.TwitterUsername.Decode(d); err != nil {
				return err
			}
		case "public_repos":
			v, err := d.Int()
			s.PublicRepos = int(v)
			if err != nil {
				return err
			}
		case "public_gists":
			v, err := d.Int()
			s.PublicGists = int(v)
			if err != nil {
				return err
			}
		case "followers":
			v, err := d.Int()
			s.Followers = int(v)
			if err != nil {
				return err
			}
		case "following":
			v, err := d.Int()
			s.Following = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "plan":
			s.Plan.Reset()
			if err := s.Plan.Decode(d); err != nil {
				return err
			}
		case "suspended_at":
			s.SuspendedAt.Reset()
			if err := s.SuspendedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "private_gists":
			s.PrivateGists.Reset()
			if err := s.PrivateGists.Decode(d); err != nil {
				return err
			}
		case "total_private_repos":
			s.TotalPrivateRepos.Reset()
			if err := s.TotalPrivateRepos.Decode(d); err != nil {
				return err
			}
		case "owned_private_repos":
			s.OwnedPrivateRepos.Reset()
			if err := s.OwnedPrivateRepos.Decode(d); err != nil {
				return err
			}
		case "disk_usage":
			s.DiskUsage.Reset()
			if err := s.DiskUsage.Decode(d); err != nil {
				return err
			}
		case "collaborators":
			s.Collaborators.Reset()
			if err := s.Collaborators.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PublicUserPlan) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("collaborators")
	e.Int(s.Collaborators)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("space")
	e.Int(s.Space)

	e.FieldStart("private_repos")
	e.Int(s.PrivateRepos)
	e.ObjEnd()
}

// Decode decodes PublicUserPlan from json.
func (s *PublicUserPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PublicUserPlan to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "collaborators":
			v, err := d.Int()
			s.Collaborators = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "space":
			v, err := d.Int()
			s.Space = int(v)
			if err != nil {
				return err
			}
		case "private_repos":
			v, err := d.Int()
			s.PrivateRepos = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequest) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("diff_url")
	json.EncodeURI(e, s.DiffURL)

	e.FieldStart("patch_url")
	json.EncodeURI(e, s.PatchURL)

	e.FieldStart("issue_url")
	json.EncodeURI(e, s.IssueURL)

	e.FieldStart("commits_url")
	json.EncodeURI(e, s.CommitsURL)

	e.FieldStart("review_comments_url")
	json.EncodeURI(e, s.ReviewCommentsURL)

	e.FieldStart("review_comment_url")
	e.Str(s.ReviewCommentURL)

	e.FieldStart("comments_url")
	json.EncodeURI(e, s.CommentsURL)

	e.FieldStart("statuses_url")
	json.EncodeURI(e, s.StatusesURL)

	e.FieldStart("number")
	e.Int(s.Number)

	e.FieldStart("state")
	s.State.Encode(e)

	e.FieldStart("locked")
	e.Bool(s.Locked)

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("user")
	s.User.Encode(e)

	e.FieldStart("body")
	s.Body.Encode(e)

	e.FieldStart("labels")
	e.ArrStart()
	for _, elem := range s.Labels {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("milestone")
	s.Milestone.Encode(e)
	if s.ActiveLockReason.Set {
		e.FieldStart("active_lock_reason")
		s.ActiveLockReason.Encode(e)
	}

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("closed_at")
	s.ClosedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("merged_at")
	s.MergedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("merge_commit_sha")
	s.MergeCommitSha.Encode(e)

	e.FieldStart("assignee")
	s.Assignee.Encode(e)
	if s.Assignees.Set {
		e.FieldStart("assignees")
		s.Assignees.Encode(e)
	}
	if s.RequestedReviewers.Set {
		e.FieldStart("requested_reviewers")
		s.RequestedReviewers.Encode(e)
	}
	if s.RequestedTeams.Set {
		e.FieldStart("requested_teams")
		s.RequestedTeams.Encode(e)
	}

	e.FieldStart("head")
	s.Head.Encode(e)

	e.FieldStart("base")
	s.Base.Encode(e)

	e.FieldStart("_links")
	s.Links.Encode(e)

	e.FieldStart("author_association")
	s.AuthorAssociation.Encode(e)

	e.FieldStart("auto_merge")
	s.AutoMerge.Encode(e)
	if s.Draft.Set {
		e.FieldStart("draft")
		s.Draft.Encode(e)
	}

	e.FieldStart("merged")
	e.Bool(s.Merged)

	e.FieldStart("mergeable")
	s.Mergeable.Encode(e)
	if s.Rebaseable.Set {
		e.FieldStart("rebaseable")
		s.Rebaseable.Encode(e)
	}

	e.FieldStart("mergeable_state")
	e.Str(s.MergeableState)

	e.FieldStart("merged_by")
	s.MergedBy.Encode(e)

	e.FieldStart("comments")
	e.Int(s.Comments)

	e.FieldStart("review_comments")
	e.Int(s.ReviewComments)

	e.FieldStart("maintainer_can_modify")
	e.Bool(s.MaintainerCanModify)

	e.FieldStart("commits")
	e.Int(s.Commits)

	e.FieldStart("additions")
	e.Int(s.Additions)

	e.FieldStart("deletions")
	e.Int(s.Deletions)

	e.FieldStart("changed_files")
	e.Int(s.ChangedFiles)
	e.ObjEnd()
}

// Decode decodes PullRequest from json.
func (s *PullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "diff_url":
			v, err := json.DecodeURI(d)
			s.DiffURL = v
			if err != nil {
				return err
			}
		case "patch_url":
			v, err := json.DecodeURI(d)
			s.PatchURL = v
			if err != nil {
				return err
			}
		case "issue_url":
			v, err := json.DecodeURI(d)
			s.IssueURL = v
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := json.DecodeURI(d)
			s.CommitsURL = v
			if err != nil {
				return err
			}
		case "review_comments_url":
			v, err := json.DecodeURI(d)
			s.ReviewCommentsURL = v
			if err != nil {
				return err
			}
		case "review_comment_url":
			v, err := d.Str()
			s.ReviewCommentURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := json.DecodeURI(d)
			s.StatusesURL = v
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "locked":
			v, err := d.Bool()
			s.Locked = bool(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "body":
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "labels":
			s.Labels = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PullRequestLabelsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Labels = append(s.Labels, elem)
				return nil
			}); err != nil {
				return err
			}
		case "milestone":
			if err := s.Milestone.Decode(d); err != nil {
				return err
			}
		case "active_lock_reason":
			s.ActiveLockReason.Reset()
			if err := s.ActiveLockReason.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "closed_at":
			if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "merged_at":
			if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "merge_commit_sha":
			if err := s.MergeCommitSha.Decode(d); err != nil {
				return err
			}
		case "assignee":
			if err := s.Assignee.Decode(d); err != nil {
				return err
			}
		case "assignees":
			s.Assignees.Reset()
			if err := s.Assignees.Decode(d); err != nil {
				return err
			}
		case "requested_reviewers":
			s.RequestedReviewers.Reset()
			if err := s.RequestedReviewers.Decode(d); err != nil {
				return err
			}
		case "requested_teams":
			s.RequestedTeams.Reset()
			if err := s.RequestedTeams.Decode(d); err != nil {
				return err
			}
		case "head":
			if err := s.Head.Decode(d); err != nil {
				return err
			}
		case "base":
			if err := s.Base.Decode(d); err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "auto_merge":
			if err := s.AutoMerge.Decode(d); err != nil {
				return err
			}
		case "draft":
			s.Draft.Reset()
			if err := s.Draft.Decode(d); err != nil {
				return err
			}
		case "merged":
			v, err := d.Bool()
			s.Merged = bool(v)
			if err != nil {
				return err
			}
		case "mergeable":
			if err := s.Mergeable.Decode(d); err != nil {
				return err
			}
		case "rebaseable":
			s.Rebaseable.Reset()
			if err := s.Rebaseable.Decode(d); err != nil {
				return err
			}
		case "mergeable_state":
			v, err := d.Str()
			s.MergeableState = string(v)
			if err != nil {
				return err
			}
		case "merged_by":
			if err := s.MergedBy.Decode(d); err != nil {
				return err
			}
		case "comments":
			v, err := d.Int()
			s.Comments = int(v)
			if err != nil {
				return err
			}
		case "review_comments":
			v, err := d.Int()
			s.ReviewComments = int(v)
			if err != nil {
				return err
			}
		case "maintainer_can_modify":
			v, err := d.Bool()
			s.MaintainerCanModify = bool(v)
			if err != nil {
				return err
			}
		case "commits":
			v, err := d.Int()
			s.Commits = int(v)
			if err != nil {
				return err
			}
		case "additions":
			v, err := d.Int()
			s.Additions = int(v)
			if err != nil {
				return err
			}
		case "deletions":
			v, err := d.Int()
			s.Deletions = int(v)
			if err != nil {
				return err
			}
		case "changed_files":
			v, err := d.Int()
			s.ChangedFiles = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestBase) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("label")
	e.Str(s.Label)

	e.FieldStart("ref")
	e.Str(s.Ref)

	e.FieldStart("repo")
	s.Repo.Encode(e)

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("user")
	s.User.Encode(e)
	e.ObjEnd()
}

// Decode decodes PullRequestBase from json.
func (s *PullRequestBase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestBase to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			v, err := d.Str()
			s.Label = string(v)
			if err != nil {
				return err
			}
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "repo":
			if err := s.Repo.Decode(d); err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestBaseRepo) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("archive_url")
	e.Str(s.ArchiveURL)

	e.FieldStart("assignees_url")
	e.Str(s.AssigneesURL)

	e.FieldStart("blobs_url")
	e.Str(s.BlobsURL)

	e.FieldStart("branches_url")
	e.Str(s.BranchesURL)

	e.FieldStart("collaborators_url")
	e.Str(s.CollaboratorsURL)

	e.FieldStart("comments_url")
	e.Str(s.CommentsURL)

	e.FieldStart("commits_url")
	e.Str(s.CommitsURL)

	e.FieldStart("compare_url")
	e.Str(s.CompareURL)

	e.FieldStart("contents_url")
	e.Str(s.ContentsURL)

	e.FieldStart("contributors_url")
	json.EncodeURI(e, s.ContributorsURL)

	e.FieldStart("deployments_url")
	json.EncodeURI(e, s.DeploymentsURL)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("downloads_url")
	json.EncodeURI(e, s.DownloadsURL)

	e.FieldStart("events_url")
	json.EncodeURI(e, s.EventsURL)

	e.FieldStart("fork")
	e.Bool(s.Fork)

	e.FieldStart("forks_url")
	json.EncodeURI(e, s.ForksURL)

	e.FieldStart("full_name")
	e.Str(s.FullName)

	e.FieldStart("git_commits_url")
	e.Str(s.GitCommitsURL)

	e.FieldStart("git_refs_url")
	e.Str(s.GitRefsURL)

	e.FieldStart("git_tags_url")
	e.Str(s.GitTagsURL)

	e.FieldStart("hooks_url")
	json.EncodeURI(e, s.HooksURL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("issue_comment_url")
	e.Str(s.IssueCommentURL)

	e.FieldStart("issue_events_url")
	e.Str(s.IssueEventsURL)

	e.FieldStart("issues_url")
	e.Str(s.IssuesURL)

	e.FieldStart("keys_url")
	e.Str(s.KeysURL)

	e.FieldStart("labels_url")
	e.Str(s.LabelsURL)

	e.FieldStart("languages_url")
	json.EncodeURI(e, s.LanguagesURL)

	e.FieldStart("merges_url")
	json.EncodeURI(e, s.MergesURL)

	e.FieldStart("milestones_url")
	e.Str(s.MilestonesURL)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("notifications_url")
	e.Str(s.NotificationsURL)

	e.FieldStart("owner")
	s.Owner.Encode(e)

	e.FieldStart("private")
	e.Bool(s.Private)

	e.FieldStart("pulls_url")
	e.Str(s.PullsURL)

	e.FieldStart("releases_url")
	e.Str(s.ReleasesURL)

	e.FieldStart("stargazers_url")
	json.EncodeURI(e, s.StargazersURL)

	e.FieldStart("statuses_url")
	e.Str(s.StatusesURL)

	e.FieldStart("subscribers_url")
	json.EncodeURI(e, s.SubscribersURL)

	e.FieldStart("subscription_url")
	json.EncodeURI(e, s.SubscriptionURL)

	e.FieldStart("tags_url")
	json.EncodeURI(e, s.TagsURL)

	e.FieldStart("teams_url")
	json.EncodeURI(e, s.TeamsURL)

	e.FieldStart("trees_url")
	e.Str(s.TreesURL)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("clone_url")
	e.Str(s.CloneURL)

	e.FieldStart("default_branch")
	e.Str(s.DefaultBranch)

	e.FieldStart("forks")
	e.Int(s.Forks)

	e.FieldStart("forks_count")
	e.Int(s.ForksCount)

	e.FieldStart("git_url")
	e.Str(s.GitURL)

	e.FieldStart("has_downloads")
	e.Bool(s.HasDownloads)

	e.FieldStart("has_issues")
	e.Bool(s.HasIssues)

	e.FieldStart("has_projects")
	e.Bool(s.HasProjects)

	e.FieldStart("has_wiki")
	e.Bool(s.HasWiki)

	e.FieldStart("has_pages")
	e.Bool(s.HasPages)

	e.FieldStart("homepage")
	s.Homepage.Encode(e)

	e.FieldStart("language")
	s.Language.Encode(e)
	if s.MasterBranch.Set {
		e.FieldStart("master_branch")
		s.MasterBranch.Encode(e)
	}

	e.FieldStart("archived")
	e.Bool(s.Archived)

	e.FieldStart("disabled")
	e.Bool(s.Disabled)

	e.FieldStart("mirror_url")
	s.MirrorURL.Encode(e)

	e.FieldStart("open_issues")
	e.Int(s.OpenIssues)

	e.FieldStart("open_issues_count")
	e.Int(s.OpenIssuesCount)
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	if s.TempCloneToken.Set {
		e.FieldStart("temp_clone_token")
		s.TempCloneToken.Encode(e)
	}
	if s.AllowMergeCommit.Set {
		e.FieldStart("allow_merge_commit")
		s.AllowMergeCommit.Encode(e)
	}
	if s.AllowSquashMerge.Set {
		e.FieldStart("allow_squash_merge")
		s.AllowSquashMerge.Encode(e)
	}
	if s.AllowRebaseMerge.Set {
		e.FieldStart("allow_rebase_merge")
		s.AllowRebaseMerge.Encode(e)
	}

	e.FieldStart("license")
	s.License.Encode(e)

	e.FieldStart("pushed_at")
	json.EncodeDateTime(e, s.PushedAt)

	e.FieldStart("size")
	e.Int(s.Size)

	e.FieldStart("ssh_url")
	e.Str(s.SSHURL)

	e.FieldStart("stargazers_count")
	e.Int(s.StargazersCount)

	e.FieldStart("svn_url")
	json.EncodeURI(e, s.SvnURL)
	if s.Topics != nil {
		e.FieldStart("topics")
		e.ArrStart()
		for _, elem := range s.Topics {
			e.Str(elem)
		}
		e.ArrEnd()
	}

	e.FieldStart("watchers")
	e.Int(s.Watchers)

	e.FieldStart("watchers_count")
	e.Int(s.WatchersCount)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)
	if s.AllowForking.Set {
		e.FieldStart("allow_forking")
		s.AllowForking.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestBaseRepo from json.
func (s *PullRequestBaseRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestBaseRepo to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "clone_url":
			v, err := d.Str()
			s.CloneURL = string(v)
			if err != nil {
				return err
			}
		case "default_branch":
			v, err := d.Str()
			s.DefaultBranch = string(v)
			if err != nil {
				return err
			}
		case "forks":
			v, err := d.Int()
			s.Forks = int(v)
			if err != nil {
				return err
			}
		case "forks_count":
			v, err := d.Int()
			s.ForksCount = int(v)
			if err != nil {
				return err
			}
		case "git_url":
			v, err := d.Str()
			s.GitURL = string(v)
			if err != nil {
				return err
			}
		case "has_downloads":
			v, err := d.Bool()
			s.HasDownloads = bool(v)
			if err != nil {
				return err
			}
		case "has_issues":
			v, err := d.Bool()
			s.HasIssues = bool(v)
			if err != nil {
				return err
			}
		case "has_projects":
			v, err := d.Bool()
			s.HasProjects = bool(v)
			if err != nil {
				return err
			}
		case "has_wiki":
			v, err := d.Bool()
			s.HasWiki = bool(v)
			if err != nil {
				return err
			}
		case "has_pages":
			v, err := d.Bool()
			s.HasPages = bool(v)
			if err != nil {
				return err
			}
		case "homepage":
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "master_branch":
			s.MasterBranch.Reset()
			if err := s.MasterBranch.Decode(d); err != nil {
				return err
			}
		case "archived":
			v, err := d.Bool()
			s.Archived = bool(v)
			if err != nil {
				return err
			}
		case "disabled":
			v, err := d.Bool()
			s.Disabled = bool(v)
			if err != nil {
				return err
			}
		case "mirror_url":
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "open_issues_count":
			v, err := d.Int()
			s.OpenIssuesCount = int(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			v, err := json.DecodeDateTime(d)
			s.PushedAt = v
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			v, err := d.Str()
			s.SSHURL = string(v)
			if err != nil {
				return err
			}
		case "stargazers_count":
			v, err := d.Int()
			s.StargazersCount = int(v)
			if err != nil {
				return err
			}
		case "svn_url":
			v, err := json.DecodeURI(d)
			s.SvnURL = v
			if err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "watchers":
			v, err := d.Int()
			s.Watchers = int(v)
			if err != nil {
				return err
			}
		case "watchers_count":
			v, err := d.Int()
			s.WatchersCount = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestBaseRepoOwner) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("avatar_url")
	json.EncodeURI(e, s.AvatarURL)

	e.FieldStart("events_url")
	e.Str(s.EventsURL)

	e.FieldStart("followers_url")
	json.EncodeURI(e, s.FollowersURL)

	e.FieldStart("following_url")
	e.Str(s.FollowingURL)

	e.FieldStart("gists_url")
	e.Str(s.GistsURL)

	e.FieldStart("gravatar_id")
	s.GravatarID.Encode(e)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("login")
	e.Str(s.Login)

	e.FieldStart("organizations_url")
	json.EncodeURI(e, s.OrganizationsURL)

	e.FieldStart("received_events_url")
	json.EncodeURI(e, s.ReceivedEventsURL)

	e.FieldStart("repos_url")
	json.EncodeURI(e, s.ReposURL)

	e.FieldStart("site_admin")
	e.Bool(s.SiteAdmin)

	e.FieldStart("starred_url")
	e.Str(s.StarredURL)

	e.FieldStart("subscriptions_url")
	json.EncodeURI(e, s.SubscriptionsURL)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	e.ObjEnd()
}

// Decode decodes PullRequestBaseRepoOwner from json.
func (s *PullRequestBaseRepoOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestBaseRepoOwner to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestBaseRepoPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("admin")
	e.Bool(s.Admin)
	if s.Maintain.Set {
		e.FieldStart("maintain")
		s.Maintain.Encode(e)
	}

	e.FieldStart("push")
	e.Bool(s.Push)
	if s.Triage.Set {
		e.FieldStart("triage")
		s.Triage.Encode(e)
	}

	e.FieldStart("pull")
	e.Bool(s.Pull)
	e.ObjEnd()
}

// Decode decodes PullRequestBaseRepoPermissions from json.
func (s *PullRequestBaseRepoPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestBaseRepoPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestBaseUser) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("avatar_url")
	json.EncodeURI(e, s.AvatarURL)

	e.FieldStart("events_url")
	e.Str(s.EventsURL)

	e.FieldStart("followers_url")
	json.EncodeURI(e, s.FollowersURL)

	e.FieldStart("following_url")
	e.Str(s.FollowingURL)

	e.FieldStart("gists_url")
	e.Str(s.GistsURL)

	e.FieldStart("gravatar_id")
	s.GravatarID.Encode(e)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("login")
	e.Str(s.Login)

	e.FieldStart("organizations_url")
	json.EncodeURI(e, s.OrganizationsURL)

	e.FieldStart("received_events_url")
	json.EncodeURI(e, s.ReceivedEventsURL)

	e.FieldStart("repos_url")
	json.EncodeURI(e, s.ReposURL)

	e.FieldStart("site_admin")
	e.Bool(s.SiteAdmin)

	e.FieldStart("starred_url")
	e.Str(s.StarredURL)

	e.FieldStart("subscriptions_url")
	json.EncodeURI(e, s.SubscriptionsURL)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	e.ObjEnd()
}

// Decode decodes PullRequestBaseUser from json.
func (s *PullRequestBaseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestBaseUser to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestHead) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("label")
	e.Str(s.Label)

	e.FieldStart("ref")
	e.Str(s.Ref)

	e.FieldStart("repo")
	s.Repo.Encode(e)

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("user")
	s.User.Encode(e)
	e.ObjEnd()
}

// Decode decodes PullRequestHead from json.
func (s *PullRequestHead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestHead to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			v, err := d.Str()
			s.Label = string(v)
			if err != nil {
				return err
			}
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "repo":
			if err := s.Repo.Decode(d); err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestHeadRepo) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("archive_url")
	e.Str(s.ArchiveURL)

	e.FieldStart("assignees_url")
	e.Str(s.AssigneesURL)

	e.FieldStart("blobs_url")
	e.Str(s.BlobsURL)

	e.FieldStart("branches_url")
	e.Str(s.BranchesURL)

	e.FieldStart("collaborators_url")
	e.Str(s.CollaboratorsURL)

	e.FieldStart("comments_url")
	e.Str(s.CommentsURL)

	e.FieldStart("commits_url")
	e.Str(s.CommitsURL)

	e.FieldStart("compare_url")
	e.Str(s.CompareURL)

	e.FieldStart("contents_url")
	e.Str(s.ContentsURL)

	e.FieldStart("contributors_url")
	json.EncodeURI(e, s.ContributorsURL)

	e.FieldStart("deployments_url")
	json.EncodeURI(e, s.DeploymentsURL)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("downloads_url")
	json.EncodeURI(e, s.DownloadsURL)

	e.FieldStart("events_url")
	json.EncodeURI(e, s.EventsURL)

	e.FieldStart("fork")
	e.Bool(s.Fork)

	e.FieldStart("forks_url")
	json.EncodeURI(e, s.ForksURL)

	e.FieldStart("full_name")
	e.Str(s.FullName)

	e.FieldStart("git_commits_url")
	e.Str(s.GitCommitsURL)

	e.FieldStart("git_refs_url")
	e.Str(s.GitRefsURL)

	e.FieldStart("git_tags_url")
	e.Str(s.GitTagsURL)

	e.FieldStart("hooks_url")
	json.EncodeURI(e, s.HooksURL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("issue_comment_url")
	e.Str(s.IssueCommentURL)

	e.FieldStart("issue_events_url")
	e.Str(s.IssueEventsURL)

	e.FieldStart("issues_url")
	e.Str(s.IssuesURL)

	e.FieldStart("keys_url")
	e.Str(s.KeysURL)

	e.FieldStart("labels_url")
	e.Str(s.LabelsURL)

	e.FieldStart("languages_url")
	json.EncodeURI(e, s.LanguagesURL)

	e.FieldStart("merges_url")
	json.EncodeURI(e, s.MergesURL)

	e.FieldStart("milestones_url")
	e.Str(s.MilestonesURL)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("notifications_url")
	e.Str(s.NotificationsURL)

	e.FieldStart("owner")
	s.Owner.Encode(e)

	e.FieldStart("private")
	e.Bool(s.Private)

	e.FieldStart("pulls_url")
	e.Str(s.PullsURL)

	e.FieldStart("releases_url")
	e.Str(s.ReleasesURL)

	e.FieldStart("stargazers_url")
	json.EncodeURI(e, s.StargazersURL)

	e.FieldStart("statuses_url")
	e.Str(s.StatusesURL)

	e.FieldStart("subscribers_url")
	json.EncodeURI(e, s.SubscribersURL)

	e.FieldStart("subscription_url")
	json.EncodeURI(e, s.SubscriptionURL)

	e.FieldStart("tags_url")
	json.EncodeURI(e, s.TagsURL)

	e.FieldStart("teams_url")
	json.EncodeURI(e, s.TeamsURL)

	e.FieldStart("trees_url")
	e.Str(s.TreesURL)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("clone_url")
	e.Str(s.CloneURL)

	e.FieldStart("default_branch")
	e.Str(s.DefaultBranch)

	e.FieldStart("forks")
	e.Int(s.Forks)

	e.FieldStart("forks_count")
	e.Int(s.ForksCount)

	e.FieldStart("git_url")
	e.Str(s.GitURL)

	e.FieldStart("has_downloads")
	e.Bool(s.HasDownloads)

	e.FieldStart("has_issues")
	e.Bool(s.HasIssues)

	e.FieldStart("has_projects")
	e.Bool(s.HasProjects)

	e.FieldStart("has_wiki")
	e.Bool(s.HasWiki)

	e.FieldStart("has_pages")
	e.Bool(s.HasPages)

	e.FieldStart("homepage")
	s.Homepage.Encode(e)

	e.FieldStart("language")
	s.Language.Encode(e)
	if s.MasterBranch.Set {
		e.FieldStart("master_branch")
		s.MasterBranch.Encode(e)
	}

	e.FieldStart("archived")
	e.Bool(s.Archived)

	e.FieldStart("disabled")
	e.Bool(s.Disabled)

	e.FieldStart("mirror_url")
	s.MirrorURL.Encode(e)

	e.FieldStart("open_issues")
	e.Int(s.OpenIssues)

	e.FieldStart("open_issues_count")
	e.Int(s.OpenIssuesCount)
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	if s.TempCloneToken.Set {
		e.FieldStart("temp_clone_token")
		s.TempCloneToken.Encode(e)
	}
	if s.AllowMergeCommit.Set {
		e.FieldStart("allow_merge_commit")
		s.AllowMergeCommit.Encode(e)
	}
	if s.AllowSquashMerge.Set {
		e.FieldStart("allow_squash_merge")
		s.AllowSquashMerge.Encode(e)
	}
	if s.AllowRebaseMerge.Set {
		e.FieldStart("allow_rebase_merge")
		s.AllowRebaseMerge.Encode(e)
	}

	e.FieldStart("license")
	s.License.Encode(e)

	e.FieldStart("pushed_at")
	json.EncodeDateTime(e, s.PushedAt)

	e.FieldStart("size")
	e.Int(s.Size)

	e.FieldStart("ssh_url")
	e.Str(s.SSHURL)

	e.FieldStart("stargazers_count")
	e.Int(s.StargazersCount)

	e.FieldStart("svn_url")
	json.EncodeURI(e, s.SvnURL)
	if s.Topics != nil {
		e.FieldStart("topics")
		e.ArrStart()
		for _, elem := range s.Topics {
			e.Str(elem)
		}
		e.ArrEnd()
	}

	e.FieldStart("watchers")
	e.Int(s.Watchers)

	e.FieldStart("watchers_count")
	e.Int(s.WatchersCount)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)
	if s.AllowForking.Set {
		e.FieldStart("allow_forking")
		s.AllowForking.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestHeadRepo from json.
func (s *PullRequestHeadRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestHeadRepo to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "clone_url":
			v, err := d.Str()
			s.CloneURL = string(v)
			if err != nil {
				return err
			}
		case "default_branch":
			v, err := d.Str()
			s.DefaultBranch = string(v)
			if err != nil {
				return err
			}
		case "forks":
			v, err := d.Int()
			s.Forks = int(v)
			if err != nil {
				return err
			}
		case "forks_count":
			v, err := d.Int()
			s.ForksCount = int(v)
			if err != nil {
				return err
			}
		case "git_url":
			v, err := d.Str()
			s.GitURL = string(v)
			if err != nil {
				return err
			}
		case "has_downloads":
			v, err := d.Bool()
			s.HasDownloads = bool(v)
			if err != nil {
				return err
			}
		case "has_issues":
			v, err := d.Bool()
			s.HasIssues = bool(v)
			if err != nil {
				return err
			}
		case "has_projects":
			v, err := d.Bool()
			s.HasProjects = bool(v)
			if err != nil {
				return err
			}
		case "has_wiki":
			v, err := d.Bool()
			s.HasWiki = bool(v)
			if err != nil {
				return err
			}
		case "has_pages":
			v, err := d.Bool()
			s.HasPages = bool(v)
			if err != nil {
				return err
			}
		case "homepage":
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "master_branch":
			s.MasterBranch.Reset()
			if err := s.MasterBranch.Decode(d); err != nil {
				return err
			}
		case "archived":
			v, err := d.Bool()
			s.Archived = bool(v)
			if err != nil {
				return err
			}
		case "disabled":
			v, err := d.Bool()
			s.Disabled = bool(v)
			if err != nil {
				return err
			}
		case "mirror_url":
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "open_issues_count":
			v, err := d.Int()
			s.OpenIssuesCount = int(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			v, err := json.DecodeDateTime(d)
			s.PushedAt = v
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			v, err := d.Str()
			s.SSHURL = string(v)
			if err != nil {
				return err
			}
		case "stargazers_count":
			v, err := d.Int()
			s.StargazersCount = int(v)
			if err != nil {
				return err
			}
		case "svn_url":
			v, err := json.DecodeURI(d)
			s.SvnURL = v
			if err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "watchers":
			v, err := d.Int()
			s.Watchers = int(v)
			if err != nil {
				return err
			}
		case "watchers_count":
			v, err := d.Int()
			s.WatchersCount = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestHeadRepoLicense) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("key")
	e.Str(s.Key)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("url")
	s.URL.Encode(e)

	e.FieldStart("spdx_id")
	s.SpdxID.Encode(e)

	e.FieldStart("node_id")
	e.Str(s.NodeID)
	e.ObjEnd()
}

// Decode decodes PullRequestHeadRepoLicense from json.
func (s *PullRequestHeadRepoLicense) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestHeadRepoLicense to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "url":
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "spdx_id":
			if err := s.SpdxID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestHeadRepoOwner) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("avatar_url")
	json.EncodeURI(e, s.AvatarURL)

	e.FieldStart("events_url")
	e.Str(s.EventsURL)

	e.FieldStart("followers_url")
	json.EncodeURI(e, s.FollowersURL)

	e.FieldStart("following_url")
	e.Str(s.FollowingURL)

	e.FieldStart("gists_url")
	e.Str(s.GistsURL)

	e.FieldStart("gravatar_id")
	s.GravatarID.Encode(e)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("login")
	e.Str(s.Login)

	e.FieldStart("organizations_url")
	json.EncodeURI(e, s.OrganizationsURL)

	e.FieldStart("received_events_url")
	json.EncodeURI(e, s.ReceivedEventsURL)

	e.FieldStart("repos_url")
	json.EncodeURI(e, s.ReposURL)

	e.FieldStart("site_admin")
	e.Bool(s.SiteAdmin)

	e.FieldStart("starred_url")
	e.Str(s.StarredURL)

	e.FieldStart("subscriptions_url")
	json.EncodeURI(e, s.SubscriptionsURL)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	e.ObjEnd()
}

// Decode decodes PullRequestHeadRepoOwner from json.
func (s *PullRequestHeadRepoOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestHeadRepoOwner to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestHeadRepoPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("admin")
	e.Bool(s.Admin)
	if s.Maintain.Set {
		e.FieldStart("maintain")
		s.Maintain.Encode(e)
	}

	e.FieldStart("push")
	e.Bool(s.Push)
	if s.Triage.Set {
		e.FieldStart("triage")
		s.Triage.Encode(e)
	}

	e.FieldStart("pull")
	e.Bool(s.Pull)
	e.ObjEnd()
}

// Decode decodes PullRequestHeadRepoPermissions from json.
func (s *PullRequestHeadRepoPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestHeadRepoPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestHeadUser) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("avatar_url")
	json.EncodeURI(e, s.AvatarURL)

	e.FieldStart("events_url")
	e.Str(s.EventsURL)

	e.FieldStart("followers_url")
	json.EncodeURI(e, s.FollowersURL)

	e.FieldStart("following_url")
	e.Str(s.FollowingURL)

	e.FieldStart("gists_url")
	e.Str(s.GistsURL)

	e.FieldStart("gravatar_id")
	s.GravatarID.Encode(e)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("login")
	e.Str(s.Login)

	e.FieldStart("organizations_url")
	json.EncodeURI(e, s.OrganizationsURL)

	e.FieldStart("received_events_url")
	json.EncodeURI(e, s.ReceivedEventsURL)

	e.FieldStart("repos_url")
	json.EncodeURI(e, s.ReposURL)

	e.FieldStart("site_admin")
	e.Bool(s.SiteAdmin)

	e.FieldStart("starred_url")
	e.Str(s.StarredURL)

	e.FieldStart("subscriptions_url")
	json.EncodeURI(e, s.SubscriptionsURL)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	e.ObjEnd()
}

// Decode decodes PullRequestHeadUser from json.
func (s *PullRequestHeadUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestHeadUser to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestLabelsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.Color.Set {
		e.FieldStart("color")
		s.Color.Encode(e)
	}
	if s.Default.Set {
		e.FieldStart("default")
		s.Default.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestLabelsItem from json.
func (s *PullRequestLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestLabelsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "color":
			s.Color.Reset()
			if err := s.Color.Decode(d); err != nil {
				return err
			}
		case "default":
			s.Default.Reset()
			if err := s.Default.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestLinks) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("comments")
	s.Comments.Encode(e)

	e.FieldStart("commits")
	s.Commits.Encode(e)

	e.FieldStart("statuses")
	s.Statuses.Encode(e)

	e.FieldStart("html")
	s.HTML.Encode(e)

	e.FieldStart("issue")
	s.Issue.Encode(e)

	e.FieldStart("review_comments")
	s.ReviewComments.Encode(e)

	e.FieldStart("review_comment")
	s.ReviewComment.Encode(e)

	e.FieldStart("self")
	s.Self.Encode(e)
	e.ObjEnd()
}

// Decode decodes PullRequestLinks from json.
func (s *PullRequestLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "comments":
			if err := s.Comments.Decode(d); err != nil {
				return err
			}
		case "commits":
			if err := s.Commits.Decode(d); err != nil {
				return err
			}
		case "statuses":
			if err := s.Statuses.Decode(d); err != nil {
				return err
			}
		case "html":
			if err := s.HTML.Decode(d); err != nil {
				return err
			}
		case "issue":
			if err := s.Issue.Decode(d); err != nil {
				return err
			}
		case "review_comments":
			if err := s.ReviewComments.Decode(d); err != nil {
				return err
			}
		case "review_comment":
			if err := s.ReviewComment.Decode(d); err != nil {
				return err
			}
		case "self":
			if err := s.Self.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestMergeResult) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("merged")
	e.Bool(s.Merged)

	e.FieldStart("message")
	e.Str(s.Message)
	e.ObjEnd()
}

// Decode decodes PullRequestMergeResult from json.
func (s *PullRequestMergeResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestMergeResult to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "merged":
			v, err := d.Bool()
			s.Merged = bool(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestMinimal) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("number")
	e.Int(s.Number)

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("head")
	s.Head.Encode(e)

	e.FieldStart("base")
	s.Base.Encode(e)
	e.ObjEnd()
}

// Decode decodes PullRequestMinimal from json.
func (s *PullRequestMinimal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestMinimal to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "head":
			if err := s.Head.Decode(d); err != nil {
				return err
			}
		case "base":
			if err := s.Base.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestMinimalBase) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("ref")
	e.Str(s.Ref)

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("repo")
	s.Repo.Encode(e)
	e.ObjEnd()
}

// Decode decodes PullRequestMinimalBase from json.
func (s *PullRequestMinimalBase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestMinimalBase to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "repo":
			if err := s.Repo.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestMinimalBaseRepo) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("name")
	e.Str(s.Name)
	e.ObjEnd()
}

// Decode decodes PullRequestMinimalBaseRepo from json.
func (s *PullRequestMinimalBaseRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestMinimalBaseRepo to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestMinimalHead) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("ref")
	e.Str(s.Ref)

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("repo")
	s.Repo.Encode(e)
	e.ObjEnd()
}

// Decode decodes PullRequestMinimalHead from json.
func (s *PullRequestMinimalHead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestMinimalHead to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "repo":
			if err := s.Repo.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestMinimalHeadRepo) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("name")
	e.Str(s.Name)
	e.ObjEnd()
}

// Decode decodes PullRequestMinimalHeadRepo from json.
func (s *PullRequestMinimalHeadRepo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestMinimalHeadRepo to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReview) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("user")
	s.User.Encode(e)

	e.FieldStart("body")
	e.Str(s.Body)

	e.FieldStart("state")
	e.Str(s.State)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("pull_request_url")
	json.EncodeURI(e, s.PullRequestURL)

	e.FieldStart("_links")
	s.Links.Encode(e)
	if s.SubmittedAt.Set {
		e.FieldStart("submitted_at")
		s.SubmittedAt.Encode(e, json.EncodeDateTime)
	}

	e.FieldStart("commit_id")
	e.Str(s.CommitID)
	if s.BodyHTML.Set {
		e.FieldStart("body_html")
		s.BodyHTML.Encode(e)
	}
	if s.BodyText.Set {
		e.FieldStart("body_text")
		s.BodyText.Encode(e)
	}

	e.FieldStart("author_association")
	s.AuthorAssociation.Encode(e)
	e.ObjEnd()
}

// Decode decodes PullRequestReview from json.
func (s *PullRequestReview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReview to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "pull_request_url":
			v, err := json.DecodeURI(d)
			s.PullRequestURL = v
			if err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		case "submitted_at":
			s.SubmittedAt.Reset()
			if err := s.SubmittedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "commit_id":
			v, err := d.Str()
			s.CommitID = string(v)
			if err != nil {
				return err
			}
		case "body_html":
			s.BodyHTML.Reset()
			if err := s.BodyHTML.Decode(d); err != nil {
				return err
			}
		case "body_text":
			s.BodyText.Reset()
			if err := s.BodyText.Decode(d); err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReviewComment) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("pull_request_review_id")
	s.PullRequestReviewID.Encode(e)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("diff_hunk")
	e.Str(s.DiffHunk)

	e.FieldStart("path")
	e.Str(s.Path)

	e.FieldStart("position")
	e.Int(s.Position)

	e.FieldStart("original_position")
	e.Int(s.OriginalPosition)

	e.FieldStart("commit_id")
	e.Str(s.CommitID)

	e.FieldStart("original_commit_id")
	e.Str(s.OriginalCommitID)
	if s.InReplyToID.Set {
		e.FieldStart("in_reply_to_id")
		s.InReplyToID.Encode(e)
	}

	e.FieldStart("user")
	s.User.Encode(e)

	e.FieldStart("body")
	e.Str(s.Body)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("pull_request_url")
	json.EncodeURI(e, s.PullRequestURL)

	e.FieldStart("author_association")
	s.AuthorAssociation.Encode(e)

	e.FieldStart("_links")
	s.Links.Encode(e)
	if s.StartLine.Set {
		e.FieldStart("start_line")
		s.StartLine.Encode(e)
	}
	if s.OriginalStartLine.Set {
		e.FieldStart("original_start_line")
		s.OriginalStartLine.Encode(e)
	}
	if s.StartSide.Set {
		e.FieldStart("start_side")
		s.StartSide.Encode(e)
	}
	if s.Line.Set {
		e.FieldStart("line")
		s.Line.Encode(e)
	}
	if s.OriginalLine.Set {
		e.FieldStart("original_line")
		s.OriginalLine.Encode(e)
	}
	if s.Side.Set {
		e.FieldStart("side")
		s.Side.Encode(e)
	}
	if s.Reactions.Set {
		e.FieldStart("reactions")
		s.Reactions.Encode(e)
	}
	if s.BodyHTML.Set {
		e.FieldStart("body_html")
		s.BodyHTML.Encode(e)
	}
	if s.BodyText.Set {
		e.FieldStart("body_text")
		s.BodyText.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestReviewComment from json.
func (s *PullRequestReviewComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewComment to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "pull_request_review_id":
			if err := s.PullRequestReviewID.Decode(d); err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "diff_hunk":
			v, err := d.Str()
			s.DiffHunk = string(v)
			if err != nil {
				return err
			}
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "position":
			v, err := d.Int()
			s.Position = int(v)
			if err != nil {
				return err
			}
		case "original_position":
			v, err := d.Int()
			s.OriginalPosition = int(v)
			if err != nil {
				return err
			}
		case "commit_id":
			v, err := d.Str()
			s.CommitID = string(v)
			if err != nil {
				return err
			}
		case "original_commit_id":
			v, err := d.Str()
			s.OriginalCommitID = string(v)
			if err != nil {
				return err
			}
		case "in_reply_to_id":
			s.InReplyToID.Reset()
			if err := s.InReplyToID.Decode(d); err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "pull_request_url":
			v, err := json.DecodeURI(d)
			s.PullRequestURL = v
			if err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		case "start_line":
			s.StartLine.Reset()
			if err := s.StartLine.Decode(d); err != nil {
				return err
			}
		case "original_start_line":
			s.OriginalStartLine.Reset()
			if err := s.OriginalStartLine.Decode(d); err != nil {
				return err
			}
		case "start_side":
			s.StartSide.Reset()
			if err := s.StartSide.Decode(d); err != nil {
				return err
			}
		case "line":
			s.Line.Reset()
			if err := s.Line.Decode(d); err != nil {
				return err
			}
		case "original_line":
			s.OriginalLine.Reset()
			if err := s.OriginalLine.Decode(d); err != nil {
				return err
			}
		case "side":
			s.Side.Reset()
			if err := s.Side.Decode(d); err != nil {
				return err
			}
		case "reactions":
			s.Reactions.Reset()
			if err := s.Reactions.Decode(d); err != nil {
				return err
			}
		case "body_html":
			s.BodyHTML.Reset()
			if err := s.BodyHTML.Decode(d); err != nil {
				return err
			}
		case "body_text":
			s.BodyText.Reset()
			if err := s.BodyText.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReviewCommentLinks) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("self")
	s.Self.Encode(e)

	e.FieldStart("html")
	s.HTML.Encode(e)

	e.FieldStart("pull_request")
	s.PullRequest.Encode(e)
	e.ObjEnd()
}

// Decode decodes PullRequestReviewCommentLinks from json.
func (s *PullRequestReviewCommentLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewCommentLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			if err := s.Self.Decode(d); err != nil {
				return err
			}
		case "html":
			if err := s.HTML.Decode(d); err != nil {
				return err
			}
		case "pull_request":
			if err := s.PullRequest.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReviewCommentLinksHTML) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("href")
	json.EncodeURI(e, s.Href)
	e.ObjEnd()
}

// Decode decodes PullRequestReviewCommentLinksHTML from json.
func (s *PullRequestReviewCommentLinksHTML) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewCommentLinksHTML to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			v, err := json.DecodeURI(d)
			s.Href = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReviewCommentLinksPullRequest) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("href")
	json.EncodeURI(e, s.Href)
	e.ObjEnd()
}

// Decode decodes PullRequestReviewCommentLinksPullRequest from json.
func (s *PullRequestReviewCommentLinksPullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewCommentLinksPullRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			v, err := json.DecodeURI(d)
			s.Href = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReviewCommentLinksSelf) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("href")
	json.EncodeURI(e, s.Href)
	e.ObjEnd()
}

// Decode decodes PullRequestReviewCommentLinksSelf from json.
func (s *PullRequestReviewCommentLinksSelf) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewCommentLinksSelf to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			v, err := json.DecodeURI(d)
			s.Href = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullRequestReviewCommentSide as json.
func (s PullRequestReviewCommentSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullRequestReviewCommentSide from json.
func (s *PullRequestReviewCommentSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewCommentSide to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PullRequestReviewCommentSide(v)
	return nil
}

// Encode encodes PullRequestReviewCommentStartSide as json.
func (s PullRequestReviewCommentStartSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullRequestReviewCommentStartSide from json.
func (s *PullRequestReviewCommentStartSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewCommentStartSide to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PullRequestReviewCommentStartSide(v)
	return nil
}

// Encode implements json.Marshaler.
func (s PullRequestReviewLinks) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("html")
	s.HTML.Encode(e)

	e.FieldStart("pull_request")
	s.PullRequest.Encode(e)
	e.ObjEnd()
}

// Decode decodes PullRequestReviewLinks from json.
func (s *PullRequestReviewLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "html":
			if err := s.HTML.Decode(d); err != nil {
				return err
			}
		case "pull_request":
			if err := s.PullRequest.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReviewLinksHTML) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("href")
	e.Str(s.Href)
	e.ObjEnd()
}

// Decode decodes PullRequestReviewLinksHTML from json.
func (s *PullRequestReviewLinksHTML) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewLinksHTML to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			v, err := d.Str()
			s.Href = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReviewLinksPullRequest) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("href")
	e.Str(s.Href)
	e.ObjEnd()
}

// Decode decodes PullRequestReviewLinksPullRequest from json.
func (s *PullRequestReviewLinksPullRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewLinksPullRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "href":
			v, err := d.Str()
			s.Href = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestReviewRequest) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("users")
	e.ArrStart()
	for _, elem := range s.Users {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("teams")
	e.ArrStart()
	for _, elem := range s.Teams {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes PullRequestReviewRequest from json.
func (s *PullRequestReviewRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestReviewRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem SimpleUser
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Team
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestSimple) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("diff_url")
	json.EncodeURI(e, s.DiffURL)

	e.FieldStart("patch_url")
	json.EncodeURI(e, s.PatchURL)

	e.FieldStart("issue_url")
	json.EncodeURI(e, s.IssueURL)

	e.FieldStart("commits_url")
	json.EncodeURI(e, s.CommitsURL)

	e.FieldStart("review_comments_url")
	json.EncodeURI(e, s.ReviewCommentsURL)

	e.FieldStart("review_comment_url")
	e.Str(s.ReviewCommentURL)

	e.FieldStart("comments_url")
	json.EncodeURI(e, s.CommentsURL)

	e.FieldStart("statuses_url")
	json.EncodeURI(e, s.StatusesURL)

	e.FieldStart("number")
	e.Int(s.Number)

	e.FieldStart("state")
	e.Str(s.State)

	e.FieldStart("locked")
	e.Bool(s.Locked)

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("user")
	s.User.Encode(e)

	e.FieldStart("body")
	s.Body.Encode(e)

	e.FieldStart("labels")
	e.ArrStart()
	for _, elem := range s.Labels {
		elem.Encode(e)
	}
	e.ArrEnd()

	e.FieldStart("milestone")
	s.Milestone.Encode(e)
	if s.ActiveLockReason.Set {
		e.FieldStart("active_lock_reason")
		s.ActiveLockReason.Encode(e)
	}

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("closed_at")
	s.ClosedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("merged_at")
	s.MergedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("merge_commit_sha")
	s.MergeCommitSha.Encode(e)

	e.FieldStart("assignee")
	s.Assignee.Encode(e)
	if s.Assignees.Set {
		e.FieldStart("assignees")
		s.Assignees.Encode(e)
	}
	if s.RequestedReviewers.Set {
		e.FieldStart("requested_reviewers")
		s.RequestedReviewers.Encode(e)
	}
	if s.RequestedTeams.Set {
		e.FieldStart("requested_teams")
		s.RequestedTeams.Encode(e)
	}

	e.FieldStart("head")
	s.Head.Encode(e)

	e.FieldStart("base")
	s.Base.Encode(e)

	e.FieldStart("_links")
	s.Links.Encode(e)

	e.FieldStart("author_association")
	s.AuthorAssociation.Encode(e)

	e.FieldStart("auto_merge")
	s.AutoMerge.Encode(e)
	if s.Draft.Set {
		e.FieldStart("draft")
		s.Draft.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestSimple from json.
func (s *PullRequestSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "diff_url":
			v, err := json.DecodeURI(d)
			s.DiffURL = v
			if err != nil {
				return err
			}
		case "patch_url":
			v, err := json.DecodeURI(d)
			s.PatchURL = v
			if err != nil {
				return err
			}
		case "issue_url":
			v, err := json.DecodeURI(d)
			s.IssueURL = v
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := json.DecodeURI(d)
			s.CommitsURL = v
			if err != nil {
				return err
			}
		case "review_comments_url":
			v, err := json.DecodeURI(d)
			s.ReviewCommentsURL = v
			if err != nil {
				return err
			}
		case "review_comment_url":
			v, err := d.Str()
			s.ReviewCommentURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := json.DecodeURI(d)
			s.StatusesURL = v
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "locked":
			v, err := d.Bool()
			s.Locked = bool(v)
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "body":
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "labels":
			s.Labels = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PullRequestSimpleLabelsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Labels = append(s.Labels, elem)
				return nil
			}); err != nil {
				return err
			}
		case "milestone":
			if err := s.Milestone.Decode(d); err != nil {
				return err
			}
		case "active_lock_reason":
			s.ActiveLockReason.Reset()
			if err := s.ActiveLockReason.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "closed_at":
			if err := s.ClosedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "merged_at":
			if err := s.MergedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "merge_commit_sha":
			if err := s.MergeCommitSha.Decode(d); err != nil {
				return err
			}
		case "assignee":
			if err := s.Assignee.Decode(d); err != nil {
				return err
			}
		case "assignees":
			s.Assignees.Reset()
			if err := s.Assignees.Decode(d); err != nil {
				return err
			}
		case "requested_reviewers":
			s.RequestedReviewers.Reset()
			if err := s.RequestedReviewers.Decode(d); err != nil {
				return err
			}
		case "requested_teams":
			s.RequestedTeams.Reset()
			if err := s.RequestedTeams.Decode(d); err != nil {
				return err
			}
		case "head":
			if err := s.Head.Decode(d); err != nil {
				return err
			}
		case "base":
			if err := s.Base.Decode(d); err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "auto_merge":
			if err := s.AutoMerge.Decode(d); err != nil {
				return err
			}
		case "draft":
			s.Draft.Reset()
			if err := s.Draft.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestSimpleBase) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("label")
	e.Str(s.Label)

	e.FieldStart("ref")
	e.Str(s.Ref)

	e.FieldStart("repo")
	s.Repo.Encode(e)

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("user")
	s.User.Encode(e)
	e.ObjEnd()
}

// Decode decodes PullRequestSimpleBase from json.
func (s *PullRequestSimpleBase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestSimpleBase to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			v, err := d.Str()
			s.Label = string(v)
			if err != nil {
				return err
			}
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "repo":
			if err := s.Repo.Decode(d); err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestSimpleHead) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("label")
	e.Str(s.Label)

	e.FieldStart("ref")
	e.Str(s.Ref)

	e.FieldStart("repo")
	s.Repo.Encode(e)

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("user")
	s.User.Encode(e)
	e.ObjEnd()
}

// Decode decodes PullRequestSimpleHead from json.
func (s *PullRequestSimpleHead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestSimpleHead to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			v, err := d.Str()
			s.Label = string(v)
			if err != nil {
				return err
			}
		case "ref":
			v, err := d.Str()
			s.Ref = string(v)
			if err != nil {
				return err
			}
		case "repo":
			if err := s.Repo.Decode(d); err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestSimpleLabelsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.Color.Set {
		e.FieldStart("color")
		s.Color.Encode(e)
	}
	if s.Default.Set {
		e.FieldStart("default")
		s.Default.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullRequestSimpleLabelsItem from json.
func (s *PullRequestSimpleLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestSimpleLabelsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "color":
			s.Color.Reset()
			if err := s.Color.Decode(d); err != nil {
				return err
			}
		case "default":
			s.Default.Reset()
			if err := s.Default.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullRequestSimpleLinks) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("comments")
	s.Comments.Encode(e)

	e.FieldStart("commits")
	s.Commits.Encode(e)

	e.FieldStart("statuses")
	s.Statuses.Encode(e)

	e.FieldStart("html")
	s.HTML.Encode(e)

	e.FieldStart("issue")
	s.Issue.Encode(e)

	e.FieldStart("review_comments")
	s.ReviewComments.Encode(e)

	e.FieldStart("review_comment")
	s.ReviewComment.Encode(e)

	e.FieldStart("self")
	s.Self.Encode(e)
	e.ObjEnd()
}

// Decode decodes PullRequestSimpleLinks from json.
func (s *PullRequestSimpleLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestSimpleLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "comments":
			if err := s.Comments.Decode(d); err != nil {
				return err
			}
		case "commits":
			if err := s.Commits.Decode(d); err != nil {
				return err
			}
		case "statuses":
			if err := s.Statuses.Decode(d); err != nil {
				return err
			}
		case "html":
			if err := s.HTML.Decode(d); err != nil {
				return err
			}
		case "issue":
			if err := s.Issue.Decode(d); err != nil {
				return err
			}
		case "review_comments":
			if err := s.ReviewComments.Decode(d); err != nil {
				return err
			}
		case "review_comment":
			if err := s.ReviewComment.Decode(d); err != nil {
				return err
			}
		case "self":
			if err := s.Self.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullRequestState as json.
func (s PullRequestState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullRequestState from json.
func (s *PullRequestState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullRequestState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PullRequestState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s PullsCheckIfMergedNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes PullsCheckIfMergedNoContent from json.
func (s *PullsCheckIfMergedNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCheckIfMergedNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsCheckIfMergedNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes PullsCheckIfMergedNotFound from json.
func (s *PullsCheckIfMergedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCheckIfMergedNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsCreateReplyForReviewCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("body")
	e.Str(s.Body)
	e.ObjEnd()
}

// Decode decodes PullsCreateReplyForReviewCommentReq from json.
func (s *PullsCreateReplyForReviewCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCreateReplyForReviewCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsCreateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Title.Set {
		e.FieldStart("title")
		s.Title.Encode(e)
	}

	e.FieldStart("head")
	e.Str(s.Head)

	e.FieldStart("base")
	e.Str(s.Base)
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	if s.MaintainerCanModify.Set {
		e.FieldStart("maintainer_can_modify")
		s.MaintainerCanModify.Encode(e)
	}
	if s.Draft.Set {
		e.FieldStart("draft")
		s.Draft.Encode(e)
	}
	if s.Issue.Set {
		e.FieldStart("issue")
		s.Issue.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullsCreateReq from json.
func (s *PullsCreateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCreateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "head":
			v, err := d.Str()
			s.Head = string(v)
			if err != nil {
				return err
			}
		case "base":
			v, err := d.Str()
			s.Base = string(v)
			if err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "maintainer_can_modify":
			s.MaintainerCanModify.Reset()
			if err := s.MaintainerCanModify.Decode(d); err != nil {
				return err
			}
		case "draft":
			s.Draft.Reset()
			if err := s.Draft.Decode(d); err != nil {
				return err
			}
		case "issue":
			s.Issue.Reset()
			if err := s.Issue.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsCreateReviewCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("body")
	e.Str(s.Body)
	if s.CommitID.Set {
		e.FieldStart("commit_id")
		s.CommitID.Encode(e)
	}
	if s.Path.Set {
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	if s.Position.Set {
		e.FieldStart("position")
		s.Position.Encode(e)
	}
	if s.Side.Set {
		e.FieldStart("side")
		s.Side.Encode(e)
	}
	if s.Line.Set {
		e.FieldStart("line")
		s.Line.Encode(e)
	}
	if s.StartLine.Set {
		e.FieldStart("start_line")
		s.StartLine.Encode(e)
	}
	if s.StartSide.Set {
		e.FieldStart("start_side")
		s.StartSide.Encode(e)
	}
	if s.InReplyTo.Set {
		e.FieldStart("in_reply_to")
		s.InReplyTo.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullsCreateReviewCommentReq from json.
func (s *PullsCreateReviewCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCreateReviewCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "commit_id":
			s.CommitID.Reset()
			if err := s.CommitID.Decode(d); err != nil {
				return err
			}
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "position":
			s.Position.Reset()
			if err := s.Position.Decode(d); err != nil {
				return err
			}
		case "side":
			s.Side.Reset()
			if err := s.Side.Decode(d); err != nil {
				return err
			}
		case "line":
			s.Line.Reset()
			if err := s.Line.Decode(d); err != nil {
				return err
			}
		case "start_line":
			s.StartLine.Reset()
			if err := s.StartLine.Decode(d); err != nil {
				return err
			}
		case "start_side":
			s.StartSide.Reset()
			if err := s.StartSide.Decode(d); err != nil {
				return err
			}
		case "in_reply_to":
			s.InReplyTo.Reset()
			if err := s.InReplyTo.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullsCreateReviewCommentReqSide as json.
func (s PullsCreateReviewCommentReqSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsCreateReviewCommentReqSide from json.
func (s *PullsCreateReviewCommentReqSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCreateReviewCommentReqSide to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PullsCreateReviewCommentReqSide(v)
	return nil
}

// Encode encodes PullsCreateReviewCommentReqStartSide as json.
func (s PullsCreateReviewCommentReqStartSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsCreateReviewCommentReqStartSide from json.
func (s *PullsCreateReviewCommentReqStartSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCreateReviewCommentReqStartSide to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PullsCreateReviewCommentReqStartSide(v)
	return nil
}

// Encode implements json.Marshaler.
func (s PullsCreateReviewReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.CommitID.Set {
		e.FieldStart("commit_id")
		s.CommitID.Encode(e)
	}
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	if s.Event.Set {
		e.FieldStart("event")
		s.Event.Encode(e)
	}
	if s.Comments != nil {
		e.FieldStart("comments")
		e.ArrStart()
		for _, elem := range s.Comments {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes PullsCreateReviewReq from json.
func (s *PullsCreateReviewReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCreateReviewReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commit_id":
			s.CommitID.Reset()
			if err := s.CommitID.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "event":
			s.Event.Reset()
			if err := s.Event.Decode(d); err != nil {
				return err
			}
		case "comments":
			s.Comments = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PullsCreateReviewReqCommentsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Comments = append(s.Comments, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsCreateReviewReqCommentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("path")
	e.Str(s.Path)
	if s.Position.Set {
		e.FieldStart("position")
		s.Position.Encode(e)
	}

	e.FieldStart("body")
	e.Str(s.Body)
	if s.Line.Set {
		e.FieldStart("line")
		s.Line.Encode(e)
	}
	if s.Side.Set {
		e.FieldStart("side")
		s.Side.Encode(e)
	}
	if s.StartLine.Set {
		e.FieldStart("start_line")
		s.StartLine.Encode(e)
	}
	if s.StartSide.Set {
		e.FieldStart("start_side")
		s.StartSide.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullsCreateReviewReqCommentsItem from json.
func (s *PullsCreateReviewReqCommentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCreateReviewReqCommentsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "position":
			s.Position.Reset()
			if err := s.Position.Decode(d); err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "line":
			s.Line.Reset()
			if err := s.Line.Decode(d); err != nil {
				return err
			}
		case "side":
			s.Side.Reset()
			if err := s.Side.Decode(d); err != nil {
				return err
			}
		case "start_line":
			s.StartLine.Reset()
			if err := s.StartLine.Decode(d); err != nil {
				return err
			}
		case "start_side":
			s.StartSide.Reset()
			if err := s.StartSide.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullsCreateReviewReqEvent as json.
func (s PullsCreateReviewReqEvent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsCreateReviewReqEvent from json.
func (s *PullsCreateReviewReqEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsCreateReviewReqEvent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PullsCreateReviewReqEvent(v)
	return nil
}

// Encode implements json.Marshaler.
func (s PullsDeleteReviewCommentNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes PullsDeleteReviewCommentNoContent from json.
func (s *PullsDeleteReviewCommentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsDeleteReviewCommentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsDismissReviewReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("message")
	e.Str(s.Message)
	if s.Event.Set {
		e.FieldStart("event")
		s.Event.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullsDismissReviewReq from json.
func (s *PullsDismissReviewReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsDismissReviewReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "event":
			s.Event.Reset()
			if err := s.Event.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullsGetApplicationJSONInternalServerError as json.
func (s PullsGetApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PullsGetApplicationJSONInternalServerError from json.
func (s *PullsGetApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsGetApplicationJSONInternalServerError to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsGetApplicationJSONInternalServerError(unwrapped)
	return nil
}

// Encode encodes PullsGetApplicationJSONNotFound as json.
func (s PullsGetApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PullsGetApplicationJSONNotFound from json.
func (s *PullsGetApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsGetApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsGetApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes PullsListCommentsForReviewOKApplicationJSON as json.
func (s PullsListCommentsForReviewOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ReviewComment(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes PullsListCommentsForReviewOKApplicationJSON from json.
func (s *PullsListCommentsForReviewOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListCommentsForReviewOKApplicationJSON to nil`)
	}
	var unwrapped []ReviewComment
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ReviewComment
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsListCommentsForReviewOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes PullsListDirection as json.
func (s PullsListDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsListDirection from json.
func (s *PullsListDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PullsListDirection(v)
	return nil
}

// Encode encodes PullsListReviewCommentsDirection as json.
func (s PullsListReviewCommentsDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsListReviewCommentsDirection from json.
func (s *PullsListReviewCommentsDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListReviewCommentsDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PullsListReviewCommentsDirection(v)
	return nil
}

// Encode encodes PullsListReviewCommentsForRepoDirection as json.
func (s PullsListReviewCommentsForRepoDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsListReviewCommentsForRepoDirection from json.
func (s *PullsListReviewCommentsForRepoDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListReviewCommentsForRepoDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PullsListReviewCommentsForRepoDirection(v)
	return nil
}

// Encode encodes PullsListReviewCommentsForRepoSort as json.
func (s PullsListReviewCommentsForRepoSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsListReviewCommentsForRepoSort from json.
func (s *PullsListReviewCommentsForRepoSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListReviewCommentsForRepoSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PullsListReviewCommentsForRepoSort(v)
	return nil
}

// Encode encodes PullsListReviewCommentsSort as json.
func (s PullsListReviewCommentsSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsListReviewCommentsSort from json.
func (s *PullsListReviewCommentsSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListReviewCommentsSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PullsListReviewCommentsSort(v)
	return nil
}

// Encode encodes PullsListSort as json.
func (s PullsListSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsListSort from json.
func (s *PullsListSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PullsListSort(v)
	return nil
}

// Encode encodes PullsListState as json.
func (s PullsListState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsListState from json.
func (s *PullsListState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsListState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PullsListState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s PullsMergeConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.DocumentationURL.Set {
		e.FieldStart("documentation_url")
		s.DocumentationURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullsMergeConflict from json.
func (s *PullsMergeConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsMergeConflict to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsMergeMethodNotAllowed) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.DocumentationURL.Set {
		e.FieldStart("documentation_url")
		s.DocumentationURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullsMergeMethodNotAllowed from json.
func (s *PullsMergeMethodNotAllowed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsMergeMethodNotAllowed to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsMergeReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.CommitTitle.Set {
		e.FieldStart("commit_title")
		s.CommitTitle.Encode(e)
	}
	if s.CommitMessage.Set {
		e.FieldStart("commit_message")
		s.CommitMessage.Encode(e)
	}
	if s.Sha.Set {
		e.FieldStart("sha")
		s.Sha.Encode(e)
	}
	if s.MergeMethod.Set {
		e.FieldStart("merge_method")
		s.MergeMethod.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullsMergeReq from json.
func (s *PullsMergeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsMergeReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "commit_title":
			s.CommitTitle.Reset()
			if err := s.CommitTitle.Decode(d); err != nil {
				return err
			}
		case "commit_message":
			s.CommitMessage.Reset()
			if err := s.CommitMessage.Decode(d); err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		case "merge_method":
			s.MergeMethod.Reset()
			if err := s.MergeMethod.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullsMergeReqMergeMethod as json.
func (s PullsMergeReqMergeMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsMergeReqMergeMethod from json.
func (s *PullsMergeReqMergeMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsMergeReqMergeMethod to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PullsMergeReqMergeMethod(v)
	return nil
}

// Encode implements json.Marshaler.
func (s PullsRemoveRequestedReviewersReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("reviewers")
	e.ArrStart()
	for _, elem := range s.Reviewers {
		e.Str(elem)
	}
	e.ArrEnd()
	if s.TeamReviewers != nil {
		e.FieldStart("team_reviewers")
		e.ArrStart()
		for _, elem := range s.TeamReviewers {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes PullsRemoveRequestedReviewersReq from json.
func (s *PullsRemoveRequestedReviewersReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsRemoveRequestedReviewersReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reviewers":
			s.Reviewers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Reviewers = append(s.Reviewers, elem)
				return nil
			}); err != nil {
				return err
			}
		case "team_reviewers":
			s.TeamReviewers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.TeamReviewers = append(s.TeamReviewers, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullsSubmitReviewApplicationJSONForbidden as json.
func (s PullsSubmitReviewApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PullsSubmitReviewApplicationJSONForbidden from json.
func (s *PullsSubmitReviewApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsSubmitReviewApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsSubmitReviewApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes PullsSubmitReviewApplicationJSONNotFound as json.
func (s PullsSubmitReviewApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes PullsSubmitReviewApplicationJSONNotFound from json.
func (s *PullsSubmitReviewApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsSubmitReviewApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PullsSubmitReviewApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s PullsSubmitReviewReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}

	e.FieldStart("event")
	s.Event.Encode(e)
	e.ObjEnd()
}

// Decode decodes PullsSubmitReviewReq from json.
func (s *PullsSubmitReviewReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsSubmitReviewReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "event":
			if err := s.Event.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullsSubmitReviewReqEvent as json.
func (s PullsSubmitReviewReqEvent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsSubmitReviewReqEvent from json.
func (s *PullsSubmitReviewReqEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsSubmitReviewReqEvent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PullsSubmitReviewReqEvent(v)
	return nil
}

// Encode implements json.Marshaler.
func (s PullsUpdateBranchAccepted) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullsUpdateBranchAccepted from json.
func (s *PullsUpdateBranchAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsUpdateBranchAccepted to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsUpdateBranchReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ExpectedHeadSha.Set {
		e.FieldStart("expected_head_sha")
		s.ExpectedHeadSha.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullsUpdateBranchReq from json.
func (s *PullsUpdateBranchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsUpdateBranchReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "expected_head_sha":
			s.ExpectedHeadSha.Reset()
			if err := s.ExpectedHeadSha.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsUpdateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Title.Set {
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	if s.State.Set {
		e.FieldStart("state")
		s.State.Encode(e)
	}
	if s.Base.Set {
		e.FieldStart("base")
		s.Base.Encode(e)
	}
	if s.MaintainerCanModify.Set {
		e.FieldStart("maintainer_can_modify")
		s.MaintainerCanModify.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes PullsUpdateReq from json.
func (s *PullsUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsUpdateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "base":
			s.Base.Reset()
			if err := s.Base.Decode(d); err != nil {
				return err
			}
		case "maintainer_can_modify":
			s.MaintainerCanModify.Reset()
			if err := s.MaintainerCanModify.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes PullsUpdateReqState as json.
func (s PullsUpdateReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PullsUpdateReqState from json.
func (s *PullsUpdateReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsUpdateReqState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = PullsUpdateReqState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s PullsUpdateReviewCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("body")
	e.Str(s.Body)
	e.ObjEnd()
}

// Decode decodes PullsUpdateReviewCommentReq from json.
func (s *PullsUpdateReviewCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsUpdateReviewCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s PullsUpdateReviewReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("body")
	e.Str(s.Body)
	e.ObjEnd()
}

// Decode decodes PullsUpdateReviewReq from json.
func (s *PullsUpdateReviewReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode PullsUpdateReviewReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RateLimit) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("limit")
	e.Int(s.Limit)

	e.FieldStart("remaining")
	e.Int(s.Remaining)

	e.FieldStart("reset")
	e.Int(s.Reset)

	e.FieldStart("used")
	e.Int(s.Used)
	e.ObjEnd()
}

// Decode decodes RateLimit from json.
func (s *RateLimit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RateLimit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			v, err := d.Int()
			s.Limit = int(v)
			if err != nil {
				return err
			}
		case "remaining":
			v, err := d.Int()
			s.Remaining = int(v)
			if err != nil {
				return err
			}
		case "reset":
			v, err := d.Int()
			s.Reset = int(v)
			if err != nil {
				return err
			}
		case "used":
			v, err := d.Int()
			s.Used = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RateLimitOverview) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("resources")
	s.Resources.Encode(e)

	e.FieldStart("rate")
	s.Rate.Encode(e)
	e.ObjEnd()
}

// Decode decodes RateLimitOverview from json.
func (s *RateLimitOverview) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RateLimitOverview to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resources":
			if err := s.Resources.Decode(d); err != nil {
				return err
			}
		case "rate":
			if err := s.Rate.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RateLimitOverviewResources) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("core")
	s.Core.Encode(e)
	if s.Graphql.Set {
		e.FieldStart("graphql")
		s.Graphql.Encode(e)
	}

	e.FieldStart("search")
	s.Search.Encode(e)
	if s.SourceImport.Set {
		e.FieldStart("source_import")
		s.SourceImport.Encode(e)
	}
	if s.IntegrationManifest.Set {
		e.FieldStart("integration_manifest")
		s.IntegrationManifest.Encode(e)
	}
	if s.CodeScanningUpload.Set {
		e.FieldStart("code_scanning_upload")
		s.CodeScanningUpload.Encode(e)
	}
	if s.ActionsRunnerRegistration.Set {
		e.FieldStart("actions_runner_registration")
		s.ActionsRunnerRegistration.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes RateLimitOverviewResources from json.
func (s *RateLimitOverviewResources) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RateLimitOverviewResources to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "core":
			if err := s.Core.Decode(d); err != nil {
				return err
			}
		case "graphql":
			s.Graphql.Reset()
			if err := s.Graphql.Decode(d); err != nil {
				return err
			}
		case "search":
			if err := s.Search.Decode(d); err != nil {
				return err
			}
		case "source_import":
			s.SourceImport.Reset()
			if err := s.SourceImport.Decode(d); err != nil {
				return err
			}
		case "integration_manifest":
			s.IntegrationManifest.Reset()
			if err := s.IntegrationManifest.Decode(d); err != nil {
				return err
			}
		case "code_scanning_upload":
			s.CodeScanningUpload.Reset()
			if err := s.CodeScanningUpload.Decode(d); err != nil {
				return err
			}
		case "actions_runner_registration":
			s.ActionsRunnerRegistration.Reset()
			if err := s.ActionsRunnerRegistration.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Reaction) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("user")
	s.User.Encode(e)

	e.FieldStart("content")
	s.Content.Encode(e)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)
	e.ObjEnd()
}

// Decode decodes Reaction from json.
func (s *Reaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Reaction to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionContent as json.
func (s ReactionContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionContent from json.
func (s *ReactionContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionContent(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionRollup) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("+1")
	e.Int(s.Plus1)

	e.FieldStart("-1")
	e.Int(s.Minus1)

	e.FieldStart("laugh")
	e.Int(s.Laugh)

	e.FieldStart("confused")
	e.Int(s.Confused)

	e.FieldStart("heart")
	e.Int(s.Heart)

	e.FieldStart("hooray")
	e.Int(s.Hooray)

	e.FieldStart("eyes")
	e.Int(s.Eyes)

	e.FieldStart("rocket")
	e.Int(s.Rocket)
	e.ObjEnd()
}

// Decode decodes ReactionRollup from json.
func (s *ReactionRollup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionRollup to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "+1":
			v, err := d.Int()
			s.Plus1 = int(v)
			if err != nil {
				return err
			}
		case "-1":
			v, err := d.Int()
			s.Minus1 = int(v)
			if err != nil {
				return err
			}
		case "laugh":
			v, err := d.Int()
			s.Laugh = int(v)
			if err != nil {
				return err
			}
		case "confused":
			v, err := d.Int()
			s.Confused = int(v)
			if err != nil {
				return err
			}
		case "heart":
			v, err := d.Int()
			s.Heart = int(v)
			if err != nil {
				return err
			}
		case "hooray":
			v, err := d.Int()
			s.Hooray = int(v)
			if err != nil {
				return err
			}
		case "eyes":
			v, err := d.Int()
			s.Eyes = int(v)
			if err != nil {
				return err
			}
		case "rocket":
			v, err := d.Int()
			s.Rocket = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForCommitCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("content")
	s.Content.Encode(e)
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForCommitCommentReq from json.
func (s *ReactionsCreateForCommitCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForCommitCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForCommitCommentReqContent as json.
func (s ReactionsCreateForCommitCommentReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForCommitCommentReqContent from json.
func (s *ReactionsCreateForCommitCommentReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForCommitCommentReqContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsCreateForCommitCommentReqContent(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForIssueCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("content")
	s.Content.Encode(e)
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForIssueCommentReq from json.
func (s *ReactionsCreateForIssueCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForIssueCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForIssueCommentReqContent as json.
func (s ReactionsCreateForIssueCommentReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForIssueCommentReqContent from json.
func (s *ReactionsCreateForIssueCommentReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForIssueCommentReqContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsCreateForIssueCommentReqContent(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForIssueReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("content")
	s.Content.Encode(e)
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForIssueReq from json.
func (s *ReactionsCreateForIssueReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForIssueReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForIssueReqContent as json.
func (s ReactionsCreateForIssueReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForIssueReqContent from json.
func (s *ReactionsCreateForIssueReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForIssueReqContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsCreateForIssueReqContent(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForPullRequestReviewCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("content")
	s.Content.Encode(e)
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForPullRequestReviewCommentReq from json.
func (s *ReactionsCreateForPullRequestReviewCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForPullRequestReviewCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForPullRequestReviewCommentReqContent as json.
func (s ReactionsCreateForPullRequestReviewCommentReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForPullRequestReviewCommentReqContent from json.
func (s *ReactionsCreateForPullRequestReviewCommentReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForPullRequestReviewCommentReqContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsCreateForPullRequestReviewCommentReqContent(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForReleaseReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("content")
	s.Content.Encode(e)
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForReleaseReq from json.
func (s *ReactionsCreateForReleaseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForReleaseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForReleaseReqContent as json.
func (s ReactionsCreateForReleaseReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForReleaseReqContent from json.
func (s *ReactionsCreateForReleaseReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForReleaseReqContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsCreateForReleaseReqContent(v)
	return nil
}

// Encode encodes ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated as json.
func (s ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated) Encode(e *jx.Encoder) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated from json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK as json.
func (s ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK) Encode(e *jx.Encoder) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK from json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForTeamDiscussionCommentInOrgApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForTeamDiscussionCommentInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("content")
	s.Content.Encode(e)
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentInOrgReq from json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionCommentInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForTeamDiscussionCommentInOrgReqContent as json.
func (s ReactionsCreateForTeamDiscussionCommentInOrgReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentInOrgReqContent from json.
func (s *ReactionsCreateForTeamDiscussionCommentInOrgReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionCommentInOrgReqContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsCreateForTeamDiscussionCommentInOrgReqContent(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForTeamDiscussionCommentLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("content")
	s.Content.Encode(e)
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentLegacyReq from json.
func (s *ReactionsCreateForTeamDiscussionCommentLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionCommentLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForTeamDiscussionCommentLegacyReqContent as json.
func (s ReactionsCreateForTeamDiscussionCommentLegacyReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForTeamDiscussionCommentLegacyReqContent from json.
func (s *ReactionsCreateForTeamDiscussionCommentLegacyReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionCommentLegacyReqContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsCreateForTeamDiscussionCommentLegacyReqContent(v)
	return nil
}

// Encode encodes ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated as json.
func (s ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated) Encode(e *jx.Encoder) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated from json.
func (s *ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForTeamDiscussionInOrgApplicationJSONCreated(unwrapped)
	return nil
}

// Encode encodes ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK as json.
func (s ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK) Encode(e *jx.Encoder) {
	unwrapped := Reaction(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK from json.
func (s *ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK to nil`)
	}
	var unwrapped Reaction
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsCreateForTeamDiscussionInOrgApplicationJSONOK(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForTeamDiscussionInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("content")
	s.Content.Encode(e)
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForTeamDiscussionInOrgReq from json.
func (s *ReactionsCreateForTeamDiscussionInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForTeamDiscussionInOrgReqContent as json.
func (s ReactionsCreateForTeamDiscussionInOrgReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForTeamDiscussionInOrgReqContent from json.
func (s *ReactionsCreateForTeamDiscussionInOrgReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionInOrgReqContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsCreateForTeamDiscussionInOrgReqContent(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsCreateForTeamDiscussionLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("content")
	s.Content.Encode(e)
	e.ObjEnd()
}

// Decode decodes ReactionsCreateForTeamDiscussionLegacyReq from json.
func (s *ReactionsCreateForTeamDiscussionLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := s.Content.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsCreateForTeamDiscussionLegacyReqContent as json.
func (s ReactionsCreateForTeamDiscussionLegacyReqContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsCreateForTeamDiscussionLegacyReqContent from json.
func (s *ReactionsCreateForTeamDiscussionLegacyReqContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsCreateForTeamDiscussionLegacyReqContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsCreateForTeamDiscussionLegacyReqContent(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsDeleteForCommitCommentNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReactionsDeleteForCommitCommentNoContent from json.
func (s *ReactionsDeleteForCommitCommentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteForCommitCommentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReactionsDeleteForIssueCommentNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReactionsDeleteForIssueCommentNoContent from json.
func (s *ReactionsDeleteForIssueCommentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteForIssueCommentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReactionsDeleteForIssueNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReactionsDeleteForIssueNoContent from json.
func (s *ReactionsDeleteForIssueNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteForIssueNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReactionsDeleteForPullRequestCommentNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReactionsDeleteForPullRequestCommentNoContent from json.
func (s *ReactionsDeleteForPullRequestCommentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteForPullRequestCommentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReactionsDeleteForTeamDiscussionCommentNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReactionsDeleteForTeamDiscussionCommentNoContent from json.
func (s *ReactionsDeleteForTeamDiscussionCommentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteForTeamDiscussionCommentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReactionsDeleteForTeamDiscussionNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReactionsDeleteForTeamDiscussionNoContent from json.
func (s *ReactionsDeleteForTeamDiscussionNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteForTeamDiscussionNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsDeleteLegacyApplicationJSONForbidden as json.
func (s ReactionsDeleteLegacyApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsDeleteLegacyApplicationJSONForbidden from json.
func (s *ReactionsDeleteLegacyApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteLegacyApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsDeleteLegacyApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReactionsDeleteLegacyApplicationJSONGone as json.
func (s ReactionsDeleteLegacyApplicationJSONGone) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsDeleteLegacyApplicationJSONGone from json.
func (s *ReactionsDeleteLegacyApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteLegacyApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsDeleteLegacyApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ReactionsDeleteLegacyApplicationJSONUnauthorized as json.
func (s ReactionsDeleteLegacyApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsDeleteLegacyApplicationJSONUnauthorized from json.
func (s *ReactionsDeleteLegacyApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteLegacyApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsDeleteLegacyApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReactionsDeleteLegacyNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReactionsDeleteLegacyNoContent from json.
func (s *ReactionsDeleteLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsDeleteLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReactionsListForCommitCommentContent as json.
func (s ReactionsListForCommitCommentContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsListForCommitCommentContent from json.
func (s *ReactionsListForCommitCommentContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForCommitCommentContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsListForCommitCommentContent(v)
	return nil
}

// Encode encodes ReactionsListForCommitCommentOKApplicationJSON as json.
func (s ReactionsListForCommitCommentOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Reaction(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReactionsListForCommitCommentOKApplicationJSON from json.
func (s *ReactionsListForCommitCommentOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForCommitCommentOKApplicationJSON to nil`)
	}
	var unwrapped []Reaction
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Reaction
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForCommitCommentOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReactionsListForIssueApplicationJSONGone as json.
func (s ReactionsListForIssueApplicationJSONGone) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsListForIssueApplicationJSONGone from json.
func (s *ReactionsListForIssueApplicationJSONGone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForIssueApplicationJSONGone to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForIssueApplicationJSONGone(unwrapped)
	return nil
}

// Encode encodes ReactionsListForIssueApplicationJSONNotFound as json.
func (s ReactionsListForIssueApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReactionsListForIssueApplicationJSONNotFound from json.
func (s *ReactionsListForIssueApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForIssueApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForIssueApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReactionsListForIssueCommentContent as json.
func (s ReactionsListForIssueCommentContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsListForIssueCommentContent from json.
func (s *ReactionsListForIssueCommentContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForIssueCommentContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsListForIssueCommentContent(v)
	return nil
}

// Encode encodes ReactionsListForIssueCommentOKApplicationJSON as json.
func (s ReactionsListForIssueCommentOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Reaction(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReactionsListForIssueCommentOKApplicationJSON from json.
func (s *ReactionsListForIssueCommentOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForIssueCommentOKApplicationJSON to nil`)
	}
	var unwrapped []Reaction
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Reaction
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForIssueCommentOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReactionsListForIssueContent as json.
func (s ReactionsListForIssueContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsListForIssueContent from json.
func (s *ReactionsListForIssueContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForIssueContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsListForIssueContent(v)
	return nil
}

// Encode encodes ReactionsListForIssueOKApplicationJSON as json.
func (s ReactionsListForIssueOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Reaction(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReactionsListForIssueOKApplicationJSON from json.
func (s *ReactionsListForIssueOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForIssueOKApplicationJSON to nil`)
	}
	var unwrapped []Reaction
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Reaction
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForIssueOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReactionsListForPullRequestReviewCommentContent as json.
func (s ReactionsListForPullRequestReviewCommentContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsListForPullRequestReviewCommentContent from json.
func (s *ReactionsListForPullRequestReviewCommentContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForPullRequestReviewCommentContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsListForPullRequestReviewCommentContent(v)
	return nil
}

// Encode encodes ReactionsListForPullRequestReviewCommentOKApplicationJSON as json.
func (s ReactionsListForPullRequestReviewCommentOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Reaction(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReactionsListForPullRequestReviewCommentOKApplicationJSON from json.
func (s *ReactionsListForPullRequestReviewCommentOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForPullRequestReviewCommentOKApplicationJSON to nil`)
	}
	var unwrapped []Reaction
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Reaction
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReactionsListForPullRequestReviewCommentOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReactionsListForTeamDiscussionCommentInOrgContent as json.
func (s ReactionsListForTeamDiscussionCommentInOrgContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsListForTeamDiscussionCommentInOrgContent from json.
func (s *ReactionsListForTeamDiscussionCommentInOrgContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForTeamDiscussionCommentInOrgContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsListForTeamDiscussionCommentInOrgContent(v)
	return nil
}

// Encode encodes ReactionsListForTeamDiscussionCommentLegacyContent as json.
func (s ReactionsListForTeamDiscussionCommentLegacyContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsListForTeamDiscussionCommentLegacyContent from json.
func (s *ReactionsListForTeamDiscussionCommentLegacyContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForTeamDiscussionCommentLegacyContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsListForTeamDiscussionCommentLegacyContent(v)
	return nil
}

// Encode encodes ReactionsListForTeamDiscussionInOrgContent as json.
func (s ReactionsListForTeamDiscussionInOrgContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsListForTeamDiscussionInOrgContent from json.
func (s *ReactionsListForTeamDiscussionInOrgContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForTeamDiscussionInOrgContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsListForTeamDiscussionInOrgContent(v)
	return nil
}

// Encode encodes ReactionsListForTeamDiscussionLegacyContent as json.
func (s ReactionsListForTeamDiscussionLegacyContent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReactionsListForTeamDiscussionLegacyContent from json.
func (s *ReactionsListForTeamDiscussionLegacyContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReactionsListForTeamDiscussionLegacyContent to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReactionsListForTeamDiscussionLegacyContent(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ReferrerTraffic) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("referrer")
	e.Str(s.Referrer)

	e.FieldStart("count")
	e.Int(s.Count)

	e.FieldStart("uniques")
	e.Int(s.Uniques)
	e.ObjEnd()
}

// Decode decodes ReferrerTraffic from json.
func (s *ReferrerTraffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReferrerTraffic to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referrer":
			v, err := d.Str()
			s.Referrer = string(v)
			if err != nil {
				return err
			}
		case "count":
			v, err := d.Int()
			s.Count = int(v)
			if err != nil {
				return err
			}
		case "uniques":
			v, err := d.Int()
			s.Uniques = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Release) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("assets_url")
	json.EncodeURI(e, s.AssetsURL)

	e.FieldStart("upload_url")
	e.Str(s.UploadURL)

	e.FieldStart("tarball_url")
	s.TarballURL.Encode(e)

	e.FieldStart("zipball_url")
	s.ZipballURL.Encode(e)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("tag_name")
	e.Str(s.TagName)

	e.FieldStart("target_commitish")
	e.Str(s.TargetCommitish)

	e.FieldStart("name")
	s.Name.Encode(e)
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}

	e.FieldStart("draft")
	e.Bool(s.Draft)

	e.FieldStart("prerelease")
	e.Bool(s.Prerelease)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("published_at")
	s.PublishedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("author")
	s.Author.Encode(e)

	e.FieldStart("assets")
	e.ArrStart()
	for _, elem := range s.Assets {
		elem.Encode(e)
	}
	e.ArrEnd()
	if s.BodyHTML.Set {
		e.FieldStart("body_html")
		s.BodyHTML.Encode(e)
	}
	if s.BodyText.Set {
		e.FieldStart("body_text")
		s.BodyText.Encode(e)
	}
	if s.MentionsCount.Set {
		e.FieldStart("mentions_count")
		s.MentionsCount.Encode(e)
	}
	if s.DiscussionURL.Set {
		e.FieldStart("discussion_url")
		s.DiscussionURL.Encode(e)
	}
	if s.Reactions.Set {
		e.FieldStart("reactions")
		s.Reactions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Release from json.
func (s *Release) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Release to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "assets_url":
			v, err := json.DecodeURI(d)
			s.AssetsURL = v
			if err != nil {
				return err
			}
		case "upload_url":
			v, err := d.Str()
			s.UploadURL = string(v)
			if err != nil {
				return err
			}
		case "tarball_url":
			if err := s.TarballURL.Decode(d); err != nil {
				return err
			}
		case "zipball_url":
			if err := s.ZipballURL.Decode(d); err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "tag_name":
			v, err := d.Str()
			s.TagName = string(v)
			if err != nil {
				return err
			}
		case "target_commitish":
			v, err := d.Str()
			s.TargetCommitish = string(v)
			if err != nil {
				return err
			}
		case "name":
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "draft":
			v, err := d.Bool()
			s.Draft = bool(v)
			if err != nil {
				return err
			}
		case "prerelease":
			v, err := d.Bool()
			s.Prerelease = bool(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "published_at":
			if err := s.PublishedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "assets":
			s.Assets = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ReleaseAsset
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Assets = append(s.Assets, elem)
				return nil
			}); err != nil {
				return err
			}
		case "body_html":
			s.BodyHTML.Reset()
			if err := s.BodyHTML.Decode(d); err != nil {
				return err
			}
		case "body_text":
			s.BodyText.Reset()
			if err := s.BodyText.Decode(d); err != nil {
				return err
			}
		case "mentions_count":
			s.MentionsCount.Reset()
			if err := s.MentionsCount.Decode(d); err != nil {
				return err
			}
		case "discussion_url":
			s.DiscussionURL.Reset()
			if err := s.DiscussionURL.Decode(d); err != nil {
				return err
			}
		case "reactions":
			s.Reactions.Reset()
			if err := s.Reactions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReleaseAsset) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("browser_download_url")
	json.EncodeURI(e, s.BrowserDownloadURL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("label")
	s.Label.Encode(e)

	e.FieldStart("state")
	s.State.Encode(e)

	e.FieldStart("content_type")
	e.Str(s.ContentType)

	e.FieldStart("size")
	e.Int(s.Size)

	e.FieldStart("download_count")
	e.Int(s.DownloadCount)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("uploader")
	s.Uploader.Encode(e)
	e.ObjEnd()
}

// Decode decodes ReleaseAsset from json.
func (s *ReleaseAsset) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReleaseAsset to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "browser_download_url":
			v, err := json.DecodeURI(d)
			s.BrowserDownloadURL = v
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "label":
			if err := s.Label.Decode(d); err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "content_type":
			v, err := d.Str()
			s.ContentType = string(v)
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "download_count":
			v, err := d.Int()
			s.DownloadCount = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "uploader":
			if err := s.Uploader.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReleaseAssetState as json.
func (s ReleaseAssetState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReleaseAssetState from json.
func (s *ReleaseAssetState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReleaseAssetState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReleaseAssetState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s RepoSearchResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("full_name")
	e.Str(s.FullName)

	e.FieldStart("owner")
	s.Owner.Encode(e)

	e.FieldStart("private")
	e.Bool(s.Private)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("fork")
	e.Bool(s.Fork)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("pushed_at")
	json.EncodeDateTime(e, s.PushedAt)

	e.FieldStart("homepage")
	s.Homepage.Encode(e)

	e.FieldStart("size")
	e.Int(s.Size)

	e.FieldStart("stargazers_count")
	e.Int(s.StargazersCount)

	e.FieldStart("watchers_count")
	e.Int(s.WatchersCount)

	e.FieldStart("language")
	s.Language.Encode(e)

	e.FieldStart("forks_count")
	e.Int(s.ForksCount)

	e.FieldStart("open_issues_count")
	e.Int(s.OpenIssuesCount)
	if s.MasterBranch.Set {
		e.FieldStart("master_branch")
		s.MasterBranch.Encode(e)
	}

	e.FieldStart("default_branch")
	e.Str(s.DefaultBranch)

	e.FieldStart("score")
	e.Float64(s.Score)

	e.FieldStart("forks_url")
	json.EncodeURI(e, s.ForksURL)

	e.FieldStart("keys_url")
	e.Str(s.KeysURL)

	e.FieldStart("collaborators_url")
	e.Str(s.CollaboratorsURL)

	e.FieldStart("teams_url")
	json.EncodeURI(e, s.TeamsURL)

	e.FieldStart("hooks_url")
	json.EncodeURI(e, s.HooksURL)

	e.FieldStart("issue_events_url")
	e.Str(s.IssueEventsURL)

	e.FieldStart("events_url")
	json.EncodeURI(e, s.EventsURL)

	e.FieldStart("assignees_url")
	e.Str(s.AssigneesURL)

	e.FieldStart("branches_url")
	e.Str(s.BranchesURL)

	e.FieldStart("tags_url")
	json.EncodeURI(e, s.TagsURL)

	e.FieldStart("blobs_url")
	e.Str(s.BlobsURL)

	e.FieldStart("git_tags_url")
	e.Str(s.GitTagsURL)

	e.FieldStart("git_refs_url")
	e.Str(s.GitRefsURL)

	e.FieldStart("trees_url")
	e.Str(s.TreesURL)

	e.FieldStart("statuses_url")
	e.Str(s.StatusesURL)

	e.FieldStart("languages_url")
	json.EncodeURI(e, s.LanguagesURL)

	e.FieldStart("stargazers_url")
	json.EncodeURI(e, s.StargazersURL)

	e.FieldStart("contributors_url")
	json.EncodeURI(e, s.ContributorsURL)

	e.FieldStart("subscribers_url")
	json.EncodeURI(e, s.SubscribersURL)

	e.FieldStart("subscription_url")
	json.EncodeURI(e, s.SubscriptionURL)

	e.FieldStart("commits_url")
	e.Str(s.CommitsURL)

	e.FieldStart("git_commits_url")
	e.Str(s.GitCommitsURL)

	e.FieldStart("comments_url")
	e.Str(s.CommentsURL)

	e.FieldStart("issue_comment_url")
	e.Str(s.IssueCommentURL)

	e.FieldStart("contents_url")
	e.Str(s.ContentsURL)

	e.FieldStart("compare_url")
	e.Str(s.CompareURL)

	e.FieldStart("merges_url")
	json.EncodeURI(e, s.MergesURL)

	e.FieldStart("archive_url")
	e.Str(s.ArchiveURL)

	e.FieldStart("downloads_url")
	json.EncodeURI(e, s.DownloadsURL)

	e.FieldStart("issues_url")
	e.Str(s.IssuesURL)

	e.FieldStart("pulls_url")
	e.Str(s.PullsURL)

	e.FieldStart("milestones_url")
	e.Str(s.MilestonesURL)

	e.FieldStart("notifications_url")
	e.Str(s.NotificationsURL)

	e.FieldStart("labels_url")
	e.Str(s.LabelsURL)

	e.FieldStart("releases_url")
	e.Str(s.ReleasesURL)

	e.FieldStart("deployments_url")
	json.EncodeURI(e, s.DeploymentsURL)

	e.FieldStart("git_url")
	e.Str(s.GitURL)

	e.FieldStart("ssh_url")
	e.Str(s.SSHURL)

	e.FieldStart("clone_url")
	e.Str(s.CloneURL)

	e.FieldStart("svn_url")
	json.EncodeURI(e, s.SvnURL)

	e.FieldStart("forks")
	e.Int(s.Forks)

	e.FieldStart("open_issues")
	e.Int(s.OpenIssues)

	e.FieldStart("watchers")
	e.Int(s.Watchers)
	if s.Topics != nil {
		e.FieldStart("topics")
		e.ArrStart()
		for _, elem := range s.Topics {
			e.Str(elem)
		}
		e.ArrEnd()
	}

	e.FieldStart("mirror_url")
	s.MirrorURL.Encode(e)

	e.FieldStart("has_issues")
	e.Bool(s.HasIssues)

	e.FieldStart("has_projects")
	e.Bool(s.HasProjects)

	e.FieldStart("has_pages")
	e.Bool(s.HasPages)

	e.FieldStart("has_wiki")
	e.Bool(s.HasWiki)

	e.FieldStart("has_downloads")
	e.Bool(s.HasDownloads)

	e.FieldStart("archived")
	e.Bool(s.Archived)

	e.FieldStart("disabled")
	e.Bool(s.Disabled)

	e.FieldStart("license")
	s.License.Encode(e)
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	if s.TextMatches != nil {
		e.FieldStart("text_matches")
		s.TextMatches.Encode(e)
	}
	if s.TempCloneToken.Set {
		e.FieldStart("temp_clone_token")
		s.TempCloneToken.Encode(e)
	}
	if s.AllowMergeCommit.Set {
		e.FieldStart("allow_merge_commit")
		s.AllowMergeCommit.Encode(e)
	}
	if s.AllowSquashMerge.Set {
		e.FieldStart("allow_squash_merge")
		s.AllowSquashMerge.Encode(e)
	}
	if s.AllowRebaseMerge.Set {
		e.FieldStart("allow_rebase_merge")
		s.AllowRebaseMerge.Encode(e)
	}
	if s.AllowAutoMerge.Set {
		e.FieldStart("allow_auto_merge")
		s.AllowAutoMerge.Encode(e)
	}
	if s.DeleteBranchOnMerge.Set {
		e.FieldStart("delete_branch_on_merge")
		s.DeleteBranchOnMerge.Encode(e)
	}
	if s.AllowForking.Set {
		e.FieldStart("allow_forking")
		s.AllowForking.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes RepoSearchResultItem from json.
func (s *RepoSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepoSearchResultItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "pushed_at":
			v, err := json.DecodeDateTime(d)
			s.PushedAt = v
			if err != nil {
				return err
			}
		case "homepage":
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "stargazers_count":
			v, err := d.Int()
			s.StargazersCount = int(v)
			if err != nil {
				return err
			}
		case "watchers_count":
			v, err := d.Int()
			s.WatchersCount = int(v)
			if err != nil {
				return err
			}
		case "language":
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			v, err := d.Int()
			s.ForksCount = int(v)
			if err != nil {
				return err
			}
		case "open_issues_count":
			v, err := d.Int()
			s.OpenIssuesCount = int(v)
			if err != nil {
				return err
			}
		case "master_branch":
			s.MasterBranch.Reset()
			if err := s.MasterBranch.Decode(d); err != nil {
				return err
			}
		case "default_branch":
			v, err := d.Str()
			s.DefaultBranch = string(v)
			if err != nil {
				return err
			}
		case "score":
			v, err := d.Float64()
			s.Score = float64(v)
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "git_url":
			v, err := d.Str()
			s.GitURL = string(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			v, err := d.Str()
			s.SSHURL = string(v)
			if err != nil {
				return err
			}
		case "clone_url":
			v, err := d.Str()
			s.CloneURL = string(v)
			if err != nil {
				return err
			}
		case "svn_url":
			v, err := json.DecodeURI(d)
			s.SvnURL = v
			if err != nil {
				return err
			}
		case "forks":
			v, err := d.Int()
			s.Forks = int(v)
			if err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "watchers":
			v, err := d.Int()
			s.Watchers = int(v)
			if err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "mirror_url":
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "has_issues":
			v, err := d.Bool()
			s.HasIssues = bool(v)
			if err != nil {
				return err
			}
		case "has_projects":
			v, err := d.Bool()
			s.HasProjects = bool(v)
			if err != nil {
				return err
			}
		case "has_pages":
			v, err := d.Bool()
			s.HasPages = bool(v)
			if err != nil {
				return err
			}
		case "has_wiki":
			v, err := d.Bool()
			s.HasWiki = bool(v)
			if err != nil {
				return err
			}
		case "has_downloads":
			v, err := d.Bool()
			s.HasDownloads = bool(v)
			if err != nil {
				return err
			}
		case "archived":
			v, err := d.Bool()
			s.Archived = bool(v)
			if err != nil {
				return err
			}
		case "disabled":
			v, err := d.Bool()
			s.Disabled = bool(v)
			if err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "text_matches":
			s.TextMatches = nil
			var elem SearchResultTextMatches
			{
				var unwrapped []SearchResultTextMatchesItem
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultTextMatchesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = SearchResultTextMatches(unwrapped)
			}
			s.TextMatches = &elem
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RepoSearchResultItemPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("admin")
	e.Bool(s.Admin)
	if s.Maintain.Set {
		e.FieldStart("maintain")
		s.Maintain.Encode(e)
	}

	e.FieldStart("push")
	e.Bool(s.Push)
	if s.Triage.Set {
		e.FieldStart("triage")
		s.Triage.Encode(e)
	}

	e.FieldStart("pull")
	e.Bool(s.Pull)
	e.ObjEnd()
}

// Decode decodes RepoSearchResultItemPermissions from json.
func (s *RepoSearchResultItemPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepoSearchResultItemPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposAcceptInvitationApplicationJSONConflict as json.
func (s ReposAcceptInvitationApplicationJSONConflict) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposAcceptInvitationApplicationJSONConflict from json.
func (s *ReposAcceptInvitationApplicationJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAcceptInvitationApplicationJSONConflict to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAcceptInvitationApplicationJSONConflict(unwrapped)
	return nil
}

// Encode encodes ReposAcceptInvitationApplicationJSONForbidden as json.
func (s ReposAcceptInvitationApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposAcceptInvitationApplicationJSONForbidden from json.
func (s *ReposAcceptInvitationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAcceptInvitationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAcceptInvitationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposAcceptInvitationApplicationJSONNotFound as json.
func (s ReposAcceptInvitationApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposAcceptInvitationApplicationJSONNotFound from json.
func (s *ReposAcceptInvitationApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAcceptInvitationApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposAcceptInvitationApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposAcceptInvitationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposAcceptInvitationNoContent from json.
func (s *ReposAcceptInvitationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAcceptInvitationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposAddCollaboratorNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposAddCollaboratorNoContent from json.
func (s *ReposAddCollaboratorNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddCollaboratorNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposAddCollaboratorReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Permission.Set {
		e.FieldStart("permission")
		s.Permission.Encode(e)
	}
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposAddCollaboratorReq from json.
func (s *ReposAddCollaboratorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddCollaboratorReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposAddCollaboratorReqPermission as json.
func (s ReposAddCollaboratorReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposAddCollaboratorReqPermission from json.
func (s *ReposAddCollaboratorReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposAddCollaboratorReqPermission to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposAddCollaboratorReqPermission(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCheckCollaboratorNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposCheckCollaboratorNoContent from json.
func (s *ReposCheckCollaboratorNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCheckCollaboratorNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCheckCollaboratorNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposCheckCollaboratorNotFound from json.
func (s *ReposCheckCollaboratorNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCheckCollaboratorNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCheckVulnerabilityAlertsNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposCheckVulnerabilityAlertsNoContent from json.
func (s *ReposCheckVulnerabilityAlertsNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCheckVulnerabilityAlertsNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCheckVulnerabilityAlertsNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposCheckVulnerabilityAlertsNotFound from json.
func (s *ReposCheckVulnerabilityAlertsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCheckVulnerabilityAlertsNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposCompareCommitsApplicationJSONInternalServerError as json.
func (s ReposCompareCommitsApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCompareCommitsApplicationJSONInternalServerError from json.
func (s *ReposCompareCommitsApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCompareCommitsApplicationJSONInternalServerError to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCompareCommitsApplicationJSONInternalServerError(unwrapped)
	return nil
}

// Encode encodes ReposCompareCommitsApplicationJSONNotFound as json.
func (s ReposCompareCommitsApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposCompareCommitsApplicationJSONNotFound from json.
func (s *ReposCompareCommitsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCompareCommitsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposCompareCommitsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateAutolinkReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("key_prefix")
	e.Str(s.KeyPrefix)

	e.FieldStart("url_template")
	e.Str(s.URLTemplate)
	e.ObjEnd()
}

// Decode decodes ReposCreateAutolinkReq from json.
func (s *ReposCreateAutolinkReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateAutolinkReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key_prefix":
			v, err := d.Str()
			s.KeyPrefix = string(v)
			if err != nil {
				return err
			}
		case "url_template":
			v, err := d.Str()
			s.URLTemplate = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateCommitCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("body")
	e.Str(s.Body)
	if s.Path.Set {
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	if s.Position.Set {
		e.FieldStart("position")
		s.Position.Encode(e)
	}
	if s.Line.Set {
		e.FieldStart("line")
		s.Line.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateCommitCommentReq from json.
func (s *ReposCreateCommitCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateCommitCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		case "position":
			s.Position.Reset()
			if err := s.Position.Decode(d); err != nil {
				return err
			}
		case "line":
			s.Line.Reset()
			if err := s.Line.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateCommitStatusReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("state")
	s.State.Encode(e)
	if s.TargetURL.Set {
		e.FieldStart("target_url")
		s.TargetURL.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.Context.Set {
		e.FieldStart("context")
		s.Context.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateCommitStatusReq from json.
func (s *ReposCreateCommitStatusReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateCommitStatusReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "target_url":
			s.TargetURL.Reset()
			if err := s.TargetURL.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "context":
			s.Context.Reset()
			if err := s.Context.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposCreateCommitStatusReqState as json.
func (s ReposCreateCommitStatusReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposCreateCommitStatusReqState from json.
func (s *ReposCreateCommitStatusReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateCommitStatusReqState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposCreateCommitStatusReqState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateDeployKeyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Title.Set {
		e.FieldStart("title")
		s.Title.Encode(e)
	}

	e.FieldStart("key")
	e.Str(s.Key)
	if s.ReadOnly.Set {
		e.FieldStart("read_only")
		s.ReadOnly.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateDeployKeyReq from json.
func (s *ReposCreateDeployKeyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDeployKeyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		case "read_only":
			s.ReadOnly.Reset()
			if err := s.ReadOnly.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateDeploymentStatusReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("state")
	s.State.Encode(e)
	if s.TargetURL.Set {
		e.FieldStart("target_url")
		s.TargetURL.Encode(e)
	}
	if s.LogURL.Set {
		e.FieldStart("log_url")
		s.LogURL.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.Environment.Set {
		e.FieldStart("environment")
		s.Environment.Encode(e)
	}
	if s.EnvironmentURL.Set {
		e.FieldStart("environment_url")
		s.EnvironmentURL.Encode(e)
	}
	if s.AutoInactive.Set {
		e.FieldStart("auto_inactive")
		s.AutoInactive.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateDeploymentStatusReq from json.
func (s *ReposCreateDeploymentStatusReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDeploymentStatusReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "target_url":
			s.TargetURL.Reset()
			if err := s.TargetURL.Decode(d); err != nil {
				return err
			}
		case "log_url":
			s.LogURL.Reset()
			if err := s.LogURL.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "environment":
			s.Environment.Reset()
			if err := s.Environment.Decode(d); err != nil {
				return err
			}
		case "environment_url":
			s.EnvironmentURL.Reset()
			if err := s.EnvironmentURL.Decode(d); err != nil {
				return err
			}
		case "auto_inactive":
			s.AutoInactive.Reset()
			if err := s.AutoInactive.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposCreateDeploymentStatusReqEnvironment as json.
func (s ReposCreateDeploymentStatusReqEnvironment) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposCreateDeploymentStatusReqEnvironment from json.
func (s *ReposCreateDeploymentStatusReqEnvironment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDeploymentStatusReqEnvironment to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposCreateDeploymentStatusReqEnvironment(v)
	return nil
}

// Encode encodes ReposCreateDeploymentStatusReqState as json.
func (s ReposCreateDeploymentStatusReqState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposCreateDeploymentStatusReqState from json.
func (s *ReposCreateDeploymentStatusReqState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDeploymentStatusReqState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposCreateDeploymentStatusReqState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateDispatchEventNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposCreateDispatchEventNoContent from json.
func (s *ReposCreateDispatchEventNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDispatchEventNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateDispatchEventReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("event_type")
	e.Str(s.EventType)
	if s.ClientPayload != nil {
		e.FieldStart("client_payload")
		s.ClientPayload.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateDispatchEventReq from json.
func (s *ReposCreateDispatchEventReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDispatchEventReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			v, err := d.Str()
			s.EventType = string(v)
			if err != nil {
				return err
			}
		case "client_payload":
			s.ClientPayload = nil
			var elem ReposCreateDispatchEventReqClientPayload
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.ClientPayload = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateDispatchEventReqClientPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposCreateDispatchEventReqClientPayload from json.
func (s *ReposCreateDispatchEventReqClientPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateDispatchEventReqClientPayload to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateForAuthenticatedUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.Homepage.Set {
		e.FieldStart("homepage")
		s.Homepage.Encode(e)
	}
	if s.Private.Set {
		e.FieldStart("private")
		s.Private.Encode(e)
	}
	if s.HasIssues.Set {
		e.FieldStart("has_issues")
		s.HasIssues.Encode(e)
	}
	if s.HasProjects.Set {
		e.FieldStart("has_projects")
		s.HasProjects.Encode(e)
	}
	if s.HasWiki.Set {
		e.FieldStart("has_wiki")
		s.HasWiki.Encode(e)
	}
	if s.TeamID.Set {
		e.FieldStart("team_id")
		s.TeamID.Encode(e)
	}
	if s.AutoInit.Set {
		e.FieldStart("auto_init")
		s.AutoInit.Encode(e)
	}
	if s.GitignoreTemplate.Set {
		e.FieldStart("gitignore_template")
		s.GitignoreTemplate.Encode(e)
	}
	if s.LicenseTemplate.Set {
		e.FieldStart("license_template")
		s.LicenseTemplate.Encode(e)
	}
	if s.AllowSquashMerge.Set {
		e.FieldStart("allow_squash_merge")
		s.AllowSquashMerge.Encode(e)
	}
	if s.AllowMergeCommit.Set {
		e.FieldStart("allow_merge_commit")
		s.AllowMergeCommit.Encode(e)
	}
	if s.AllowRebaseMerge.Set {
		e.FieldStart("allow_rebase_merge")
		s.AllowRebaseMerge.Encode(e)
	}
	if s.AllowAutoMerge.Set {
		e.FieldStart("allow_auto_merge")
		s.AllowAutoMerge.Encode(e)
	}
	if s.DeleteBranchOnMerge.Set {
		e.FieldStart("delete_branch_on_merge")
		s.DeleteBranchOnMerge.Encode(e)
	}
	if s.HasDownloads.Set {
		e.FieldStart("has_downloads")
		s.HasDownloads.Encode(e)
	}
	if s.IsTemplate.Set {
		e.FieldStart("is_template")
		s.IsTemplate.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateForAuthenticatedUserReq from json.
func (s *ReposCreateForAuthenticatedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateForAuthenticatedUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "homepage":
			s.Homepage.Reset()
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		case "has_issues":
			s.HasIssues.Reset()
			if err := s.HasIssues.Decode(d); err != nil {
				return err
			}
		case "has_projects":
			s.HasProjects.Reset()
			if err := s.HasProjects.Decode(d); err != nil {
				return err
			}
		case "has_wiki":
			s.HasWiki.Reset()
			if err := s.HasWiki.Decode(d); err != nil {
				return err
			}
		case "team_id":
			s.TeamID.Reset()
			if err := s.TeamID.Decode(d); err != nil {
				return err
			}
		case "auto_init":
			s.AutoInit.Reset()
			if err := s.AutoInit.Decode(d); err != nil {
				return err
			}
		case "gitignore_template":
			s.GitignoreTemplate.Reset()
			if err := s.GitignoreTemplate.Decode(d); err != nil {
				return err
			}
		case "license_template":
			s.LicenseTemplate.Reset()
			if err := s.LicenseTemplate.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "has_downloads":
			s.HasDownloads.Reset()
			if err := s.HasDownloads.Decode(d); err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateForkReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Organization.Set {
		e.FieldStart("organization")
		s.Organization.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateForkReq from json.
func (s *ReposCreateForkReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateForkReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "organization":
			s.Organization.Reset()
			if err := s.Organization.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.Homepage.Set {
		e.FieldStart("homepage")
		s.Homepage.Encode(e)
	}
	if s.Private.Set {
		e.FieldStart("private")
		s.Private.Encode(e)
	}
	if s.Visibility.Set {
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
	if s.HasIssues.Set {
		e.FieldStart("has_issues")
		s.HasIssues.Encode(e)
	}
	if s.HasProjects.Set {
		e.FieldStart("has_projects")
		s.HasProjects.Encode(e)
	}
	if s.HasWiki.Set {
		e.FieldStart("has_wiki")
		s.HasWiki.Encode(e)
	}
	if s.IsTemplate.Set {
		e.FieldStart("is_template")
		s.IsTemplate.Encode(e)
	}
	if s.TeamID.Set {
		e.FieldStart("team_id")
		s.TeamID.Encode(e)
	}
	if s.AutoInit.Set {
		e.FieldStart("auto_init")
		s.AutoInit.Encode(e)
	}
	if s.GitignoreTemplate.Set {
		e.FieldStart("gitignore_template")
		s.GitignoreTemplate.Encode(e)
	}
	if s.LicenseTemplate.Set {
		e.FieldStart("license_template")
		s.LicenseTemplate.Encode(e)
	}
	if s.AllowSquashMerge.Set {
		e.FieldStart("allow_squash_merge")
		s.AllowSquashMerge.Encode(e)
	}
	if s.AllowMergeCommit.Set {
		e.FieldStart("allow_merge_commit")
		s.AllowMergeCommit.Encode(e)
	}
	if s.AllowRebaseMerge.Set {
		e.FieldStart("allow_rebase_merge")
		s.AllowRebaseMerge.Encode(e)
	}
	if s.AllowAutoMerge.Set {
		e.FieldStart("allow_auto_merge")
		s.AllowAutoMerge.Encode(e)
	}
	if s.DeleteBranchOnMerge.Set {
		e.FieldStart("delete_branch_on_merge")
		s.DeleteBranchOnMerge.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateInOrgReq from json.
func (s *ReposCreateInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "homepage":
			s.Homepage.Reset()
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "has_issues":
			s.HasIssues.Reset()
			if err := s.HasIssues.Decode(d); err != nil {
				return err
			}
		case "has_projects":
			s.HasProjects.Reset()
			if err := s.HasProjects.Decode(d); err != nil {
				return err
			}
		case "has_wiki":
			s.HasWiki.Reset()
			if err := s.HasWiki.Decode(d); err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "team_id":
			s.TeamID.Reset()
			if err := s.TeamID.Decode(d); err != nil {
				return err
			}
		case "auto_init":
			s.AutoInit.Reset()
			if err := s.AutoInit.Decode(d); err != nil {
				return err
			}
		case "gitignore_template":
			s.GitignoreTemplate.Reset()
			if err := s.GitignoreTemplate.Decode(d); err != nil {
				return err
			}
		case "license_template":
			s.LicenseTemplate.Reset()
			if err := s.LicenseTemplate.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposCreateInOrgReqVisibility as json.
func (s ReposCreateInOrgReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposCreateInOrgReqVisibility from json.
func (s *ReposCreateInOrgReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateInOrgReqVisibility to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposCreateInOrgReqVisibility(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateOrUpdateEnvironmentReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.WaitTimer.Set {
		e.FieldStart("wait_timer")
		s.WaitTimer.Encode(e)
	}
	if s.Reviewers.Set {
		e.FieldStart("reviewers")
		s.Reviewers.Encode(e)
	}
	if s.DeploymentBranchPolicy.Set {
		e.FieldStart("deployment_branch_policy")
		s.DeploymentBranchPolicy.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateOrUpdateEnvironmentReq from json.
func (s *ReposCreateOrUpdateEnvironmentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateOrUpdateEnvironmentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "wait_timer":
			s.WaitTimer.Reset()
			if err := s.WaitTimer.Decode(d); err != nil {
				return err
			}
		case "reviewers":
			s.Reviewers.Reset()
			if err := s.Reviewers.Decode(d); err != nil {
				return err
			}
		case "deployment_branch_policy":
			s.DeploymentBranchPolicy.Reset()
			if err := s.DeploymentBranchPolicy.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateOrUpdateEnvironmentReqReviewersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Type.Set {
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateOrUpdateEnvironmentReqReviewersItem from json.
func (s *ReposCreateOrUpdateEnvironmentReqReviewersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateOrUpdateEnvironmentReqReviewersItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateOrUpdateFileContentsReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("message")
	e.Str(s.Message)

	e.FieldStart("content")
	e.Str(s.Content)
	if s.Sha.Set {
		e.FieldStart("sha")
		s.Sha.Encode(e)
	}
	if s.Branch.Set {
		e.FieldStart("branch")
		s.Branch.Encode(e)
	}
	if s.Committer.Set {
		e.FieldStart("committer")
		s.Committer.Encode(e)
	}
	if s.Author.Set {
		e.FieldStart("author")
		s.Author.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateOrUpdateFileContentsReq from json.
func (s *ReposCreateOrUpdateFileContentsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateOrUpdateFileContentsReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "content":
			v, err := d.Str()
			s.Content = string(v)
			if err != nil {
				return err
			}
		case "sha":
			s.Sha.Reset()
			if err := s.Sha.Decode(d); err != nil {
				return err
			}
		case "branch":
			s.Branch.Reset()
			if err := s.Branch.Decode(d); err != nil {
				return err
			}
		case "committer":
			s.Committer.Reset()
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "author":
			s.Author.Reset()
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateOrUpdateFileContentsReqAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("email")
	e.Str(s.Email)
	if s.Date.Set {
		e.FieldStart("date")
		s.Date.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateOrUpdateFileContentsReqAuthor from json.
func (s *ReposCreateOrUpdateFileContentsReqAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateOrUpdateFileContentsReqAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "date":
			s.Date.Reset()
			if err := s.Date.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateOrUpdateFileContentsReqCommitter) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("email")
	e.Str(s.Email)
	if s.Date.Set {
		e.FieldStart("date")
		s.Date.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateOrUpdateFileContentsReqCommitter from json.
func (s *ReposCreateOrUpdateFileContentsReqCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateOrUpdateFileContentsReqCommitter to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		case "date":
			s.Date.Reset()
			if err := s.Date.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreatePagesSiteReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("source")
	s.Source.Encode(e)
	e.ObjEnd()
}

// Decode decodes ReposCreatePagesSiteReq from json.
func (s *ReposCreatePagesSiteReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreatePagesSiteReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			if err := s.Source.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreatePagesSiteReqSource) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("branch")
	e.Str(s.Branch)
	if s.Path.Set {
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreatePagesSiteReqSource from json.
func (s *ReposCreatePagesSiteReqSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreatePagesSiteReqSource to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "branch":
			v, err := d.Str()
			s.Branch = string(v)
			if err != nil {
				return err
			}
		case "path":
			s.Path.Reset()
			if err := s.Path.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposCreatePagesSiteReqSourcePath as json.
func (s ReposCreatePagesSiteReqSourcePath) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposCreatePagesSiteReqSourcePath from json.
func (s *ReposCreatePagesSiteReqSourcePath) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreatePagesSiteReqSourcePath to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposCreatePagesSiteReqSourcePath(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposCreateReleaseReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("tag_name")
	e.Str(s.TagName)
	if s.TargetCommitish.Set {
		e.FieldStart("target_commitish")
		s.TargetCommitish.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	if s.Draft.Set {
		e.FieldStart("draft")
		s.Draft.Encode(e)
	}
	if s.Prerelease.Set {
		e.FieldStart("prerelease")
		s.Prerelease.Encode(e)
	}
	if s.DiscussionCategoryName.Set {
		e.FieldStart("discussion_category_name")
		s.DiscussionCategoryName.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateReleaseReq from json.
func (s *ReposCreateReleaseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateReleaseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag_name":
			v, err := d.Str()
			s.TagName = string(v)
			if err != nil {
				return err
			}
		case "target_commitish":
			s.TargetCommitish.Reset()
			if err := s.TargetCommitish.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "draft":
			s.Draft.Reset()
			if err := s.Draft.Decode(d); err != nil {
				return err
			}
		case "prerelease":
			s.Prerelease.Reset()
			if err := s.Prerelease.Decode(d); err != nil {
				return err
			}
		case "discussion_category_name":
			s.DiscussionCategoryName.Reset()
			if err := s.DiscussionCategoryName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateUsingTemplateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Owner.Set {
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}

	e.FieldStart("name")
	e.Str(s.Name)
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.IncludeAllBranches.Set {
		e.FieldStart("include_all_branches")
		s.IncludeAllBranches.Encode(e)
	}
	if s.Private.Set {
		e.FieldStart("private")
		s.Private.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateUsingTemplateReq from json.
func (s *ReposCreateUsingTemplateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateUsingTemplateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "owner":
			s.Owner.Reset()
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "include_all_branches":
			s.IncludeAllBranches.Reset()
			if err := s.IncludeAllBranches.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateWebhookReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Config.Set {
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	if s.Events != nil {
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Active.Set {
		e.FieldStart("active")
		s.Active.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateWebhookReq from json.
func (s *ReposCreateWebhookReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateWebhookReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "config":
			s.Config.Reset()
			if err := s.Config.Decode(d); err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposCreateWebhookReqConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.ContentType.Set {
		e.FieldStart("content_type")
		s.ContentType.Encode(e)
	}
	if s.Secret.Set {
		e.FieldStart("secret")
		s.Secret.Encode(e)
	}
	if s.InsecureSsl != nil {
		e.FieldStart("insecure_ssl")
		s.InsecureSsl.Encode(e)
	}
	if s.Token.Set {
		e.FieldStart("token")
		s.Token.Encode(e)
	}
	if s.Digest.Set {
		e.FieldStart("digest")
		s.Digest.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposCreateWebhookReqConfig from json.
func (s *ReposCreateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposCreateWebhookReqConfig to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl = nil
			var elem WebhookConfigInsecureSsl
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.InsecureSsl = &elem
		case "token":
			s.Token.Reset()
			if err := s.Token.Decode(d); err != nil {
				return err
			}
		case "digest":
			s.Digest.Reset()
			if err := s.Digest.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposDeclineInvitationApplicationJSONConflict as json.
func (s ReposDeclineInvitationApplicationJSONConflict) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeclineInvitationApplicationJSONConflict from json.
func (s *ReposDeclineInvitationApplicationJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeclineInvitationApplicationJSONConflict to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeclineInvitationApplicationJSONConflict(unwrapped)
	return nil
}

// Encode encodes ReposDeclineInvitationApplicationJSONForbidden as json.
func (s ReposDeclineInvitationApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeclineInvitationApplicationJSONForbidden from json.
func (s *ReposDeclineInvitationApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeclineInvitationApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeclineInvitationApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposDeclineInvitationApplicationJSONNotFound as json.
func (s ReposDeclineInvitationApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeclineInvitationApplicationJSONNotFound from json.
func (s *ReposDeclineInvitationApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeclineInvitationApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeclineInvitationApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposDeclineInvitationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeclineInvitationNoContent from json.
func (s *ReposDeclineInvitationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeclineInvitationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteAccessRestrictionsNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeleteAccessRestrictionsNoContent from json.
func (s *ReposDeleteAccessRestrictionsNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteAccessRestrictionsNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteAdminBranchProtectionNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeleteAdminBranchProtectionNoContent from json.
func (s *ReposDeleteAdminBranchProtectionNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteAdminBranchProtectionNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteAnEnvironmentNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeleteAnEnvironmentNoContent from json.
func (s *ReposDeleteAnEnvironmentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteAnEnvironmentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposDeleteApplicationJSONNotFound as json.
func (s ReposDeleteApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeleteApplicationJSONNotFound from json.
func (s *ReposDeleteApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeleteApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposDeleteApplicationJSONTemporaryRedirect as json.
func (s ReposDeleteApplicationJSONTemporaryRedirect) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposDeleteApplicationJSONTemporaryRedirect from json.
func (s *ReposDeleteApplicationJSONTemporaryRedirect) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteApplicationJSONTemporaryRedirect to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposDeleteApplicationJSONTemporaryRedirect(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposDeleteAutolinkNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeleteAutolinkNoContent from json.
func (s *ReposDeleteAutolinkNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteAutolinkNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteBranchProtectionNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeleteBranchProtectionNoContent from json.
func (s *ReposDeleteBranchProtectionNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteBranchProtectionNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteCommitCommentNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeleteCommitCommentNoContent from json.
func (s *ReposDeleteCommitCommentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteCommitCommentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteCommitSignatureProtectionNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeleteCommitSignatureProtectionNoContent from json.
func (s *ReposDeleteCommitSignatureProtectionNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteCommitSignatureProtectionNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteDeployKeyNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeleteDeployKeyNoContent from json.
func (s *ReposDeleteDeployKeyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteDeployKeyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteDeploymentNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeleteDeploymentNoContent from json.
func (s *ReposDeleteDeploymentNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteDeploymentNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteFileReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("message")
	e.Str(s.Message)

	e.FieldStart("sha")
	e.Str(s.Sha)
	if s.Branch.Set {
		e.FieldStart("branch")
		s.Branch.Encode(e)
	}
	if s.Committer.Set {
		e.FieldStart("committer")
		s.Committer.Encode(e)
	}
	if s.Author.Set {
		e.FieldStart("author")
		s.Author.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposDeleteFileReq from json.
func (s *ReposDeleteFileReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteFileReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "branch":
			s.Branch.Reset()
			if err := s.Branch.Decode(d); err != nil {
				return err
			}
		case "committer":
			s.Committer.Reset()
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		case "author":
			s.Author.Reset()
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteFileReqAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposDeleteFileReqAuthor from json.
func (s *ReposDeleteFileReqAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteFileReqAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteFileReqCommitter) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposDeleteFileReqCommitter from json.
func (s *ReposDeleteFileReqCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteFileReqCommitter to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.DocumentationURL.Set {
		e.FieldStart("documentation_url")
		s.DocumentationURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposDeleteForbidden from json.
func (s *ReposDeleteForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteInvitationNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeleteInvitationNoContent from json.
func (s *ReposDeleteInvitationNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteInvitationNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeleteNoContent from json.
func (s *ReposDeleteNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeletePagesSiteNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeletePagesSiteNoContent from json.
func (s *ReposDeletePagesSiteNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeletePagesSiteNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeletePullRequestReviewProtectionNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeletePullRequestReviewProtectionNoContent from json.
func (s *ReposDeletePullRequestReviewProtectionNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeletePullRequestReviewProtectionNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteReleaseAssetNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeleteReleaseAssetNoContent from json.
func (s *ReposDeleteReleaseAssetNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteReleaseAssetNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteReleaseNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeleteReleaseNoContent from json.
func (s *ReposDeleteReleaseNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteReleaseNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDeleteWebhookNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDeleteWebhookNoContent from json.
func (s *ReposDeleteWebhookNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDeleteWebhookNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDisableAutomatedSecurityFixesNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDisableAutomatedSecurityFixesNoContent from json.
func (s *ReposDisableAutomatedSecurityFixesNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDisableAutomatedSecurityFixesNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDisableLfsForRepoNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDisableLfsForRepoNoContent from json.
func (s *ReposDisableLfsForRepoNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDisableLfsForRepoNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDisableVulnerabilityAlertsNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDisableVulnerabilityAlertsNoContent from json.
func (s *ReposDisableVulnerabilityAlertsNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDisableVulnerabilityAlertsNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDownloadTarballArchiveFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDownloadTarballArchiveFound from json.
func (s *ReposDownloadTarballArchiveFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDownloadTarballArchiveFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposDownloadZipballArchiveFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposDownloadZipballArchiveFound from json.
func (s *ReposDownloadZipballArchiveFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposDownloadZipballArchiveFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposEnableAutomatedSecurityFixesNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposEnableAutomatedSecurityFixesNoContent from json.
func (s *ReposEnableAutomatedSecurityFixesNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposEnableAutomatedSecurityFixesNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposEnableLfsForRepoForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposEnableLfsForRepoForbidden from json.
func (s *ReposEnableLfsForRepoForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposEnableLfsForRepoForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposEnableVulnerabilityAlertsNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposEnableVulnerabilityAlertsNoContent from json.
func (s *ReposEnableVulnerabilityAlertsNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposEnableVulnerabilityAlertsNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposGetAllStatusCheckContextsOKApplicationJSON as json.
func (s ReposGetAllStatusCheckContextsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetAllStatusCheckContextsOKApplicationJSON from json.
func (s *ReposGetAllStatusCheckContextsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetAllStatusCheckContextsOKApplicationJSON to nil`)
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetAllStatusCheckContextsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetApplicationJSONForbidden as json.
func (s ReposGetApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetApplicationJSONForbidden from json.
func (s *ReposGetApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposGetApplicationJSONMovedPermanently as json.
func (s ReposGetApplicationJSONMovedPermanently) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetApplicationJSONMovedPermanently from json.
func (s *ReposGetApplicationJSONMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetApplicationJSONMovedPermanently to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetApplicationJSONMovedPermanently(unwrapped)
	return nil
}

// Encode encodes ReposGetApplicationJSONNotFound as json.
func (s ReposGetApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetApplicationJSONNotFound from json.
func (s *ReposGetApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON as json.
func (s ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Integration(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON from json.
func (s *ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON to nil`)
	}
	var unwrapped []Integration
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Integration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetAppsWithAccessToProtectedBranchOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetBranchApplicationJSONMovedPermanently as json.
func (s ReposGetBranchApplicationJSONMovedPermanently) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetBranchApplicationJSONMovedPermanently from json.
func (s *ReposGetBranchApplicationJSONMovedPermanently) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetBranchApplicationJSONMovedPermanently to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetBranchApplicationJSONMovedPermanently(unwrapped)
	return nil
}

// Encode encodes ReposGetBranchApplicationJSONNotFound as json.
func (s ReposGetBranchApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposGetBranchApplicationJSONNotFound from json.
func (s *ReposGetBranchApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetBranchApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetBranchApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposGetClonesPer as json.
func (s ReposGetClonesPer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposGetClonesPer from json.
func (s *ReposGetClonesPer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetClonesPer to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposGetClonesPer(v)
	return nil
}

// Encode encodes ReposGetCodeFrequencyStatsOKApplicationJSON as json.
func (s ReposGetCodeFrequencyStatsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CodeFrequencyStat(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetCodeFrequencyStatsOKApplicationJSON from json.
func (s *ReposGetCodeFrequencyStatsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetCodeFrequencyStatsOKApplicationJSON to nil`)
	}
	var unwrapped []CodeFrequencyStat
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeFrequencyStat
			{
				var unwrapped []int
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = CodeFrequencyStat(unwrapped)
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetCodeFrequencyStatsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetCommitActivityStatsOKApplicationJSON as json.
func (s ReposGetCommitActivityStatsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CommitActivity(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetCommitActivityStatsOKApplicationJSON from json.
func (s *ReposGetCommitActivityStatsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetCommitActivityStatsOKApplicationJSON to nil`)
	}
	var unwrapped []CommitActivity
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CommitActivity
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetCommitActivityStatsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetContributorsStatsOKApplicationJSON as json.
func (s ReposGetContributorsStatsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ContributorActivity(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetContributorsStatsOKApplicationJSON from json.
func (s *ReposGetContributorsStatsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetContributorsStatsOKApplicationJSON to nil`)
	}
	var unwrapped []ContributorActivity
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ContributorActivity
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetContributorsStatsOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposGetPagesHealthCheckBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposGetPagesHealthCheckBadRequest from json.
func (s *ReposGetPagesHealthCheckBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetPagesHealthCheckBadRequest to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposGetPagesHealthCheckUnprocessableEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposGetPagesHealthCheckUnprocessableEntity from json.
func (s *ReposGetPagesHealthCheckUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetPagesHealthCheckUnprocessableEntity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposGetPunchCardStatsOKApplicationJSON as json.
func (s ReposGetPunchCardStatsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CodeFrequencyStat(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetPunchCardStatsOKApplicationJSON from json.
func (s *ReposGetPunchCardStatsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetPunchCardStatsOKApplicationJSON to nil`)
	}
	var unwrapped []CodeFrequencyStat
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CodeFrequencyStat
			{
				var unwrapped []int
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = CodeFrequencyStat(unwrapped)
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetPunchCardStatsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON as json.
func (s ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Team(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON from json.
func (s *ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON to nil`)
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetTeamsWithAccessToProtectedBranchOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetTopPathsOKApplicationJSON as json.
func (s ReposGetTopPathsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ContentTraffic(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetTopPathsOKApplicationJSON from json.
func (s *ReposGetTopPathsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetTopPathsOKApplicationJSON to nil`)
	}
	var unwrapped []ContentTraffic
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ContentTraffic
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetTopPathsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetTopReferrersOKApplicationJSON as json.
func (s ReposGetTopReferrersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ReferrerTraffic(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetTopReferrersOKApplicationJSON from json.
func (s *ReposGetTopReferrersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetTopReferrersOKApplicationJSON to nil`)
	}
	var unwrapped []ReferrerTraffic
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ReferrerTraffic
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetTopReferrersOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON as json.
func (s ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON from json.
func (s *ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposGetUsersWithAccessToProtectedBranchOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposGetViewsPer as json.
func (s ReposGetViewsPer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposGetViewsPer from json.
func (s *ReposGetViewsPer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposGetViewsPer to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposGetViewsPer(v)
	return nil
}

// Encode encodes ReposListBranchesOKApplicationJSON as json.
func (s ReposListBranchesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ShortBranch(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposListBranchesOKApplicationJSON from json.
func (s *ReposListBranchesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListBranchesOKApplicationJSON to nil`)
	}
	var unwrapped []ShortBranch
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ShortBranch
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListBranchesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListCollaboratorsAffiliation as json.
func (s ReposListCollaboratorsAffiliation) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposListCollaboratorsAffiliation from json.
func (s *ReposListCollaboratorsAffiliation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListCollaboratorsAffiliation to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposListCollaboratorsAffiliation(v)
	return nil
}

// Encode encodes ReposListCollaboratorsOKApplicationJSON as json.
func (s ReposListCollaboratorsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Collaborator(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposListCollaboratorsOKApplicationJSON from json.
func (s *ReposListCollaboratorsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListCollaboratorsOKApplicationJSON to nil`)
	}
	var unwrapped []Collaborator
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Collaborator
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCollaboratorsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListCommitStatusesForRefOKApplicationJSON as json.
func (s ReposListCommitStatusesForRefOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Status(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposListCommitStatusesForRefOKApplicationJSON from json.
func (s *ReposListCommitStatusesForRefOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListCommitStatusesForRefOKApplicationJSON to nil`)
	}
	var unwrapped []Status
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Status
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitStatusesForRefOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListCommitsApplicationJSONBadRequest as json.
func (s ReposListCommitsApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListCommitsApplicationJSONBadRequest from json.
func (s *ReposListCommitsApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListCommitsApplicationJSONBadRequest to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsApplicationJSONBadRequest(unwrapped)
	return nil
}

// Encode encodes ReposListCommitsApplicationJSONConflict as json.
func (s ReposListCommitsApplicationJSONConflict) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListCommitsApplicationJSONConflict from json.
func (s *ReposListCommitsApplicationJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListCommitsApplicationJSONConflict to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsApplicationJSONConflict(unwrapped)
	return nil
}

// Encode encodes ReposListCommitsApplicationJSONInternalServerError as json.
func (s ReposListCommitsApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListCommitsApplicationJSONInternalServerError from json.
func (s *ReposListCommitsApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListCommitsApplicationJSONInternalServerError to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsApplicationJSONInternalServerError(unwrapped)
	return nil
}

// Encode encodes ReposListCommitsApplicationJSONNotFound as json.
func (s ReposListCommitsApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListCommitsApplicationJSONNotFound from json.
func (s *ReposListCommitsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListCommitsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposListCommitsOKApplicationJSON as json.
func (s ReposListCommitsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Commit(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposListCommitsOKApplicationJSON from json.
func (s *ReposListCommitsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListCommitsOKApplicationJSON to nil`)
	}
	var unwrapped []Commit
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Commit
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListCommitsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListContributorsApplicationJSONForbidden as json.
func (s ReposListContributorsApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListContributorsApplicationJSONForbidden from json.
func (s *ReposListContributorsApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListContributorsApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListContributorsApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposListContributorsApplicationJSONNotFound as json.
func (s ReposListContributorsApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListContributorsApplicationJSONNotFound from json.
func (s *ReposListContributorsApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListContributorsApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListContributorsApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposListContributorsNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposListContributorsNoContent from json.
func (s *ReposListContributorsNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListContributorsNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposListContributorsOKApplicationJSON as json.
func (s ReposListContributorsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Contributor(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposListContributorsOKApplicationJSON from json.
func (s *ReposListContributorsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListContributorsOKApplicationJSON to nil`)
	}
	var unwrapped []Contributor
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Contributor
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListContributorsOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListDeploymentStatusesOKApplicationJSON as json.
func (s ReposListDeploymentStatusesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []DeploymentStatus(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposListDeploymentStatusesOKApplicationJSON from json.
func (s *ReposListDeploymentStatusesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListDeploymentStatusesOKApplicationJSON to nil`)
	}
	var unwrapped []DeploymentStatus
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem DeploymentStatus
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListDeploymentStatusesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListForAuthenticatedUserDirection as json.
func (s ReposListForAuthenticatedUserDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposListForAuthenticatedUserDirection from json.
func (s *ReposListForAuthenticatedUserDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForAuthenticatedUserDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposListForAuthenticatedUserDirection(v)
	return nil
}

// Encode encodes ReposListForAuthenticatedUserSort as json.
func (s ReposListForAuthenticatedUserSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposListForAuthenticatedUserSort from json.
func (s *ReposListForAuthenticatedUserSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForAuthenticatedUserSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposListForAuthenticatedUserSort(v)
	return nil
}

// Encode encodes ReposListForAuthenticatedUserType as json.
func (s ReposListForAuthenticatedUserType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposListForAuthenticatedUserType from json.
func (s *ReposListForAuthenticatedUserType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForAuthenticatedUserType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposListForAuthenticatedUserType(v)
	return nil
}

// Encode encodes ReposListForAuthenticatedUserVisibility as json.
func (s ReposListForAuthenticatedUserVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposListForAuthenticatedUserVisibility from json.
func (s *ReposListForAuthenticatedUserVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForAuthenticatedUserVisibility to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposListForAuthenticatedUserVisibility(v)
	return nil
}

// Encode encodes ReposListForOrgDirection as json.
func (s ReposListForOrgDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposListForOrgDirection from json.
func (s *ReposListForOrgDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForOrgDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposListForOrgDirection(v)
	return nil
}

// Encode encodes ReposListForOrgSort as json.
func (s ReposListForOrgSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposListForOrgSort from json.
func (s *ReposListForOrgSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForOrgSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposListForOrgSort(v)
	return nil
}

// Encode encodes ReposListForOrgType as json.
func (s ReposListForOrgType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposListForOrgType from json.
func (s *ReposListForOrgType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForOrgType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposListForOrgType(v)
	return nil
}

// Encode encodes ReposListForUserDirection as json.
func (s ReposListForUserDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposListForUserDirection from json.
func (s *ReposListForUserDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForUserDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposListForUserDirection(v)
	return nil
}

// Encode encodes ReposListForUserSort as json.
func (s ReposListForUserSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposListForUserSort from json.
func (s *ReposListForUserSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForUserSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposListForUserSort(v)
	return nil
}

// Encode encodes ReposListForUserType as json.
func (s ReposListForUserType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposListForUserType from json.
func (s *ReposListForUserType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForUserType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposListForUserType(v)
	return nil
}

// Encode encodes ReposListForksOKApplicationJSON as json.
func (s ReposListForksOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposListForksOKApplicationJSON from json.
func (s *ReposListForksOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForksOKApplicationJSON to nil`)
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListForksOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListForksSort as json.
func (s ReposListForksSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposListForksSort from json.
func (s *ReposListForksSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListForksSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposListForksSort(v)
	return nil
}

// Encode encodes ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden as json.
func (s ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden from json.
func (s *ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListInvitationsForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound as json.
func (s ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound from json.
func (s *ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListInvitationsForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListInvitationsForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes ReposListInvitationsForAuthenticatedUserOKApplicationJSON as json.
func (s ReposListInvitationsForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []RepositoryInvitation(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposListInvitationsForAuthenticatedUserOKApplicationJSON from json.
func (s *ReposListInvitationsForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListInvitationsForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []RepositoryInvitation
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem RepositoryInvitation
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListInvitationsForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListReleasesOKApplicationJSON as json.
func (s ReposListReleasesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Release(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposListReleasesOKApplicationJSON from json.
func (s *ReposListReleasesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListReleasesOKApplicationJSON to nil`)
	}
	var unwrapped []Release
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Release
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListReleasesOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes ReposListWebhooksOKApplicationJSON as json.
func (s ReposListWebhooksOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Hook(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ReposListWebhooksOKApplicationJSON from json.
func (s *ReposListWebhooksOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposListWebhooksOKApplicationJSON to nil`)
	}
	var unwrapped []Hook
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Hook
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposListWebhooksOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposMergeConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposMergeConflict from json.
func (s *ReposMergeConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposMergeConflict to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposMergeNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposMergeNoContent from json.
func (s *ReposMergeNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposMergeNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposMergeNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposMergeNotFound from json.
func (s *ReposMergeNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposMergeNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposMergeReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("base")
	e.Str(s.Base)

	e.FieldStart("head")
	e.Str(s.Head)
	if s.CommitMessage.Set {
		e.FieldStart("commit_message")
		s.CommitMessage.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposMergeReq from json.
func (s *ReposMergeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposMergeReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "base":
			v, err := d.Str()
			s.Base = string(v)
			if err != nil {
				return err
			}
		case "head":
			v, err := d.Str()
			s.Head = string(v)
			if err != nil {
				return err
			}
		case "commit_message":
			s.CommitMessage.Reset()
			if err := s.CommitMessage.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposMergeUpstreamConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposMergeUpstreamConflict from json.
func (s *ReposMergeUpstreamConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposMergeUpstreamConflict to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposMergeUpstreamReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("branch")
	e.Str(s.Branch)
	e.ObjEnd()
}

// Decode decodes ReposMergeUpstreamReq from json.
func (s *ReposMergeUpstreamReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposMergeUpstreamReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "branch":
			v, err := d.Str()
			s.Branch = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposMergeUpstreamUnprocessableEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposMergeUpstreamUnprocessableEntity from json.
func (s *ReposMergeUpstreamUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposMergeUpstreamUnprocessableEntity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposPingWebhookNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposPingWebhookNoContent from json.
func (s *ReposPingWebhookNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposPingWebhookNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposRemoveCollaboratorNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposRemoveCollaboratorNoContent from json.
func (s *ReposRemoveCollaboratorNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRemoveCollaboratorNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposRemoveStatusCheckProtectionNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposRemoveStatusCheckProtectionNoContent from json.
func (s *ReposRemoveStatusCheckProtectionNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRemoveStatusCheckProtectionNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposRenameBranchReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("new_name")
	e.Str(s.NewName)
	e.ObjEnd()
}

// Decode decodes ReposRenameBranchReq from json.
func (s *ReposRenameBranchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposRenameBranchReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "new_name":
			v, err := d.Str()
			s.NewName = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposReplaceAllTopicsReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("names")
	e.ArrStart()
	for _, elem := range s.Names {
		e.Str(elem)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ReposReplaceAllTopicsReq from json.
func (s *ReposReplaceAllTopicsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposReplaceAllTopicsReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "names":
			s.Names = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Names = append(s.Names, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposTestPushWebhookNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ReposTestPushWebhookNoContent from json.
func (s *ReposTestPushWebhookNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposTestPushWebhookNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposTransferReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("new_owner")
	e.Str(s.NewOwner)
	if s.TeamIds != nil {
		e.FieldStart("team_ids")
		e.ArrStart()
		for _, elem := range s.TeamIds {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposTransferReq from json.
func (s *ReposTransferReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposTransferReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "new_owner":
			v, err := d.Str()
			s.NewOwner = string(v)
			if err != nil {
				return err
			}
		case "team_ids":
			s.TeamIds = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.TeamIds = append(s.TeamIds, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposUpdateBranchProtectionApplicationJSONForbidden as json.
func (s ReposUpdateBranchProtectionApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionApplicationJSONForbidden from json.
func (s *ReposUpdateBranchProtectionApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateBranchProtectionApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateBranchProtectionApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ReposUpdateBranchProtectionApplicationJSONNotFound as json.
func (s ReposUpdateBranchProtectionApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes ReposUpdateBranchProtectionApplicationJSONNotFound from json.
func (s *ReposUpdateBranchProtectionApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateBranchProtectionApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReposUpdateBranchProtectionApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateBranchProtectionReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("required_status_checks")
	s.RequiredStatusChecks.Encode(e)

	e.FieldStart("enforce_admins")
	s.EnforceAdmins.Encode(e)

	e.FieldStart("required_pull_request_reviews")
	s.RequiredPullRequestReviews.Encode(e)

	e.FieldStart("restrictions")
	s.Restrictions.Encode(e)
	if s.RequiredLinearHistory.Set {
		e.FieldStart("required_linear_history")
		s.RequiredLinearHistory.Encode(e)
	}
	if s.AllowForcePushes.Set {
		e.FieldStart("allow_force_pushes")
		s.AllowForcePushes.Encode(e)
	}
	if s.AllowDeletions.Set {
		e.FieldStart("allow_deletions")
		s.AllowDeletions.Encode(e)
	}
	if s.RequiredConversationResolution.Set {
		e.FieldStart("required_conversation_resolution")
		s.RequiredConversationResolution.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateBranchProtectionReq from json.
func (s *ReposUpdateBranchProtectionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateBranchProtectionReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "required_status_checks":
			if err := s.RequiredStatusChecks.Decode(d); err != nil {
				return err
			}
		case "enforce_admins":
			if err := s.EnforceAdmins.Decode(d); err != nil {
				return err
			}
		case "required_pull_request_reviews":
			if err := s.RequiredPullRequestReviews.Decode(d); err != nil {
				return err
			}
		case "restrictions":
			if err := s.Restrictions.Decode(d); err != nil {
				return err
			}
		case "required_linear_history":
			s.RequiredLinearHistory.Reset()
			if err := s.RequiredLinearHistory.Decode(d); err != nil {
				return err
			}
		case "allow_force_pushes":
			s.AllowForcePushes.Reset()
			if err := s.AllowForcePushes.Decode(d); err != nil {
				return err
			}
		case "allow_deletions":
			s.AllowDeletions.Reset()
			if err := s.AllowDeletions.Decode(d); err != nil {
				return err
			}
		case "required_conversation_resolution":
			s.RequiredConversationResolution.Reset()
			if err := s.RequiredConversationResolution.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateBranchProtectionReqRequiredPullRequestReviews) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.DismissalRestrictions.Set {
		e.FieldStart("dismissal_restrictions")
		s.DismissalRestrictions.Encode(e)
	}
	if s.DismissStaleReviews.Set {
		e.FieldStart("dismiss_stale_reviews")
		s.DismissStaleReviews.Encode(e)
	}
	if s.RequireCodeOwnerReviews.Set {
		e.FieldStart("require_code_owner_reviews")
		s.RequireCodeOwnerReviews.Encode(e)
	}
	if s.RequiredApprovingReviewCount.Set {
		e.FieldStart("required_approving_review_count")
		s.RequiredApprovingReviewCount.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredPullRequestReviews from json.
func (s *ReposUpdateBranchProtectionReqRequiredPullRequestReviews) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateBranchProtectionReqRequiredPullRequestReviews to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dismissal_restrictions":
			s.DismissalRestrictions.Reset()
			if err := s.DismissalRestrictions.Decode(d); err != nil {
				return err
			}
		case "dismiss_stale_reviews":
			s.DismissStaleReviews.Reset()
			if err := s.DismissStaleReviews.Decode(d); err != nil {
				return err
			}
		case "require_code_owner_reviews":
			s.RequireCodeOwnerReviews.Reset()
			if err := s.RequireCodeOwnerReviews.Decode(d); err != nil {
				return err
			}
		case "required_approving_review_count":
			s.RequiredApprovingReviewCount.Reset()
			if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Users != nil {
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Teams != nil {
		e.FieldStart("teams")
		e.ArrStart()
		for _, elem := range s.Teams {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions from json.
func (s *ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateBranchProtectionReqRequiredPullRequestReviewsDismissalRestrictions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateBranchProtectionReqRequiredStatusChecks) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("strict")
	e.Bool(s.Strict)

	e.FieldStart("contexts")
	e.ArrStart()
	for _, elem := range s.Contexts {
		e.Str(elem)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ReposUpdateBranchProtectionReqRequiredStatusChecks from json.
func (s *ReposUpdateBranchProtectionReqRequiredStatusChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateBranchProtectionReqRequiredStatusChecks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "strict":
			v, err := d.Bool()
			s.Strict = bool(v)
			if err != nil {
				return err
			}
		case "contexts":
			s.Contexts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Contexts = append(s.Contexts, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateBranchProtectionReqRestrictions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("users")
	e.ArrStart()
	for _, elem := range s.Users {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("teams")
	e.ArrStart()
	for _, elem := range s.Teams {
		e.Str(elem)
	}
	e.ArrEnd()
	if s.Apps != nil {
		e.FieldStart("apps")
		e.ArrStart()
		for _, elem := range s.Apps {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateBranchProtectionReqRestrictions from json.
func (s *ReposUpdateBranchProtectionReqRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateBranchProtectionReqRestrictions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		case "apps":
			s.Apps = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Apps = append(s.Apps, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateCommitCommentReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("body")
	e.Str(s.Body)
	e.ObjEnd()
}

// Decode decodes ReposUpdateCommitCommentReq from json.
func (s *ReposUpdateCommitCommentReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateCommitCommentReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateInvitationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateInvitationReq from json.
func (s *ReposUpdateInvitationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateInvitationReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposUpdateInvitationReqPermissions as json.
func (s ReposUpdateInvitationReqPermissions) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposUpdateInvitationReqPermissions from json.
func (s *ReposUpdateInvitationReqPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateInvitationReqPermissions to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposUpdateInvitationReqPermissions(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdatePullRequestReviewProtectionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.DismissalRestrictions.Set {
		e.FieldStart("dismissal_restrictions")
		s.DismissalRestrictions.Encode(e)
	}
	if s.DismissStaleReviews.Set {
		e.FieldStart("dismiss_stale_reviews")
		s.DismissStaleReviews.Encode(e)
	}
	if s.RequireCodeOwnerReviews.Set {
		e.FieldStart("require_code_owner_reviews")
		s.RequireCodeOwnerReviews.Encode(e)
	}
	if s.RequiredApprovingReviewCount.Set {
		e.FieldStart("required_approving_review_count")
		s.RequiredApprovingReviewCount.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdatePullRequestReviewProtectionReq from json.
func (s *ReposUpdatePullRequestReviewProtectionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdatePullRequestReviewProtectionReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dismissal_restrictions":
			s.DismissalRestrictions.Reset()
			if err := s.DismissalRestrictions.Decode(d); err != nil {
				return err
			}
		case "dismiss_stale_reviews":
			s.DismissStaleReviews.Reset()
			if err := s.DismissStaleReviews.Decode(d); err != nil {
				return err
			}
		case "require_code_owner_reviews":
			s.RequireCodeOwnerReviews.Reset()
			if err := s.RequireCodeOwnerReviews.Decode(d); err != nil {
				return err
			}
		case "required_approving_review_count":
			s.RequiredApprovingReviewCount.Reset()
			if err := s.RequiredApprovingReviewCount.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Users != nil {
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Teams != nil {
		e.FieldStart("teams")
		e.ArrStart()
		for _, elem := range s.Teams {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions from json.
func (s *ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdatePullRequestReviewProtectionReqDismissalRestrictions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			s.Users = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Users = append(s.Users, elem)
				return nil
			}); err != nil {
				return err
			}
		case "teams":
			s.Teams = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Teams = append(s.Teams, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateReleaseAssetReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Label.Set {
		e.FieldStart("label")
		s.Label.Encode(e)
	}
	if s.State.Set {
		e.FieldStart("state")
		s.State.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateReleaseAssetReq from json.
func (s *ReposUpdateReleaseAssetReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateReleaseAssetReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "label":
			s.Label.Reset()
			if err := s.Label.Decode(d); err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateReleaseReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.TagName.Set {
		e.FieldStart("tag_name")
		s.TagName.Encode(e)
	}
	if s.TargetCommitish.Set {
		e.FieldStart("target_commitish")
		s.TargetCommitish.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	if s.Draft.Set {
		e.FieldStart("draft")
		s.Draft.Encode(e)
	}
	if s.Prerelease.Set {
		e.FieldStart("prerelease")
		s.Prerelease.Encode(e)
	}
	if s.DiscussionCategoryName.Set {
		e.FieldStart("discussion_category_name")
		s.DiscussionCategoryName.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateReleaseReq from json.
func (s *ReposUpdateReleaseReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateReleaseReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag_name":
			s.TagName.Reset()
			if err := s.TagName.Decode(d); err != nil {
				return err
			}
		case "target_commitish":
			s.TargetCommitish.Reset()
			if err := s.TargetCommitish.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "draft":
			s.Draft.Reset()
			if err := s.Draft.Decode(d); err != nil {
				return err
			}
		case "prerelease":
			s.Prerelease.Reset()
			if err := s.Prerelease.Decode(d); err != nil {
				return err
			}
		case "discussion_category_name":
			s.DiscussionCategoryName.Reset()
			if err := s.DiscussionCategoryName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.Homepage.Set {
		e.FieldStart("homepage")
		s.Homepage.Encode(e)
	}
	if s.Private.Set {
		e.FieldStart("private")
		s.Private.Encode(e)
	}
	if s.Visibility.Set {
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
	if s.SecurityAndAnalysis.Set {
		e.FieldStart("security_and_analysis")
		s.SecurityAndAnalysis.Encode(e)
	}
	if s.HasIssues.Set {
		e.FieldStart("has_issues")
		s.HasIssues.Encode(e)
	}
	if s.HasProjects.Set {
		e.FieldStart("has_projects")
		s.HasProjects.Encode(e)
	}
	if s.HasWiki.Set {
		e.FieldStart("has_wiki")
		s.HasWiki.Encode(e)
	}
	if s.IsTemplate.Set {
		e.FieldStart("is_template")
		s.IsTemplate.Encode(e)
	}
	if s.DefaultBranch.Set {
		e.FieldStart("default_branch")
		s.DefaultBranch.Encode(e)
	}
	if s.AllowSquashMerge.Set {
		e.FieldStart("allow_squash_merge")
		s.AllowSquashMerge.Encode(e)
	}
	if s.AllowMergeCommit.Set {
		e.FieldStart("allow_merge_commit")
		s.AllowMergeCommit.Encode(e)
	}
	if s.AllowRebaseMerge.Set {
		e.FieldStart("allow_rebase_merge")
		s.AllowRebaseMerge.Encode(e)
	}
	if s.AllowAutoMerge.Set {
		e.FieldStart("allow_auto_merge")
		s.AllowAutoMerge.Encode(e)
	}
	if s.DeleteBranchOnMerge.Set {
		e.FieldStart("delete_branch_on_merge")
		s.DeleteBranchOnMerge.Encode(e)
	}
	if s.Archived.Set {
		e.FieldStart("archived")
		s.Archived.Encode(e)
	}
	if s.AllowForking.Set {
		e.FieldStart("allow_forking")
		s.AllowForking.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateReq from json.
func (s *ReposUpdateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "homepage":
			s.Homepage.Reset()
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "security_and_analysis":
			s.SecurityAndAnalysis.Reset()
			if err := s.SecurityAndAnalysis.Decode(d); err != nil {
				return err
			}
		case "has_issues":
			s.HasIssues.Reset()
			if err := s.HasIssues.Decode(d); err != nil {
				return err
			}
		case "has_projects":
			s.HasProjects.Reset()
			if err := s.HasProjects.Decode(d); err != nil {
				return err
			}
		case "has_wiki":
			s.HasWiki.Reset()
			if err := s.HasWiki.Decode(d); err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "default_branch":
			s.DefaultBranch.Reset()
			if err := s.DefaultBranch.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "archived":
			s.Archived.Reset()
			if err := s.Archived.Decode(d); err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateReqSecurityAndAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.AdvancedSecurity.Set {
		e.FieldStart("advanced_security")
		s.AdvancedSecurity.Encode(e)
	}
	if s.SecretScanning.Set {
		e.FieldStart("secret_scanning")
		s.SecretScanning.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateReqSecurityAndAnalysis from json.
func (s *ReposUpdateReqSecurityAndAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateReqSecurityAndAnalysis to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "advanced_security":
			s.AdvancedSecurity.Reset()
			if err := s.AdvancedSecurity.Decode(d); err != nil {
				return err
			}
		case "secret_scanning":
			s.SecretScanning.Reset()
			if err := s.SecretScanning.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateReqSecurityAndAnalysisAdvancedSecurity) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Status.Set {
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateReqSecurityAndAnalysisAdvancedSecurity from json.
func (s *ReposUpdateReqSecurityAndAnalysisAdvancedSecurity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateReqSecurityAndAnalysisAdvancedSecurity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateReqSecurityAndAnalysisSecretScanning) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Status.Set {
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateReqSecurityAndAnalysisSecretScanning from json.
func (s *ReposUpdateReqSecurityAndAnalysisSecretScanning) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateReqSecurityAndAnalysisSecretScanning to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReposUpdateReqVisibility as json.
func (s ReposUpdateReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReposUpdateReqVisibility from json.
func (s *ReposUpdateReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateReqVisibility to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReposUpdateReqVisibility(v)
	return nil
}

// Encode implements json.Marshaler.
func (s ReposUpdateStatusCheckProtectionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Strict.Set {
		e.FieldStart("strict")
		s.Strict.Encode(e)
	}
	if s.Contexts != nil {
		e.FieldStart("contexts")
		e.ArrStart()
		for _, elem := range s.Contexts {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateStatusCheckProtectionReq from json.
func (s *ReposUpdateStatusCheckProtectionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateStatusCheckProtectionReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "strict":
			s.Strict.Reset()
			if err := s.Strict.Decode(d); err != nil {
				return err
			}
		case "contexts":
			s.Contexts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Contexts = append(s.Contexts, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateWebhookConfigForRepoReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.ContentType.Set {
		e.FieldStart("content_type")
		s.ContentType.Encode(e)
	}
	if s.Secret.Set {
		e.FieldStart("secret")
		s.Secret.Encode(e)
	}
	if s.InsecureSsl != nil {
		e.FieldStart("insecure_ssl")
		s.InsecureSsl.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateWebhookConfigForRepoReq from json.
func (s *ReposUpdateWebhookConfigForRepoReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateWebhookConfigForRepoReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl = nil
			var elem WebhookConfigInsecureSsl
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.InsecureSsl = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateWebhookReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Config.Set {
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	if s.Events != nil {
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.AddEvents != nil {
		e.FieldStart("add_events")
		e.ArrStart()
		for _, elem := range s.AddEvents {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.RemoveEvents != nil {
		e.FieldStart("remove_events")
		e.ArrStart()
		for _, elem := range s.RemoveEvents {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Active.Set {
		e.FieldStart("active")
		s.Active.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateWebhookReq from json.
func (s *ReposUpdateWebhookReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateWebhookReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			s.Config.Reset()
			if err := s.Config.Decode(d); err != nil {
				return err
			}
		case "events":
			s.Events = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Events = append(s.Events, elem)
				return nil
			}); err != nil {
				return err
			}
		case "add_events":
			s.AddEvents = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.AddEvents = append(s.AddEvents, elem)
				return nil
			}); err != nil {
				return err
			}
		case "remove_events":
			s.RemoveEvents = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.RemoveEvents = append(s.RemoveEvents, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReposUpdateWebhookReqConfig) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	s.URL.Encode(e)
	if s.ContentType.Set {
		e.FieldStart("content_type")
		s.ContentType.Encode(e)
	}
	if s.Secret.Set {
		e.FieldStart("secret")
		s.Secret.Encode(e)
	}
	if s.InsecureSsl != nil {
		e.FieldStart("insecure_ssl")
		s.InsecureSsl.Encode(e)
	}
	if s.Address.Set {
		e.FieldStart("address")
		s.Address.Encode(e)
	}
	if s.Room.Set {
		e.FieldStart("room")
		s.Room.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReposUpdateWebhookReqConfig from json.
func (s *ReposUpdateWebhookReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReposUpdateWebhookReqConfig to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			{
				var unwrapped url.URL
				v, err := json.DecodeURI(d)
				unwrapped = v
				if err != nil {
					return err
				}
				s.URL = WebhookConfigURL(unwrapped)
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl = nil
			var elem WebhookConfigInsecureSsl
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.InsecureSsl = &elem
		case "address":
			s.Address.Reset()
			if err := s.Address.Decode(d); err != nil {
				return err
			}
		case "room":
			s.Room.Reset()
			if err := s.Room.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Repository) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("full_name")
	e.Str(s.FullName)

	e.FieldStart("license")
	s.License.Encode(e)
	if s.Organization.Set {
		e.FieldStart("organization")
		s.Organization.Encode(e)
	}

	e.FieldStart("forks")
	e.Int(s.Forks)
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}

	e.FieldStart("owner")
	s.Owner.Encode(e)

	e.FieldStart("private")
	e.Bool(s.Private)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("fork")
	e.Bool(s.Fork)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("archive_url")
	e.Str(s.ArchiveURL)

	e.FieldStart("assignees_url")
	e.Str(s.AssigneesURL)

	e.FieldStart("blobs_url")
	e.Str(s.BlobsURL)

	e.FieldStart("branches_url")
	e.Str(s.BranchesURL)

	e.FieldStart("collaborators_url")
	e.Str(s.CollaboratorsURL)

	e.FieldStart("comments_url")
	e.Str(s.CommentsURL)

	e.FieldStart("commits_url")
	e.Str(s.CommitsURL)

	e.FieldStart("compare_url")
	e.Str(s.CompareURL)

	e.FieldStart("contents_url")
	e.Str(s.ContentsURL)

	e.FieldStart("contributors_url")
	json.EncodeURI(e, s.ContributorsURL)

	e.FieldStart("deployments_url")
	json.EncodeURI(e, s.DeploymentsURL)

	e.FieldStart("downloads_url")
	json.EncodeURI(e, s.DownloadsURL)

	e.FieldStart("events_url")
	json.EncodeURI(e, s.EventsURL)

	e.FieldStart("forks_url")
	json.EncodeURI(e, s.ForksURL)

	e.FieldStart("git_commits_url")
	e.Str(s.GitCommitsURL)

	e.FieldStart("git_refs_url")
	e.Str(s.GitRefsURL)

	e.FieldStart("git_tags_url")
	e.Str(s.GitTagsURL)

	e.FieldStart("git_url")
	e.Str(s.GitURL)

	e.FieldStart("issue_comment_url")
	e.Str(s.IssueCommentURL)

	e.FieldStart("issue_events_url")
	e.Str(s.IssueEventsURL)

	e.FieldStart("issues_url")
	e.Str(s.IssuesURL)

	e.FieldStart("keys_url")
	e.Str(s.KeysURL)

	e.FieldStart("labels_url")
	e.Str(s.LabelsURL)

	e.FieldStart("languages_url")
	json.EncodeURI(e, s.LanguagesURL)

	e.FieldStart("merges_url")
	json.EncodeURI(e, s.MergesURL)

	e.FieldStart("milestones_url")
	e.Str(s.MilestonesURL)

	e.FieldStart("notifications_url")
	e.Str(s.NotificationsURL)

	e.FieldStart("pulls_url")
	e.Str(s.PullsURL)

	e.FieldStart("releases_url")
	e.Str(s.ReleasesURL)

	e.FieldStart("ssh_url")
	e.Str(s.SSHURL)

	e.FieldStart("stargazers_url")
	json.EncodeURI(e, s.StargazersURL)

	e.FieldStart("statuses_url")
	e.Str(s.StatusesURL)

	e.FieldStart("subscribers_url")
	json.EncodeURI(e, s.SubscribersURL)

	e.FieldStart("subscription_url")
	json.EncodeURI(e, s.SubscriptionURL)

	e.FieldStart("tags_url")
	json.EncodeURI(e, s.TagsURL)

	e.FieldStart("teams_url")
	json.EncodeURI(e, s.TeamsURL)

	e.FieldStart("trees_url")
	e.Str(s.TreesURL)

	e.FieldStart("clone_url")
	e.Str(s.CloneURL)

	e.FieldStart("mirror_url")
	s.MirrorURL.Encode(e)

	e.FieldStart("hooks_url")
	json.EncodeURI(e, s.HooksURL)

	e.FieldStart("svn_url")
	json.EncodeURI(e, s.SvnURL)

	e.FieldStart("homepage")
	s.Homepage.Encode(e)

	e.FieldStart("language")
	s.Language.Encode(e)

	e.FieldStart("forks_count")
	e.Int(s.ForksCount)

	e.FieldStart("stargazers_count")
	e.Int(s.StargazersCount)

	e.FieldStart("watchers_count")
	e.Int(s.WatchersCount)

	e.FieldStart("size")
	e.Int(s.Size)

	e.FieldStart("default_branch")
	e.Str(s.DefaultBranch)

	e.FieldStart("open_issues_count")
	e.Int(s.OpenIssuesCount)
	if s.IsTemplate.Set {
		e.FieldStart("is_template")
		s.IsTemplate.Encode(e)
	}
	if s.Topics != nil {
		e.FieldStart("topics")
		e.ArrStart()
		for _, elem := range s.Topics {
			e.Str(elem)
		}
		e.ArrEnd()
	}

	e.FieldStart("has_issues")
	e.Bool(s.HasIssues)

	e.FieldStart("has_projects")
	e.Bool(s.HasProjects)

	e.FieldStart("has_wiki")
	e.Bool(s.HasWiki)

	e.FieldStart("has_pages")
	e.Bool(s.HasPages)

	e.FieldStart("has_downloads")
	e.Bool(s.HasDownloads)

	e.FieldStart("archived")
	e.Bool(s.Archived)

	e.FieldStart("disabled")
	e.Bool(s.Disabled)
	if s.Visibility.Set {
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}

	e.FieldStart("pushed_at")
	s.PushedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("created_at")
	s.CreatedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("updated_at")
	s.UpdatedAt.Encode(e, json.EncodeDateTime)
	if s.AllowRebaseMerge.Set {
		e.FieldStart("allow_rebase_merge")
		s.AllowRebaseMerge.Encode(e)
	}
	if s.TemplateRepository.Set {
		e.FieldStart("template_repository")
		s.TemplateRepository.Encode(e)
	}
	if s.TempCloneToken.Set {
		e.FieldStart("temp_clone_token")
		s.TempCloneToken.Encode(e)
	}
	if s.AllowSquashMerge.Set {
		e.FieldStart("allow_squash_merge")
		s.AllowSquashMerge.Encode(e)
	}
	if s.AllowAutoMerge.Set {
		e.FieldStart("allow_auto_merge")
		s.AllowAutoMerge.Encode(e)
	}
	if s.DeleteBranchOnMerge.Set {
		e.FieldStart("delete_branch_on_merge")
		s.DeleteBranchOnMerge.Encode(e)
	}
	if s.AllowMergeCommit.Set {
		e.FieldStart("allow_merge_commit")
		s.AllowMergeCommit.Encode(e)
	}
	if s.AllowForking.Set {
		e.FieldStart("allow_forking")
		s.AllowForking.Encode(e)
	}
	if s.SubscribersCount.Set {
		e.FieldStart("subscribers_count")
		s.SubscribersCount.Encode(e)
	}
	if s.NetworkCount.Set {
		e.FieldStart("network_count")
		s.NetworkCount.Encode(e)
	}

	e.FieldStart("open_issues")
	e.Int(s.OpenIssues)

	e.FieldStart("watchers")
	e.Int(s.Watchers)
	if s.MasterBranch.Set {
		e.FieldStart("master_branch")
		s.MasterBranch.Encode(e)
	}
	if s.StarredAt.Set {
		e.FieldStart("starred_at")
		s.StarredAt.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes Repository from json.
func (s *Repository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Repository to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "organization":
			s.Organization.Reset()
			if err := s.Organization.Decode(d); err != nil {
				return err
			}
		case "forks":
			v, err := d.Int()
			s.Forks = int(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "git_url":
			v, err := d.Str()
			s.GitURL = string(v)
			if err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			v, err := d.Str()
			s.SSHURL = string(v)
			if err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "clone_url":
			v, err := d.Str()
			s.CloneURL = string(v)
			if err != nil {
				return err
			}
		case "mirror_url":
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "svn_url":
			v, err := json.DecodeURI(d)
			s.SvnURL = v
			if err != nil {
				return err
			}
		case "homepage":
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			v, err := d.Int()
			s.ForksCount = int(v)
			if err != nil {
				return err
			}
		case "stargazers_count":
			v, err := d.Int()
			s.StargazersCount = int(v)
			if err != nil {
				return err
			}
		case "watchers_count":
			v, err := d.Int()
			s.WatchersCount = int(v)
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "default_branch":
			v, err := d.Str()
			s.DefaultBranch = string(v)
			if err != nil {
				return err
			}
		case "open_issues_count":
			v, err := d.Int()
			s.OpenIssuesCount = int(v)
			if err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "has_issues":
			v, err := d.Bool()
			s.HasIssues = bool(v)
			if err != nil {
				return err
			}
		case "has_projects":
			v, err := d.Bool()
			s.HasProjects = bool(v)
			if err != nil {
				return err
			}
		case "has_wiki":
			v, err := d.Bool()
			s.HasWiki = bool(v)
			if err != nil {
				return err
			}
		case "has_pages":
			v, err := d.Bool()
			s.HasPages = bool(v)
			if err != nil {
				return err
			}
		case "has_downloads":
			v, err := d.Bool()
			s.HasDownloads = bool(v)
			if err != nil {
				return err
			}
		case "archived":
			v, err := d.Bool()
			s.Archived = bool(v)
			if err != nil {
				return err
			}
		case "disabled":
			v, err := d.Bool()
			s.Disabled = bool(v)
			if err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "created_at":
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "template_repository":
			s.TemplateRepository.Reset()
			if err := s.TemplateRepository.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		case "subscribers_count":
			s.SubscribersCount.Reset()
			if err := s.SubscribersCount.Decode(d); err != nil {
				return err
			}
		case "network_count":
			s.NetworkCount.Reset()
			if err := s.NetworkCount.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "watchers":
			v, err := d.Int()
			s.Watchers = int(v)
			if err != nil {
				return err
			}
		case "master_branch":
			s.MasterBranch.Reset()
			if err := s.MasterBranch.Decode(d); err != nil {
				return err
			}
		case "starred_at":
			s.StarredAt.Reset()
			if err := s.StarredAt.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RepositoryCollaboratorPermission) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("permission")
	e.Str(s.Permission)

	e.FieldStart("user")
	s.User.Encode(e)
	e.ObjEnd()
}

// Decode decodes RepositoryCollaboratorPermission from json.
func (s *RepositoryCollaboratorPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepositoryCollaboratorPermission to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			v, err := d.Str()
			s.Permission = string(v)
			if err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RepositoryInvitation) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("repository")
	s.Repository.Encode(e)

	e.FieldStart("invitee")
	s.Invitee.Encode(e)

	e.FieldStart("inviter")
	s.Inviter.Encode(e)

	e.FieldStart("permissions")
	s.Permissions.Encode(e)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)
	if s.Expired.Set {
		e.FieldStart("expired")
		s.Expired.Encode(e)
	}

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("html_url")
	e.Str(s.HTMLURL)

	e.FieldStart("node_id")
	e.Str(s.NodeID)
	e.ObjEnd()
}

// Decode decodes RepositoryInvitation from json.
func (s *RepositoryInvitation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepositoryInvitation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "repository":
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "invitee":
			if err := s.Invitee.Decode(d); err != nil {
				return err
			}
		case "inviter":
			if err := s.Inviter.Decode(d); err != nil {
				return err
			}
		case "permissions":
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "expired":
			s.Expired.Reset()
			if err := s.Expired.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := d.Str()
			s.HTMLURL = string(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes RepositoryInvitationPermissions as json.
func (s RepositoryInvitationPermissions) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RepositoryInvitationPermissions from json.
func (s *RepositoryInvitationPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepositoryInvitationPermissions to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = RepositoryInvitationPermissions(v)
	return nil
}

// Encode implements json.Marshaler.
func (s RepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("admin")
	e.Bool(s.Admin)

	e.FieldStart("pull")
	e.Bool(s.Pull)
	if s.Triage.Set {
		e.FieldStart("triage")
		s.Triage.Encode(e)
	}

	e.FieldStart("push")
	e.Bool(s.Push)
	if s.Maintain.Set {
		e.FieldStart("maintain")
		s.Maintain.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes RepositoryPermissions from json.
func (s *RepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RepositorySubscription) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("subscribed")
	e.Bool(s.Subscribed)

	e.FieldStart("ignored")
	e.Bool(s.Ignored)

	e.FieldStart("reason")
	s.Reason.Encode(e)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("repository_url")
	json.EncodeURI(e, s.RepositoryURL)
	e.ObjEnd()
}

// Decode decodes RepositorySubscription from json.
func (s *RepositorySubscription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepositorySubscription to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscribed":
			v, err := d.Bool()
			s.Subscribed = bool(v)
			if err != nil {
				return err
			}
		case "ignored":
			v, err := d.Bool()
			s.Ignored = bool(v)
			if err != nil {
				return err
			}
		case "reason":
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "repository_url":
			v, err := json.DecodeURI(d)
			s.RepositoryURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RepositoryTemplateRepository) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.FullName.Set {
		e.FieldStart("full_name")
		s.FullName.Encode(e)
	}
	if s.Owner.Set {
		e.FieldStart("owner")
		s.Owner.Encode(e)
	}
	if s.Private.Set {
		e.FieldStart("private")
		s.Private.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.Fork.Set {
		e.FieldStart("fork")
		s.Fork.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.ArchiveURL.Set {
		e.FieldStart("archive_url")
		s.ArchiveURL.Encode(e)
	}
	if s.AssigneesURL.Set {
		e.FieldStart("assignees_url")
		s.AssigneesURL.Encode(e)
	}
	if s.BlobsURL.Set {
		e.FieldStart("blobs_url")
		s.BlobsURL.Encode(e)
	}
	if s.BranchesURL.Set {
		e.FieldStart("branches_url")
		s.BranchesURL.Encode(e)
	}
	if s.CollaboratorsURL.Set {
		e.FieldStart("collaborators_url")
		s.CollaboratorsURL.Encode(e)
	}
	if s.CommentsURL.Set {
		e.FieldStart("comments_url")
		s.CommentsURL.Encode(e)
	}
	if s.CommitsURL.Set {
		e.FieldStart("commits_url")
		s.CommitsURL.Encode(e)
	}
	if s.CompareURL.Set {
		e.FieldStart("compare_url")
		s.CompareURL.Encode(e)
	}
	if s.ContentsURL.Set {
		e.FieldStart("contents_url")
		s.ContentsURL.Encode(e)
	}
	if s.ContributorsURL.Set {
		e.FieldStart("contributors_url")
		s.ContributorsURL.Encode(e)
	}
	if s.DeploymentsURL.Set {
		e.FieldStart("deployments_url")
		s.DeploymentsURL.Encode(e)
	}
	if s.DownloadsURL.Set {
		e.FieldStart("downloads_url")
		s.DownloadsURL.Encode(e)
	}
	if s.EventsURL.Set {
		e.FieldStart("events_url")
		s.EventsURL.Encode(e)
	}
	if s.ForksURL.Set {
		e.FieldStart("forks_url")
		s.ForksURL.Encode(e)
	}
	if s.GitCommitsURL.Set {
		e.FieldStart("git_commits_url")
		s.GitCommitsURL.Encode(e)
	}
	if s.GitRefsURL.Set {
		e.FieldStart("git_refs_url")
		s.GitRefsURL.Encode(e)
	}
	if s.GitTagsURL.Set {
		e.FieldStart("git_tags_url")
		s.GitTagsURL.Encode(e)
	}
	if s.GitURL.Set {
		e.FieldStart("git_url")
		s.GitURL.Encode(e)
	}
	if s.IssueCommentURL.Set {
		e.FieldStart("issue_comment_url")
		s.IssueCommentURL.Encode(e)
	}
	if s.IssueEventsURL.Set {
		e.FieldStart("issue_events_url")
		s.IssueEventsURL.Encode(e)
	}
	if s.IssuesURL.Set {
		e.FieldStart("issues_url")
		s.IssuesURL.Encode(e)
	}
	if s.KeysURL.Set {
		e.FieldStart("keys_url")
		s.KeysURL.Encode(e)
	}
	if s.LabelsURL.Set {
		e.FieldStart("labels_url")
		s.LabelsURL.Encode(e)
	}
	if s.LanguagesURL.Set {
		e.FieldStart("languages_url")
		s.LanguagesURL.Encode(e)
	}
	if s.MergesURL.Set {
		e.FieldStart("merges_url")
		s.MergesURL.Encode(e)
	}
	if s.MilestonesURL.Set {
		e.FieldStart("milestones_url")
		s.MilestonesURL.Encode(e)
	}
	if s.NotificationsURL.Set {
		e.FieldStart("notifications_url")
		s.NotificationsURL.Encode(e)
	}
	if s.PullsURL.Set {
		e.FieldStart("pulls_url")
		s.PullsURL.Encode(e)
	}
	if s.ReleasesURL.Set {
		e.FieldStart("releases_url")
		s.ReleasesURL.Encode(e)
	}
	if s.SSHURL.Set {
		e.FieldStart("ssh_url")
		s.SSHURL.Encode(e)
	}
	if s.StargazersURL.Set {
		e.FieldStart("stargazers_url")
		s.StargazersURL.Encode(e)
	}
	if s.StatusesURL.Set {
		e.FieldStart("statuses_url")
		s.StatusesURL.Encode(e)
	}
	if s.SubscribersURL.Set {
		e.FieldStart("subscribers_url")
		s.SubscribersURL.Encode(e)
	}
	if s.SubscriptionURL.Set {
		e.FieldStart("subscription_url")
		s.SubscriptionURL.Encode(e)
	}
	if s.TagsURL.Set {
		e.FieldStart("tags_url")
		s.TagsURL.Encode(e)
	}
	if s.TeamsURL.Set {
		e.FieldStart("teams_url")
		s.TeamsURL.Encode(e)
	}
	if s.TreesURL.Set {
		e.FieldStart("trees_url")
		s.TreesURL.Encode(e)
	}
	if s.CloneURL.Set {
		e.FieldStart("clone_url")
		s.CloneURL.Encode(e)
	}
	if s.MirrorURL.Set {
		e.FieldStart("mirror_url")
		s.MirrorURL.Encode(e)
	}
	if s.HooksURL.Set {
		e.FieldStart("hooks_url")
		s.HooksURL.Encode(e)
	}
	if s.SvnURL.Set {
		e.FieldStart("svn_url")
		s.SvnURL.Encode(e)
	}
	if s.Homepage.Set {
		e.FieldStart("homepage")
		s.Homepage.Encode(e)
	}
	if s.Language.Set {
		e.FieldStart("language")
		s.Language.Encode(e)
	}
	if s.ForksCount.Set {
		e.FieldStart("forks_count")
		s.ForksCount.Encode(e)
	}
	if s.StargazersCount.Set {
		e.FieldStart("stargazers_count")
		s.StargazersCount.Encode(e)
	}
	if s.WatchersCount.Set {
		e.FieldStart("watchers_count")
		s.WatchersCount.Encode(e)
	}
	if s.Size.Set {
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	if s.DefaultBranch.Set {
		e.FieldStart("default_branch")
		s.DefaultBranch.Encode(e)
	}
	if s.OpenIssuesCount.Set {
		e.FieldStart("open_issues_count")
		s.OpenIssuesCount.Encode(e)
	}
	if s.IsTemplate.Set {
		e.FieldStart("is_template")
		s.IsTemplate.Encode(e)
	}
	if s.Topics != nil {
		e.FieldStart("topics")
		e.ArrStart()
		for _, elem := range s.Topics {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.HasIssues.Set {
		e.FieldStart("has_issues")
		s.HasIssues.Encode(e)
	}
	if s.HasProjects.Set {
		e.FieldStart("has_projects")
		s.HasProjects.Encode(e)
	}
	if s.HasWiki.Set {
		e.FieldStart("has_wiki")
		s.HasWiki.Encode(e)
	}
	if s.HasPages.Set {
		e.FieldStart("has_pages")
		s.HasPages.Encode(e)
	}
	if s.HasDownloads.Set {
		e.FieldStart("has_downloads")
		s.HasDownloads.Encode(e)
	}
	if s.Archived.Set {
		e.FieldStart("archived")
		s.Archived.Encode(e)
	}
	if s.Disabled.Set {
		e.FieldStart("disabled")
		s.Disabled.Encode(e)
	}
	if s.Visibility.Set {
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}
	if s.PushedAt.Set {
		e.FieldStart("pushed_at")
		s.PushedAt.Encode(e)
	}
	if s.CreatedAt.Set {
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e)
	}
	if s.UpdatedAt.Set {
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e)
	}
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
	if s.AllowRebaseMerge.Set {
		e.FieldStart("allow_rebase_merge")
		s.AllowRebaseMerge.Encode(e)
	}
	if s.TempCloneToken.Set {
		e.FieldStart("temp_clone_token")
		s.TempCloneToken.Encode(e)
	}
	if s.AllowSquashMerge.Set {
		e.FieldStart("allow_squash_merge")
		s.AllowSquashMerge.Encode(e)
	}
	if s.AllowAutoMerge.Set {
		e.FieldStart("allow_auto_merge")
		s.AllowAutoMerge.Encode(e)
	}
	if s.DeleteBranchOnMerge.Set {
		e.FieldStart("delete_branch_on_merge")
		s.DeleteBranchOnMerge.Encode(e)
	}
	if s.AllowMergeCommit.Set {
		e.FieldStart("allow_merge_commit")
		s.AllowMergeCommit.Encode(e)
	}
	if s.SubscribersCount.Set {
		e.FieldStart("subscribers_count")
		s.SubscribersCount.Encode(e)
	}
	if s.NetworkCount.Set {
		e.FieldStart("network_count")
		s.NetworkCount.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes RepositoryTemplateRepository from json.
func (s *RepositoryTemplateRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepositoryTemplateRepository to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "full_name":
			s.FullName.Reset()
			if err := s.FullName.Decode(d); err != nil {
				return err
			}
		case "owner":
			s.Owner.Reset()
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			s.Fork.Reset()
			if err := s.Fork.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "archive_url":
			s.ArchiveURL.Reset()
			if err := s.ArchiveURL.Decode(d); err != nil {
				return err
			}
		case "assignees_url":
			s.AssigneesURL.Reset()
			if err := s.AssigneesURL.Decode(d); err != nil {
				return err
			}
		case "blobs_url":
			s.BlobsURL.Reset()
			if err := s.BlobsURL.Decode(d); err != nil {
				return err
			}
		case "branches_url":
			s.BranchesURL.Reset()
			if err := s.BranchesURL.Decode(d); err != nil {
				return err
			}
		case "collaborators_url":
			s.CollaboratorsURL.Reset()
			if err := s.CollaboratorsURL.Decode(d); err != nil {
				return err
			}
		case "comments_url":
			s.CommentsURL.Reset()
			if err := s.CommentsURL.Decode(d); err != nil {
				return err
			}
		case "commits_url":
			s.CommitsURL.Reset()
			if err := s.CommitsURL.Decode(d); err != nil {
				return err
			}
		case "compare_url":
			s.CompareURL.Reset()
			if err := s.CompareURL.Decode(d); err != nil {
				return err
			}
		case "contents_url":
			s.ContentsURL.Reset()
			if err := s.ContentsURL.Decode(d); err != nil {
				return err
			}
		case "contributors_url":
			s.ContributorsURL.Reset()
			if err := s.ContributorsURL.Decode(d); err != nil {
				return err
			}
		case "deployments_url":
			s.DeploymentsURL.Reset()
			if err := s.DeploymentsURL.Decode(d); err != nil {
				return err
			}
		case "downloads_url":
			s.DownloadsURL.Reset()
			if err := s.DownloadsURL.Decode(d); err != nil {
				return err
			}
		case "events_url":
			s.EventsURL.Reset()
			if err := s.EventsURL.Decode(d); err != nil {
				return err
			}
		case "forks_url":
			s.ForksURL.Reset()
			if err := s.ForksURL.Decode(d); err != nil {
				return err
			}
		case "git_commits_url":
			s.GitCommitsURL.Reset()
			if err := s.GitCommitsURL.Decode(d); err != nil {
				return err
			}
		case "git_refs_url":
			s.GitRefsURL.Reset()
			if err := s.GitRefsURL.Decode(d); err != nil {
				return err
			}
		case "git_tags_url":
			s.GitTagsURL.Reset()
			if err := s.GitTagsURL.Decode(d); err != nil {
				return err
			}
		case "git_url":
			s.GitURL.Reset()
			if err := s.GitURL.Decode(d); err != nil {
				return err
			}
		case "issue_comment_url":
			s.IssueCommentURL.Reset()
			if err := s.IssueCommentURL.Decode(d); err != nil {
				return err
			}
		case "issue_events_url":
			s.IssueEventsURL.Reset()
			if err := s.IssueEventsURL.Decode(d); err != nil {
				return err
			}
		case "issues_url":
			s.IssuesURL.Reset()
			if err := s.IssuesURL.Decode(d); err != nil {
				return err
			}
		case "keys_url":
			s.KeysURL.Reset()
			if err := s.KeysURL.Decode(d); err != nil {
				return err
			}
		case "labels_url":
			s.LabelsURL.Reset()
			if err := s.LabelsURL.Decode(d); err != nil {
				return err
			}
		case "languages_url":
			s.LanguagesURL.Reset()
			if err := s.LanguagesURL.Decode(d); err != nil {
				return err
			}
		case "merges_url":
			s.MergesURL.Reset()
			if err := s.MergesURL.Decode(d); err != nil {
				return err
			}
		case "milestones_url":
			s.MilestonesURL.Reset()
			if err := s.MilestonesURL.Decode(d); err != nil {
				return err
			}
		case "notifications_url":
			s.NotificationsURL.Reset()
			if err := s.NotificationsURL.Decode(d); err != nil {
				return err
			}
		case "pulls_url":
			s.PullsURL.Reset()
			if err := s.PullsURL.Decode(d); err != nil {
				return err
			}
		case "releases_url":
			s.ReleasesURL.Reset()
			if err := s.ReleasesURL.Decode(d); err != nil {
				return err
			}
		case "ssh_url":
			s.SSHURL.Reset()
			if err := s.SSHURL.Decode(d); err != nil {
				return err
			}
		case "stargazers_url":
			s.StargazersURL.Reset()
			if err := s.StargazersURL.Decode(d); err != nil {
				return err
			}
		case "statuses_url":
			s.StatusesURL.Reset()
			if err := s.StatusesURL.Decode(d); err != nil {
				return err
			}
		case "subscribers_url":
			s.SubscribersURL.Reset()
			if err := s.SubscribersURL.Decode(d); err != nil {
				return err
			}
		case "subscription_url":
			s.SubscriptionURL.Reset()
			if err := s.SubscriptionURL.Decode(d); err != nil {
				return err
			}
		case "tags_url":
			s.TagsURL.Reset()
			if err := s.TagsURL.Decode(d); err != nil {
				return err
			}
		case "teams_url":
			s.TeamsURL.Reset()
			if err := s.TeamsURL.Decode(d); err != nil {
				return err
			}
		case "trees_url":
			s.TreesURL.Reset()
			if err := s.TreesURL.Decode(d); err != nil {
				return err
			}
		case "clone_url":
			s.CloneURL.Reset()
			if err := s.CloneURL.Decode(d); err != nil {
				return err
			}
		case "mirror_url":
			s.MirrorURL.Reset()
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			s.HooksURL.Reset()
			if err := s.HooksURL.Decode(d); err != nil {
				return err
			}
		case "svn_url":
			s.SvnURL.Reset()
			if err := s.SvnURL.Decode(d); err != nil {
				return err
			}
		case "homepage":
			s.Homepage.Reset()
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			s.Language.Reset()
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			s.ForksCount.Reset()
			if err := s.ForksCount.Decode(d); err != nil {
				return err
			}
		case "stargazers_count":
			s.StargazersCount.Reset()
			if err := s.StargazersCount.Decode(d); err != nil {
				return err
			}
		case "watchers_count":
			s.WatchersCount.Reset()
			if err := s.WatchersCount.Decode(d); err != nil {
				return err
			}
		case "size":
			s.Size.Reset()
			if err := s.Size.Decode(d); err != nil {
				return err
			}
		case "default_branch":
			s.DefaultBranch.Reset()
			if err := s.DefaultBranch.Decode(d); err != nil {
				return err
			}
		case "open_issues_count":
			s.OpenIssuesCount.Reset()
			if err := s.OpenIssuesCount.Decode(d); err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "has_issues":
			s.HasIssues.Reset()
			if err := s.HasIssues.Decode(d); err != nil {
				return err
			}
		case "has_projects":
			s.HasProjects.Reset()
			if err := s.HasProjects.Decode(d); err != nil {
				return err
			}
		case "has_wiki":
			s.HasWiki.Reset()
			if err := s.HasWiki.Decode(d); err != nil {
				return err
			}
		case "has_pages":
			s.HasPages.Reset()
			if err := s.HasPages.Decode(d); err != nil {
				return err
			}
		case "has_downloads":
			s.HasDownloads.Reset()
			if err := s.HasDownloads.Decode(d); err != nil {
				return err
			}
		case "archived":
			s.Archived.Reset()
			if err := s.Archived.Decode(d); err != nil {
				return err
			}
		case "disabled":
			s.Disabled.Reset()
			if err := s.Disabled.Decode(d); err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			s.PushedAt.Reset()
			if err := s.PushedAt.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d); err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "subscribers_count":
			s.SubscribersCount.Reset()
			if err := s.SubscribersCount.Decode(d); err != nil {
				return err
			}
		case "network_count":
			s.NetworkCount.Reset()
			if err := s.NetworkCount.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RepositoryTemplateRepositoryOwner) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Login.Set {
		e.FieldStart("login")
		s.Login.Encode(e)
	}
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.NodeID.Set {
		e.FieldStart("node_id")
		s.NodeID.Encode(e)
	}
	if s.AvatarURL.Set {
		e.FieldStart("avatar_url")
		s.AvatarURL.Encode(e)
	}
	if s.GravatarID.Set {
		e.FieldStart("gravatar_id")
		s.GravatarID.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.FollowersURL.Set {
		e.FieldStart("followers_url")
		s.FollowersURL.Encode(e)
	}
	if s.FollowingURL.Set {
		e.FieldStart("following_url")
		s.FollowingURL.Encode(e)
	}
	if s.GistsURL.Set {
		e.FieldStart("gists_url")
		s.GistsURL.Encode(e)
	}
	if s.StarredURL.Set {
		e.FieldStart("starred_url")
		s.StarredURL.Encode(e)
	}
	if s.SubscriptionsURL.Set {
		e.FieldStart("subscriptions_url")
		s.SubscriptionsURL.Encode(e)
	}
	if s.OrganizationsURL.Set {
		e.FieldStart("organizations_url")
		s.OrganizationsURL.Encode(e)
	}
	if s.ReposURL.Set {
		e.FieldStart("repos_url")
		s.ReposURL.Encode(e)
	}
	if s.EventsURL.Set {
		e.FieldStart("events_url")
		s.EventsURL.Encode(e)
	}
	if s.ReceivedEventsURL.Set {
		e.FieldStart("received_events_url")
		s.ReceivedEventsURL.Encode(e)
	}
	if s.Type.Set {
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	if s.SiteAdmin.Set {
		e.FieldStart("site_admin")
		s.SiteAdmin.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes RepositoryTemplateRepositoryOwner from json.
func (s *RepositoryTemplateRepositoryOwner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepositoryTemplateRepositoryOwner to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			s.Login.Reset()
			if err := s.Login.Decode(d); err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "node_id":
			s.NodeID.Reset()
			if err := s.NodeID.Decode(d); err != nil {
				return err
			}
		case "avatar_url":
			s.AvatarURL.Reset()
			if err := s.AvatarURL.Decode(d); err != nil {
				return err
			}
		case "gravatar_id":
			s.GravatarID.Reset()
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "followers_url":
			s.FollowersURL.Reset()
			if err := s.FollowersURL.Decode(d); err != nil {
				return err
			}
		case "following_url":
			s.FollowingURL.Reset()
			if err := s.FollowingURL.Decode(d); err != nil {
				return err
			}
		case "gists_url":
			s.GistsURL.Reset()
			if err := s.GistsURL.Decode(d); err != nil {
				return err
			}
		case "starred_url":
			s.StarredURL.Reset()
			if err := s.StarredURL.Decode(d); err != nil {
				return err
			}
		case "subscriptions_url":
			s.SubscriptionsURL.Reset()
			if err := s.SubscriptionsURL.Decode(d); err != nil {
				return err
			}
		case "organizations_url":
			s.OrganizationsURL.Reset()
			if err := s.OrganizationsURL.Decode(d); err != nil {
				return err
			}
		case "repos_url":
			s.ReposURL.Reset()
			if err := s.ReposURL.Decode(d); err != nil {
				return err
			}
		case "events_url":
			s.EventsURL.Reset()
			if err := s.EventsURL.Decode(d); err != nil {
				return err
			}
		case "received_events_url":
			s.ReceivedEventsURL.Reset()
			if err := s.ReceivedEventsURL.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "site_admin":
			s.SiteAdmin.Reset()
			if err := s.SiteAdmin.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RepositoryTemplateRepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Admin.Set {
		e.FieldStart("admin")
		s.Admin.Encode(e)
	}
	if s.Maintain.Set {
		e.FieldStart("maintain")
		s.Maintain.Encode(e)
	}
	if s.Push.Set {
		e.FieldStart("push")
		s.Push.Encode(e)
	}
	if s.Triage.Set {
		e.FieldStart("triage")
		s.Triage.Encode(e)
	}
	if s.Pull.Set {
		e.FieldStart("pull")
		s.Pull.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes RepositoryTemplateRepositoryPermissions from json.
func (s *RepositoryTemplateRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RepositoryTemplateRepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			s.Admin.Reset()
			if err := s.Admin.Decode(d); err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		case "push":
			s.Push.Reset()
			if err := s.Push.Decode(d); err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "pull":
			s.Pull.Reset()
			if err := s.Pull.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReviewComment) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("pull_request_review_id")
	s.PullRequestReviewID.Encode(e)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("diff_hunk")
	e.Str(s.DiffHunk)

	e.FieldStart("path")
	e.Str(s.Path)

	e.FieldStart("position")
	s.Position.Encode(e)

	e.FieldStart("original_position")
	e.Int(s.OriginalPosition)

	e.FieldStart("commit_id")
	e.Str(s.CommitID)

	e.FieldStart("original_commit_id")
	e.Str(s.OriginalCommitID)
	if s.InReplyToID.Set {
		e.FieldStart("in_reply_to_id")
		s.InReplyToID.Encode(e)
	}

	e.FieldStart("user")
	s.User.Encode(e)

	e.FieldStart("body")
	e.Str(s.Body)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("pull_request_url")
	json.EncodeURI(e, s.PullRequestURL)

	e.FieldStart("author_association")
	s.AuthorAssociation.Encode(e)

	e.FieldStart("_links")
	s.Links.Encode(e)
	if s.BodyText.Set {
		e.FieldStart("body_text")
		s.BodyText.Encode(e)
	}
	if s.BodyHTML.Set {
		e.FieldStart("body_html")
		s.BodyHTML.Encode(e)
	}
	if s.Reactions.Set {
		e.FieldStart("reactions")
		s.Reactions.Encode(e)
	}
	if s.Side.Set {
		e.FieldStart("side")
		s.Side.Encode(e)
	}
	if s.StartSide.Set {
		e.FieldStart("start_side")
		s.StartSide.Encode(e)
	}
	if s.Line.Set {
		e.FieldStart("line")
		s.Line.Encode(e)
	}
	if s.OriginalLine.Set {
		e.FieldStart("original_line")
		s.OriginalLine.Encode(e)
	}
	if s.StartLine.Set {
		e.FieldStart("start_line")
		s.StartLine.Encode(e)
	}
	if s.OriginalStartLine.Set {
		e.FieldStart("original_start_line")
		s.OriginalStartLine.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ReviewComment from json.
func (s *ReviewComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReviewComment to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "pull_request_review_id":
			if err := s.PullRequestReviewID.Decode(d); err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "diff_hunk":
			v, err := d.Str()
			s.DiffHunk = string(v)
			if err != nil {
				return err
			}
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "position":
			if err := s.Position.Decode(d); err != nil {
				return err
			}
		case "original_position":
			v, err := d.Int()
			s.OriginalPosition = int(v)
			if err != nil {
				return err
			}
		case "commit_id":
			v, err := d.Str()
			s.CommitID = string(v)
			if err != nil {
				return err
			}
		case "original_commit_id":
			v, err := d.Str()
			s.OriginalCommitID = string(v)
			if err != nil {
				return err
			}
		case "in_reply_to_id":
			s.InReplyToID.Reset()
			if err := s.InReplyToID.Decode(d); err != nil {
				return err
			}
		case "user":
			if err := s.User.Decode(d); err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "pull_request_url":
			v, err := json.DecodeURI(d)
			s.PullRequestURL = v
			if err != nil {
				return err
			}
		case "author_association":
			if err := s.AuthorAssociation.Decode(d); err != nil {
				return err
			}
		case "_links":
			if err := s.Links.Decode(d); err != nil {
				return err
			}
		case "body_text":
			s.BodyText.Reset()
			if err := s.BodyText.Decode(d); err != nil {
				return err
			}
		case "body_html":
			s.BodyHTML.Reset()
			if err := s.BodyHTML.Decode(d); err != nil {
				return err
			}
		case "reactions":
			s.Reactions.Reset()
			if err := s.Reactions.Decode(d); err != nil {
				return err
			}
		case "side":
			s.Side.Reset()
			if err := s.Side.Decode(d); err != nil {
				return err
			}
		case "start_side":
			s.StartSide.Reset()
			if err := s.StartSide.Decode(d); err != nil {
				return err
			}
		case "line":
			s.Line.Reset()
			if err := s.Line.Decode(d); err != nil {
				return err
			}
		case "original_line":
			s.OriginalLine.Reset()
			if err := s.OriginalLine.Decode(d); err != nil {
				return err
			}
		case "start_line":
			s.StartLine.Reset()
			if err := s.StartLine.Decode(d); err != nil {
				return err
			}
		case "original_start_line":
			s.OriginalStartLine.Reset()
			if err := s.OriginalStartLine.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ReviewCommentLinks) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("self")
	s.Self.Encode(e)

	e.FieldStart("html")
	s.HTML.Encode(e)

	e.FieldStart("pull_request")
	s.PullRequest.Encode(e)
	e.ObjEnd()
}

// Decode decodes ReviewCommentLinks from json.
func (s *ReviewCommentLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReviewCommentLinks to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			if err := s.Self.Decode(d); err != nil {
				return err
			}
		case "html":
			if err := s.HTML.Decode(d); err != nil {
				return err
			}
		case "pull_request":
			if err := s.PullRequest.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes ReviewCommentSide as json.
func (s ReviewCommentSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReviewCommentSide from json.
func (s *ReviewCommentSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReviewCommentSide to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReviewCommentSide(v)
	return nil
}

// Encode encodes ReviewCommentStartSide as json.
func (s ReviewCommentStartSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReviewCommentStartSide from json.
func (s *ReviewCommentStartSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ReviewCommentStartSide to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = ReviewCommentStartSide(v)
	return nil
}

// Encode implements json.Marshaler.
func (s Runner) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("os")
	e.Str(s.Os)

	e.FieldStart("status")
	e.Str(s.Status)

	e.FieldStart("busy")
	e.Bool(s.Busy)

	e.FieldStart("labels")
	e.ArrStart()
	for _, elem := range s.Labels {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes Runner from json.
func (s *Runner) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Runner to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "os":
			v, err := d.Str()
			s.Os = string(v)
			if err != nil {
				return err
			}
		case "status":
			v, err := d.Str()
			s.Status = string(v)
			if err != nil {
				return err
			}
		case "busy":
			v, err := d.Bool()
			s.Busy = bool(v)
			if err != nil {
				return err
			}
		case "labels":
			s.Labels = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem RunnerLabelsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Labels = append(s.Labels, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RunnerApplication) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("os")
	e.Str(s.Os)

	e.FieldStart("architecture")
	e.Str(s.Architecture)

	e.FieldStart("download_url")
	e.Str(s.DownloadURL)

	e.FieldStart("filename")
	e.Str(s.Filename)
	if s.TempDownloadToken.Set {
		e.FieldStart("temp_download_token")
		s.TempDownloadToken.Encode(e)
	}
	if s.SHA256Checksum.Set {
		e.FieldStart("sha256_checksum")
		s.SHA256Checksum.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes RunnerApplication from json.
func (s *RunnerApplication) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RunnerApplication to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "os":
			v, err := d.Str()
			s.Os = string(v)
			if err != nil {
				return err
			}
		case "architecture":
			v, err := d.Str()
			s.Architecture = string(v)
			if err != nil {
				return err
			}
		case "download_url":
			v, err := d.Str()
			s.DownloadURL = string(v)
			if err != nil {
				return err
			}
		case "filename":
			v, err := d.Str()
			s.Filename = string(v)
			if err != nil {
				return err
			}
		case "temp_download_token":
			s.TempDownloadToken.Reset()
			if err := s.TempDownloadToken.Decode(d); err != nil {
				return err
			}
		case "sha256_checksum":
			s.SHA256Checksum.Reset()
			if err := s.SHA256Checksum.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RunnerGroupsEnterprise) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Float64(s.ID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("visibility")
	e.Str(s.Visibility)

	e.FieldStart("default")
	e.Bool(s.Default)
	if s.SelectedOrganizationsURL.Set {
		e.FieldStart("selected_organizations_url")
		s.SelectedOrganizationsURL.Encode(e)
	}

	e.FieldStart("runners_url")
	e.Str(s.RunnersURL)

	e.FieldStart("allows_public_repositories")
	e.Bool(s.AllowsPublicRepositories)
	e.ObjEnd()
}

// Decode decodes RunnerGroupsEnterprise from json.
func (s *RunnerGroupsEnterprise) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RunnerGroupsEnterprise to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Float64()
			s.ID = float64(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "visibility":
			v, err := d.Str()
			s.Visibility = string(v)
			if err != nil {
				return err
			}
		case "default":
			v, err := d.Bool()
			s.Default = bool(v)
			if err != nil {
				return err
			}
		case "selected_organizations_url":
			s.SelectedOrganizationsURL.Reset()
			if err := s.SelectedOrganizationsURL.Decode(d); err != nil {
				return err
			}
		case "runners_url":
			v, err := d.Str()
			s.RunnersURL = string(v)
			if err != nil {
				return err
			}
		case "allows_public_repositories":
			v, err := d.Bool()
			s.AllowsPublicRepositories = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RunnerGroupsOrg) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Float64(s.ID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("visibility")
	e.Str(s.Visibility)

	e.FieldStart("default")
	e.Bool(s.Default)
	if s.SelectedRepositoriesURL.Set {
		e.FieldStart("selected_repositories_url")
		s.SelectedRepositoriesURL.Encode(e)
	}

	e.FieldStart("runners_url")
	e.Str(s.RunnersURL)

	e.FieldStart("inherited")
	e.Bool(s.Inherited)
	if s.InheritedAllowsPublicRepositories.Set {
		e.FieldStart("inherited_allows_public_repositories")
		s.InheritedAllowsPublicRepositories.Encode(e)
	}

	e.FieldStart("allows_public_repositories")
	e.Bool(s.AllowsPublicRepositories)
	e.ObjEnd()
}

// Decode decodes RunnerGroupsOrg from json.
func (s *RunnerGroupsOrg) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RunnerGroupsOrg to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Float64()
			s.ID = float64(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "visibility":
			v, err := d.Str()
			s.Visibility = string(v)
			if err != nil {
				return err
			}
		case "default":
			v, err := d.Bool()
			s.Default = bool(v)
			if err != nil {
				return err
			}
		case "selected_repositories_url":
			s.SelectedRepositoriesURL.Reset()
			if err := s.SelectedRepositoriesURL.Decode(d); err != nil {
				return err
			}
		case "runners_url":
			v, err := d.Str()
			s.RunnersURL = string(v)
			if err != nil {
				return err
			}
		case "inherited":
			v, err := d.Bool()
			s.Inherited = bool(v)
			if err != nil {
				return err
			}
		case "inherited_allows_public_repositories":
			s.InheritedAllowsPublicRepositories.Reset()
			if err := s.InheritedAllowsPublicRepositories.Decode(d); err != nil {
				return err
			}
		case "allows_public_repositories":
			v, err := d.Bool()
			s.AllowsPublicRepositories = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s RunnerLabelsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Type.Set {
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes RunnerLabelsItem from json.
func (s *RunnerLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RunnerLabelsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes RunnerLabelsItemType as json.
func (s RunnerLabelsItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RunnerLabelsItemType from json.
func (s *RunnerLabelsItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode RunnerLabelsItemType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = RunnerLabelsItemType(v)
	return nil
}

// Encode encodes ScimDeleteUserFromOrgApplicationJSONForbidden as json.
func (s ScimDeleteUserFromOrgApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := ScimError(s)
	unwrapped.Encode(e)
}

// Decode decodes ScimDeleteUserFromOrgApplicationJSONForbidden from json.
func (s *ScimDeleteUserFromOrgApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimDeleteUserFromOrgApplicationJSONForbidden to nil`)
	}
	var unwrapped ScimError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ScimDeleteUserFromOrgApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes ScimDeleteUserFromOrgApplicationJSONNotFound as json.
func (s ScimDeleteUserFromOrgApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := ScimError(s)
	unwrapped.Encode(e)
}

// Decode decodes ScimDeleteUserFromOrgApplicationJSONNotFound from json.
func (s *ScimDeleteUserFromOrgApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimDeleteUserFromOrgApplicationJSONNotFound to nil`)
	}
	var unwrapped ScimError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ScimDeleteUserFromOrgApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ScimDeleteUserFromOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes ScimDeleteUserFromOrgNoContent from json.
func (s *ScimDeleteUserFromOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimDeleteUserFromOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseGroup) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("schemas")
	e.ArrStart()
	for _, elem := range s.Schemas {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("id")
	e.Str(s.ID)
	if s.ExternalId.Set {
		e.FieldStart("externalId")
		s.ExternalId.Encode(e)
	}
	if s.DisplayName.Set {
		e.FieldStart("displayName")
		s.DisplayName.Encode(e)
	}
	if s.Members != nil {
		e.FieldStart("members")
		e.ArrStart()
		for _, elem := range s.Members {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Meta.Set {
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimEnterpriseGroup from json.
func (s *ScimEnterpriseGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimEnterpriseGroup to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "externalId":
			s.ExternalId.Reset()
			if err := s.ExternalId.Decode(d); err != nil {
				return err
			}
		case "displayName":
			s.DisplayName.Reset()
			if err := s.DisplayName.Decode(d); err != nil {
				return err
			}
		case "members":
			s.Members = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimEnterpriseGroupMembersItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Members = append(s.Members, elem)
				return nil
			}); err != nil {
				return err
			}
		case "meta":
			s.Meta.Reset()
			if err := s.Meta.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseGroupMembersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Value.Set {
		e.FieldStart("value")
		s.Value.Encode(e)
	}
	if s.Ref.Set {
		e.FieldStart("$ref")
		s.Ref.Encode(e)
	}
	if s.Display.Set {
		e.FieldStart("display")
		s.Display.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimEnterpriseGroupMembersItem from json.
func (s *ScimEnterpriseGroupMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimEnterpriseGroupMembersItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		case "$ref":
			s.Ref.Reset()
			if err := s.Ref.Decode(d); err != nil {
				return err
			}
		case "display":
			s.Display.Reset()
			if err := s.Display.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseGroupMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ResourceType.Set {
		e.FieldStart("resourceType")
		s.ResourceType.Encode(e)
	}
	if s.Created.Set {
		e.FieldStart("created")
		s.Created.Encode(e)
	}
	if s.LastModified.Set {
		e.FieldStart("lastModified")
		s.LastModified.Encode(e)
	}
	if s.Location.Set {
		e.FieldStart("location")
		s.Location.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimEnterpriseGroupMeta from json.
func (s *ScimEnterpriseGroupMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimEnterpriseGroupMeta to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			s.ResourceType.Reset()
			if err := s.ResourceType.Decode(d); err != nil {
				return err
			}
		case "created":
			s.Created.Reset()
			if err := s.Created.Decode(d); err != nil {
				return err
			}
		case "lastModified":
			s.LastModified.Reset()
			if err := s.LastModified.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseUser) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("schemas")
	e.ArrStart()
	for _, elem := range s.Schemas {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("id")
	e.Str(s.ID)
	if s.ExternalId.Set {
		e.FieldStart("externalId")
		s.ExternalId.Encode(e)
	}
	if s.UserName.Set {
		e.FieldStart("userName")
		s.UserName.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Emails != nil {
		e.FieldStart("emails")
		e.ArrStart()
		for _, elem := range s.Emails {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Groups != nil {
		e.FieldStart("groups")
		e.ArrStart()
		for _, elem := range s.Groups {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Active.Set {
		e.FieldStart("active")
		s.Active.Encode(e)
	}
	if s.Meta.Set {
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimEnterpriseUser from json.
func (s *ScimEnterpriseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimEnterpriseUser to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "externalId":
			s.ExternalId.Reset()
			if err := s.ExternalId.Decode(d); err != nil {
				return err
			}
		case "userName":
			s.UserName.Reset()
			if err := s.UserName.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimEnterpriseUserEmailsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimEnterpriseUserGroupsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		case "meta":
			s.Meta.Reset()
			if err := s.Meta.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseUserEmailsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Value.Set {
		e.FieldStart("value")
		s.Value.Encode(e)
	}
	if s.Type.Set {
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	if s.Primary.Set {
		e.FieldStart("primary")
		s.Primary.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimEnterpriseUserEmailsItem from json.
func (s *ScimEnterpriseUserEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimEnterpriseUserEmailsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "primary":
			s.Primary.Reset()
			if err := s.Primary.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseUserGroupsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Value.Set {
		e.FieldStart("value")
		s.Value.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimEnterpriseUserGroupsItem from json.
func (s *ScimEnterpriseUserGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimEnterpriseUserGroupsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseUserMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ResourceType.Set {
		e.FieldStart("resourceType")
		s.ResourceType.Encode(e)
	}
	if s.Created.Set {
		e.FieldStart("created")
		s.Created.Encode(e)
	}
	if s.LastModified.Set {
		e.FieldStart("lastModified")
		s.LastModified.Encode(e)
	}
	if s.Location.Set {
		e.FieldStart("location")
		s.Location.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimEnterpriseUserMeta from json.
func (s *ScimEnterpriseUserMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimEnterpriseUserMeta to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			s.ResourceType.Reset()
			if err := s.ResourceType.Decode(d); err != nil {
				return err
			}
		case "created":
			s.Created.Reset()
			if err := s.Created.Decode(d); err != nil {
				return err
			}
		case "lastModified":
			s.LastModified.Reset()
			if err := s.LastModified.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimEnterpriseUserName) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.GivenName.Set {
		e.FieldStart("givenName")
		s.GivenName.Encode(e)
	}
	if s.FamilyName.Set {
		e.FieldStart("familyName")
		s.FamilyName.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimEnterpriseUserName from json.
func (s *ScimEnterpriseUserName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimEnterpriseUserName to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			s.GivenName.Reset()
			if err := s.GivenName.Decode(d); err != nil {
				return err
			}
		case "familyName":
			s.FamilyName.Reset()
			if err := s.FamilyName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimError) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.DocumentationURL.Set {
		e.FieldStart("documentation_url")
		s.DocumentationURL.Encode(e)
	}
	if s.Detail.Set {
		e.FieldStart("detail")
		s.Detail.Encode(e)
	}
	if s.Status.Set {
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	if s.ScimType.Set {
		e.FieldStart("scimType")
		s.ScimType.Encode(e)
	}
	if s.Schemas != nil {
		e.FieldStart("schemas")
		e.ArrStart()
		for _, elem := range s.Schemas {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ScimError from json.
func (s *ScimError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimError to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		case "detail":
			s.Detail.Reset()
			if err := s.Detail.Decode(d); err != nil {
				return err
			}
		case "status":
			s.Status.Reset()
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "scimType":
			s.ScimType.Reset()
			if err := s.ScimType.Decode(d); err != nil {
				return err
			}
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimGroupListEnterprise) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("schemas")
	e.ArrStart()
	for _, elem := range s.Schemas {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("totalResults")
	e.Float64(s.TotalResults)

	e.FieldStart("itemsPerPage")
	e.Float64(s.ItemsPerPage)

	e.FieldStart("startIndex")
	e.Float64(s.StartIndex)

	e.FieldStart("Resources")
	e.ArrStart()
	for _, elem := range s.Resources {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ScimGroupListEnterprise from json.
func (s *ScimGroupListEnterprise) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimGroupListEnterprise to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "totalResults":
			v, err := d.Float64()
			s.TotalResults = float64(v)
			if err != nil {
				return err
			}
		case "itemsPerPage":
			v, err := d.Float64()
			s.ItemsPerPage = float64(v)
			if err != nil {
				return err
			}
		case "startIndex":
			v, err := d.Float64()
			s.StartIndex = float64(v)
			if err != nil {
				return err
			}
		case "Resources":
			s.Resources = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimGroupListEnterpriseResourcesItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Resources = append(s.Resources, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimGroupListEnterpriseResourcesItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("schemas")
	e.ArrStart()
	for _, elem := range s.Schemas {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("id")
	e.Str(s.ID)
	if s.ExternalId.Set {
		e.FieldStart("externalId")
		s.ExternalId.Encode(e)
	}
	if s.DisplayName.Set {
		e.FieldStart("displayName")
		s.DisplayName.Encode(e)
	}
	if s.Members != nil {
		e.FieldStart("members")
		e.ArrStart()
		for _, elem := range s.Members {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Meta.Set {
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimGroupListEnterpriseResourcesItem from json.
func (s *ScimGroupListEnterpriseResourcesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimGroupListEnterpriseResourcesItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "externalId":
			s.ExternalId.Reset()
			if err := s.ExternalId.Decode(d); err != nil {
				return err
			}
		case "displayName":
			s.DisplayName.Reset()
			if err := s.DisplayName.Decode(d); err != nil {
				return err
			}
		case "members":
			s.Members = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimGroupListEnterpriseResourcesItemMembersItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Members = append(s.Members, elem)
				return nil
			}); err != nil {
				return err
			}
		case "meta":
			s.Meta.Reset()
			if err := s.Meta.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimGroupListEnterpriseResourcesItemMembersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Value.Set {
		e.FieldStart("value")
		s.Value.Encode(e)
	}
	if s.Ref.Set {
		e.FieldStart("$ref")
		s.Ref.Encode(e)
	}
	if s.Display.Set {
		e.FieldStart("display")
		s.Display.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimGroupListEnterpriseResourcesItemMembersItem from json.
func (s *ScimGroupListEnterpriseResourcesItemMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimGroupListEnterpriseResourcesItemMembersItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		case "$ref":
			s.Ref.Reset()
			if err := s.Ref.Decode(d); err != nil {
				return err
			}
		case "display":
			s.Display.Reset()
			if err := s.Display.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimGroupListEnterpriseResourcesItemMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ResourceType.Set {
		e.FieldStart("resourceType")
		s.ResourceType.Encode(e)
	}
	if s.Created.Set {
		e.FieldStart("created")
		s.Created.Encode(e)
	}
	if s.LastModified.Set {
		e.FieldStart("lastModified")
		s.LastModified.Encode(e)
	}
	if s.Location.Set {
		e.FieldStart("location")
		s.Location.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimGroupListEnterpriseResourcesItemMeta from json.
func (s *ScimGroupListEnterpriseResourcesItemMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimGroupListEnterpriseResourcesItemMeta to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			s.ResourceType.Reset()
			if err := s.ResourceType.Decode(d); err != nil {
				return err
			}
		case "created":
			s.Created.Reset()
			if err := s.Created.Decode(d); err != nil {
				return err
			}
		case "lastModified":
			s.LastModified.Reset()
			if err := s.LastModified.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimProvisionAndInviteUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("userName")
	e.Str(s.UserName)
	if s.DisplayName.Set {
		e.FieldStart("displayName")
		s.DisplayName.Encode(e)
	}

	e.FieldStart("name")
	s.Name.Encode(e)

	e.FieldStart("emails")
	e.ArrStart()
	for _, elem := range s.Emails {
		elem.Encode(e)
	}
	e.ArrEnd()
	if s.Schemas != nil {
		e.FieldStart("schemas")
		e.ArrStart()
		for _, elem := range s.Schemas {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.ExternalId.Set {
		e.FieldStart("externalId")
		s.ExternalId.Encode(e)
	}
	if s.Groups != nil {
		e.FieldStart("groups")
		e.ArrStart()
		for _, elem := range s.Groups {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Active.Set {
		e.FieldStart("active")
		s.Active.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimProvisionAndInviteUserReq from json.
func (s *ScimProvisionAndInviteUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimProvisionAndInviteUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "userName":
			v, err := d.Str()
			s.UserName = string(v)
			if err != nil {
				return err
			}
		case "displayName":
			s.DisplayName.Reset()
			if err := s.DisplayName.Decode(d); err != nil {
				return err
			}
		case "name":
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimProvisionAndInviteUserReqEmailsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "externalId":
			s.ExternalId.Reset()
			if err := s.ExternalId.Decode(d); err != nil {
				return err
			}
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimProvisionAndInviteUserReqEmailsItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("value")
	e.Str(s.Value)
	if s.Primary.Set {
		e.FieldStart("primary")
		s.Primary.Encode(e)
	}
	if s.Type.Set {
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimProvisionAndInviteUserReqEmailsItem from json.
func (s *ScimProvisionAndInviteUserReqEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimProvisionAndInviteUserReqEmailsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			v, err := d.Str()
			s.Value = string(v)
			if err != nil {
				return err
			}
		case "primary":
			s.Primary.Reset()
			if err := s.Primary.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimProvisionAndInviteUserReqName) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("givenName")
	e.Str(s.GivenName)

	e.FieldStart("familyName")
	e.Str(s.FamilyName)
	if s.Formatted.Set {
		e.FieldStart("formatted")
		s.Formatted.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimProvisionAndInviteUserReqName from json.
func (s *ScimProvisionAndInviteUserReqName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimProvisionAndInviteUserReqName to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			v, err := d.Str()
			s.GivenName = string(v)
			if err != nil {
				return err
			}
		case "familyName":
			v, err := d.Str()
			s.FamilyName = string(v)
			if err != nil {
				return err
			}
		case "formatted":
			s.Formatted.Reset()
			if err := s.Formatted.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimSetInformationForProvisionedUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Schemas != nil {
		e.FieldStart("schemas")
		e.ArrStart()
		for _, elem := range s.Schemas {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.DisplayName.Set {
		e.FieldStart("displayName")
		s.DisplayName.Encode(e)
	}
	if s.ExternalId.Set {
		e.FieldStart("externalId")
		s.ExternalId.Encode(e)
	}
	if s.Groups != nil {
		e.FieldStart("groups")
		e.ArrStart()
		for _, elem := range s.Groups {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Active.Set {
		e.FieldStart("active")
		s.Active.Encode(e)
	}

	e.FieldStart("userName")
	e.Str(s.UserName)

	e.FieldStart("name")
	s.Name.Encode(e)

	e.FieldStart("emails")
	e.ArrStart()
	for _, elem := range s.Emails {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ScimSetInformationForProvisionedUserReq from json.
func (s *ScimSetInformationForProvisionedUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimSetInformationForProvisionedUserReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "displayName":
			s.DisplayName.Reset()
			if err := s.DisplayName.Decode(d); err != nil {
				return err
			}
		case "externalId":
			s.ExternalId.Reset()
			if err := s.ExternalId.Decode(d); err != nil {
				return err
			}
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		case "userName":
			v, err := d.Str()
			s.UserName = string(v)
			if err != nil {
				return err
			}
		case "name":
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimSetInformationForProvisionedUserReqEmailsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimSetInformationForProvisionedUserReqEmailsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Type.Set {
		e.FieldStart("type")
		s.Type.Encode(e)
	}

	e.FieldStart("value")
	e.Str(s.Value)
	if s.Primary.Set {
		e.FieldStart("primary")
		s.Primary.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimSetInformationForProvisionedUserReqEmailsItem from json.
func (s *ScimSetInformationForProvisionedUserReqEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimSetInformationForProvisionedUserReqEmailsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		case "value":
			v, err := d.Str()
			s.Value = string(v)
			if err != nil {
				return err
			}
		case "primary":
			s.Primary.Reset()
			if err := s.Primary.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimSetInformationForProvisionedUserReqName) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("givenName")
	e.Str(s.GivenName)

	e.FieldStart("familyName")
	e.Str(s.FamilyName)
	if s.Formatted.Set {
		e.FieldStart("formatted")
		s.Formatted.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimSetInformationForProvisionedUserReqName from json.
func (s *ScimSetInformationForProvisionedUserReqName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimSetInformationForProvisionedUserReqName to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			v, err := d.Str()
			s.GivenName = string(v)
			if err != nil {
				return err
			}
		case "familyName":
			v, err := d.Str()
			s.FamilyName = string(v)
			if err != nil {
				return err
			}
		case "formatted":
			s.Formatted.Reset()
			if err := s.Formatted.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterprise) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("schemas")
	e.ArrStart()
	for _, elem := range s.Schemas {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("totalResults")
	e.Float64(s.TotalResults)

	e.FieldStart("itemsPerPage")
	e.Float64(s.ItemsPerPage)

	e.FieldStart("startIndex")
	e.Float64(s.StartIndex)

	e.FieldStart("Resources")
	e.ArrStart()
	for _, elem := range s.Resources {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ScimUserListEnterprise from json.
func (s *ScimUserListEnterprise) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUserListEnterprise to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "totalResults":
			v, err := d.Float64()
			s.TotalResults = float64(v)
			if err != nil {
				return err
			}
		case "itemsPerPage":
			v, err := d.Float64()
			s.ItemsPerPage = float64(v)
			if err != nil {
				return err
			}
		case "startIndex":
			v, err := d.Float64()
			s.StartIndex = float64(v)
			if err != nil {
				return err
			}
		case "Resources":
			s.Resources = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimUserListEnterpriseResourcesItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Resources = append(s.Resources, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterpriseResourcesItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("schemas")
	e.ArrStart()
	for _, elem := range s.Schemas {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("id")
	e.Str(s.ID)
	if s.ExternalId.Set {
		e.FieldStart("externalId")
		s.ExternalId.Encode(e)
	}
	if s.UserName.Set {
		e.FieldStart("userName")
		s.UserName.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Emails != nil {
		e.FieldStart("emails")
		e.ArrStart()
		for _, elem := range s.Emails {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Groups != nil {
		e.FieldStart("groups")
		e.ArrStart()
		for _, elem := range s.Groups {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	if s.Active.Set {
		e.FieldStart("active")
		s.Active.Encode(e)
	}
	if s.Meta.Set {
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimUserListEnterpriseResourcesItem from json.
func (s *ScimUserListEnterpriseResourcesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUserListEnterpriseResourcesItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			s.Schemas = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Schemas = append(s.Schemas, elem)
				return nil
			}); err != nil {
				return err
			}
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "externalId":
			s.ExternalId.Reset()
			if err := s.ExternalId.Decode(d); err != nil {
				return err
			}
		case "userName":
			s.UserName.Reset()
			if err := s.UserName.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "emails":
			s.Emails = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimUserListEnterpriseResourcesItemEmailsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Emails = append(s.Emails, elem)
				return nil
			}); err != nil {
				return err
			}
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem ScimUserListEnterpriseResourcesItemGroupsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "active":
			s.Active.Reset()
			if err := s.Active.Decode(d); err != nil {
				return err
			}
		case "meta":
			s.Meta.Reset()
			if err := s.Meta.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterpriseResourcesItemEmailsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Value.Set {
		e.FieldStart("value")
		s.Value.Encode(e)
	}
	if s.Primary.Set {
		e.FieldStart("primary")
		s.Primary.Encode(e)
	}
	if s.Type.Set {
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimUserListEnterpriseResourcesItemEmailsItem from json.
func (s *ScimUserListEnterpriseResourcesItemEmailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUserListEnterpriseResourcesItemEmailsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		case "primary":
			s.Primary.Reset()
			if err := s.Primary.Decode(d); err != nil {
				return err
			}
		case "type":
			s.Type.Reset()
			if err := s.Type.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterpriseResourcesItemGroupsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Value.Set {
		e.FieldStart("value")
		s.Value.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimUserListEnterpriseResourcesItemGroupsItem from json.
func (s *ScimUserListEnterpriseResourcesItemGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUserListEnterpriseResourcesItemGroupsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			s.Value.Reset()
			if err := s.Value.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterpriseResourcesItemMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ResourceType.Set {
		e.FieldStart("resourceType")
		s.ResourceType.Encode(e)
	}
	if s.Created.Set {
		e.FieldStart("created")
		s.Created.Encode(e)
	}
	if s.LastModified.Set {
		e.FieldStart("lastModified")
		s.LastModified.Encode(e)
	}
	if s.Location.Set {
		e.FieldStart("location")
		s.Location.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimUserListEnterpriseResourcesItemMeta from json.
func (s *ScimUserListEnterpriseResourcesItemMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUserListEnterpriseResourcesItemMeta to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resourceType":
			s.ResourceType.Reset()
			if err := s.ResourceType.Decode(d); err != nil {
				return err
			}
		case "created":
			s.Created.Reset()
			if err := s.Created.Decode(d); err != nil {
				return err
			}
		case "lastModified":
			s.LastModified.Reset()
			if err := s.LastModified.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ScimUserListEnterpriseResourcesItemName) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.GivenName.Set {
		e.FieldStart("givenName")
		s.GivenName.Encode(e)
	}
	if s.FamilyName.Set {
		e.FieldStart("familyName")
		s.FamilyName.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ScimUserListEnterpriseResourcesItemName from json.
func (s *ScimUserListEnterpriseResourcesItemName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ScimUserListEnterpriseResourcesItemName to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "givenName":
			s.GivenName.Reset()
			if err := s.GivenName.Decode(d); err != nil {
				return err
			}
		case "familyName":
			s.FamilyName.Reset()
			if err := s.FamilyName.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SearchCodeOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("incomplete_results")
	e.Bool(s.IncompleteResults)

	e.FieldStart("items")
	e.ArrStart()
	for _, elem := range s.Items {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes SearchCodeOK from json.
func (s *SearchCodeOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchCodeOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "incomplete_results":
			v, err := d.Bool()
			s.IncompleteResults = bool(v)
			if err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CodeSearchResultItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SearchCodeOrder as json.
func (s SearchCodeOrder) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchCodeOrder from json.
func (s *SearchCodeOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchCodeOrder to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = SearchCodeOrder(v)
	return nil
}

// Encode encodes SearchCodeSort as json.
func (s SearchCodeSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchCodeSort from json.
func (s *SearchCodeSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchCodeSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = SearchCodeSort(v)
	return nil
}

// Encode implements json.Marshaler.
func (s SearchCommitsOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("incomplete_results")
	e.Bool(s.IncompleteResults)

	e.FieldStart("items")
	e.ArrStart()
	for _, elem := range s.Items {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes SearchCommitsOK from json.
func (s *SearchCommitsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchCommitsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "incomplete_results":
			v, err := d.Bool()
			s.IncompleteResults = bool(v)
			if err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem CommitSearchResultItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SearchCommitsOrder as json.
func (s SearchCommitsOrder) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchCommitsOrder from json.
func (s *SearchCommitsOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchCommitsOrder to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = SearchCommitsOrder(v)
	return nil
}

// Encode encodes SearchCommitsSort as json.
func (s SearchCommitsSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchCommitsSort from json.
func (s *SearchCommitsSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchCommitsSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = SearchCommitsSort(v)
	return nil
}

// Encode implements json.Marshaler.
func (s SearchIssuesAndPullRequestsOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("incomplete_results")
	e.Bool(s.IncompleteResults)

	e.FieldStart("items")
	e.ArrStart()
	for _, elem := range s.Items {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes SearchIssuesAndPullRequestsOK from json.
func (s *SearchIssuesAndPullRequestsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchIssuesAndPullRequestsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "incomplete_results":
			v, err := d.Bool()
			s.IncompleteResults = bool(v)
			if err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem IssueSearchResultItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SearchIssuesAndPullRequestsOrder as json.
func (s SearchIssuesAndPullRequestsOrder) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchIssuesAndPullRequestsOrder from json.
func (s *SearchIssuesAndPullRequestsOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchIssuesAndPullRequestsOrder to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = SearchIssuesAndPullRequestsOrder(v)
	return nil
}

// Encode encodes SearchIssuesAndPullRequestsSort as json.
func (s SearchIssuesAndPullRequestsSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchIssuesAndPullRequestsSort from json.
func (s *SearchIssuesAndPullRequestsSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchIssuesAndPullRequestsSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = SearchIssuesAndPullRequestsSort(v)
	return nil
}

// Encode implements json.Marshaler.
func (s SearchLabelsOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("incomplete_results")
	e.Bool(s.IncompleteResults)

	e.FieldStart("items")
	e.ArrStart()
	for _, elem := range s.Items {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes SearchLabelsOK from json.
func (s *SearchLabelsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchLabelsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "incomplete_results":
			v, err := d.Bool()
			s.IncompleteResults = bool(v)
			if err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem LabelSearchResultItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SearchLabelsOrder as json.
func (s SearchLabelsOrder) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchLabelsOrder from json.
func (s *SearchLabelsOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchLabelsOrder to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = SearchLabelsOrder(v)
	return nil
}

// Encode encodes SearchLabelsSort as json.
func (s SearchLabelsSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchLabelsSort from json.
func (s *SearchLabelsSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchLabelsSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = SearchLabelsSort(v)
	return nil
}

// Encode implements json.Marshaler.
func (s SearchReposOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("incomplete_results")
	e.Bool(s.IncompleteResults)

	e.FieldStart("items")
	e.ArrStart()
	for _, elem := range s.Items {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes SearchReposOK from json.
func (s *SearchReposOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchReposOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "incomplete_results":
			v, err := d.Bool()
			s.IncompleteResults = bool(v)
			if err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem RepoSearchResultItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SearchReposOrder as json.
func (s SearchReposOrder) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchReposOrder from json.
func (s *SearchReposOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchReposOrder to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = SearchReposOrder(v)
	return nil
}

// Encode encodes SearchReposSort as json.
func (s SearchReposSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchReposSort from json.
func (s *SearchReposSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchReposSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = SearchReposSort(v)
	return nil
}

// Encode encodes SearchResultTextMatches as json.
func (s SearchResultTextMatches) Encode(e *jx.Encoder) {
	unwrapped := []SearchResultTextMatchesItem(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes SearchResultTextMatches from json.
func (s *SearchResultTextMatches) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchResultTextMatches to nil`)
	}
	var unwrapped []SearchResultTextMatchesItem
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SearchResultTextMatchesItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchResultTextMatches(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s SearchResultTextMatchesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ObjectURL.Set {
		e.FieldStart("object_url")
		s.ObjectURL.Encode(e)
	}
	if s.ObjectType.Set {
		e.FieldStart("object_type")
		s.ObjectType.Encode(e)
	}
	if s.Property.Set {
		e.FieldStart("property")
		s.Property.Encode(e)
	}
	if s.Fragment.Set {
		e.FieldStart("fragment")
		s.Fragment.Encode(e)
	}
	if s.Matches != nil {
		e.FieldStart("matches")
		e.ArrStart()
		for _, elem := range s.Matches {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes SearchResultTextMatchesItem from json.
func (s *SearchResultTextMatchesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchResultTextMatchesItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object_url":
			s.ObjectURL.Reset()
			if err := s.ObjectURL.Decode(d); err != nil {
				return err
			}
		case "object_type":
			s.ObjectType.Reset()
			if err := s.ObjectType.Decode(d); err != nil {
				return err
			}
		case "property":
			s.Property.Reset()
			if err := s.Property.Decode(d); err != nil {
				return err
			}
		case "fragment":
			s.Fragment.Reset()
			if err := s.Fragment.Decode(d); err != nil {
				return err
			}
		case "matches":
			s.Matches = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem SearchResultTextMatchesItemMatchesItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Matches = append(s.Matches, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SearchResultTextMatchesItemMatchesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Text.Set {
		e.FieldStart("text")
		s.Text.Encode(e)
	}
	if s.Indices != nil {
		e.FieldStart("indices")
		e.ArrStart()
		for _, elem := range s.Indices {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes SearchResultTextMatchesItemMatchesItem from json.
func (s *SearchResultTextMatchesItemMatchesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchResultTextMatchesItemMatchesItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			s.Text.Reset()
			if err := s.Text.Decode(d); err != nil {
				return err
			}
		case "indices":
			s.Indices = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem int
				v, err := d.Int()
				elem = int(v)
				if err != nil {
					return err
				}
				s.Indices = append(s.Indices, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SearchTopicsOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("incomplete_results")
	e.Bool(s.IncompleteResults)

	e.FieldStart("items")
	e.ArrStart()
	for _, elem := range s.Items {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes SearchTopicsOK from json.
func (s *SearchTopicsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchTopicsOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "incomplete_results":
			v, err := d.Bool()
			s.IncompleteResults = bool(v)
			if err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem TopicSearchResultItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SearchUsersOK) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_count")
	e.Int(s.TotalCount)

	e.FieldStart("incomplete_results")
	e.Bool(s.IncompleteResults)

	e.FieldStart("items")
	e.ArrStart()
	for _, elem := range s.Items {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes SearchUsersOK from json.
func (s *SearchUsersOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchUsersOK to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			v, err := d.Int()
			s.TotalCount = int(v)
			if err != nil {
				return err
			}
		case "incomplete_results":
			v, err := d.Bool()
			s.IncompleteResults = bool(v)
			if err != nil {
				return err
			}
		case "items":
			s.Items = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem UserSearchResultItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = append(s.Items, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SearchUsersOrder as json.
func (s SearchUsersOrder) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchUsersOrder from json.
func (s *SearchUsersOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchUsersOrder to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = SearchUsersOrder(v)
	return nil
}

// Encode encodes SearchUsersSort as json.
func (s SearchUsersSort) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchUsersSort from json.
func (s *SearchUsersSort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SearchUsersSort to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = SearchUsersSort(v)
	return nil
}

// Encode implements json.Marshaler.
func (s SecretScanningAlert) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Number.Set {
		e.FieldStart("number")
		s.Number.Encode(e)
	}
	if s.CreatedAt.Set {
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e)
	}
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.HTMLURL.Set {
		e.FieldStart("html_url")
		s.HTMLURL.Encode(e)
	}
	if s.LocationsURL.Set {
		e.FieldStart("locations_url")
		s.LocationsURL.Encode(e)
	}
	if s.State.Set {
		e.FieldStart("state")
		s.State.Encode(e)
	}
	if s.Resolution.Set {
		e.FieldStart("resolution")
		s.Resolution.Encode(e)
	}
	if s.ResolvedAt.Set {
		e.FieldStart("resolved_at")
		s.ResolvedAt.Encode(e, json.EncodeDateTime)
	}
	if s.ResolvedBy.Set {
		e.FieldStart("resolved_by")
		s.ResolvedBy.Encode(e)
	}
	if s.SecretType.Set {
		e.FieldStart("secret_type")
		s.SecretType.Encode(e)
	}
	if s.Secret.Set {
		e.FieldStart("secret")
		s.Secret.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SecretScanningAlert from json.
func (s *SecretScanningAlert) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningAlert to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			s.Number.Reset()
			if err := s.Number.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d); err != nil {
				return err
			}
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "html_url":
			s.HTMLURL.Reset()
			if err := s.HTMLURL.Decode(d); err != nil {
				return err
			}
		case "locations_url":
			s.LocationsURL.Reset()
			if err := s.LocationsURL.Decode(d); err != nil {
				return err
			}
		case "state":
			s.State.Reset()
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "resolution":
			s.Resolution.Reset()
			if err := s.Resolution.Decode(d); err != nil {
				return err
			}
		case "resolved_at":
			s.ResolvedAt.Reset()
			if err := s.ResolvedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "resolved_by":
			s.ResolvedBy.Reset()
			if err := s.ResolvedBy.Decode(d); err != nil {
				return err
			}
		case "secret_type":
			s.SecretType.Reset()
			if err := s.SecretType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SecretScanningAlertResolution as json.
func (s SecretScanningAlertResolution) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SecretScanningAlertResolution from json.
func (s *SecretScanningAlertResolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningAlertResolution to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = SecretScanningAlertResolution(v)
	return nil
}

// Encode encodes SecretScanningAlertState as json.
func (s SecretScanningAlertState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SecretScanningAlertState from json.
func (s *SecretScanningAlertState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningAlertState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = SecretScanningAlertState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s SecretScanningGetAlertNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes SecretScanningGetAlertNotFound from json.
func (s *SecretScanningGetAlertNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningGetAlertNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SecretScanningListAlertsForOrgOKApplicationJSON as json.
func (s SecretScanningListAlertsForOrgOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []OrganizationSecretScanningAlert(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes SecretScanningListAlertsForOrgOKApplicationJSON from json.
func (s *SecretScanningListAlertsForOrgOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningListAlertsForOrgOKApplicationJSON to nil`)
	}
	var unwrapped []OrganizationSecretScanningAlert
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrganizationSecretScanningAlert
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SecretScanningListAlertsForOrgOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes SecretScanningListAlertsForOrgState as json.
func (s SecretScanningListAlertsForOrgState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SecretScanningListAlertsForOrgState from json.
func (s *SecretScanningListAlertsForOrgState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningListAlertsForOrgState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = SecretScanningListAlertsForOrgState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s SecretScanningListAlertsForRepoNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes SecretScanningListAlertsForRepoNotFound from json.
func (s *SecretScanningListAlertsForRepoNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningListAlertsForRepoNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SecretScanningListAlertsForRepoOKApplicationJSON as json.
func (s SecretScanningListAlertsForRepoOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SecretScanningAlert(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes SecretScanningListAlertsForRepoOKApplicationJSON from json.
func (s *SecretScanningListAlertsForRepoOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningListAlertsForRepoOKApplicationJSON to nil`)
	}
	var unwrapped []SecretScanningAlert
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SecretScanningAlert
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SecretScanningListAlertsForRepoOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes SecretScanningListAlertsForRepoState as json.
func (s SecretScanningListAlertsForRepoState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SecretScanningListAlertsForRepoState from json.
func (s *SecretScanningListAlertsForRepoState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningListAlertsForRepoState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = SecretScanningListAlertsForRepoState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s SecretScanningUpdateAlertNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes SecretScanningUpdateAlertNotFound from json.
func (s *SecretScanningUpdateAlertNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningUpdateAlertNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SecretScanningUpdateAlertReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("state")
	s.State.Encode(e)
	if s.Resolution.Set {
		e.FieldStart("resolution")
		s.Resolution.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SecretScanningUpdateAlertReq from json.
func (s *SecretScanningUpdateAlertReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningUpdateAlertReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "resolution":
			s.Resolution.Reset()
			if err := s.Resolution.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SecretScanningUpdateAlertUnprocessableEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes SecretScanningUpdateAlertUnprocessableEntity from json.
func (s *SecretScanningUpdateAlertUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SecretScanningUpdateAlertUnprocessableEntity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SelectedActions) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.GithubOwnedAllowed.Set {
		e.FieldStart("github_owned_allowed")
		s.GithubOwnedAllowed.Encode(e)
	}
	if s.VerifiedAllowed.Set {
		e.FieldStart("verified_allowed")
		s.VerifiedAllowed.Encode(e)
	}
	if s.PatternsAllowed != nil {
		e.FieldStart("patterns_allowed")
		e.ArrStart()
		for _, elem := range s.PatternsAllowed {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes SelectedActions from json.
func (s *SelectedActions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SelectedActions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "github_owned_allowed":
			s.GithubOwnedAllowed.Reset()
			if err := s.GithubOwnedAllowed.Decode(d); err != nil {
				return err
			}
		case "verified_allowed":
			s.VerifiedAllowed.Reset()
			if err := s.VerifiedAllowed.Decode(d); err != nil {
				return err
			}
		case "patterns_allowed":
			s.PatternsAllowed = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.PatternsAllowed = append(s.PatternsAllowed, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes SelectedActionsURL as json.
func (s SelectedActionsURL) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes SelectedActionsURL from json.
func (s *SelectedActionsURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SelectedActionsURL to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SelectedActionsURL(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s ServiceUnavailable) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Code.Set {
		e.FieldStart("code")
		s.Code.Encode(e)
	}
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.DocumentationURL.Set {
		e.FieldStart("documentation_url")
		s.DocumentationURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ServiceUnavailable from json.
func (s *ServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ServiceUnavailable to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			s.Code.Reset()
			if err := s.Code.Decode(d); err != nil {
				return err
			}
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ShortBlob) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("sha")
	e.Str(s.Sha)
	e.ObjEnd()
}

// Decode decodes ShortBlob from json.
func (s *ShortBlob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ShortBlob to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ShortBranch) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("commit")
	s.Commit.Encode(e)

	e.FieldStart("protected")
	e.Bool(s.Protected)
	if s.Protection.Set {
		e.FieldStart("protection")
		s.Protection.Encode(e)
	}
	if s.ProtectionURL.Set {
		e.FieldStart("protection_url")
		s.ProtectionURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ShortBranch from json.
func (s *ShortBranch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ShortBranch to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "commit":
			if err := s.Commit.Decode(d); err != nil {
				return err
			}
		case "protected":
			v, err := d.Bool()
			s.Protected = bool(v)
			if err != nil {
				return err
			}
		case "protection":
			s.Protection.Reset()
			if err := s.Protection.Decode(d); err != nil {
				return err
			}
		case "protection_url":
			s.ProtectionURL.Reset()
			if err := s.ProtectionURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ShortBranchCommit) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	e.ObjEnd()
}

// Decode decodes ShortBranchCommit from json.
func (s *ShortBranchCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ShortBranchCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SimpleCommit) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Str(s.ID)

	e.FieldStart("tree_id")
	e.Str(s.TreeID)

	e.FieldStart("message")
	e.Str(s.Message)

	e.FieldStart("timestamp")
	json.EncodeDateTime(e, s.Timestamp)

	e.FieldStart("author")
	s.Author.Encode(e)

	e.FieldStart("committer")
	s.Committer.Encode(e)
	e.ObjEnd()
}

// Decode decodes SimpleCommit from json.
func (s *SimpleCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SimpleCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "tree_id":
			v, err := d.Str()
			s.TreeID = string(v)
			if err != nil {
				return err
			}
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "timestamp":
			v, err := json.DecodeDateTime(d)
			s.Timestamp = v
			if err != nil {
				return err
			}
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "committer":
			if err := s.Committer.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SimpleCommitAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("email")
	e.Str(s.Email)
	e.ObjEnd()
}

// Decode decodes SimpleCommitAuthor from json.
func (s *SimpleCommitAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SimpleCommitAuthor to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SimpleCommitCommitter) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("email")
	e.Str(s.Email)
	e.ObjEnd()
}

// Decode decodes SimpleCommitCommitter from json.
func (s *SimpleCommitCommitter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SimpleCommitCommitter to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "email":
			v, err := d.Str()
			s.Email = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SimpleCommitStatus) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("state")
	e.Str(s.State)

	e.FieldStart("context")
	e.Str(s.Context)

	e.FieldStart("target_url")
	json.EncodeURI(e, s.TargetURL)
	if s.Required.Set {
		e.FieldStart("required")
		s.Required.Encode(e)
	}

	e.FieldStart("avatar_url")
	s.AvatarURL.Encode(e)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)
	e.ObjEnd()
}

// Decode decodes SimpleCommitStatus from json.
func (s *SimpleCommitStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SimpleCommitStatus to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "context":
			v, err := d.Str()
			s.Context = string(v)
			if err != nil {
				return err
			}
		case "target_url":
			v, err := json.DecodeURI(d)
			s.TargetURL = v
			if err != nil {
				return err
			}
		case "required":
			s.Required.Reset()
			if err := s.Required.Decode(d); err != nil {
				return err
			}
		case "avatar_url":
			if err := s.AvatarURL.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s SimpleUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}

	e.FieldStart("login")
	e.Str(s.Login)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("avatar_url")
	json.EncodeURI(e, s.AvatarURL)

	e.FieldStart("gravatar_id")
	s.GravatarID.Encode(e)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("followers_url")
	json.EncodeURI(e, s.FollowersURL)

	e.FieldStart("following_url")
	e.Str(s.FollowingURL)

	e.FieldStart("gists_url")
	e.Str(s.GistsURL)

	e.FieldStart("starred_url")
	e.Str(s.StarredURL)

	e.FieldStart("subscriptions_url")
	json.EncodeURI(e, s.SubscriptionsURL)

	e.FieldStart("organizations_url")
	json.EncodeURI(e, s.OrganizationsURL)

	e.FieldStart("repos_url")
	json.EncodeURI(e, s.ReposURL)

	e.FieldStart("events_url")
	e.Str(s.EventsURL)

	e.FieldStart("received_events_url")
	json.EncodeURI(e, s.ReceivedEventsURL)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("site_admin")
	e.Bool(s.SiteAdmin)
	if s.StarredAt.Set {
		e.FieldStart("starred_at")
		s.StarredAt.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes SimpleUser from json.
func (s *SimpleUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode SimpleUser to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "starred_at":
			s.StarredAt.Reset()
			if err := s.StarredAt.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Status) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("avatar_url")
	s.AvatarURL.Encode(e)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("state")
	e.Str(s.State)

	e.FieldStart("description")
	e.Str(s.Description)

	e.FieldStart("target_url")
	e.Str(s.TargetURL)

	e.FieldStart("context")
	e.Str(s.Context)

	e.FieldStart("created_at")
	e.Str(s.CreatedAt)

	e.FieldStart("updated_at")
	e.Str(s.UpdatedAt)

	e.FieldStart("creator")
	s.Creator.Encode(e)
	e.ObjEnd()
}

// Decode decodes Status from json.
func (s *Status) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Status to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			if err := s.AvatarURL.Decode(d); err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "description":
			v, err := d.Str()
			s.Description = string(v)
			if err != nil {
				return err
			}
		case "target_url":
			v, err := d.Str()
			s.TargetURL = string(v)
			if err != nil {
				return err
			}
		case "context":
			v, err := d.Str()
			s.Context = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := d.Str()
			s.CreatedAt = string(v)
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := d.Str()
			s.UpdatedAt = string(v)
			if err != nil {
				return err
			}
		case "creator":
			if err := s.Creator.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s StatusCheckPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("strict")
	e.Bool(s.Strict)

	e.FieldStart("contexts")
	e.ArrStart()
	for _, elem := range s.Contexts {
		e.Str(elem)
	}
	e.ArrEnd()

	e.FieldStart("contexts_url")
	json.EncodeURI(e, s.ContextsURL)
	e.ObjEnd()
}

// Decode decodes StatusCheckPolicy from json.
func (s *StatusCheckPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode StatusCheckPolicy to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "strict":
			v, err := d.Bool()
			s.Strict = bool(v)
			if err != nil {
				return err
			}
		case "contexts":
			s.Contexts = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Contexts = append(s.Contexts, elem)
				return nil
			}); err != nil {
				return err
			}
		case "contexts_url":
			v, err := json.DecodeURI(d)
			s.ContextsURL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Tag) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("commit")
	s.Commit.Encode(e)

	e.FieldStart("zipball_url")
	json.EncodeURI(e, s.ZipballURL)

	e.FieldStart("tarball_url")
	json.EncodeURI(e, s.TarballURL)

	e.FieldStart("node_id")
	e.Str(s.NodeID)
	e.ObjEnd()
}

// Decode decodes Tag from json.
func (s *Tag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Tag to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "commit":
			if err := s.Commit.Decode(d); err != nil {
				return err
			}
		case "zipball_url":
			v, err := json.DecodeURI(d)
			s.ZipballURL = v
			if err != nil {
				return err
			}
		case "tarball_url":
			v, err := json.DecodeURI(d)
			s.TarballURL = v
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TagCommit) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("sha")
	e.Str(s.Sha)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	e.ObjEnd()
}

// Decode decodes TagCommit from json.
func (s *TagCommit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TagCommit to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha":
			v, err := d.Str()
			s.Sha = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Team) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("slug")
	e.Str(s.Slug)

	e.FieldStart("description")
	s.Description.Encode(e)
	if s.Privacy.Set {
		e.FieldStart("privacy")
		s.Privacy.Encode(e)
	}

	e.FieldStart("permission")
	e.Str(s.Permission)
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("members_url")
	e.Str(s.MembersURL)

	e.FieldStart("repositories_url")
	json.EncodeURI(e, s.RepositoriesURL)

	e.FieldStart("parent")
	s.Parent.Encode(e)
	e.ObjEnd()
}

// Decode decodes Team from json.
func (s *Team) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Team to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "slug":
			v, err := d.Str()
			s.Slug = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "privacy":
			s.Privacy.Reset()
			if err := s.Privacy.Decode(d); err != nil {
				return err
			}
		case "permission":
			v, err := d.Str()
			s.Permission = string(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "members_url":
			v, err := d.Str()
			s.MembersURL = string(v)
			if err != nil {
				return err
			}
		case "repositories_url":
			v, err := json.DecodeURI(d)
			s.RepositoriesURL = v
			if err != nil {
				return err
			}
		case "parent":
			if err := s.Parent.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamDiscussion) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("author")
	s.Author.Encode(e)

	e.FieldStart("body")
	e.Str(s.Body)

	e.FieldStart("body_html")
	e.Str(s.BodyHTML)

	e.FieldStart("body_version")
	e.Str(s.BodyVersion)

	e.FieldStart("comments_count")
	e.Int(s.CommentsCount)

	e.FieldStart("comments_url")
	json.EncodeURI(e, s.CommentsURL)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("last_edited_at")
	s.LastEditedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("number")
	e.Int(s.Number)

	e.FieldStart("pinned")
	e.Bool(s.Pinned)

	e.FieldStart("private")
	e.Bool(s.Private)

	e.FieldStart("team_url")
	json.EncodeURI(e, s.TeamURL)

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	if s.Reactions.Set {
		e.FieldStart("reactions")
		s.Reactions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamDiscussion from json.
func (s *TeamDiscussion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamDiscussion to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "body_html":
			v, err := d.Str()
			s.BodyHTML = string(v)
			if err != nil {
				return err
			}
		case "body_version":
			v, err := d.Str()
			s.BodyVersion = string(v)
			if err != nil {
				return err
			}
		case "comments_count":
			v, err := d.Int()
			s.CommentsCount = int(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := json.DecodeURI(d)
			s.CommentsURL = v
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "last_edited_at":
			if err := s.LastEditedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "pinned":
			v, err := d.Bool()
			s.Pinned = bool(v)
			if err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "team_url":
			v, err := json.DecodeURI(d)
			s.TeamURL = v
			if err != nil {
				return err
			}
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "reactions":
			s.Reactions.Reset()
			if err := s.Reactions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamDiscussionComment) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("author")
	s.Author.Encode(e)

	e.FieldStart("body")
	e.Str(s.Body)

	e.FieldStart("body_html")
	e.Str(s.BodyHTML)

	e.FieldStart("body_version")
	e.Str(s.BodyVersion)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("last_edited_at")
	s.LastEditedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("discussion_url")
	json.EncodeURI(e, s.DiscussionURL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("number")
	e.Int(s.Number)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	if s.Reactions.Set {
		e.FieldStart("reactions")
		s.Reactions.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamDiscussionComment from json.
func (s *TeamDiscussionComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamDiscussionComment to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			if err := s.Author.Decode(d); err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "body_html":
			v, err := d.Str()
			s.BodyHTML = string(v)
			if err != nil {
				return err
			}
		case "body_version":
			v, err := d.Str()
			s.BodyVersion = string(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "last_edited_at":
			if err := s.LastEditedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "discussion_url":
			v, err := json.DecodeURI(d)
			s.DiscussionURL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "reactions":
			s.Reactions.Reset()
			if err := s.Reactions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamFull) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("slug")
	e.Str(s.Slug)

	e.FieldStart("description")
	s.Description.Encode(e)
	if s.Privacy.Set {
		e.FieldStart("privacy")
		s.Privacy.Encode(e)
	}

	e.FieldStart("permission")
	e.Str(s.Permission)

	e.FieldStart("members_url")
	e.Str(s.MembersURL)

	e.FieldStart("repositories_url")
	json.EncodeURI(e, s.RepositoriesURL)
	if s.Parent.Set {
		e.FieldStart("parent")
		s.Parent.Encode(e)
	}

	e.FieldStart("members_count")
	e.Int(s.MembersCount)

	e.FieldStart("repos_count")
	e.Int(s.ReposCount)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("organization")
	s.Organization.Encode(e)
	if s.LdapDn.Set {
		e.FieldStart("ldap_dn")
		s.LdapDn.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamFull from json.
func (s *TeamFull) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamFull to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "slug":
			v, err := d.Str()
			s.Slug = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "privacy":
			s.Privacy.Reset()
			if err := s.Privacy.Decode(d); err != nil {
				return err
			}
		case "permission":
			v, err := d.Str()
			s.Permission = string(v)
			if err != nil {
				return err
			}
		case "members_url":
			v, err := d.Str()
			s.MembersURL = string(v)
			if err != nil {
				return err
			}
		case "repositories_url":
			v, err := json.DecodeURI(d)
			s.RepositoriesURL = v
			if err != nil {
				return err
			}
		case "parent":
			s.Parent.Reset()
			if err := s.Parent.Decode(d); err != nil {
				return err
			}
		case "members_count":
			v, err := d.Int()
			s.MembersCount = int(v)
			if err != nil {
				return err
			}
		case "repos_count":
			v, err := d.Int()
			s.ReposCount = int(v)
			if err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "organization":
			if err := s.Organization.Decode(d); err != nil {
				return err
			}
		case "ldap_dn":
			s.LdapDn.Reset()
			if err := s.LdapDn.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamFullPrivacy as json.
func (s TeamFullPrivacy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamFullPrivacy from json.
func (s *TeamFullPrivacy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamFullPrivacy to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamFullPrivacy(v)
	return nil
}

// Encode implements json.Marshaler.
func (s TeamMembership) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("role")
	s.Role.Encode(e)

	e.FieldStart("state")
	s.State.Encode(e)
	e.ObjEnd()
}

// Decode decodes TeamMembership from json.
func (s *TeamMembership) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamMembership to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "role":
			if err := s.Role.Decode(d); err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamMembershipRole as json.
func (s TeamMembershipRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamMembershipRole from json.
func (s *TeamMembershipRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamMembershipRole to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamMembershipRole(v)
	return nil
}

// Encode encodes TeamMembershipState as json.
func (s TeamMembershipState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamMembershipState from json.
func (s *TeamMembershipState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamMembershipState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamMembershipState(v)
	return nil
}

// Encode implements json.Marshaler.
func (s TeamPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("pull")
	e.Bool(s.Pull)

	e.FieldStart("triage")
	e.Bool(s.Triage)

	e.FieldStart("push")
	e.Bool(s.Push)

	e.FieldStart("maintain")
	e.Bool(s.Maintain)

	e.FieldStart("admin")
	e.Bool(s.Admin)
	e.ObjEnd()
}

// Decode decodes TeamPermissions from json.
func (s *TeamPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			v, err := d.Bool()
			s.Triage = bool(v)
			if err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			v, err := d.Bool()
			s.Maintain = bool(v)
			if err != nil {
				return err
			}
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamProject) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("owner_url")
	e.Str(s.OwnerURL)

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("html_url")
	e.Str(s.HTMLURL)

	e.FieldStart("columns_url")
	e.Str(s.ColumnsURL)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("body")
	s.Body.Encode(e)

	e.FieldStart("number")
	e.Int(s.Number)

	e.FieldStart("state")
	e.Str(s.State)

	e.FieldStart("creator")
	s.Creator.Encode(e)

	e.FieldStart("created_at")
	e.Str(s.CreatedAt)

	e.FieldStart("updated_at")
	e.Str(s.UpdatedAt)
	if s.OrganizationPermission.Set {
		e.FieldStart("organization_permission")
		s.OrganizationPermission.Encode(e)
	}
	if s.Private.Set {
		e.FieldStart("private")
		s.Private.Encode(e)
	}

	e.FieldStart("permissions")
	s.Permissions.Encode(e)
	e.ObjEnd()
}

// Decode decodes TeamProject from json.
func (s *TeamProject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamProject to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "owner_url":
			v, err := d.Str()
			s.OwnerURL = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := d.Str()
			s.HTMLURL = string(v)
			if err != nil {
				return err
			}
		case "columns_url":
			v, err := d.Str()
			s.ColumnsURL = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "body":
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		case "number":
			v, err := d.Int()
			s.Number = int(v)
			if err != nil {
				return err
			}
		case "state":
			v, err := d.Str()
			s.State = string(v)
			if err != nil {
				return err
			}
		case "creator":
			if err := s.Creator.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := d.Str()
			s.CreatedAt = string(v)
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := d.Str()
			s.UpdatedAt = string(v)
			if err != nil {
				return err
			}
		case "organization_permission":
			s.OrganizationPermission.Reset()
			if err := s.OrganizationPermission.Decode(d); err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		case "permissions":
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamProjectPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("read")
	e.Bool(s.Read)

	e.FieldStart("write")
	e.Bool(s.Write)

	e.FieldStart("admin")
	e.Bool(s.Admin)
	e.ObjEnd()
}

// Decode decodes TeamProjectPermissions from json.
func (s *TeamProjectPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamProjectPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "read":
			v, err := d.Bool()
			s.Read = bool(v)
			if err != nil {
				return err
			}
		case "write":
			v, err := d.Bool()
			s.Write = bool(v)
			if err != nil {
				return err
			}
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamRepository) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("full_name")
	e.Str(s.FullName)

	e.FieldStart("license")
	s.License.Encode(e)

	e.FieldStart("forks")
	e.Int(s.Forks)
	if s.Permissions.Set {
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}

	e.FieldStart("owner")
	s.Owner.Encode(e)

	e.FieldStart("private")
	e.Bool(s.Private)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("fork")
	e.Bool(s.Fork)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("archive_url")
	e.Str(s.ArchiveURL)

	e.FieldStart("assignees_url")
	e.Str(s.AssigneesURL)

	e.FieldStart("blobs_url")
	e.Str(s.BlobsURL)

	e.FieldStart("branches_url")
	e.Str(s.BranchesURL)

	e.FieldStart("collaborators_url")
	e.Str(s.CollaboratorsURL)

	e.FieldStart("comments_url")
	e.Str(s.CommentsURL)

	e.FieldStart("commits_url")
	e.Str(s.CommitsURL)

	e.FieldStart("compare_url")
	e.Str(s.CompareURL)

	e.FieldStart("contents_url")
	e.Str(s.ContentsURL)

	e.FieldStart("contributors_url")
	json.EncodeURI(e, s.ContributorsURL)

	e.FieldStart("deployments_url")
	json.EncodeURI(e, s.DeploymentsURL)

	e.FieldStart("downloads_url")
	json.EncodeURI(e, s.DownloadsURL)

	e.FieldStart("events_url")
	json.EncodeURI(e, s.EventsURL)

	e.FieldStart("forks_url")
	json.EncodeURI(e, s.ForksURL)

	e.FieldStart("git_commits_url")
	e.Str(s.GitCommitsURL)

	e.FieldStart("git_refs_url")
	e.Str(s.GitRefsURL)

	e.FieldStart("git_tags_url")
	e.Str(s.GitTagsURL)

	e.FieldStart("git_url")
	e.Str(s.GitURL)

	e.FieldStart("issue_comment_url")
	e.Str(s.IssueCommentURL)

	e.FieldStart("issue_events_url")
	e.Str(s.IssueEventsURL)

	e.FieldStart("issues_url")
	e.Str(s.IssuesURL)

	e.FieldStart("keys_url")
	e.Str(s.KeysURL)

	e.FieldStart("labels_url")
	e.Str(s.LabelsURL)

	e.FieldStart("languages_url")
	json.EncodeURI(e, s.LanguagesURL)

	e.FieldStart("merges_url")
	json.EncodeURI(e, s.MergesURL)

	e.FieldStart("milestones_url")
	e.Str(s.MilestonesURL)

	e.FieldStart("notifications_url")
	e.Str(s.NotificationsURL)

	e.FieldStart("pulls_url")
	e.Str(s.PullsURL)

	e.FieldStart("releases_url")
	e.Str(s.ReleasesURL)

	e.FieldStart("ssh_url")
	e.Str(s.SSHURL)

	e.FieldStart("stargazers_url")
	json.EncodeURI(e, s.StargazersURL)

	e.FieldStart("statuses_url")
	e.Str(s.StatusesURL)

	e.FieldStart("subscribers_url")
	json.EncodeURI(e, s.SubscribersURL)

	e.FieldStart("subscription_url")
	json.EncodeURI(e, s.SubscriptionURL)

	e.FieldStart("tags_url")
	json.EncodeURI(e, s.TagsURL)

	e.FieldStart("teams_url")
	json.EncodeURI(e, s.TeamsURL)

	e.FieldStart("trees_url")
	e.Str(s.TreesURL)

	e.FieldStart("clone_url")
	e.Str(s.CloneURL)

	e.FieldStart("mirror_url")
	s.MirrorURL.Encode(e)

	e.FieldStart("hooks_url")
	json.EncodeURI(e, s.HooksURL)

	e.FieldStart("svn_url")
	json.EncodeURI(e, s.SvnURL)

	e.FieldStart("homepage")
	s.Homepage.Encode(e)

	e.FieldStart("language")
	s.Language.Encode(e)

	e.FieldStart("forks_count")
	e.Int(s.ForksCount)

	e.FieldStart("stargazers_count")
	e.Int(s.StargazersCount)

	e.FieldStart("watchers_count")
	e.Int(s.WatchersCount)

	e.FieldStart("size")
	e.Int(s.Size)

	e.FieldStart("default_branch")
	e.Str(s.DefaultBranch)

	e.FieldStart("open_issues_count")
	e.Int(s.OpenIssuesCount)
	if s.IsTemplate.Set {
		e.FieldStart("is_template")
		s.IsTemplate.Encode(e)
	}
	if s.Topics != nil {
		e.FieldStart("topics")
		e.ArrStart()
		for _, elem := range s.Topics {
			e.Str(elem)
		}
		e.ArrEnd()
	}

	e.FieldStart("has_issues")
	e.Bool(s.HasIssues)

	e.FieldStart("has_projects")
	e.Bool(s.HasProjects)

	e.FieldStart("has_wiki")
	e.Bool(s.HasWiki)

	e.FieldStart("has_pages")
	e.Bool(s.HasPages)

	e.FieldStart("has_downloads")
	e.Bool(s.HasDownloads)

	e.FieldStart("archived")
	e.Bool(s.Archived)

	e.FieldStart("disabled")
	e.Bool(s.Disabled)
	if s.Visibility.Set {
		e.FieldStart("visibility")
		s.Visibility.Encode(e)
	}

	e.FieldStart("pushed_at")
	s.PushedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("created_at")
	s.CreatedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("updated_at")
	s.UpdatedAt.Encode(e, json.EncodeDateTime)
	if s.AllowRebaseMerge.Set {
		e.FieldStart("allow_rebase_merge")
		s.AllowRebaseMerge.Encode(e)
	}
	if s.TemplateRepository.Set {
		e.FieldStart("template_repository")
		s.TemplateRepository.Encode(e)
	}
	if s.TempCloneToken.Set {
		e.FieldStart("temp_clone_token")
		s.TempCloneToken.Encode(e)
	}
	if s.AllowSquashMerge.Set {
		e.FieldStart("allow_squash_merge")
		s.AllowSquashMerge.Encode(e)
	}
	if s.AllowAutoMerge.Set {
		e.FieldStart("allow_auto_merge")
		s.AllowAutoMerge.Encode(e)
	}
	if s.DeleteBranchOnMerge.Set {
		e.FieldStart("delete_branch_on_merge")
		s.DeleteBranchOnMerge.Encode(e)
	}
	if s.AllowMergeCommit.Set {
		e.FieldStart("allow_merge_commit")
		s.AllowMergeCommit.Encode(e)
	}
	if s.AllowForking.Set {
		e.FieldStart("allow_forking")
		s.AllowForking.Encode(e)
	}
	if s.SubscribersCount.Set {
		e.FieldStart("subscribers_count")
		s.SubscribersCount.Encode(e)
	}
	if s.NetworkCount.Set {
		e.FieldStart("network_count")
		s.NetworkCount.Encode(e)
	}

	e.FieldStart("open_issues")
	e.Int(s.OpenIssues)

	e.FieldStart("watchers")
	e.Int(s.Watchers)
	if s.MasterBranch.Set {
		e.FieldStart("master_branch")
		s.MasterBranch.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamRepository from json.
func (s *TeamRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamRepository to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "full_name":
			v, err := d.Str()
			s.FullName = string(v)
			if err != nil {
				return err
			}
		case "license":
			if err := s.License.Decode(d); err != nil {
				return err
			}
		case "forks":
			v, err := d.Int()
			s.Forks = int(v)
			if err != nil {
				return err
			}
		case "permissions":
			s.Permissions.Reset()
			if err := s.Permissions.Decode(d); err != nil {
				return err
			}
		case "owner":
			if err := s.Owner.Decode(d); err != nil {
				return err
			}
		case "private":
			v, err := d.Bool()
			s.Private = bool(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "fork":
			v, err := d.Bool()
			s.Fork = bool(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "archive_url":
			v, err := d.Str()
			s.ArchiveURL = string(v)
			if err != nil {
				return err
			}
		case "assignees_url":
			v, err := d.Str()
			s.AssigneesURL = string(v)
			if err != nil {
				return err
			}
		case "blobs_url":
			v, err := d.Str()
			s.BlobsURL = string(v)
			if err != nil {
				return err
			}
		case "branches_url":
			v, err := d.Str()
			s.BranchesURL = string(v)
			if err != nil {
				return err
			}
		case "collaborators_url":
			v, err := d.Str()
			s.CollaboratorsURL = string(v)
			if err != nil {
				return err
			}
		case "comments_url":
			v, err := d.Str()
			s.CommentsURL = string(v)
			if err != nil {
				return err
			}
		case "commits_url":
			v, err := d.Str()
			s.CommitsURL = string(v)
			if err != nil {
				return err
			}
		case "compare_url":
			v, err := d.Str()
			s.CompareURL = string(v)
			if err != nil {
				return err
			}
		case "contents_url":
			v, err := d.Str()
			s.ContentsURL = string(v)
			if err != nil {
				return err
			}
		case "contributors_url":
			v, err := json.DecodeURI(d)
			s.ContributorsURL = v
			if err != nil {
				return err
			}
		case "deployments_url":
			v, err := json.DecodeURI(d)
			s.DeploymentsURL = v
			if err != nil {
				return err
			}
		case "downloads_url":
			v, err := json.DecodeURI(d)
			s.DownloadsURL = v
			if err != nil {
				return err
			}
		case "events_url":
			v, err := json.DecodeURI(d)
			s.EventsURL = v
			if err != nil {
				return err
			}
		case "forks_url":
			v, err := json.DecodeURI(d)
			s.ForksURL = v
			if err != nil {
				return err
			}
		case "git_commits_url":
			v, err := d.Str()
			s.GitCommitsURL = string(v)
			if err != nil {
				return err
			}
		case "git_refs_url":
			v, err := d.Str()
			s.GitRefsURL = string(v)
			if err != nil {
				return err
			}
		case "git_tags_url":
			v, err := d.Str()
			s.GitTagsURL = string(v)
			if err != nil {
				return err
			}
		case "git_url":
			v, err := d.Str()
			s.GitURL = string(v)
			if err != nil {
				return err
			}
		case "issue_comment_url":
			v, err := d.Str()
			s.IssueCommentURL = string(v)
			if err != nil {
				return err
			}
		case "issue_events_url":
			v, err := d.Str()
			s.IssueEventsURL = string(v)
			if err != nil {
				return err
			}
		case "issues_url":
			v, err := d.Str()
			s.IssuesURL = string(v)
			if err != nil {
				return err
			}
		case "keys_url":
			v, err := d.Str()
			s.KeysURL = string(v)
			if err != nil {
				return err
			}
		case "labels_url":
			v, err := d.Str()
			s.LabelsURL = string(v)
			if err != nil {
				return err
			}
		case "languages_url":
			v, err := json.DecodeURI(d)
			s.LanguagesURL = v
			if err != nil {
				return err
			}
		case "merges_url":
			v, err := json.DecodeURI(d)
			s.MergesURL = v
			if err != nil {
				return err
			}
		case "milestones_url":
			v, err := d.Str()
			s.MilestonesURL = string(v)
			if err != nil {
				return err
			}
		case "notifications_url":
			v, err := d.Str()
			s.NotificationsURL = string(v)
			if err != nil {
				return err
			}
		case "pulls_url":
			v, err := d.Str()
			s.PullsURL = string(v)
			if err != nil {
				return err
			}
		case "releases_url":
			v, err := d.Str()
			s.ReleasesURL = string(v)
			if err != nil {
				return err
			}
		case "ssh_url":
			v, err := d.Str()
			s.SSHURL = string(v)
			if err != nil {
				return err
			}
		case "stargazers_url":
			v, err := json.DecodeURI(d)
			s.StargazersURL = v
			if err != nil {
				return err
			}
		case "statuses_url":
			v, err := d.Str()
			s.StatusesURL = string(v)
			if err != nil {
				return err
			}
		case "subscribers_url":
			v, err := json.DecodeURI(d)
			s.SubscribersURL = v
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionURL = v
			if err != nil {
				return err
			}
		case "tags_url":
			v, err := json.DecodeURI(d)
			s.TagsURL = v
			if err != nil {
				return err
			}
		case "teams_url":
			v, err := json.DecodeURI(d)
			s.TeamsURL = v
			if err != nil {
				return err
			}
		case "trees_url":
			v, err := d.Str()
			s.TreesURL = string(v)
			if err != nil {
				return err
			}
		case "clone_url":
			v, err := d.Str()
			s.CloneURL = string(v)
			if err != nil {
				return err
			}
		case "mirror_url":
			if err := s.MirrorURL.Decode(d); err != nil {
				return err
			}
		case "hooks_url":
			v, err := json.DecodeURI(d)
			s.HooksURL = v
			if err != nil {
				return err
			}
		case "svn_url":
			v, err := json.DecodeURI(d)
			s.SvnURL = v
			if err != nil {
				return err
			}
		case "homepage":
			if err := s.Homepage.Decode(d); err != nil {
				return err
			}
		case "language":
			if err := s.Language.Decode(d); err != nil {
				return err
			}
		case "forks_count":
			v, err := d.Int()
			s.ForksCount = int(v)
			if err != nil {
				return err
			}
		case "stargazers_count":
			v, err := d.Int()
			s.StargazersCount = int(v)
			if err != nil {
				return err
			}
		case "watchers_count":
			v, err := d.Int()
			s.WatchersCount = int(v)
			if err != nil {
				return err
			}
		case "size":
			v, err := d.Int()
			s.Size = int(v)
			if err != nil {
				return err
			}
		case "default_branch":
			v, err := d.Str()
			s.DefaultBranch = string(v)
			if err != nil {
				return err
			}
		case "open_issues_count":
			v, err := d.Int()
			s.OpenIssuesCount = int(v)
			if err != nil {
				return err
			}
		case "is_template":
			s.IsTemplate.Reset()
			if err := s.IsTemplate.Decode(d); err != nil {
				return err
			}
		case "topics":
			s.Topics = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Topics = append(s.Topics, elem)
				return nil
			}); err != nil {
				return err
			}
		case "has_issues":
			v, err := d.Bool()
			s.HasIssues = bool(v)
			if err != nil {
				return err
			}
		case "has_projects":
			v, err := d.Bool()
			s.HasProjects = bool(v)
			if err != nil {
				return err
			}
		case "has_wiki":
			v, err := d.Bool()
			s.HasWiki = bool(v)
			if err != nil {
				return err
			}
		case "has_pages":
			v, err := d.Bool()
			s.HasPages = bool(v)
			if err != nil {
				return err
			}
		case "has_downloads":
			v, err := d.Bool()
			s.HasDownloads = bool(v)
			if err != nil {
				return err
			}
		case "archived":
			v, err := d.Bool()
			s.Archived = bool(v)
			if err != nil {
				return err
			}
		case "disabled":
			v, err := d.Bool()
			s.Disabled = bool(v)
			if err != nil {
				return err
			}
		case "visibility":
			s.Visibility.Reset()
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		case "pushed_at":
			if err := s.PushedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "created_at":
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "allow_rebase_merge":
			s.AllowRebaseMerge.Reset()
			if err := s.AllowRebaseMerge.Decode(d); err != nil {
				return err
			}
		case "template_repository":
			s.TemplateRepository.Reset()
			if err := s.TemplateRepository.Decode(d); err != nil {
				return err
			}
		case "temp_clone_token":
			s.TempCloneToken.Reset()
			if err := s.TempCloneToken.Decode(d); err != nil {
				return err
			}
		case "allow_squash_merge":
			s.AllowSquashMerge.Reset()
			if err := s.AllowSquashMerge.Decode(d); err != nil {
				return err
			}
		case "allow_auto_merge":
			s.AllowAutoMerge.Reset()
			if err := s.AllowAutoMerge.Decode(d); err != nil {
				return err
			}
		case "delete_branch_on_merge":
			s.DeleteBranchOnMerge.Reset()
			if err := s.DeleteBranchOnMerge.Decode(d); err != nil {
				return err
			}
		case "allow_merge_commit":
			s.AllowMergeCommit.Reset()
			if err := s.AllowMergeCommit.Decode(d); err != nil {
				return err
			}
		case "allow_forking":
			s.AllowForking.Reset()
			if err := s.AllowForking.Decode(d); err != nil {
				return err
			}
		case "subscribers_count":
			s.SubscribersCount.Reset()
			if err := s.SubscribersCount.Decode(d); err != nil {
				return err
			}
		case "network_count":
			s.NetworkCount.Reset()
			if err := s.NetworkCount.Decode(d); err != nil {
				return err
			}
		case "open_issues":
			v, err := d.Int()
			s.OpenIssues = int(v)
			if err != nil {
				return err
			}
		case "watchers":
			v, err := d.Int()
			s.Watchers = int(v)
			if err != nil {
				return err
			}
		case "master_branch":
			s.MasterBranch.Reset()
			if err := s.MasterBranch.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamRepositoryPermissions) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("admin")
	e.Bool(s.Admin)

	e.FieldStart("pull")
	e.Bool(s.Pull)
	if s.Triage.Set {
		e.FieldStart("triage")
		s.Triage.Encode(e)
	}

	e.FieldStart("push")
	e.Bool(s.Push)
	if s.Maintain.Set {
		e.FieldStart("maintain")
		s.Maintain.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamRepositoryPermissions from json.
func (s *TeamRepositoryPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamRepositoryPermissions to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "admin":
			v, err := d.Bool()
			s.Admin = bool(v)
			if err != nil {
				return err
			}
		case "pull":
			v, err := d.Bool()
			s.Pull = bool(v)
			if err != nil {
				return err
			}
		case "triage":
			s.Triage.Reset()
			if err := s.Triage.Decode(d); err != nil {
				return err
			}
		case "push":
			v, err := d.Bool()
			s.Push = bool(v)
			if err != nil {
				return err
			}
		case "maintain":
			s.Maintain.Reset()
			if err := s.Maintain.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamSimple) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("members_url")
	e.Str(s.MembersURL)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("permission")
	e.Str(s.Permission)
	if s.Privacy.Set {
		e.FieldStart("privacy")
		s.Privacy.Encode(e)
	}

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("repositories_url")
	json.EncodeURI(e, s.RepositoriesURL)

	e.FieldStart("slug")
	e.Str(s.Slug)
	if s.LdapDn.Set {
		e.FieldStart("ldap_dn")
		s.LdapDn.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamSimple from json.
func (s *TeamSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "members_url":
			v, err := d.Str()
			s.MembersURL = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "permission":
			v, err := d.Str()
			s.Permission = string(v)
			if err != nil {
				return err
			}
		case "privacy":
			s.Privacy.Reset()
			if err := s.Privacy.Decode(d); err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "repositories_url":
			v, err := json.DecodeURI(d)
			s.RepositoriesURL = v
			if err != nil {
				return err
			}
		case "slug":
			v, err := d.Str()
			s.Slug = string(v)
			if err != nil {
				return err
			}
		case "ldap_dn":
			s.LdapDn.Reset()
			if err := s.LdapDn.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddMemberLegacyNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsAddMemberLegacyNoContent from json.
func (s *TeamsAddMemberLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddMemberLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddMemberLegacyNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsAddMemberLegacyNotFound from json.
func (s *TeamsAddMemberLegacyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddMemberLegacyNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddMemberLegacyUnprocessableEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsAddMemberLegacyUnprocessableEntity from json.
func (s *TeamsAddMemberLegacyUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddMemberLegacyUnprocessableEntity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateMembershipForUserInOrgForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgForbidden from json.
func (s *TeamsAddOrUpdateMembershipForUserInOrgForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateMembershipForUserInOrgForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateMembershipForUserInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Role.Set {
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgReq from json.
func (s *TeamsAddOrUpdateMembershipForUserInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateMembershipForUserInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			s.Role.Reset()
			if err := s.Role.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsAddOrUpdateMembershipForUserInOrgReqRole as json.
func (s TeamsAddOrUpdateMembershipForUserInOrgReqRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgReqRole from json.
func (s *TeamsAddOrUpdateMembershipForUserInOrgReqRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateMembershipForUserInOrgReqRole to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsAddOrUpdateMembershipForUserInOrgReqRole(v)
	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateMembershipForUserInOrgUnprocessableEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateMembershipForUserInOrgUnprocessableEntity from json.
func (s *TeamsAddOrUpdateMembershipForUserInOrgUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateMembershipForUserInOrgUnprocessableEntity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateMembershipForUserLegacyForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyForbidden from json.
func (s *TeamsAddOrUpdateMembershipForUserLegacyForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateMembershipForUserLegacyForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateMembershipForUserLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Role.Set {
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyReq from json.
func (s *TeamsAddOrUpdateMembershipForUserLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateMembershipForUserLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			s.Role.Reset()
			if err := s.Role.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsAddOrUpdateMembershipForUserLegacyReqRole as json.
func (s TeamsAddOrUpdateMembershipForUserLegacyReqRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyReqRole from json.
func (s *TeamsAddOrUpdateMembershipForUserLegacyReqRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateMembershipForUserLegacyReqRole to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsAddOrUpdateMembershipForUserLegacyReqRole(v)
	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateMembershipForUserLegacyUnprocessableEntity) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateMembershipForUserLegacyUnprocessableEntity from json.
func (s *TeamsAddOrUpdateMembershipForUserLegacyUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateMembershipForUserLegacyUnprocessableEntity to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsInOrgForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.DocumentationURL.Set {
		e.FieldStart("documentation_url")
		s.DocumentationURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgForbidden from json.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateProjectPermissionsInOrgForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsInOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgNoContent from json.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateProjectPermissionsInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Permission.Set {
		e.FieldStart("permission")
		s.Permission.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgReq from json.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateProjectPermissionsInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsInOrgReqPermission as json.
func (s TeamsAddOrUpdateProjectPermissionsInOrgReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsInOrgReqPermission from json.
func (s *TeamsAddOrUpdateProjectPermissionsInOrgReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateProjectPermissionsInOrgReqPermission to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsAddOrUpdateProjectPermissionsInOrgReqPermission(v)
	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsLegacyForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Message.Set {
		e.FieldStart("message")
		s.Message.Encode(e)
	}
	if s.DocumentationURL.Set {
		e.FieldStart("documentation_url")
		s.DocumentationURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyForbidden from json.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateProjectPermissionsLegacyForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			s.Message.Reset()
			if err := s.Message.Decode(d); err != nil {
				return err
			}
		case "documentation_url":
			s.DocumentationURL.Reset()
			if err := s.DocumentationURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsLegacyNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyNoContent from json.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateProjectPermissionsLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateProjectPermissionsLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Permission.Set {
		e.FieldStart("permission")
		s.Permission.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyReq from json.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateProjectPermissionsLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsAddOrUpdateProjectPermissionsLegacyReqPermission as json.
func (s TeamsAddOrUpdateProjectPermissionsLegacyReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateProjectPermissionsLegacyReqPermission from json.
func (s *TeamsAddOrUpdateProjectPermissionsLegacyReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateProjectPermissionsLegacyReqPermission to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsAddOrUpdateProjectPermissionsLegacyReqPermission(v)
	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateRepoPermissionsInOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgNoContent from json.
func (s *TeamsAddOrUpdateRepoPermissionsInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateRepoPermissionsInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateRepoPermissionsInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Permission.Set {
		e.FieldStart("permission")
		s.Permission.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgReq from json.
func (s *TeamsAddOrUpdateRepoPermissionsInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateRepoPermissionsInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsInOrgReqPermission as json.
func (s TeamsAddOrUpdateRepoPermissionsInOrgReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsInOrgReqPermission from json.
func (s *TeamsAddOrUpdateRepoPermissionsInOrgReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateRepoPermissionsInOrgReqPermission to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsAddOrUpdateRepoPermissionsInOrgReqPermission(v)
	return nil
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateRepoPermissionsLegacyNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyNoContent from json.
func (s *TeamsAddOrUpdateRepoPermissionsLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateRepoPermissionsLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsAddOrUpdateRepoPermissionsLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Permission.Set {
		e.FieldStart("permission")
		s.Permission.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyReq from json.
func (s *TeamsAddOrUpdateRepoPermissionsLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateRepoPermissionsLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsAddOrUpdateRepoPermissionsLegacyReqPermission as json.
func (s TeamsAddOrUpdateRepoPermissionsLegacyReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsAddOrUpdateRepoPermissionsLegacyReqPermission from json.
func (s *TeamsAddOrUpdateRepoPermissionsLegacyReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsAddOrUpdateRepoPermissionsLegacyReqPermission to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsAddOrUpdateRepoPermissionsLegacyReqPermission(v)
	return nil
}

// Encode implements json.Marshaler.
func (s TeamsCheckPermissionsForProjectInOrgNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsCheckPermissionsForProjectInOrgNotFound from json.
func (s *TeamsCheckPermissionsForProjectInOrgNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCheckPermissionsForProjectInOrgNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCheckPermissionsForProjectLegacyNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsCheckPermissionsForProjectLegacyNotFound from json.
func (s *TeamsCheckPermissionsForProjectLegacyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCheckPermissionsForProjectLegacyNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCheckPermissionsForRepoInOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsCheckPermissionsForRepoInOrgNoContent from json.
func (s *TeamsCheckPermissionsForRepoInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCheckPermissionsForRepoInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCheckPermissionsForRepoInOrgNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsCheckPermissionsForRepoInOrgNotFound from json.
func (s *TeamsCheckPermissionsForRepoInOrgNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCheckPermissionsForRepoInOrgNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCheckPermissionsForRepoLegacyNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsCheckPermissionsForRepoLegacyNoContent from json.
func (s *TeamsCheckPermissionsForRepoLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCheckPermissionsForRepoLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCheckPermissionsForRepoLegacyNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsCheckPermissionsForRepoLegacyNotFound from json.
func (s *TeamsCheckPermissionsForRepoLegacyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCheckPermissionsForRepoLegacyNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateDiscussionCommentInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("body")
	e.Str(s.Body)
	e.ObjEnd()
}

// Decode decodes TeamsCreateDiscussionCommentInOrgReq from json.
func (s *TeamsCreateDiscussionCommentInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateDiscussionCommentInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateDiscussionCommentLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("body")
	e.Str(s.Body)
	e.ObjEnd()
}

// Decode decodes TeamsCreateDiscussionCommentLegacyReq from json.
func (s *TeamsCreateDiscussionCommentLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateDiscussionCommentLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateDiscussionInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("body")
	e.Str(s.Body)
	if s.Private.Set {
		e.FieldStart("private")
		s.Private.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsCreateDiscussionInOrgReq from json.
func (s *TeamsCreateDiscussionInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateDiscussionInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateDiscussionLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("body")
	e.Str(s.Body)
	if s.Private.Set {
		e.FieldStart("private")
		s.Private.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsCreateDiscussionLegacyReq from json.
func (s *TeamsCreateDiscussionLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateDiscussionLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		case "private":
			s.Private.Reset()
			if err := s.Private.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Groups != nil {
		e.FieldStart("groups")
		e.ArrStart()
		for _, elem := range s.Groups {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq from json.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateOrUpdateIdpGroupConnectionsInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("group_id")
	e.Str(s.GroupID)

	e.FieldStart("group_name")
	e.Str(s.GroupName)

	e.FieldStart("group_description")
	e.Str(s.GroupDescription)
	e.ObjEnd()
}

// Decode decodes TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem from json.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateOrUpdateIdpGroupConnectionsInOrgReqGroupsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group_id":
			v, err := d.Str()
			s.GroupID = string(v)
			if err != nil {
				return err
			}
		case "group_name":
			v, err := d.Str()
			s.GroupName = string(v)
			if err != nil {
				return err
			}
		case "group_description":
			v, err := d.Str()
			s.GroupDescription = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("groups")
	e.ArrStart()
	for _, elem := range s.Groups {
		elem.Encode(e)
	}
	e.ArrEnd()
	if s.SyncedAt.Set {
		e.FieldStart("synced_at")
		s.SyncedAt.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq from json.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateOrUpdateIdpGroupConnectionsLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groups":
			s.Groups = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Groups = append(s.Groups, elem)
				return nil
			}); err != nil {
				return err
			}
		case "synced_at":
			s.SyncedAt.Reset()
			if err := s.SyncedAt.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("group_id")
	e.Str(s.GroupID)

	e.FieldStart("group_name")
	e.Str(s.GroupName)

	e.FieldStart("group_description")
	e.Str(s.GroupDescription)
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem from json.
func (s *TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateOrUpdateIdpGroupConnectionsLegacyReqGroupsItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group_id":
			v, err := d.Str()
			s.GroupID = string(v)
			if err != nil {
				return err
			}
		case "group_name":
			v, err := d.Str()
			s.GroupName = string(v)
			if err != nil {
				return err
			}
		case "group_description":
			v, err := d.Str()
			s.GroupDescription = string(v)
			if err != nil {
				return err
			}
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsCreateReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.Maintainers != nil {
		e.FieldStart("maintainers")
		e.ArrStart()
		for _, elem := range s.Maintainers {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.RepoNames != nil {
		e.FieldStart("repo_names")
		e.ArrStart()
		for _, elem := range s.RepoNames {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	if s.Privacy.Set {
		e.FieldStart("privacy")
		s.Privacy.Encode(e)
	}
	if s.Permission.Set {
		e.FieldStart("permission")
		s.Permission.Encode(e)
	}
	if s.ParentTeamID.Set {
		e.FieldStart("parent_team_id")
		s.ParentTeamID.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsCreateReq from json.
func (s *TeamsCreateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "maintainers":
			s.Maintainers = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Maintainers = append(s.Maintainers, elem)
				return nil
			}); err != nil {
				return err
			}
		case "repo_names":
			s.RepoNames = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.RepoNames = append(s.RepoNames, elem)
				return nil
			}); err != nil {
				return err
			}
		case "privacy":
			s.Privacy.Reset()
			if err := s.Privacy.Decode(d); err != nil {
				return err
			}
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		case "parent_team_id":
			s.ParentTeamID.Reset()
			if err := s.ParentTeamID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsCreateReqPermission as json.
func (s TeamsCreateReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsCreateReqPermission from json.
func (s *TeamsCreateReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateReqPermission to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsCreateReqPermission(v)
	return nil
}

// Encode encodes TeamsCreateReqPrivacy as json.
func (s TeamsCreateReqPrivacy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsCreateReqPrivacy from json.
func (s *TeamsCreateReqPrivacy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsCreateReqPrivacy to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsCreateReqPrivacy(v)
	return nil
}

// Encode implements json.Marshaler.
func (s TeamsDeleteDiscussionCommentInOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsDeleteDiscussionCommentInOrgNoContent from json.
func (s *TeamsDeleteDiscussionCommentInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsDeleteDiscussionCommentInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsDeleteDiscussionCommentLegacyNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsDeleteDiscussionCommentLegacyNoContent from json.
func (s *TeamsDeleteDiscussionCommentLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsDeleteDiscussionCommentLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsDeleteDiscussionInOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsDeleteDiscussionInOrgNoContent from json.
func (s *TeamsDeleteDiscussionInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsDeleteDiscussionInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsDeleteDiscussionLegacyNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsDeleteDiscussionLegacyNoContent from json.
func (s *TeamsDeleteDiscussionLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsDeleteDiscussionLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsDeleteInOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsDeleteInOrgNoContent from json.
func (s *TeamsDeleteInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsDeleteInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsDeleteLegacyNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsDeleteLegacyNoContent from json.
func (s *TeamsDeleteLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsDeleteLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsGetMemberLegacyNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsGetMemberLegacyNoContent from json.
func (s *TeamsGetMemberLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsGetMemberLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsGetMemberLegacyNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsGetMemberLegacyNotFound from json.
func (s *TeamsGetMemberLegacyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsGetMemberLegacyNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsGetMembershipForUserInOrgNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsGetMembershipForUserInOrgNotFound from json.
func (s *TeamsGetMembershipForUserInOrgNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsGetMembershipForUserInOrgNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsListDiscussionCommentsInOrgDirection as json.
func (s TeamsListDiscussionCommentsInOrgDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsListDiscussionCommentsInOrgDirection from json.
func (s *TeamsListDiscussionCommentsInOrgDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListDiscussionCommentsInOrgDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsListDiscussionCommentsInOrgDirection(v)
	return nil
}

// Encode encodes TeamsListDiscussionCommentsLegacyDirection as json.
func (s TeamsListDiscussionCommentsLegacyDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsListDiscussionCommentsLegacyDirection from json.
func (s *TeamsListDiscussionCommentsLegacyDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListDiscussionCommentsLegacyDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsListDiscussionCommentsLegacyDirection(v)
	return nil
}

// Encode encodes TeamsListDiscussionsInOrgDirection as json.
func (s TeamsListDiscussionsInOrgDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsListDiscussionsInOrgDirection from json.
func (s *TeamsListDiscussionsInOrgDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListDiscussionsInOrgDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsListDiscussionsInOrgDirection(v)
	return nil
}

// Encode encodes TeamsListDiscussionsLegacyDirection as json.
func (s TeamsListDiscussionsLegacyDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsListDiscussionsLegacyDirection from json.
func (s *TeamsListDiscussionsLegacyDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListDiscussionsLegacyDirection to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsListDiscussionsLegacyDirection(v)
	return nil
}

// Encode encodes TeamsListForAuthenticatedUserApplicationJSONForbidden as json.
func (s TeamsListForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsListForAuthenticatedUserApplicationJSONForbidden from json.
func (s *TeamsListForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes TeamsListForAuthenticatedUserApplicationJSONNotFound as json.
func (s TeamsListForAuthenticatedUserApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsListForAuthenticatedUserApplicationJSONNotFound from json.
func (s *TeamsListForAuthenticatedUserApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListForAuthenticatedUserApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListForAuthenticatedUserApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes TeamsListForAuthenticatedUserOKApplicationJSON as json.
func (s TeamsListForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []TeamFull(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes TeamsListForAuthenticatedUserOKApplicationJSON from json.
func (s *TeamsListForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []TeamFull
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TeamFull
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes TeamsListIdpGroupsForLegacyApplicationJSONForbidden as json.
func (s TeamsListIdpGroupsForLegacyApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsListIdpGroupsForLegacyApplicationJSONForbidden from json.
func (s *TeamsListIdpGroupsForLegacyApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListIdpGroupsForLegacyApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListIdpGroupsForLegacyApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes TeamsListIdpGroupsForLegacyApplicationJSONNotFound as json.
func (s TeamsListIdpGroupsForLegacyApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes TeamsListIdpGroupsForLegacyApplicationJSONNotFound from json.
func (s *TeamsListIdpGroupsForLegacyApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListIdpGroupsForLegacyApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListIdpGroupsForLegacyApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes TeamsListMembersInOrgRole as json.
func (s TeamsListMembersInOrgRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsListMembersInOrgRole from json.
func (s *TeamsListMembersInOrgRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListMembersInOrgRole to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsListMembersInOrgRole(v)
	return nil
}

// Encode encodes TeamsListMembersLegacyOKApplicationJSON as json.
func (s TeamsListMembersLegacyOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes TeamsListMembersLegacyOKApplicationJSON from json.
func (s *TeamsListMembersLegacyOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListMembersLegacyOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListMembersLegacyOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes TeamsListMembersLegacyRole as json.
func (s TeamsListMembersLegacyRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsListMembersLegacyRole from json.
func (s *TeamsListMembersLegacyRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListMembersLegacyRole to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsListMembersLegacyRole(v)
	return nil
}

// Encode encodes TeamsListOKApplicationJSON as json.
func (s TeamsListOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Team(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes TeamsListOKApplicationJSON from json.
func (s *TeamsListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListOKApplicationJSON to nil`)
	}
	var unwrapped []Team
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Team
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes TeamsListProjectsLegacyOKApplicationJSON as json.
func (s TeamsListProjectsLegacyOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []TeamProject(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes TeamsListProjectsLegacyOKApplicationJSON from json.
func (s *TeamsListProjectsLegacyOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListProjectsLegacyOKApplicationJSON to nil`)
	}
	var unwrapped []TeamProject
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TeamProject
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListProjectsLegacyOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes TeamsListReposLegacyOKApplicationJSON as json.
func (s TeamsListReposLegacyOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []MinimalRepository(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes TeamsListReposLegacyOKApplicationJSON from json.
func (s *TeamsListReposLegacyOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsListReposLegacyOKApplicationJSON to nil`)
	}
	var unwrapped []MinimalRepository
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem MinimalRepository
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsListReposLegacyOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s TeamsRemoveMemberLegacyNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsRemoveMemberLegacyNoContent from json.
func (s *TeamsRemoveMemberLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveMemberLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveMemberLegacyNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsRemoveMemberLegacyNotFound from json.
func (s *TeamsRemoveMemberLegacyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveMemberLegacyNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveMembershipForUserInOrgForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsRemoveMembershipForUserInOrgForbidden from json.
func (s *TeamsRemoveMembershipForUserInOrgForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveMembershipForUserInOrgForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveMembershipForUserInOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsRemoveMembershipForUserInOrgNoContent from json.
func (s *TeamsRemoveMembershipForUserInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveMembershipForUserInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveMembershipForUserLegacyForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsRemoveMembershipForUserLegacyForbidden from json.
func (s *TeamsRemoveMembershipForUserLegacyForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveMembershipForUserLegacyForbidden to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveMembershipForUserLegacyNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsRemoveMembershipForUserLegacyNoContent from json.
func (s *TeamsRemoveMembershipForUserLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveMembershipForUserLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveProjectInOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsRemoveProjectInOrgNoContent from json.
func (s *TeamsRemoveProjectInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveProjectInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveProjectLegacyNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsRemoveProjectLegacyNoContent from json.
func (s *TeamsRemoveProjectLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveProjectLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveRepoInOrgNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsRemoveRepoInOrgNoContent from json.
func (s *TeamsRemoveRepoInOrgNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveRepoInOrgNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsRemoveRepoLegacyNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes TeamsRemoveRepoLegacyNoContent from json.
func (s *TeamsRemoveRepoLegacyNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsRemoveRepoLegacyNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsUpdateDiscussionCommentInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("body")
	e.Str(s.Body)
	e.ObjEnd()
}

// Decode decodes TeamsUpdateDiscussionCommentInOrgReq from json.
func (s *TeamsUpdateDiscussionCommentInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateDiscussionCommentInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsUpdateDiscussionCommentLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("body")
	e.Str(s.Body)
	e.ObjEnd()
}

// Decode decodes TeamsUpdateDiscussionCommentLegacyReq from json.
func (s *TeamsUpdateDiscussionCommentLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateDiscussionCommentLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			v, err := d.Str()
			s.Body = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsUpdateDiscussionInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Title.Set {
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsUpdateDiscussionInOrgReq from json.
func (s *TeamsUpdateDiscussionInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateDiscussionInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsUpdateDiscussionLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Title.Set {
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	if s.Body.Set {
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsUpdateDiscussionLegacyReq from json.
func (s *TeamsUpdateDiscussionLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateDiscussionLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "body":
			s.Body.Reset()
			if err := s.Body.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TeamsUpdateInOrgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.Privacy.Set {
		e.FieldStart("privacy")
		s.Privacy.Encode(e)
	}
	if s.Permission.Set {
		e.FieldStart("permission")
		s.Permission.Encode(e)
	}
	if s.ParentTeamID.Set {
		e.FieldStart("parent_team_id")
		s.ParentTeamID.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsUpdateInOrgReq from json.
func (s *TeamsUpdateInOrgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateInOrgReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "privacy":
			s.Privacy.Reset()
			if err := s.Privacy.Decode(d); err != nil {
				return err
			}
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		case "parent_team_id":
			s.ParentTeamID.Reset()
			if err := s.ParentTeamID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsUpdateInOrgReqPermission as json.
func (s TeamsUpdateInOrgReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsUpdateInOrgReqPermission from json.
func (s *TeamsUpdateInOrgReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateInOrgReqPermission to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsUpdateInOrgReqPermission(v)
	return nil
}

// Encode encodes TeamsUpdateInOrgReqPrivacy as json.
func (s TeamsUpdateInOrgReqPrivacy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsUpdateInOrgReqPrivacy from json.
func (s *TeamsUpdateInOrgReqPrivacy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateInOrgReqPrivacy to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsUpdateInOrgReqPrivacy(v)
	return nil
}

// Encode implements json.Marshaler.
func (s TeamsUpdateLegacyReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)
	if s.Description.Set {
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	if s.Privacy.Set {
		e.FieldStart("privacy")
		s.Privacy.Encode(e)
	}
	if s.Permission.Set {
		e.FieldStart("permission")
		s.Permission.Encode(e)
	}
	if s.ParentTeamID.Set {
		e.FieldStart("parent_team_id")
		s.ParentTeamID.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TeamsUpdateLegacyReq from json.
func (s *TeamsUpdateLegacyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateLegacyReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "description":
			s.Description.Reset()
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "privacy":
			s.Privacy.Reset()
			if err := s.Privacy.Decode(d); err != nil {
				return err
			}
		case "permission":
			s.Permission.Reset()
			if err := s.Permission.Decode(d); err != nil {
				return err
			}
		case "parent_team_id":
			s.ParentTeamID.Reset()
			if err := s.ParentTeamID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes TeamsUpdateLegacyReqPermission as json.
func (s TeamsUpdateLegacyReqPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsUpdateLegacyReqPermission from json.
func (s *TeamsUpdateLegacyReqPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateLegacyReqPermission to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsUpdateLegacyReqPermission(v)
	return nil
}

// Encode encodes TeamsUpdateLegacyReqPrivacy as json.
func (s TeamsUpdateLegacyReqPrivacy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TeamsUpdateLegacyReqPrivacy from json.
func (s *TeamsUpdateLegacyReqPrivacy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TeamsUpdateLegacyReqPrivacy to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = TeamsUpdateLegacyReqPrivacy(v)
	return nil
}

// Encode implements json.Marshaler.
func (s Thread) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Str(s.ID)

	e.FieldStart("repository")
	s.Repository.Encode(e)

	e.FieldStart("subject")
	s.Subject.Encode(e)

	e.FieldStart("reason")
	e.Str(s.Reason)

	e.FieldStart("unread")
	e.Bool(s.Unread)

	e.FieldStart("updated_at")
	e.Str(s.UpdatedAt)

	e.FieldStart("last_read_at")
	s.LastReadAt.Encode(e)

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("subscription_url")
	e.Str(s.SubscriptionURL)
	e.ObjEnd()
}

// Decode decodes Thread from json.
func (s *Thread) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Thread to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Str()
			s.ID = string(v)
			if err != nil {
				return err
			}
		case "repository":
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "subject":
			if err := s.Subject.Decode(d); err != nil {
				return err
			}
		case "reason":
			v, err := d.Str()
			s.Reason = string(v)
			if err != nil {
				return err
			}
		case "unread":
			v, err := d.Bool()
			s.Unread = bool(v)
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := d.Str()
			s.UpdatedAt = string(v)
			if err != nil {
				return err
			}
		case "last_read_at":
			if err := s.LastReadAt.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "subscription_url":
			v, err := d.Str()
			s.SubscriptionURL = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ThreadSubject) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("title")
	e.Str(s.Title)

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("latest_comment_url")
	e.Str(s.LatestCommentURL)

	e.FieldStart("type")
	e.Str(s.Type)
	e.ObjEnd()
}

// Decode decodes ThreadSubject from json.
func (s *ThreadSubject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ThreadSubject to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			v, err := d.Str()
			s.Title = string(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "latest_comment_url":
			v, err := d.Str()
			s.LatestCommentURL = string(v)
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ThreadSubscription) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("subscribed")
	e.Bool(s.Subscribed)

	e.FieldStart("ignored")
	e.Bool(s.Ignored)

	e.FieldStart("reason")
	s.Reason.Encode(e)

	e.FieldStart("created_at")
	s.CreatedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)
	if s.ThreadURL.Set {
		e.FieldStart("thread_url")
		s.ThreadURL.Encode(e)
	}
	if s.RepositoryURL.Set {
		e.FieldStart("repository_url")
		s.RepositoryURL.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes ThreadSubscription from json.
func (s *ThreadSubscription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ThreadSubscription to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscribed":
			v, err := d.Bool()
			s.Subscribed = bool(v)
			if err != nil {
				return err
			}
		case "ignored":
			v, err := d.Bool()
			s.Ignored = bool(v)
			if err != nil {
				return err
			}
		case "reason":
			if err := s.Reason.Decode(d); err != nil {
				return err
			}
		case "created_at":
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "thread_url":
			s.ThreadURL.Reset()
			if err := s.ThreadURL.Decode(d); err != nil {
				return err
			}
		case "repository_url":
			s.RepositoryURL.Reset()
			if err := s.RepositoryURL.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Topic) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("names")
	e.ArrStart()
	for _, elem := range s.Names {
		e.Str(elem)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes Topic from json.
func (s *Topic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Topic to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "names":
			s.Names = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Names = append(s.Names, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TopicSearchResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("display_name")
	s.DisplayName.Encode(e)

	e.FieldStart("short_description")
	s.ShortDescription.Encode(e)

	e.FieldStart("description")
	s.Description.Encode(e)

	e.FieldStart("created_by")
	s.CreatedBy.Encode(e)

	e.FieldStart("released")
	s.Released.Encode(e)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("featured")
	e.Bool(s.Featured)

	e.FieldStart("curated")
	e.Bool(s.Curated)

	e.FieldStart("score")
	e.Float64(s.Score)
	if s.RepositoryCount.Set {
		e.FieldStart("repository_count")
		s.RepositoryCount.Encode(e)
	}
	if s.LogoURL.Set {
		e.FieldStart("logo_url")
		s.LogoURL.Encode(e)
	}
	if s.TextMatches != nil {
		e.FieldStart("text_matches")
		s.TextMatches.Encode(e)
	}
	if s.Related.Set {
		e.FieldStart("related")
		s.Related.Encode(e)
	}
	if s.Aliases.Set {
		e.FieldStart("aliases")
		s.Aliases.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TopicSearchResultItem from json.
func (s *TopicSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TopicSearchResultItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "display_name":
			if err := s.DisplayName.Decode(d); err != nil {
				return err
			}
		case "short_description":
			if err := s.ShortDescription.Decode(d); err != nil {
				return err
			}
		case "description":
			if err := s.Description.Decode(d); err != nil {
				return err
			}
		case "created_by":
			if err := s.CreatedBy.Decode(d); err != nil {
				return err
			}
		case "released":
			if err := s.Released.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "featured":
			v, err := d.Bool()
			s.Featured = bool(v)
			if err != nil {
				return err
			}
		case "curated":
			v, err := d.Bool()
			s.Curated = bool(v)
			if err != nil {
				return err
			}
		case "score":
			v, err := d.Float64()
			s.Score = float64(v)
			if err != nil {
				return err
			}
		case "repository_count":
			s.RepositoryCount.Reset()
			if err := s.RepositoryCount.Decode(d); err != nil {
				return err
			}
		case "logo_url":
			s.LogoURL.Reset()
			if err := s.LogoURL.Decode(d); err != nil {
				return err
			}
		case "text_matches":
			s.TextMatches = nil
			var elem SearchResultTextMatches
			{
				var unwrapped []SearchResultTextMatchesItem
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultTextMatchesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = SearchResultTextMatches(unwrapped)
			}
			s.TextMatches = &elem
		case "related":
			s.Related.Reset()
			if err := s.Related.Decode(d); err != nil {
				return err
			}
		case "aliases":
			s.Aliases.Reset()
			if err := s.Aliases.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TopicSearchResultItemAliasesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.TopicRelation.Set {
		e.FieldStart("topic_relation")
		s.TopicRelation.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TopicSearchResultItemAliasesItem from json.
func (s *TopicSearchResultItemAliasesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TopicSearchResultItemAliasesItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "topic_relation":
			s.TopicRelation.Reset()
			if err := s.TopicRelation.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TopicSearchResultItemAliasesItemTopicRelation) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.TopicID.Set {
		e.FieldStart("topic_id")
		s.TopicID.Encode(e)
	}
	if s.RelationType.Set {
		e.FieldStart("relation_type")
		s.RelationType.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TopicSearchResultItemAliasesItemTopicRelation from json.
func (s *TopicSearchResultItemAliasesItemTopicRelation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TopicSearchResultItemAliasesItemTopicRelation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "topic_id":
			s.TopicID.Reset()
			if err := s.TopicID.Decode(d); err != nil {
				return err
			}
		case "relation_type":
			s.RelationType.Reset()
			if err := s.RelationType.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TopicSearchResultItemRelatedItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.TopicRelation.Set {
		e.FieldStart("topic_relation")
		s.TopicRelation.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TopicSearchResultItemRelatedItem from json.
func (s *TopicSearchResultItemRelatedItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TopicSearchResultItemRelatedItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "topic_relation":
			s.TopicRelation.Reset()
			if err := s.TopicRelation.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s TopicSearchResultItemRelatedItemTopicRelation) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.ID.Set {
		e.FieldStart("id")
		s.ID.Encode(e)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.TopicID.Set {
		e.FieldStart("topic_id")
		s.TopicID.Encode(e)
	}
	if s.RelationType.Set {
		e.FieldStart("relation_type")
		s.RelationType.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes TopicSearchResultItemRelatedItemTopicRelation from json.
func (s *TopicSearchResultItemRelatedItemTopicRelation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode TopicSearchResultItemRelatedItemTopicRelation to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			s.ID.Reset()
			if err := s.ID.Decode(d); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "topic_id":
			s.TopicID.Reset()
			if err := s.TopicID.Decode(d); err != nil {
				return err
			}
		case "relation_type":
			s.RelationType.Reset()
			if err := s.RelationType.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Traffic) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("timestamp")
	json.EncodeDateTime(e, s.Timestamp)

	e.FieldStart("uniques")
	e.Int(s.Uniques)

	e.FieldStart("count")
	e.Int(s.Count)
	e.ObjEnd()
}

// Decode decodes Traffic from json.
func (s *Traffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Traffic to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			v, err := json.DecodeDateTime(d)
			s.Timestamp = v
			if err != nil {
				return err
			}
		case "uniques":
			v, err := d.Int()
			s.Uniques = int(v)
			if err != nil {
				return err
			}
		case "count":
			v, err := d.Int()
			s.Count = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UserMarketplacePurchase) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("billing_cycle")
	e.Str(s.BillingCycle)

	e.FieldStart("next_billing_date")
	s.NextBillingDate.Encode(e, json.EncodeDateTime)

	e.FieldStart("unit_count")
	s.UnitCount.Encode(e)

	e.FieldStart("on_free_trial")
	e.Bool(s.OnFreeTrial)

	e.FieldStart("free_trial_ends_on")
	s.FreeTrialEndsOn.Encode(e, json.EncodeDateTime)

	e.FieldStart("updated_at")
	s.UpdatedAt.Encode(e, json.EncodeDateTime)

	e.FieldStart("account")
	s.Account.Encode(e)

	e.FieldStart("plan")
	s.Plan.Encode(e)
	e.ObjEnd()
}

// Decode decodes UserMarketplacePurchase from json.
func (s *UserMarketplacePurchase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UserMarketplacePurchase to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billing_cycle":
			v, err := d.Str()
			s.BillingCycle = string(v)
			if err != nil {
				return err
			}
		case "next_billing_date":
			if err := s.NextBillingDate.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "unit_count":
			if err := s.UnitCount.Decode(d); err != nil {
				return err
			}
		case "on_free_trial":
			v, err := d.Bool()
			s.OnFreeTrial = bool(v)
			if err != nil {
				return err
			}
		case "free_trial_ends_on":
			if err := s.FreeTrialEndsOn.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "account":
			if err := s.Account.Decode(d); err != nil {
				return err
			}
		case "plan":
			if err := s.Plan.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UserSearchResultItem) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("login")
	e.Str(s.Login)

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("avatar_url")
	json.EncodeURI(e, s.AvatarURL)

	e.FieldStart("gravatar_id")
	s.GravatarID.Encode(e)

	e.FieldStart("url")
	json.EncodeURI(e, s.URL)

	e.FieldStart("html_url")
	json.EncodeURI(e, s.HTMLURL)

	e.FieldStart("followers_url")
	json.EncodeURI(e, s.FollowersURL)

	e.FieldStart("subscriptions_url")
	json.EncodeURI(e, s.SubscriptionsURL)

	e.FieldStart("organizations_url")
	json.EncodeURI(e, s.OrganizationsURL)

	e.FieldStart("repos_url")
	json.EncodeURI(e, s.ReposURL)

	e.FieldStart("received_events_url")
	json.EncodeURI(e, s.ReceivedEventsURL)

	e.FieldStart("type")
	e.Str(s.Type)

	e.FieldStart("score")
	e.Float64(s.Score)

	e.FieldStart("following_url")
	e.Str(s.FollowingURL)

	e.FieldStart("gists_url")
	e.Str(s.GistsURL)

	e.FieldStart("starred_url")
	e.Str(s.StarredURL)

	e.FieldStart("events_url")
	e.Str(s.EventsURL)
	if s.PublicRepos.Set {
		e.FieldStart("public_repos")
		s.PublicRepos.Encode(e)
	}
	if s.PublicGists.Set {
		e.FieldStart("public_gists")
		s.PublicGists.Encode(e)
	}
	if s.Followers.Set {
		e.FieldStart("followers")
		s.Followers.Encode(e)
	}
	if s.Following.Set {
		e.FieldStart("following")
		s.Following.Encode(e)
	}
	if s.CreatedAt.Set {
		e.FieldStart("created_at")
		s.CreatedAt.Encode(e, json.EncodeDateTime)
	}
	if s.UpdatedAt.Set {
		e.FieldStart("updated_at")
		s.UpdatedAt.Encode(e, json.EncodeDateTime)
	}
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Bio.Set {
		e.FieldStart("bio")
		s.Bio.Encode(e)
	}
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	if s.Location.Set {
		e.FieldStart("location")
		s.Location.Encode(e)
	}

	e.FieldStart("site_admin")
	e.Bool(s.SiteAdmin)
	if s.Hireable.Set {
		e.FieldStart("hireable")
		s.Hireable.Encode(e)
	}
	if s.TextMatches != nil {
		e.FieldStart("text_matches")
		s.TextMatches.Encode(e)
	}
	if s.Blog.Set {
		e.FieldStart("blog")
		s.Blog.Encode(e)
	}
	if s.Company.Set {
		e.FieldStart("company")
		s.Company.Encode(e)
	}
	if s.SuspendedAt.Set {
		e.FieldStart("suspended_at")
		s.SuspendedAt.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

// Decode decodes UserSearchResultItem from json.
func (s *UserSearchResultItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UserSearchResultItem to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "login":
			v, err := d.Str()
			s.Login = string(v)
			if err != nil {
				return err
			}
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "avatar_url":
			v, err := json.DecodeURI(d)
			s.AvatarURL = v
			if err != nil {
				return err
			}
		case "gravatar_id":
			if err := s.GravatarID.Decode(d); err != nil {
				return err
			}
		case "url":
			v, err := json.DecodeURI(d)
			s.URL = v
			if err != nil {
				return err
			}
		case "html_url":
			v, err := json.DecodeURI(d)
			s.HTMLURL = v
			if err != nil {
				return err
			}
		case "followers_url":
			v, err := json.DecodeURI(d)
			s.FollowersURL = v
			if err != nil {
				return err
			}
		case "subscriptions_url":
			v, err := json.DecodeURI(d)
			s.SubscriptionsURL = v
			if err != nil {
				return err
			}
		case "organizations_url":
			v, err := json.DecodeURI(d)
			s.OrganizationsURL = v
			if err != nil {
				return err
			}
		case "repos_url":
			v, err := json.DecodeURI(d)
			s.ReposURL = v
			if err != nil {
				return err
			}
		case "received_events_url":
			v, err := json.DecodeURI(d)
			s.ReceivedEventsURL = v
			if err != nil {
				return err
			}
		case "type":
			v, err := d.Str()
			s.Type = string(v)
			if err != nil {
				return err
			}
		case "score":
			v, err := d.Float64()
			s.Score = float64(v)
			if err != nil {
				return err
			}
		case "following_url":
			v, err := d.Str()
			s.FollowingURL = string(v)
			if err != nil {
				return err
			}
		case "gists_url":
			v, err := d.Str()
			s.GistsURL = string(v)
			if err != nil {
				return err
			}
		case "starred_url":
			v, err := d.Str()
			s.StarredURL = string(v)
			if err != nil {
				return err
			}
		case "events_url":
			v, err := d.Str()
			s.EventsURL = string(v)
			if err != nil {
				return err
			}
		case "public_repos":
			s.PublicRepos.Reset()
			if err := s.PublicRepos.Decode(d); err != nil {
				return err
			}
		case "public_gists":
			s.PublicGists.Reset()
			if err := s.PublicGists.Decode(d); err != nil {
				return err
			}
		case "followers":
			s.Followers.Reset()
			if err := s.Followers.Decode(d); err != nil {
				return err
			}
		case "following":
			s.Following.Reset()
			if err := s.Following.Decode(d); err != nil {
				return err
			}
		case "created_at":
			s.CreatedAt.Reset()
			if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "updated_at":
			s.UpdatedAt.Reset()
			if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "bio":
			s.Bio.Reset()
			if err := s.Bio.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "site_admin":
			v, err := d.Bool()
			s.SiteAdmin = bool(v)
			if err != nil {
				return err
			}
		case "hireable":
			s.Hireable.Reset()
			if err := s.Hireable.Decode(d); err != nil {
				return err
			}
		case "text_matches":
			s.TextMatches = nil
			var elem SearchResultTextMatches
			{
				var unwrapped []SearchResultTextMatchesItem
				unwrapped = nil
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SearchResultTextMatchesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					unwrapped = append(unwrapped, elem)
					return nil
				}); err != nil {
					return err
				}
				elem = SearchResultTextMatches(unwrapped)
			}
			s.TextMatches = &elem
		case "blog":
			s.Blog.Reset()
			if err := s.Blog.Decode(d); err != nil {
				return err
			}
		case "company":
			s.Company.Reset()
			if err := s.Company.Decode(d); err != nil {
				return err
			}
		case "suspended_at":
			s.SuspendedAt.Reset()
			if err := s.SuspendedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UsersBlockNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes UsersBlockNoContent from json.
func (s *UsersBlockNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersBlockNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersCheckBlockedApplicationJSONForbidden as json.
func (s UsersCheckBlockedApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckBlockedApplicationJSONForbidden from json.
func (s *UsersCheckBlockedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckBlockedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckBlockedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersCheckBlockedApplicationJSONNotFound as json.
func (s UsersCheckBlockedApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckBlockedApplicationJSONNotFound from json.
func (s *UsersCheckBlockedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckBlockedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckBlockedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersCheckBlockedApplicationJSONUnauthorized as json.
func (s UsersCheckBlockedApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckBlockedApplicationJSONUnauthorized from json.
func (s *UsersCheckBlockedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckBlockedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckBlockedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersCheckBlockedNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes UsersCheckBlockedNoContent from json.
func (s *UsersCheckBlockedNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckBlockedNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UsersCheckFollowingForUserNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes UsersCheckFollowingForUserNoContent from json.
func (s *UsersCheckFollowingForUserNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckFollowingForUserNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UsersCheckFollowingForUserNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes UsersCheckFollowingForUserNotFound from json.
func (s *UsersCheckFollowingForUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckFollowingForUserNotFound to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden as json.
func (s UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden from json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound as json.
func (s UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound from json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersCheckPersonIsFollowedByAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersCheckPersonIsFollowedByAuthenticatedNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes UsersCheckPersonIsFollowedByAuthenticatedNoContent from json.
func (s *UsersCheckPersonIsFollowedByAuthenticatedNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCheckPersonIsFollowedByAuthenticatedNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UsersCreateGpgKeyForAuthenticatedReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("armored_public_key")
	e.Str(s.ArmoredPublicKey)
	e.ObjEnd()
}

// Decode decodes UsersCreateGpgKeyForAuthenticatedReq from json.
func (s *UsersCreateGpgKeyForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCreateGpgKeyForAuthenticatedReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "armored_public_key":
			v, err := d.Str()
			s.ArmoredPublicKey = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UsersCreatePublicSSHKeyForAuthenticatedReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Title.Set {
		e.FieldStart("title")
		s.Title.Encode(e)
	}

	e.FieldStart("key")
	e.Str(s.Key)
	e.ObjEnd()
}

// Decode decodes UsersCreatePublicSSHKeyForAuthenticatedReq from json.
func (s *UsersCreatePublicSSHKeyForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersCreatePublicSSHKeyForAuthenticatedReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			s.Title.Reset()
			if err := s.Title.Decode(d); err != nil {
				return err
			}
		case "key":
			v, err := d.Str()
			s.Key = string(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UsersDeleteGpgKeyForAuthenticatedNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes UsersDeleteGpgKeyForAuthenticatedNoContent from json.
func (s *UsersDeleteGpgKeyForAuthenticatedNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeleteGpgKeyForAuthenticatedNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden as json.
func (s UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound as json.
func (s UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersDeletePublicSSHKeyForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersDeletePublicSSHKeyForAuthenticatedNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes UsersDeletePublicSSHKeyForAuthenticatedNoContent from json.
func (s *UsersDeletePublicSSHKeyForAuthenticatedNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersDeletePublicSSHKeyForAuthenticatedNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersFollowApplicationJSONForbidden as json.
func (s UsersFollowApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersFollowApplicationJSONForbidden from json.
func (s *UsersFollowApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersFollowApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersFollowApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersFollowApplicationJSONNotFound as json.
func (s UsersFollowApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersFollowApplicationJSONNotFound from json.
func (s *UsersFollowApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersFollowApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersFollowApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersFollowApplicationJSONUnauthorized as json.
func (s UsersFollowApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersFollowApplicationJSONUnauthorized from json.
func (s *UsersFollowApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersFollowApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersFollowApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersFollowNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes UsersFollowNoContent from json.
func (s *UsersFollowNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersFollowNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersGetAuthenticatedApplicationJSONForbidden as json.
func (s UsersGetAuthenticatedApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetAuthenticatedApplicationJSONForbidden from json.
func (s *UsersGetAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersGetAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersGetAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersGetAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersGetAuthenticatedOK as json.
func (s UsersGetAuthenticatedOK) Encode(e *jx.Encoder) {
	switch s.Type {
	case PrivateUserUsersGetAuthenticatedOK:
		s.PrivateUser.Encode(e)
	case PublicUserUsersGetAuthenticatedOK:
		s.PublicUser.Encode(e)
	}
}

// Decode decodes UsersGetAuthenticatedOK from json.
func (s *UsersGetAuthenticatedOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetAuthenticatedOK to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "two_factor_authentication":
				found = true
				s.Type = PrivateUserUsersGetAuthenticatedOK
			case "business_plus":
				found = true
				s.Type = PrivateUserUsersGetAuthenticatedOK
			case "ldap_dn":
				found = true
				s.Type = PrivateUserUsersGetAuthenticatedOK
			case "login":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "id":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "node_id":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "avatar_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "gravatar_id":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "html_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "followers_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "following_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "gists_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "starred_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "subscriptions_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "organizations_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "repos_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "events_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "received_events_url":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "type":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "site_admin":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "name":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "company":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "blog":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "location":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "email":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "hireable":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "bio":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "twitter_username":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "public_repos":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "public_gists":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "followers":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "following":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "created_at":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "updated_at":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "plan":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "suspended_at":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "private_gists":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "total_private_repos":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "owned_private_repos":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "disk_usage":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			case "collaborators":
				found = true
				s.Type = PublicUserUsersGetAuthenticatedOK
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PrivateUserUsersGetAuthenticatedOK:
		if err := s.PrivateUser.Decode(d); err != nil {
			return err
		}
	case PublicUserUsersGetAuthenticatedOK:
		if err := s.PublicUser.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode encodes UsersGetByUsernameOK as json.
func (s UsersGetByUsernameOK) Encode(e *jx.Encoder) {
	switch s.Type {
	case PrivateUserUsersGetByUsernameOK:
		s.PrivateUser.Encode(e)
	case PublicUserUsersGetByUsernameOK:
		s.PublicUser.Encode(e)
	}
}

// Decode decodes UsersGetByUsernameOK from json.
func (s *UsersGetByUsernameOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetByUsernameOK to nil`)
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}
	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "two_factor_authentication":
				found = true
				s.Type = PrivateUserUsersGetByUsernameOK
			case "business_plus":
				found = true
				s.Type = PrivateUserUsersGetByUsernameOK
			case "ldap_dn":
				found = true
				s.Type = PrivateUserUsersGetByUsernameOK
			case "login":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "id":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "node_id":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "avatar_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "gravatar_id":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "html_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "followers_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "following_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "gists_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "starred_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "subscriptions_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "organizations_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "repos_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "events_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "received_events_url":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "type":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "site_admin":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "name":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "company":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "blog":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "location":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "email":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "hireable":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "bio":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "twitter_username":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "public_repos":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "public_gists":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "followers":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "following":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "created_at":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "updated_at":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "plan":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "suspended_at":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "private_gists":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "total_private_repos":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "owned_private_repos":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "disk_usage":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			case "collaborators":
				found = true
				s.Type = PublicUserUsersGetByUsernameOK
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case PrivateUserUsersGetByUsernameOK:
		if err := s.PrivateUser.Decode(d); err != nil {
			return err
		}
	case PublicUserUsersGetByUsernameOK:
		if err := s.PublicUser.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// Encode encodes UsersGetContextForUserSubjectType as json.
func (s UsersGetContextForUserSubjectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UsersGetContextForUserSubjectType from json.
func (s *UsersGetContextForUserSubjectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetContextForUserSubjectType to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = UsersGetContextForUserSubjectType(v)
	return nil
}

// Encode encodes UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden as json.
func (s UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetGpgKeyForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound as json.
func (s UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetGpgKeyForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetGpgKeyForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden as json.
func (s UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetPublicSSHKeyForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound as json.
func (s UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetPublicSSHKeyForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersGetPublicSSHKeyForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListBlockedByAuthenticatedApplicationJSONForbidden as json.
func (s UsersListBlockedByAuthenticatedApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListBlockedByAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListBlockedByAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListBlockedByAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListBlockedByAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListBlockedByAuthenticatedApplicationJSONNotFound as json.
func (s UsersListBlockedByAuthenticatedApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListBlockedByAuthenticatedApplicationJSONNotFound from json.
func (s *UsersListBlockedByAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListBlockedByAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListBlockedByAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersListBlockedByAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListBlockedByAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListBlockedByAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListBlockedByAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListBlockedByAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListBlockedByAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListBlockedByAuthenticatedOKApplicationJSON as json.
func (s UsersListBlockedByAuthenticatedOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UsersListBlockedByAuthenticatedOKApplicationJSON from json.
func (s *UsersListBlockedByAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListBlockedByAuthenticatedOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListBlockedByAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListEmailsForAuthenticatedApplicationJSONForbidden as json.
func (s UsersListEmailsForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListEmailsForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListEmailsForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListEmailsForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListEmailsForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListEmailsForAuthenticatedApplicationJSONNotFound as json.
func (s UsersListEmailsForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListEmailsForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersListEmailsForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListEmailsForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListEmailsForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersListEmailsForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListEmailsForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListEmailsForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListEmailsForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListEmailsForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListEmailsForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListEmailsForAuthenticatedOKApplicationJSON as json.
func (s UsersListEmailsForAuthenticatedOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Email(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UsersListEmailsForAuthenticatedOKApplicationJSON from json.
func (s *UsersListEmailsForAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListEmailsForAuthenticatedOKApplicationJSON to nil`)
	}
	var unwrapped []Email
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Email
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListEmailsForAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListFollowedByAuthenticatedApplicationJSONForbidden as json.
func (s UsersListFollowedByAuthenticatedApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListFollowedByAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListFollowedByAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListFollowedByAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowedByAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListFollowedByAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListFollowedByAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListFollowedByAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListFollowedByAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListFollowedByAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowedByAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListFollowedByAuthenticatedOKApplicationJSON as json.
func (s UsersListFollowedByAuthenticatedOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UsersListFollowedByAuthenticatedOKApplicationJSON from json.
func (s *UsersListFollowedByAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListFollowedByAuthenticatedOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowedByAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListFollowersForAuthenticatedUserApplicationJSONForbidden as json.
func (s UsersListFollowersForAuthenticatedUserApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListFollowersForAuthenticatedUserApplicationJSONForbidden from json.
func (s *UsersListFollowersForAuthenticatedUserApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListFollowersForAuthenticatedUserApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowersForAuthenticatedUserApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized as json.
func (s UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized from json.
func (s *UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowersForAuthenticatedUserApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListFollowersForAuthenticatedUserOKApplicationJSON as json.
func (s UsersListFollowersForAuthenticatedUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UsersListFollowersForAuthenticatedUserOKApplicationJSON from json.
func (s *UsersListFollowersForAuthenticatedUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListFollowersForAuthenticatedUserOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListFollowersForAuthenticatedUserOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListGpgKeysForAuthenticatedApplicationJSONForbidden as json.
func (s UsersListGpgKeysForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListGpgKeysForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListGpgKeysForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListGpgKeysForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListGpgKeysForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListGpgKeysForAuthenticatedApplicationJSONNotFound as json.
func (s UsersListGpgKeysForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListGpgKeysForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersListGpgKeysForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListGpgKeysForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListGpgKeysForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListGpgKeysForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListGpgKeysForAuthenticatedOKApplicationJSON as json.
func (s UsersListGpgKeysForAuthenticatedOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []GpgKey(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UsersListGpgKeysForAuthenticatedOKApplicationJSON from json.
func (s *UsersListGpgKeysForAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListGpgKeysForAuthenticatedOKApplicationJSON to nil`)
	}
	var unwrapped []GpgKey
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GpgKey
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListGpgKeysForAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListOKApplicationJSON as json.
func (s UsersListOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SimpleUser(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UsersListOKApplicationJSON from json.
func (s *UsersListOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListOKApplicationJSON to nil`)
	}
	var unwrapped []SimpleUser
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SimpleUser
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden as json.
func (s UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicEmailsForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound as json.
func (s UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicEmailsForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicEmailsForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListPublicEmailsForAuthenticatedOKApplicationJSON as json.
func (s UsersListPublicEmailsForAuthenticatedOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Email(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UsersListPublicEmailsForAuthenticatedOKApplicationJSON from json.
func (s *UsersListPublicEmailsForAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListPublicEmailsForAuthenticatedOKApplicationJSON to nil`)
	}
	var unwrapped []Email
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Email
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicEmailsForAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode encodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden as json.
func (s UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden from json.
func (s *UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicSSHKeysForAuthenticatedApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound as json.
func (s UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound from json.
func (s *UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicSSHKeysForAuthenticatedApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized as json.
func (s UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized from json.
func (s *UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicSSHKeysForAuthenticatedApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode encodes UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON as json.
func (s UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Key(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON from json.
func (s *UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON to nil`)
	}
	var unwrapped []Key
	if err := func() error {
		unwrapped = nil
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Key
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersListPublicSSHKeysForAuthenticatedOKApplicationJSON(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedReq) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("visibility")
	s.Visibility.Encode(e)
	e.ObjEnd()
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedReq from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "visibility":
			if err := s.Visibility.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility as json.
func (s UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility from json.
func (s *UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = UsersSetPrimaryEmailVisibilityForAuthenticatedReqVisibility(v)
	return nil
}

// Encode encodes UsersUnblockApplicationJSONForbidden as json.
func (s UsersUnblockApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnblockApplicationJSONForbidden from json.
func (s *UsersUnblockApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUnblockApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnblockApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersUnblockApplicationJSONNotFound as json.
func (s UsersUnblockApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnblockApplicationJSONNotFound from json.
func (s *UsersUnblockApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUnblockApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnblockApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersUnblockApplicationJSONUnauthorized as json.
func (s UsersUnblockApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnblockApplicationJSONUnauthorized from json.
func (s *UsersUnblockApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUnblockApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnblockApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersUnblockNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes UsersUnblockNoContent from json.
func (s *UsersUnblockNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUnblockNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes UsersUnfollowApplicationJSONForbidden as json.
func (s UsersUnfollowApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnfollowApplicationJSONForbidden from json.
func (s *UsersUnfollowApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUnfollowApplicationJSONForbidden to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnfollowApplicationJSONForbidden(unwrapped)
	return nil
}

// Encode encodes UsersUnfollowApplicationJSONNotFound as json.
func (s UsersUnfollowApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnfollowApplicationJSONNotFound from json.
func (s *UsersUnfollowApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUnfollowApplicationJSONNotFound to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnfollowApplicationJSONNotFound(unwrapped)
	return nil
}

// Encode encodes UsersUnfollowApplicationJSONUnauthorized as json.
func (s UsersUnfollowApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := BasicError(s)
	unwrapped.Encode(e)
}

// Decode decodes UsersUnfollowApplicationJSONUnauthorized from json.
func (s *UsersUnfollowApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUnfollowApplicationJSONUnauthorized to nil`)
	}
	var unwrapped BasicError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersUnfollowApplicationJSONUnauthorized(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s UsersUnfollowNoContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	e.ObjEnd()
}

// Decode decodes UsersUnfollowNoContent from json.
func (s *UsersUnfollowNoContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUnfollowNoContent to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s UsersUpdateAuthenticatedReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	if s.Email.Set {
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	if s.Blog.Set {
		e.FieldStart("blog")
		s.Blog.Encode(e)
	}
	if s.TwitterUsername.Set {
		e.FieldStart("twitter_username")
		s.TwitterUsername.Encode(e)
	}
	if s.Company.Set {
		e.FieldStart("company")
		s.Company.Encode(e)
	}
	if s.Location.Set {
		e.FieldStart("location")
		s.Location.Encode(e)
	}
	if s.Hireable.Set {
		e.FieldStart("hireable")
		s.Hireable.Encode(e)
	}
	if s.Bio.Set {
		e.FieldStart("bio")
		s.Bio.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes UsersUpdateAuthenticatedReq from json.
func (s *UsersUpdateAuthenticatedReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode UsersUpdateAuthenticatedReq to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "email":
			s.Email.Reset()
			if err := s.Email.Decode(d); err != nil {
				return err
			}
		case "blog":
			s.Blog.Reset()
			if err := s.Blog.Decode(d); err != nil {
				return err
			}
		case "twitter_username":
			s.TwitterUsername.Reset()
			if err := s.TwitterUsername.Decode(d); err != nil {
				return err
			}
		case "company":
			s.Company.Reset()
			if err := s.Company.Decode(d); err != nil {
				return err
			}
		case "location":
			s.Location.Reset()
			if err := s.Location.Decode(d); err != nil {
				return err
			}
		case "hireable":
			s.Hireable.Reset()
			if err := s.Hireable.Decode(d); err != nil {
				return err
			}
		case "bio":
			s.Bio.Reset()
			if err := s.Bio.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ValidationErrorSimple) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("message")
	e.Str(s.Message)

	e.FieldStart("documentation_url")
	e.Str(s.DocumentationURL)
	if s.Errors != nil {
		e.FieldStart("errors")
		e.ArrStart()
		for _, elem := range s.Errors {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	e.ObjEnd()
}

// Decode decodes ValidationErrorSimple from json.
func (s *ValidationErrorSimple) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ValidationErrorSimple to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			v, err := d.Str()
			s.Message = string(v)
			if err != nil {
				return err
			}
		case "documentation_url":
			v, err := d.Str()
			s.DocumentationURL = string(v)
			if err != nil {
				return err
			}
		case "errors":
			s.Errors = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem string
				v, err := d.Str()
				elem = string(v)
				if err != nil {
					return err
				}
				s.Errors = append(s.Errors, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s Verification) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("verified")
	e.Bool(s.Verified)

	e.FieldStart("reason")
	e.Str(s.Reason)

	e.FieldStart("payload")
	s.Payload.Encode(e)

	e.FieldStart("signature")
	s.Signature.Encode(e)
	e.ObjEnd()
}

// Decode decodes Verification from json.
func (s *Verification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Verification to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "verified":
			v, err := d.Bool()
			s.Verified = bool(v)
			if err != nil {
				return err
			}
		case "reason":
			v, err := d.Str()
			s.Reason = string(v)
			if err != nil {
				return err
			}
		case "payload":
			if err := s.Payload.Decode(d); err != nil {
				return err
			}
		case "signature":
			if err := s.Signature.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s ViewTraffic) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("count")
	e.Int(s.Count)

	e.FieldStart("uniques")
	e.Int(s.Uniques)

	e.FieldStart("views")
	e.ArrStart()
	for _, elem := range s.Views {
		elem.Encode(e)
	}
	e.ArrEnd()
	e.ObjEnd()
}

// Decode decodes ViewTraffic from json.
func (s *ViewTraffic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode ViewTraffic to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			v, err := d.Int()
			s.Count = int(v)
			if err != nil {
				return err
			}
		case "uniques":
			v, err := d.Int()
			s.Uniques = int(v)
			if err != nil {
				return err
			}
		case "views":
			s.Views = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem Traffic
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Views = append(s.Views, elem)
				return nil
			}); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes WaitTimer as json.
func (s WaitTimer) Encode(e *jx.Encoder) {
	unwrapped := int(s)
	e.Int(unwrapped)
}

// Decode decodes WaitTimer from json.
func (s *WaitTimer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WaitTimer to nil`)
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WaitTimer(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s WebhookConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.URL.Set {
		e.FieldStart("url")
		s.URL.Encode(e)
	}
	if s.ContentType.Set {
		e.FieldStart("content_type")
		s.ContentType.Encode(e)
	}
	if s.Secret.Set {
		e.FieldStart("secret")
		s.Secret.Encode(e)
	}
	if s.InsecureSsl != nil {
		e.FieldStart("insecure_ssl")
		s.InsecureSsl.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes WebhookConfig from json.
func (s *WebhookConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WebhookConfig to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			s.URL.Reset()
			if err := s.URL.Decode(d); err != nil {
				return err
			}
		case "content_type":
			s.ContentType.Reset()
			if err := s.ContentType.Decode(d); err != nil {
				return err
			}
		case "secret":
			s.Secret.Reset()
			if err := s.Secret.Decode(d); err != nil {
				return err
			}
		case "insecure_ssl":
			s.InsecureSsl = nil
			var elem WebhookConfigInsecureSsl
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.InsecureSsl = &elem
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes WebhookConfigContentType as json.
func (s WebhookConfigContentType) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes WebhookConfigContentType from json.
func (s *WebhookConfigContentType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WebhookConfigContentType to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WebhookConfigContentType(unwrapped)
	return nil
}

// Encode encodes WebhookConfigInsecureSsl as json.
func (s WebhookConfigInsecureSsl) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringWebhookConfigInsecureSsl:
		e.Str(s.String)
	case Float64WebhookConfigInsecureSsl:
		e.Float64(s.Float64)
	}
}

// Decode decodes WebhookConfigInsecureSsl from json.
func (s *WebhookConfigInsecureSsl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WebhookConfigInsecureSsl to nil`)
	}
	// Sum type primitive.
	switch t := d.Next(); t {
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringWebhookConfigInsecureSsl
	case jx.Number:
		v, err := d.Float64()
		s.Float64 = float64(v)
		if err != nil {
			return err
		}
		s.Type = Float64WebhookConfigInsecureSsl
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// Encode encodes WebhookConfigSecret as json.
func (s WebhookConfigSecret) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes WebhookConfigSecret from json.
func (s *WebhookConfigSecret) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WebhookConfigSecret to nil`)
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WebhookConfigSecret(unwrapped)
	return nil
}

// Encode encodes WebhookConfigURL as json.
func (s WebhookConfigURL) Encode(e *jx.Encoder) {
	unwrapped := url.URL(s)
	json.EncodeURI(e, unwrapped)
}

// Decode decodes WebhookConfigURL from json.
func (s *WebhookConfigURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WebhookConfigURL to nil`)
	}
	var unwrapped url.URL
	if err := func() error {
		v, err := json.DecodeURI(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = WebhookConfigURL(unwrapped)
	return nil
}

// Encode implements json.Marshaler.
func (s Workflow) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)

	e.FieldStart("node_id")
	e.Str(s.NodeID)

	e.FieldStart("name")
	e.Str(s.Name)

	e.FieldStart("path")
	e.Str(s.Path)

	e.FieldStart("state")
	s.State.Encode(e)

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("html_url")
	e.Str(s.HTMLURL)

	e.FieldStart("badge_url")
	e.Str(s.BadgeURL)
	if s.DeletedAt.Set {
		e.FieldStart("deleted_at")
		s.DeletedAt.Encode(e, json.EncodeDateTime)
	}
	e.ObjEnd()
}

// Decode decodes Workflow from json.
func (s *Workflow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode Workflow to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "name":
			v, err := d.Str()
			s.Name = string(v)
			if err != nil {
				return err
			}
		case "path":
			v, err := d.Str()
			s.Path = string(v)
			if err != nil {
				return err
			}
		case "state":
			if err := s.State.Decode(d); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := d.Str()
			s.HTMLURL = string(v)
			if err != nil {
				return err
			}
		case "badge_url":
			v, err := d.Str()
			s.BadgeURL = string(v)
			if err != nil {
				return err
			}
		case "deleted_at":
			s.DeletedAt.Reset()
			if err := s.DeletedAt.Decode(d, json.DecodeDateTime); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s WorkflowRun) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("id")
	e.Int(s.ID)
	if s.Name.Set {
		e.FieldStart("name")
		s.Name.Encode(e)
	}

	e.FieldStart("node_id")
	e.Str(s.NodeID)
	if s.CheckSuiteID.Set {
		e.FieldStart("check_suite_id")
		s.CheckSuiteID.Encode(e)
	}
	if s.CheckSuiteNodeID.Set {
		e.FieldStart("check_suite_node_id")
		s.CheckSuiteNodeID.Encode(e)
	}

	e.FieldStart("head_branch")
	s.HeadBranch.Encode(e)

	e.FieldStart("head_sha")
	e.Str(s.HeadSha)

	e.FieldStart("run_number")
	e.Int(s.RunNumber)
	if s.RunAttempt.Set {
		e.FieldStart("run_attempt")
		s.RunAttempt.Encode(e)
	}

	e.FieldStart("event")
	e.Str(s.Event)

	e.FieldStart("status")
	s.Status.Encode(e)

	e.FieldStart("conclusion")
	s.Conclusion.Encode(e)

	e.FieldStart("workflow_id")
	e.Int(s.WorkflowID)

	e.FieldStart("url")
	e.Str(s.URL)

	e.FieldStart("html_url")
	e.Str(s.HTMLURL)

	e.FieldStart("pull_requests")
	if s.PullRequests == nil {
		e.Null()
	} else {
		e.ArrStart()
		for _, elem := range s.PullRequests {
			elem.Encode(e)
		}
		e.ArrEnd()
	}

	e.FieldStart("created_at")
	json.EncodeDateTime(e, s.CreatedAt)

	e.FieldStart("updated_at")
	json.EncodeDateTime(e, s.UpdatedAt)

	e.FieldStart("jobs_url")
	e.Str(s.JobsURL)

	e.FieldStart("logs_url")
	e.Str(s.LogsURL)

	e.FieldStart("check_suite_url")
	e.Str(s.CheckSuiteURL)

	e.FieldStart("artifacts_url")
	e.Str(s.ArtifactsURL)

	e.FieldStart("cancel_url")
	e.Str(s.CancelURL)

	e.FieldStart("rerun_url")
	e.Str(s.RerunURL)
	if s.PreviousAttemptURL.Set {
		e.FieldStart("previous_attempt_url")
		s.PreviousAttemptURL.Encode(e)
	}

	e.FieldStart("workflow_url")
	e.Str(s.WorkflowURL)

	e.FieldStart("head_commit")
	s.HeadCommit.Encode(e)

	e.FieldStart("repository")
	s.Repository.Encode(e)

	e.FieldStart("head_repository")
	s.HeadRepository.Encode(e)
	if s.HeadRepositoryID.Set {
		e.FieldStart("head_repository_id")
		s.HeadRepositoryID.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes WorkflowRun from json.
func (s *WorkflowRun) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WorkflowRun to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			v, err := d.Int()
			s.ID = int(v)
			if err != nil {
				return err
			}
		case "name":
			s.Name.Reset()
			if err := s.Name.Decode(d); err != nil {
				return err
			}
		case "node_id":
			v, err := d.Str()
			s.NodeID = string(v)
			if err != nil {
				return err
			}
		case "check_suite_id":
			s.CheckSuiteID.Reset()
			if err := s.CheckSuiteID.Decode(d); err != nil {
				return err
			}
		case "check_suite_node_id":
			s.CheckSuiteNodeID.Reset()
			if err := s.CheckSuiteNodeID.Decode(d); err != nil {
				return err
			}
		case "head_branch":
			if err := s.HeadBranch.Decode(d); err != nil {
				return err
			}
		case "head_sha":
			v, err := d.Str()
			s.HeadSha = string(v)
			if err != nil {
				return err
			}
		case "run_number":
			v, err := d.Int()
			s.RunNumber = int(v)
			if err != nil {
				return err
			}
		case "run_attempt":
			s.RunAttempt.Reset()
			if err := s.RunAttempt.Decode(d); err != nil {
				return err
			}
		case "event":
			v, err := d.Str()
			s.Event = string(v)
			if err != nil {
				return err
			}
		case "status":
			if err := s.Status.Decode(d); err != nil {
				return err
			}
		case "conclusion":
			if err := s.Conclusion.Decode(d); err != nil {
				return err
			}
		case "workflow_id":
			v, err := d.Int()
			s.WorkflowID = int(v)
			if err != nil {
				return err
			}
		case "url":
			v, err := d.Str()
			s.URL = string(v)
			if err != nil {
				return err
			}
		case "html_url":
			v, err := d.Str()
			s.HTMLURL = string(v)
			if err != nil {
				return err
			}
		case "pull_requests":
			s.PullRequests = nil
			if err := d.Arr(func(d *jx.Decoder) error {
				var elem PullRequestMinimal
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PullRequests = append(s.PullRequests, elem)
				return nil
			}); err != nil {
				return err
			}
		case "created_at":
			v, err := json.DecodeDateTime(d)
			s.CreatedAt = v
			if err != nil {
				return err
			}
		case "updated_at":
			v, err := json.DecodeDateTime(d)
			s.UpdatedAt = v
			if err != nil {
				return err
			}
		case "jobs_url":
			v, err := d.Str()
			s.JobsURL = string(v)
			if err != nil {
				return err
			}
		case "logs_url":
			v, err := d.Str()
			s.LogsURL = string(v)
			if err != nil {
				return err
			}
		case "check_suite_url":
			v, err := d.Str()
			s.CheckSuiteURL = string(v)
			if err != nil {
				return err
			}
		case "artifacts_url":
			v, err := d.Str()
			s.ArtifactsURL = string(v)
			if err != nil {
				return err
			}
		case "cancel_url":
			v, err := d.Str()
			s.CancelURL = string(v)
			if err != nil {
				return err
			}
		case "rerun_url":
			v, err := d.Str()
			s.RerunURL = string(v)
			if err != nil {
				return err
			}
		case "previous_attempt_url":
			s.PreviousAttemptURL.Reset()
			if err := s.PreviousAttemptURL.Decode(d); err != nil {
				return err
			}
		case "workflow_url":
			v, err := d.Str()
			s.WorkflowURL = string(v)
			if err != nil {
				return err
			}
		case "head_commit":
			if err := s.HeadCommit.Decode(d); err != nil {
				return err
			}
		case "repository":
			if err := s.Repository.Decode(d); err != nil {
				return err
			}
		case "head_repository":
			if err := s.HeadRepository.Decode(d); err != nil {
				return err
			}
		case "head_repository_id":
			s.HeadRepositoryID.Reset()
			if err := s.HeadRepositoryID.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s WorkflowRunUsage) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("billable")
	s.Billable.Encode(e)
	if s.RunDurationMs.Set {
		e.FieldStart("run_duration_ms")
		s.RunDurationMs.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes WorkflowRunUsage from json.
func (s *WorkflowRunUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WorkflowRunUsage to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "billable":
			if err := s.Billable.Decode(d); err != nil {
				return err
			}
		case "run_duration_ms":
			s.RunDurationMs.Reset()
			if err := s.RunDurationMs.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s WorkflowRunUsageBillable) Encode(e *jx.Encoder) {
	e.ObjStart()
	if s.UBUNTU.Set {
		e.FieldStart("UBUNTU")
		s.UBUNTU.Encode(e)
	}
	if s.MACOS.Set {
		e.FieldStart("MACOS")
		s.MACOS.Encode(e)
	}
	if s.WINDOWS.Set {
		e.FieldStart("WINDOWS")
		s.WINDOWS.Encode(e)
	}
	e.ObjEnd()
}

// Decode decodes WorkflowRunUsageBillable from json.
func (s *WorkflowRunUsageBillable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WorkflowRunUsageBillable to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "UBUNTU":
			s.UBUNTU.Reset()
			if err := s.UBUNTU.Decode(d); err != nil {
				return err
			}
		case "MACOS":
			s.MACOS.Reset()
			if err := s.MACOS.Decode(d); err != nil {
				return err
			}
		case "WINDOWS":
			s.WINDOWS.Reset()
			if err := s.WINDOWS.Decode(d); err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s WorkflowRunUsageBillableMACOS) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_ms")
	e.Int(s.TotalMs)

	e.FieldStart("jobs")
	e.Int(s.Jobs)
	e.ObjEnd()
}

// Decode decodes WorkflowRunUsageBillableMACOS from json.
func (s *WorkflowRunUsageBillableMACOS) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WorkflowRunUsageBillableMACOS to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_ms":
			v, err := d.Int()
			s.TotalMs = int(v)
			if err != nil {
				return err
			}
		case "jobs":
			v, err := d.Int()
			s.Jobs = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s WorkflowRunUsageBillableUBUNTU) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_ms")
	e.Int(s.TotalMs)

	e.FieldStart("jobs")
	e.Int(s.Jobs)
	e.ObjEnd()
}

// Decode decodes WorkflowRunUsageBillableUBUNTU from json.
func (s *WorkflowRunUsageBillableUBUNTU) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WorkflowRunUsageBillableUBUNTU to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_ms":
			v, err := d.Int()
			s.TotalMs = int(v)
			if err != nil {
				return err
			}
		case "jobs":
			v, err := d.Int()
			s.Jobs = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode implements json.Marshaler.
func (s WorkflowRunUsageBillableWINDOWS) Encode(e *jx.Encoder) {
	e.ObjStart()

	e.FieldStart("total_ms")
	e.Int(s.TotalMs)

	e.FieldStart("jobs")
	e.Int(s.Jobs)
	e.ObjEnd()
}

// Decode decodes WorkflowRunUsageBillableWINDOWS from json.
func (s *WorkflowRunUsageBillableWINDOWS) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WorkflowRunUsageBillableWINDOWS to nil`)
	}
	return d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_ms":
			v, err := d.Int()
			s.TotalMs = int(v)
			if err != nil {
				return err
			}
		case "jobs":
			v, err := d.Int()
			s.Jobs = int(v)
			if err != nil {
				return err
			}
		default:
			return d.Skip()
		}
		return nil
	})
}

// Encode encodes WorkflowState as json.
func (s WorkflowState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowState from json.
func (s *WorkflowState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New(`invalid: unable to decode WorkflowState to nil`)
	}
	v, err := d.Str()
	if err != nil {
		return err
	}
	*s = WorkflowState(v)
	return nil
}
