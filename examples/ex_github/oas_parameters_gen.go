// Code generated by ogen, DO NOT EDIT.

package api

import (
	"fmt"
	"net/http"
	"time"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams is parameters of actions/add-repo-access-to-self-hosted-runner-group-in-org operation.
type ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams struct {
	Org string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
	RepositoryID  int
}

func unpackActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams(packed map[string]any) (params ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams) {
	params.Org = packed["org"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	params.RepositoryID = packed["repository_id"].(int)
	return params
}

func decodeActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams(args [3]string, r *http.Request) (params ActionsAddRepoAccessToSelfHostedRunnerGroupInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Decode path: repository_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repository_id: parse")
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	return params, nil
}

// ActionsAddSelectedRepoToOrgSecretParams is parameters of actions/add-selected-repo-to-org-secret operation.
type ActionsAddSelectedRepoToOrgSecretParams struct {
	Org string
	// Secret_name parameter.
	SecretName   string
	RepositoryID int
}

func unpackActionsAddSelectedRepoToOrgSecretParams(packed map[string]any) (params ActionsAddSelectedRepoToOrgSecretParams) {
	params.Org = packed["org"].(string)
	params.SecretName = packed["secret_name"].(string)
	params.RepositoryID = packed["repository_id"].(int)
	return params
}

func decodeActionsAddSelectedRepoToOrgSecretParams(args [3]string, r *http.Request) (params ActionsAddSelectedRepoToOrgSecretParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: secret_name: parse")
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	// Decode path: repository_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repository_id: parse")
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	return params, nil
}

// ActionsAddSelfHostedRunnerToGroupForOrgParams is parameters of actions/add-self-hosted-runner-to-group-for-org operation.
type ActionsAddSelfHostedRunnerToGroupForOrgParams struct {
	Org string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
	// Unique identifier of the self-hosted runner.
	RunnerID int
}

func unpackActionsAddSelfHostedRunnerToGroupForOrgParams(packed map[string]any) (params ActionsAddSelfHostedRunnerToGroupForOrgParams) {
	params.Org = packed["org"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	params.RunnerID = packed["runner_id"].(int)
	return params
}

func decodeActionsAddSelfHostedRunnerToGroupForOrgParams(args [3]string, r *http.Request) (params ActionsAddSelfHostedRunnerToGroupForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_id: parse")
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

// ActionsApproveWorkflowRunParams is parameters of actions/approve-workflow-run operation.
type ActionsApproveWorkflowRunParams struct {
	Owner string
	Repo  string
	// The id of the workflow run.
	RunID int
}

func unpackActionsApproveWorkflowRunParams(packed map[string]any) (params ActionsApproveWorkflowRunParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.RunID = packed["run_id"].(int)
	return params
}

func decodeActionsApproveWorkflowRunParams(args [3]string, r *http.Request) (params ActionsApproveWorkflowRunParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: run_id: parse")
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

// ActionsCancelWorkflowRunParams is parameters of actions/cancel-workflow-run operation.
type ActionsCancelWorkflowRunParams struct {
	Owner string
	Repo  string
	// The id of the workflow run.
	RunID int
}

func unpackActionsCancelWorkflowRunParams(packed map[string]any) (params ActionsCancelWorkflowRunParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.RunID = packed["run_id"].(int)
	return params
}

func decodeActionsCancelWorkflowRunParams(args [3]string, r *http.Request) (params ActionsCancelWorkflowRunParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: run_id: parse")
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

// ActionsCreateOrUpdateEnvironmentSecretParams is parameters of actions/create-or-update-environment-secret operation.
type ActionsCreateOrUpdateEnvironmentSecretParams struct {
	RepositoryID int
	// The name of the environment.
	EnvironmentName string
	// Secret_name parameter.
	SecretName string
}

func unpackActionsCreateOrUpdateEnvironmentSecretParams(packed map[string]any) (params ActionsCreateOrUpdateEnvironmentSecretParams) {
	params.RepositoryID = packed["repository_id"].(int)
	params.EnvironmentName = packed["environment_name"].(string)
	params.SecretName = packed["secret_name"].(string)
	return params
}

func decodeActionsCreateOrUpdateEnvironmentSecretParams(args [3]string, r *http.Request) (params ActionsCreateOrUpdateEnvironmentSecretParams, _ error) {
	// Decode path: repository_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repository_id: parse")
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	// Decode path: environment_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: environment_name: parse")
			}
		} else {
			return params, errors.New("path: environment_name: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: secret_name: parse")
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

// ActionsCreateOrUpdateOrgSecretParams is parameters of actions/create-or-update-org-secret operation.
type ActionsCreateOrUpdateOrgSecretParams struct {
	Org string
	// Secret_name parameter.
	SecretName string
}

func unpackActionsCreateOrUpdateOrgSecretParams(packed map[string]any) (params ActionsCreateOrUpdateOrgSecretParams) {
	params.Org = packed["org"].(string)
	params.SecretName = packed["secret_name"].(string)
	return params
}

func decodeActionsCreateOrUpdateOrgSecretParams(args [2]string, r *http.Request) (params ActionsCreateOrUpdateOrgSecretParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: secret_name: parse")
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

// ActionsCreateOrUpdateRepoSecretParams is parameters of actions/create-or-update-repo-secret operation.
type ActionsCreateOrUpdateRepoSecretParams struct {
	Owner string
	Repo  string
	// Secret_name parameter.
	SecretName string
}

func unpackActionsCreateOrUpdateRepoSecretParams(packed map[string]any) (params ActionsCreateOrUpdateRepoSecretParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.SecretName = packed["secret_name"].(string)
	return params
}

func decodeActionsCreateOrUpdateRepoSecretParams(args [3]string, r *http.Request) (params ActionsCreateOrUpdateRepoSecretParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: secret_name: parse")
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

// ActionsCreateRegistrationTokenForOrgParams is parameters of actions/create-registration-token-for-org operation.
type ActionsCreateRegistrationTokenForOrgParams struct {
	Org string
}

func unpackActionsCreateRegistrationTokenForOrgParams(packed map[string]any) (params ActionsCreateRegistrationTokenForOrgParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeActionsCreateRegistrationTokenForOrgParams(args [1]string, r *http.Request) (params ActionsCreateRegistrationTokenForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// ActionsCreateRegistrationTokenForRepoParams is parameters of actions/create-registration-token-for-repo operation.
type ActionsCreateRegistrationTokenForRepoParams struct {
	Owner string
	Repo  string
}

func unpackActionsCreateRegistrationTokenForRepoParams(packed map[string]any) (params ActionsCreateRegistrationTokenForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeActionsCreateRegistrationTokenForRepoParams(args [2]string, r *http.Request) (params ActionsCreateRegistrationTokenForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ActionsCreateRemoveTokenForOrgParams is parameters of actions/create-remove-token-for-org operation.
type ActionsCreateRemoveTokenForOrgParams struct {
	Org string
}

func unpackActionsCreateRemoveTokenForOrgParams(packed map[string]any) (params ActionsCreateRemoveTokenForOrgParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeActionsCreateRemoveTokenForOrgParams(args [1]string, r *http.Request) (params ActionsCreateRemoveTokenForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// ActionsCreateRemoveTokenForRepoParams is parameters of actions/create-remove-token-for-repo operation.
type ActionsCreateRemoveTokenForRepoParams struct {
	Owner string
	Repo  string
}

func unpackActionsCreateRemoveTokenForRepoParams(packed map[string]any) (params ActionsCreateRemoveTokenForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeActionsCreateRemoveTokenForRepoParams(args [2]string, r *http.Request) (params ActionsCreateRemoveTokenForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ActionsCreateSelfHostedRunnerGroupForOrgParams is parameters of actions/create-self-hosted-runner-group-for-org operation.
type ActionsCreateSelfHostedRunnerGroupForOrgParams struct {
	Org string
}

func unpackActionsCreateSelfHostedRunnerGroupForOrgParams(packed map[string]any) (params ActionsCreateSelfHostedRunnerGroupForOrgParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeActionsCreateSelfHostedRunnerGroupForOrgParams(args [1]string, r *http.Request) (params ActionsCreateSelfHostedRunnerGroupForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// ActionsDeleteArtifactParams is parameters of actions/delete-artifact operation.
type ActionsDeleteArtifactParams struct {
	Owner string
	Repo  string
	// Artifact_id parameter.
	ArtifactID int
}

func unpackActionsDeleteArtifactParams(packed map[string]any) (params ActionsDeleteArtifactParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.ArtifactID = packed["artifact_id"].(int)
	return params
}

func decodeActionsDeleteArtifactParams(args [3]string, r *http.Request) (params ActionsDeleteArtifactParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: artifact_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "artifact_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ArtifactID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: artifact_id: parse")
			}
		} else {
			return params, errors.New("path: artifact_id: not specified")
		}
	}
	return params, nil
}

// ActionsDeleteEnvironmentSecretParams is parameters of actions/delete-environment-secret operation.
type ActionsDeleteEnvironmentSecretParams struct {
	RepositoryID int
	// The name of the environment.
	EnvironmentName string
	// Secret_name parameter.
	SecretName string
}

func unpackActionsDeleteEnvironmentSecretParams(packed map[string]any) (params ActionsDeleteEnvironmentSecretParams) {
	params.RepositoryID = packed["repository_id"].(int)
	params.EnvironmentName = packed["environment_name"].(string)
	params.SecretName = packed["secret_name"].(string)
	return params
}

func decodeActionsDeleteEnvironmentSecretParams(args [3]string, r *http.Request) (params ActionsDeleteEnvironmentSecretParams, _ error) {
	// Decode path: repository_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repository_id: parse")
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	// Decode path: environment_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: environment_name: parse")
			}
		} else {
			return params, errors.New("path: environment_name: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: secret_name: parse")
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

// ActionsDeleteOrgSecretParams is parameters of actions/delete-org-secret operation.
type ActionsDeleteOrgSecretParams struct {
	Org string
	// Secret_name parameter.
	SecretName string
}

func unpackActionsDeleteOrgSecretParams(packed map[string]any) (params ActionsDeleteOrgSecretParams) {
	params.Org = packed["org"].(string)
	params.SecretName = packed["secret_name"].(string)
	return params
}

func decodeActionsDeleteOrgSecretParams(args [2]string, r *http.Request) (params ActionsDeleteOrgSecretParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: secret_name: parse")
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

// ActionsDeleteRepoSecretParams is parameters of actions/delete-repo-secret operation.
type ActionsDeleteRepoSecretParams struct {
	Owner string
	Repo  string
	// Secret_name parameter.
	SecretName string
}

func unpackActionsDeleteRepoSecretParams(packed map[string]any) (params ActionsDeleteRepoSecretParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.SecretName = packed["secret_name"].(string)
	return params
}

func decodeActionsDeleteRepoSecretParams(args [3]string, r *http.Request) (params ActionsDeleteRepoSecretParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: secret_name: parse")
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

// ActionsDeleteSelfHostedRunnerFromOrgParams is parameters of actions/delete-self-hosted-runner-from-org operation.
type ActionsDeleteSelfHostedRunnerFromOrgParams struct {
	Org string
	// Unique identifier of the self-hosted runner.
	RunnerID int
}

func unpackActionsDeleteSelfHostedRunnerFromOrgParams(packed map[string]any) (params ActionsDeleteSelfHostedRunnerFromOrgParams) {
	params.Org = packed["org"].(string)
	params.RunnerID = packed["runner_id"].(int)
	return params
}

func decodeActionsDeleteSelfHostedRunnerFromOrgParams(args [2]string, r *http.Request) (params ActionsDeleteSelfHostedRunnerFromOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_id: parse")
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

// ActionsDeleteSelfHostedRunnerFromRepoParams is parameters of actions/delete-self-hosted-runner-from-repo operation.
type ActionsDeleteSelfHostedRunnerFromRepoParams struct {
	Owner string
	Repo  string
	// Unique identifier of the self-hosted runner.
	RunnerID int
}

func unpackActionsDeleteSelfHostedRunnerFromRepoParams(packed map[string]any) (params ActionsDeleteSelfHostedRunnerFromRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.RunnerID = packed["runner_id"].(int)
	return params
}

func decodeActionsDeleteSelfHostedRunnerFromRepoParams(args [3]string, r *http.Request) (params ActionsDeleteSelfHostedRunnerFromRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_id: parse")
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

// ActionsDeleteSelfHostedRunnerGroupFromOrgParams is parameters of actions/delete-self-hosted-runner-group-from-org operation.
type ActionsDeleteSelfHostedRunnerGroupFromOrgParams struct {
	Org string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
}

func unpackActionsDeleteSelfHostedRunnerGroupFromOrgParams(packed map[string]any) (params ActionsDeleteSelfHostedRunnerGroupFromOrgParams) {
	params.Org = packed["org"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	return params
}

func decodeActionsDeleteSelfHostedRunnerGroupFromOrgParams(args [2]string, r *http.Request) (params ActionsDeleteSelfHostedRunnerGroupFromOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

// ActionsDeleteWorkflowRunParams is parameters of actions/delete-workflow-run operation.
type ActionsDeleteWorkflowRunParams struct {
	Owner string
	Repo  string
	// The id of the workflow run.
	RunID int
}

func unpackActionsDeleteWorkflowRunParams(packed map[string]any) (params ActionsDeleteWorkflowRunParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.RunID = packed["run_id"].(int)
	return params
}

func decodeActionsDeleteWorkflowRunParams(args [3]string, r *http.Request) (params ActionsDeleteWorkflowRunParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: run_id: parse")
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

// ActionsDeleteWorkflowRunLogsParams is parameters of actions/delete-workflow-run-logs operation.
type ActionsDeleteWorkflowRunLogsParams struct {
	Owner string
	Repo  string
	// The id of the workflow run.
	RunID int
}

func unpackActionsDeleteWorkflowRunLogsParams(packed map[string]any) (params ActionsDeleteWorkflowRunLogsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.RunID = packed["run_id"].(int)
	return params
}

func decodeActionsDeleteWorkflowRunLogsParams(args [3]string, r *http.Request) (params ActionsDeleteWorkflowRunLogsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: run_id: parse")
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

// ActionsDisableSelectedRepositoryGithubActionsOrganizationParams is parameters of actions/disable-selected-repository-github-actions-organization operation.
type ActionsDisableSelectedRepositoryGithubActionsOrganizationParams struct {
	Org          string
	RepositoryID int
}

func unpackActionsDisableSelectedRepositoryGithubActionsOrganizationParams(packed map[string]any) (params ActionsDisableSelectedRepositoryGithubActionsOrganizationParams) {
	params.Org = packed["org"].(string)
	params.RepositoryID = packed["repository_id"].(int)
	return params
}

func decodeActionsDisableSelectedRepositoryGithubActionsOrganizationParams(args [2]string, r *http.Request) (params ActionsDisableSelectedRepositoryGithubActionsOrganizationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: repository_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repository_id: parse")
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	return params, nil
}

// ActionsDownloadArtifactParams is parameters of actions/download-artifact operation.
type ActionsDownloadArtifactParams struct {
	Owner string
	Repo  string
	// Artifact_id parameter.
	ArtifactID    int
	ArchiveFormat string
}

func unpackActionsDownloadArtifactParams(packed map[string]any) (params ActionsDownloadArtifactParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.ArtifactID = packed["artifact_id"].(int)
	params.ArchiveFormat = packed["archive_format"].(string)
	return params
}

func decodeActionsDownloadArtifactParams(args [4]string, r *http.Request) (params ActionsDownloadArtifactParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: artifact_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "artifact_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ArtifactID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: artifact_id: parse")
			}
		} else {
			return params, errors.New("path: artifact_id: not specified")
		}
	}
	// Decode path: archive_format.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "archive_format",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ArchiveFormat = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: archive_format: parse")
			}
		} else {
			return params, errors.New("path: archive_format: not specified")
		}
	}
	return params, nil
}

// ActionsDownloadJobLogsForWorkflowRunParams is parameters of actions/download-job-logs-for-workflow-run operation.
type ActionsDownloadJobLogsForWorkflowRunParams struct {
	Owner string
	Repo  string
	// Job_id parameter.
	JobID int
}

func unpackActionsDownloadJobLogsForWorkflowRunParams(packed map[string]any) (params ActionsDownloadJobLogsForWorkflowRunParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.JobID = packed["job_id"].(int)
	return params
}

func decodeActionsDownloadJobLogsForWorkflowRunParams(args [3]string, r *http.Request) (params ActionsDownloadJobLogsForWorkflowRunParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: job_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "job_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.JobID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: job_id: parse")
			}
		} else {
			return params, errors.New("path: job_id: not specified")
		}
	}
	return params, nil
}

// ActionsDownloadWorkflowRunLogsParams is parameters of actions/download-workflow-run-logs operation.
type ActionsDownloadWorkflowRunLogsParams struct {
	Owner string
	Repo  string
	// The id of the workflow run.
	RunID int
}

func unpackActionsDownloadWorkflowRunLogsParams(packed map[string]any) (params ActionsDownloadWorkflowRunLogsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.RunID = packed["run_id"].(int)
	return params
}

func decodeActionsDownloadWorkflowRunLogsParams(args [3]string, r *http.Request) (params ActionsDownloadWorkflowRunLogsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: run_id: parse")
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

// ActionsEnableSelectedRepositoryGithubActionsOrganizationParams is parameters of actions/enable-selected-repository-github-actions-organization operation.
type ActionsEnableSelectedRepositoryGithubActionsOrganizationParams struct {
	Org          string
	RepositoryID int
}

func unpackActionsEnableSelectedRepositoryGithubActionsOrganizationParams(packed map[string]any) (params ActionsEnableSelectedRepositoryGithubActionsOrganizationParams) {
	params.Org = packed["org"].(string)
	params.RepositoryID = packed["repository_id"].(int)
	return params
}

func decodeActionsEnableSelectedRepositoryGithubActionsOrganizationParams(args [2]string, r *http.Request) (params ActionsEnableSelectedRepositoryGithubActionsOrganizationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: repository_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repository_id: parse")
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	return params, nil
}

// ActionsGetAllowedActionsOrganizationParams is parameters of actions/get-allowed-actions-organization operation.
type ActionsGetAllowedActionsOrganizationParams struct {
	Org string
}

func unpackActionsGetAllowedActionsOrganizationParams(packed map[string]any) (params ActionsGetAllowedActionsOrganizationParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeActionsGetAllowedActionsOrganizationParams(args [1]string, r *http.Request) (params ActionsGetAllowedActionsOrganizationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// ActionsGetAllowedActionsRepositoryParams is parameters of actions/get-allowed-actions-repository operation.
type ActionsGetAllowedActionsRepositoryParams struct {
	Owner string
	Repo  string
}

func unpackActionsGetAllowedActionsRepositoryParams(packed map[string]any) (params ActionsGetAllowedActionsRepositoryParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeActionsGetAllowedActionsRepositoryParams(args [2]string, r *http.Request) (params ActionsGetAllowedActionsRepositoryParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ActionsGetArtifactParams is parameters of actions/get-artifact operation.
type ActionsGetArtifactParams struct {
	Owner string
	Repo  string
	// Artifact_id parameter.
	ArtifactID int
}

func unpackActionsGetArtifactParams(packed map[string]any) (params ActionsGetArtifactParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.ArtifactID = packed["artifact_id"].(int)
	return params
}

func decodeActionsGetArtifactParams(args [3]string, r *http.Request) (params ActionsGetArtifactParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: artifact_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "artifact_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ArtifactID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: artifact_id: parse")
			}
		} else {
			return params, errors.New("path: artifact_id: not specified")
		}
	}
	return params, nil
}

// ActionsGetEnvironmentPublicKeyParams is parameters of actions/get-environment-public-key operation.
type ActionsGetEnvironmentPublicKeyParams struct {
	RepositoryID int
	// The name of the environment.
	EnvironmentName string
}

func unpackActionsGetEnvironmentPublicKeyParams(packed map[string]any) (params ActionsGetEnvironmentPublicKeyParams) {
	params.RepositoryID = packed["repository_id"].(int)
	params.EnvironmentName = packed["environment_name"].(string)
	return params
}

func decodeActionsGetEnvironmentPublicKeyParams(args [2]string, r *http.Request) (params ActionsGetEnvironmentPublicKeyParams, _ error) {
	// Decode path: repository_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repository_id: parse")
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	// Decode path: environment_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: environment_name: parse")
			}
		} else {
			return params, errors.New("path: environment_name: not specified")
		}
	}
	return params, nil
}

// ActionsGetEnvironmentSecretParams is parameters of actions/get-environment-secret operation.
type ActionsGetEnvironmentSecretParams struct {
	RepositoryID int
	// The name of the environment.
	EnvironmentName string
	// Secret_name parameter.
	SecretName string
}

func unpackActionsGetEnvironmentSecretParams(packed map[string]any) (params ActionsGetEnvironmentSecretParams) {
	params.RepositoryID = packed["repository_id"].(int)
	params.EnvironmentName = packed["environment_name"].(string)
	params.SecretName = packed["secret_name"].(string)
	return params
}

func decodeActionsGetEnvironmentSecretParams(args [3]string, r *http.Request) (params ActionsGetEnvironmentSecretParams, _ error) {
	// Decode path: repository_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repository_id: parse")
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	// Decode path: environment_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: environment_name: parse")
			}
		} else {
			return params, errors.New("path: environment_name: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: secret_name: parse")
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

// ActionsGetGithubActionsPermissionsOrganizationParams is parameters of actions/get-github-actions-permissions-organization operation.
type ActionsGetGithubActionsPermissionsOrganizationParams struct {
	Org string
}

func unpackActionsGetGithubActionsPermissionsOrganizationParams(packed map[string]any) (params ActionsGetGithubActionsPermissionsOrganizationParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeActionsGetGithubActionsPermissionsOrganizationParams(args [1]string, r *http.Request) (params ActionsGetGithubActionsPermissionsOrganizationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// ActionsGetGithubActionsPermissionsRepositoryParams is parameters of actions/get-github-actions-permissions-repository operation.
type ActionsGetGithubActionsPermissionsRepositoryParams struct {
	Owner string
	Repo  string
}

func unpackActionsGetGithubActionsPermissionsRepositoryParams(packed map[string]any) (params ActionsGetGithubActionsPermissionsRepositoryParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeActionsGetGithubActionsPermissionsRepositoryParams(args [2]string, r *http.Request) (params ActionsGetGithubActionsPermissionsRepositoryParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ActionsGetJobForWorkflowRunParams is parameters of actions/get-job-for-workflow-run operation.
type ActionsGetJobForWorkflowRunParams struct {
	Owner string
	Repo  string
	// Job_id parameter.
	JobID int
}

func unpackActionsGetJobForWorkflowRunParams(packed map[string]any) (params ActionsGetJobForWorkflowRunParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.JobID = packed["job_id"].(int)
	return params
}

func decodeActionsGetJobForWorkflowRunParams(args [3]string, r *http.Request) (params ActionsGetJobForWorkflowRunParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: job_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "job_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.JobID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: job_id: parse")
			}
		} else {
			return params, errors.New("path: job_id: not specified")
		}
	}
	return params, nil
}

// ActionsGetOrgPublicKeyParams is parameters of actions/get-org-public-key operation.
type ActionsGetOrgPublicKeyParams struct {
	Org string
}

func unpackActionsGetOrgPublicKeyParams(packed map[string]any) (params ActionsGetOrgPublicKeyParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeActionsGetOrgPublicKeyParams(args [1]string, r *http.Request) (params ActionsGetOrgPublicKeyParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// ActionsGetOrgSecretParams is parameters of actions/get-org-secret operation.
type ActionsGetOrgSecretParams struct {
	Org string
	// Secret_name parameter.
	SecretName string
}

func unpackActionsGetOrgSecretParams(packed map[string]any) (params ActionsGetOrgSecretParams) {
	params.Org = packed["org"].(string)
	params.SecretName = packed["secret_name"].(string)
	return params
}

func decodeActionsGetOrgSecretParams(args [2]string, r *http.Request) (params ActionsGetOrgSecretParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: secret_name: parse")
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

// ActionsGetRepoPublicKeyParams is parameters of actions/get-repo-public-key operation.
type ActionsGetRepoPublicKeyParams struct {
	Owner string
	Repo  string
}

func unpackActionsGetRepoPublicKeyParams(packed map[string]any) (params ActionsGetRepoPublicKeyParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeActionsGetRepoPublicKeyParams(args [2]string, r *http.Request) (params ActionsGetRepoPublicKeyParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ActionsGetRepoSecretParams is parameters of actions/get-repo-secret operation.
type ActionsGetRepoSecretParams struct {
	Owner string
	Repo  string
	// Secret_name parameter.
	SecretName string
}

func unpackActionsGetRepoSecretParams(packed map[string]any) (params ActionsGetRepoSecretParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.SecretName = packed["secret_name"].(string)
	return params
}

func decodeActionsGetRepoSecretParams(args [3]string, r *http.Request) (params ActionsGetRepoSecretParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: secret_name: parse")
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

// ActionsGetReviewsForRunParams is parameters of actions/get-reviews-for-run operation.
type ActionsGetReviewsForRunParams struct {
	Owner string
	Repo  string
	// The id of the workflow run.
	RunID int
}

func unpackActionsGetReviewsForRunParams(packed map[string]any) (params ActionsGetReviewsForRunParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.RunID = packed["run_id"].(int)
	return params
}

func decodeActionsGetReviewsForRunParams(args [3]string, r *http.Request) (params ActionsGetReviewsForRunParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: run_id: parse")
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

// ActionsGetSelfHostedRunnerForOrgParams is parameters of actions/get-self-hosted-runner-for-org operation.
type ActionsGetSelfHostedRunnerForOrgParams struct {
	Org string
	// Unique identifier of the self-hosted runner.
	RunnerID int
}

func unpackActionsGetSelfHostedRunnerForOrgParams(packed map[string]any) (params ActionsGetSelfHostedRunnerForOrgParams) {
	params.Org = packed["org"].(string)
	params.RunnerID = packed["runner_id"].(int)
	return params
}

func decodeActionsGetSelfHostedRunnerForOrgParams(args [2]string, r *http.Request) (params ActionsGetSelfHostedRunnerForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_id: parse")
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

// ActionsGetSelfHostedRunnerForRepoParams is parameters of actions/get-self-hosted-runner-for-repo operation.
type ActionsGetSelfHostedRunnerForRepoParams struct {
	Owner string
	Repo  string
	// Unique identifier of the self-hosted runner.
	RunnerID int
}

func unpackActionsGetSelfHostedRunnerForRepoParams(packed map[string]any) (params ActionsGetSelfHostedRunnerForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.RunnerID = packed["runner_id"].(int)
	return params
}

func decodeActionsGetSelfHostedRunnerForRepoParams(args [3]string, r *http.Request) (params ActionsGetSelfHostedRunnerForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_id: parse")
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

// ActionsGetSelfHostedRunnerGroupForOrgParams is parameters of actions/get-self-hosted-runner-group-for-org operation.
type ActionsGetSelfHostedRunnerGroupForOrgParams struct {
	Org string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
}

func unpackActionsGetSelfHostedRunnerGroupForOrgParams(packed map[string]any) (params ActionsGetSelfHostedRunnerGroupForOrgParams) {
	params.Org = packed["org"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	return params
}

func decodeActionsGetSelfHostedRunnerGroupForOrgParams(args [2]string, r *http.Request) (params ActionsGetSelfHostedRunnerGroupForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

// ActionsGetWorkflowRunParams is parameters of actions/get-workflow-run operation.
type ActionsGetWorkflowRunParams struct {
	Owner string
	Repo  string
	// The id of the workflow run.
	RunID int
}

func unpackActionsGetWorkflowRunParams(packed map[string]any) (params ActionsGetWorkflowRunParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.RunID = packed["run_id"].(int)
	return params
}

func decodeActionsGetWorkflowRunParams(args [3]string, r *http.Request) (params ActionsGetWorkflowRunParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: run_id: parse")
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

// ActionsGetWorkflowRunUsageParams is parameters of actions/get-workflow-run-usage operation.
type ActionsGetWorkflowRunUsageParams struct {
	Owner string
	Repo  string
	// The id of the workflow run.
	RunID int
}

func unpackActionsGetWorkflowRunUsageParams(packed map[string]any) (params ActionsGetWorkflowRunUsageParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.RunID = packed["run_id"].(int)
	return params
}

func decodeActionsGetWorkflowRunUsageParams(args [3]string, r *http.Request) (params ActionsGetWorkflowRunUsageParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: run_id: parse")
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

// ActionsListArtifactsForRepoParams is parameters of actions/list-artifacts-for-repo operation.
type ActionsListArtifactsForRepoParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActionsListArtifactsForRepoParams(packed map[string]any) (params ActionsListArtifactsForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActionsListArtifactsForRepoParams(args [2]string, r *http.Request) (params ActionsListArtifactsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActionsListEnvironmentSecretsParams is parameters of actions/list-environment-secrets operation.
type ActionsListEnvironmentSecretsParams struct {
	RepositoryID int
	// The name of the environment.
	EnvironmentName string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActionsListEnvironmentSecretsParams(packed map[string]any) (params ActionsListEnvironmentSecretsParams) {
	params.RepositoryID = packed["repository_id"].(int)
	params.EnvironmentName = packed["environment_name"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActionsListEnvironmentSecretsParams(args [2]string, r *http.Request) (params ActionsListEnvironmentSecretsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: repository_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repository_id: parse")
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	// Decode path: environment_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: environment_name: parse")
			}
		} else {
			return params, errors.New("path: environment_name: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActionsListJobsForWorkflowRunParams is parameters of actions/list-jobs-for-workflow-run operation.
type ActionsListJobsForWorkflowRunParams struct {
	Owner string
	Repo  string
	// The id of the workflow run.
	RunID int
	// Filters jobs by their `completed_at` timestamp. Can be one of:
	// \* `latest`: Returns jobs from the most recent execution of the workflow run.
	// \* `all`: Returns all jobs for a workflow run, including from old executions of the workflow run.
	Filter OptActionsListJobsForWorkflowRunFilter `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActionsListJobsForWorkflowRunParams(packed map[string]any) (params ActionsListJobsForWorkflowRunParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.RunID = packed["run_id"].(int)
	if v, ok := packed["filter"]; ok {
		params.Filter = v.(OptActionsListJobsForWorkflowRunFilter)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActionsListJobsForWorkflowRunParams(args [3]string, r *http.Request) (params ActionsListJobsForWorkflowRunParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: run_id: parse")
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	// Set default value for query: filter.
	{
		val := ActionsListJobsForWorkflowRunFilter("latest")
		params.Filter.SetTo(val)
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal ActionsListJobsForWorkflowRunFilter
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = ActionsListJobsForWorkflowRunFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: filter: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActionsListOrgSecretsParams is parameters of actions/list-org-secrets operation.
type ActionsListOrgSecretsParams struct {
	Org string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActionsListOrgSecretsParams(packed map[string]any) (params ActionsListOrgSecretsParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActionsListOrgSecretsParams(args [1]string, r *http.Request) (params ActionsListOrgSecretsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams is parameters of actions/list-repo-access-to-self-hosted-runner-group-in-org operation.
type ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams struct {
	Org string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
}

func unpackActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams(packed map[string]any) (params ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams) {
	params.Org = packed["org"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	return params
}

func decodeActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams(args [2]string, r *http.Request) (params ActionsListRepoAccessToSelfHostedRunnerGroupInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	return params, nil
}

// ActionsListRepoSecretsParams is parameters of actions/list-repo-secrets operation.
type ActionsListRepoSecretsParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActionsListRepoSecretsParams(packed map[string]any) (params ActionsListRepoSecretsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActionsListRepoSecretsParams(args [2]string, r *http.Request) (params ActionsListRepoSecretsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActionsListRepoWorkflowsParams is parameters of actions/list-repo-workflows operation.
type ActionsListRepoWorkflowsParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActionsListRepoWorkflowsParams(packed map[string]any) (params ActionsListRepoWorkflowsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActionsListRepoWorkflowsParams(args [2]string, r *http.Request) (params ActionsListRepoWorkflowsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActionsListRunnerApplicationsForOrgParams is parameters of actions/list-runner-applications-for-org operation.
type ActionsListRunnerApplicationsForOrgParams struct {
	Org string
}

func unpackActionsListRunnerApplicationsForOrgParams(packed map[string]any) (params ActionsListRunnerApplicationsForOrgParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeActionsListRunnerApplicationsForOrgParams(args [1]string, r *http.Request) (params ActionsListRunnerApplicationsForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// ActionsListRunnerApplicationsForRepoParams is parameters of actions/list-runner-applications-for-repo operation.
type ActionsListRunnerApplicationsForRepoParams struct {
	Owner string
	Repo  string
}

func unpackActionsListRunnerApplicationsForRepoParams(packed map[string]any) (params ActionsListRunnerApplicationsForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeActionsListRunnerApplicationsForRepoParams(args [2]string, r *http.Request) (params ActionsListRunnerApplicationsForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ActionsListSelectedReposForOrgSecretParams is parameters of actions/list-selected-repos-for-org-secret operation.
type ActionsListSelectedReposForOrgSecretParams struct {
	Org string
	// Secret_name parameter.
	SecretName string
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
}

func unpackActionsListSelectedReposForOrgSecretParams(packed map[string]any) (params ActionsListSelectedReposForOrgSecretParams) {
	params.Org = packed["org"].(string)
	params.SecretName = packed["secret_name"].(string)
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	return params
}

func decodeActionsListSelectedReposForOrgSecretParams(args [2]string, r *http.Request) (params ActionsListSelectedReposForOrgSecretParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: secret_name: parse")
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	return params, nil
}

// ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams is parameters of actions/list-selected-repositories-enabled-github-actions-organization operation.
type ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams struct {
	Org string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams(packed map[string]any) (params ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams(args [1]string, r *http.Request) (params ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActionsListSelfHostedRunnerGroupsForOrgParams is parameters of actions/list-self-hosted-runner-groups-for-org operation.
type ActionsListSelfHostedRunnerGroupsForOrgParams struct {
	Org string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActionsListSelfHostedRunnerGroupsForOrgParams(packed map[string]any) (params ActionsListSelfHostedRunnerGroupsForOrgParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActionsListSelfHostedRunnerGroupsForOrgParams(args [1]string, r *http.Request) (params ActionsListSelfHostedRunnerGroupsForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActionsListSelfHostedRunnersForOrgParams is parameters of actions/list-self-hosted-runners-for-org operation.
type ActionsListSelfHostedRunnersForOrgParams struct {
	Org string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActionsListSelfHostedRunnersForOrgParams(packed map[string]any) (params ActionsListSelfHostedRunnersForOrgParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActionsListSelfHostedRunnersForOrgParams(args [1]string, r *http.Request) (params ActionsListSelfHostedRunnersForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActionsListSelfHostedRunnersForRepoParams is parameters of actions/list-self-hosted-runners-for-repo operation.
type ActionsListSelfHostedRunnersForRepoParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActionsListSelfHostedRunnersForRepoParams(packed map[string]any) (params ActionsListSelfHostedRunnersForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActionsListSelfHostedRunnersForRepoParams(args [2]string, r *http.Request) (params ActionsListSelfHostedRunnersForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActionsListSelfHostedRunnersInGroupForOrgParams is parameters of actions/list-self-hosted-runners-in-group-for-org operation.
type ActionsListSelfHostedRunnersInGroupForOrgParams struct {
	Org string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActionsListSelfHostedRunnersInGroupForOrgParams(packed map[string]any) (params ActionsListSelfHostedRunnersInGroupForOrgParams) {
	params.Org = packed["org"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActionsListSelfHostedRunnersInGroupForOrgParams(args [2]string, r *http.Request) (params ActionsListSelfHostedRunnersInGroupForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActionsListWorkflowRunArtifactsParams is parameters of actions/list-workflow-run-artifacts operation.
type ActionsListWorkflowRunArtifactsParams struct {
	Owner string
	Repo  string
	// The id of the workflow run.
	RunID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActionsListWorkflowRunArtifactsParams(packed map[string]any) (params ActionsListWorkflowRunArtifactsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.RunID = packed["run_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActionsListWorkflowRunArtifactsParams(args [3]string, r *http.Request) (params ActionsListWorkflowRunArtifactsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: run_id: parse")
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActionsListWorkflowRunsForRepoParams is parameters of actions/list-workflow-runs-for-repo operation.
type ActionsListWorkflowRunsForRepoParams struct {
	Owner string
	Repo  string
	// Returns someone's workflow runs. Use the login for the user who created the `push` associated with
	// the check suite or workflow run.
	Actor OptString `json:",omitempty"`
	// Returns workflow runs associated with a branch. Use the name of the branch of the `push`.
	Branch OptString `json:",omitempty"`
	// Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or
	// `issue`. For more information, see "[Events that trigger workflows](https://help.github.
	// com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).".
	Event OptString `json:",omitempty"`
	// Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a
	// conclusion can be `success` or a status can be `in_progress`. Only GitHub can set a status of
	// `waiting` or `requested`. For a list of the possible `status` and `conclusion` options, see
	// "[Create a check run](https://docs.github.com/rest/reference/checks#create-a-check-run).".
	Status OptActionsListWorkflowRunsForRepoStatus `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page    OptInt      `json:",omitempty"`
	Created OptDateTime `json:",omitempty"`
}

func unpackActionsListWorkflowRunsForRepoParams(packed map[string]any) (params ActionsListWorkflowRunsForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["actor"]; ok {
		params.Actor = v.(OptString)
	}
	if v, ok := packed["branch"]; ok {
		params.Branch = v.(OptString)
	}
	if v, ok := packed["event"]; ok {
		params.Event = v.(OptString)
	}
	if v, ok := packed["status"]; ok {
		params.Status = v.(OptActionsListWorkflowRunsForRepoStatus)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["created"]; ok {
		params.Created = v.(OptDateTime)
	}
	return params
}

func decodeActionsListWorkflowRunsForRepoParams(args [2]string, r *http.Request) (params ActionsListWorkflowRunsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: actor.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "actor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotActorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotActorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Actor.SetTo(paramsDotActorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: actor: parse")
			}
		}
	}
	// Decode query: branch.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "branch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBranchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBranchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Branch.SetTo(paramsDotBranchVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: branch: parse")
			}
		}
	}
	// Decode query: event.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "event",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEventVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotEventVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Event.SetTo(paramsDotEventVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: event: parse")
			}
		}
	}
	// Decode query: status.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal ActionsListWorkflowRunsForRepoStatus
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = ActionsListWorkflowRunsForRepoStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: status: parse")
			}
			if err := func() error {
				if params.Status.Set {
					if err := func() error {
						if err := params.Status.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: status: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: created.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "created",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCreatedVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotCreatedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Created.SetTo(paramsDotCreatedVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: created: parse")
			}
		}
	}
	return params, nil
}

// ActionsReRunWorkflowParams is parameters of actions/re-run-workflow operation.
type ActionsReRunWorkflowParams struct {
	Owner string
	Repo  string
	// The id of the workflow run.
	RunID int
}

func unpackActionsReRunWorkflowParams(packed map[string]any) (params ActionsReRunWorkflowParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.RunID = packed["run_id"].(int)
	return params
}

func decodeActionsReRunWorkflowParams(args [3]string, r *http.Request) (params ActionsReRunWorkflowParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: run_id: parse")
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

// ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams is parameters of actions/remove-repo-access-to-self-hosted-runner-group-in-org operation.
type ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams struct {
	Org string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
	RepositoryID  int
}

func unpackActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams(packed map[string]any) (params ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams) {
	params.Org = packed["org"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	params.RepositoryID = packed["repository_id"].(int)
	return params
}

func decodeActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams(args [3]string, r *http.Request) (params ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Decode path: repository_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repository_id: parse")
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	return params, nil
}

// ActionsRemoveSelectedRepoFromOrgSecretParams is parameters of actions/remove-selected-repo-from-org-secret operation.
type ActionsRemoveSelectedRepoFromOrgSecretParams struct {
	Org string
	// Secret_name parameter.
	SecretName   string
	RepositoryID int
}

func unpackActionsRemoveSelectedRepoFromOrgSecretParams(packed map[string]any) (params ActionsRemoveSelectedRepoFromOrgSecretParams) {
	params.Org = packed["org"].(string)
	params.SecretName = packed["secret_name"].(string)
	params.RepositoryID = packed["repository_id"].(int)
	return params
}

func decodeActionsRemoveSelectedRepoFromOrgSecretParams(args [3]string, r *http.Request) (params ActionsRemoveSelectedRepoFromOrgSecretParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: secret_name: parse")
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	// Decode path: repository_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repository_id: parse")
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	return params, nil
}

// ActionsRemoveSelfHostedRunnerFromGroupForOrgParams is parameters of actions/remove-self-hosted-runner-from-group-for-org operation.
type ActionsRemoveSelfHostedRunnerFromGroupForOrgParams struct {
	Org string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
	// Unique identifier of the self-hosted runner.
	RunnerID int
}

func unpackActionsRemoveSelfHostedRunnerFromGroupForOrgParams(packed map[string]any) (params ActionsRemoveSelfHostedRunnerFromGroupForOrgParams) {
	params.Org = packed["org"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	params.RunnerID = packed["runner_id"].(int)
	return params
}

func decodeActionsRemoveSelfHostedRunnerFromGroupForOrgParams(args [3]string, r *http.Request) (params ActionsRemoveSelfHostedRunnerFromGroupForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_id: parse")
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

// ActionsRetryWorkflowParams is parameters of actions/retry-workflow operation.
type ActionsRetryWorkflowParams struct {
	Owner string
	Repo  string
	// The id of the workflow run.
	RunID int
}

func unpackActionsRetryWorkflowParams(packed map[string]any) (params ActionsRetryWorkflowParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.RunID = packed["run_id"].(int)
	return params
}

func decodeActionsRetryWorkflowParams(args [3]string, r *http.Request) (params ActionsRetryWorkflowParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: run_id: parse")
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

// ActionsReviewPendingDeploymentsForRunParams is parameters of actions/review-pending-deployments-for-run operation.
type ActionsReviewPendingDeploymentsForRunParams struct {
	Owner string
	Repo  string
	// The id of the workflow run.
	RunID int
}

func unpackActionsReviewPendingDeploymentsForRunParams(packed map[string]any) (params ActionsReviewPendingDeploymentsForRunParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.RunID = packed["run_id"].(int)
	return params
}

func decodeActionsReviewPendingDeploymentsForRunParams(args [3]string, r *http.Request) (params ActionsReviewPendingDeploymentsForRunParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: run_id: parse")
			}
		} else {
			return params, errors.New("path: run_id: not specified")
		}
	}
	return params, nil
}

// ActionsSetAllowedActionsOrganizationParams is parameters of actions/set-allowed-actions-organization operation.
type ActionsSetAllowedActionsOrganizationParams struct {
	Org string
}

func unpackActionsSetAllowedActionsOrganizationParams(packed map[string]any) (params ActionsSetAllowedActionsOrganizationParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeActionsSetAllowedActionsOrganizationParams(args [1]string, r *http.Request) (params ActionsSetAllowedActionsOrganizationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// ActionsSetAllowedActionsRepositoryParams is parameters of actions/set-allowed-actions-repository operation.
type ActionsSetAllowedActionsRepositoryParams struct {
	Owner string
	Repo  string
}

func unpackActionsSetAllowedActionsRepositoryParams(packed map[string]any) (params ActionsSetAllowedActionsRepositoryParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeActionsSetAllowedActionsRepositoryParams(args [2]string, r *http.Request) (params ActionsSetAllowedActionsRepositoryParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ActionsSetGithubActionsPermissionsOrganizationParams is parameters of actions/set-github-actions-permissions-organization operation.
type ActionsSetGithubActionsPermissionsOrganizationParams struct {
	Org string
}

func unpackActionsSetGithubActionsPermissionsOrganizationParams(packed map[string]any) (params ActionsSetGithubActionsPermissionsOrganizationParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeActionsSetGithubActionsPermissionsOrganizationParams(args [1]string, r *http.Request) (params ActionsSetGithubActionsPermissionsOrganizationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// ActionsSetGithubActionsPermissionsRepositoryParams is parameters of actions/set-github-actions-permissions-repository operation.
type ActionsSetGithubActionsPermissionsRepositoryParams struct {
	Owner string
	Repo  string
}

func unpackActionsSetGithubActionsPermissionsRepositoryParams(packed map[string]any) (params ActionsSetGithubActionsPermissionsRepositoryParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeActionsSetGithubActionsPermissionsRepositoryParams(args [2]string, r *http.Request) (params ActionsSetGithubActionsPermissionsRepositoryParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams is parameters of actions/set-repo-access-to-self-hosted-runner-group-in-org operation.
type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams struct {
	Org string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
}

func unpackActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams(packed map[string]any) (params ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams) {
	params.Org = packed["org"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	return params
}

func decodeActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams(args [2]string, r *http.Request) (params ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

// ActionsSetSelectedReposForOrgSecretParams is parameters of actions/set-selected-repos-for-org-secret operation.
type ActionsSetSelectedReposForOrgSecretParams struct {
	Org string
	// Secret_name parameter.
	SecretName string
}

func unpackActionsSetSelectedReposForOrgSecretParams(packed map[string]any) (params ActionsSetSelectedReposForOrgSecretParams) {
	params.Org = packed["org"].(string)
	params.SecretName = packed["secret_name"].(string)
	return params
}

func decodeActionsSetSelectedReposForOrgSecretParams(args [2]string, r *http.Request) (params ActionsSetSelectedReposForOrgSecretParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: secret_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "secret_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SecretName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: secret_name: parse")
			}
		} else {
			return params, errors.New("path: secret_name: not specified")
		}
	}
	return params, nil
}

// ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams is parameters of actions/set-selected-repositories-enabled-github-actions-organization operation.
type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams struct {
	Org string
}

func unpackActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams(packed map[string]any) (params ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams(args [1]string, r *http.Request) (params ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// ActionsSetSelfHostedRunnersInGroupForOrgParams is parameters of actions/set-self-hosted-runners-in-group-for-org operation.
type ActionsSetSelfHostedRunnersInGroupForOrgParams struct {
	Org string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
}

func unpackActionsSetSelfHostedRunnersInGroupForOrgParams(packed map[string]any) (params ActionsSetSelfHostedRunnersInGroupForOrgParams) {
	params.Org = packed["org"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	return params
}

func decodeActionsSetSelfHostedRunnersInGroupForOrgParams(args [2]string, r *http.Request) (params ActionsSetSelfHostedRunnersInGroupForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

// ActionsUpdateSelfHostedRunnerGroupForOrgParams is parameters of actions/update-self-hosted-runner-group-for-org operation.
type ActionsUpdateSelfHostedRunnerGroupForOrgParams struct {
	Org string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
}

func unpackActionsUpdateSelfHostedRunnerGroupForOrgParams(packed map[string]any) (params ActionsUpdateSelfHostedRunnerGroupForOrgParams) {
	params.Org = packed["org"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	return params
}

func decodeActionsUpdateSelfHostedRunnerGroupForOrgParams(args [2]string, r *http.Request) (params ActionsUpdateSelfHostedRunnerGroupForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

// ActivityCheckRepoIsStarredByAuthenticatedUserParams is parameters of activity/check-repo-is-starred-by-authenticated-user operation.
type ActivityCheckRepoIsStarredByAuthenticatedUserParams struct {
	Owner string
	Repo  string
}

func unpackActivityCheckRepoIsStarredByAuthenticatedUserParams(packed map[string]any) (params ActivityCheckRepoIsStarredByAuthenticatedUserParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeActivityCheckRepoIsStarredByAuthenticatedUserParams(args [2]string, r *http.Request) (params ActivityCheckRepoIsStarredByAuthenticatedUserParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ActivityDeleteRepoSubscriptionParams is parameters of activity/delete-repo-subscription operation.
type ActivityDeleteRepoSubscriptionParams struct {
	Owner string
	Repo  string
}

func unpackActivityDeleteRepoSubscriptionParams(packed map[string]any) (params ActivityDeleteRepoSubscriptionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeActivityDeleteRepoSubscriptionParams(args [2]string, r *http.Request) (params ActivityDeleteRepoSubscriptionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ActivityDeleteThreadSubscriptionParams is parameters of activity/delete-thread-subscription operation.
type ActivityDeleteThreadSubscriptionParams struct {
	// Thread_id parameter.
	ThreadID int
}

func unpackActivityDeleteThreadSubscriptionParams(packed map[string]any) (params ActivityDeleteThreadSubscriptionParams) {
	params.ThreadID = packed["thread_id"].(int)
	return params
}

func decodeActivityDeleteThreadSubscriptionParams(args [1]string, r *http.Request) (params ActivityDeleteThreadSubscriptionParams, _ error) {
	// Decode path: thread_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: thread_id: parse")
			}
		} else {
			return params, errors.New("path: thread_id: not specified")
		}
	}
	return params, nil
}

// ActivityGetRepoSubscriptionParams is parameters of activity/get-repo-subscription operation.
type ActivityGetRepoSubscriptionParams struct {
	Owner string
	Repo  string
}

func unpackActivityGetRepoSubscriptionParams(packed map[string]any) (params ActivityGetRepoSubscriptionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeActivityGetRepoSubscriptionParams(args [2]string, r *http.Request) (params ActivityGetRepoSubscriptionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ActivityGetThreadParams is parameters of activity/get-thread operation.
type ActivityGetThreadParams struct {
	// Thread_id parameter.
	ThreadID int
}

func unpackActivityGetThreadParams(packed map[string]any) (params ActivityGetThreadParams) {
	params.ThreadID = packed["thread_id"].(int)
	return params
}

func decodeActivityGetThreadParams(args [1]string, r *http.Request) (params ActivityGetThreadParams, _ error) {
	// Decode path: thread_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: thread_id: parse")
			}
		} else {
			return params, errors.New("path: thread_id: not specified")
		}
	}
	return params, nil
}

// ActivityGetThreadSubscriptionForAuthenticatedUserParams is parameters of activity/get-thread-subscription-for-authenticated-user operation.
type ActivityGetThreadSubscriptionForAuthenticatedUserParams struct {
	// Thread_id parameter.
	ThreadID int
}

func unpackActivityGetThreadSubscriptionForAuthenticatedUserParams(packed map[string]any) (params ActivityGetThreadSubscriptionForAuthenticatedUserParams) {
	params.ThreadID = packed["thread_id"].(int)
	return params
}

func decodeActivityGetThreadSubscriptionForAuthenticatedUserParams(args [1]string, r *http.Request) (params ActivityGetThreadSubscriptionForAuthenticatedUserParams, _ error) {
	// Decode path: thread_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: thread_id: parse")
			}
		} else {
			return params, errors.New("path: thread_id: not specified")
		}
	}
	return params, nil
}

// ActivityListEventsForAuthenticatedUserParams is parameters of activity/list-events-for-authenticated-user operation.
type ActivityListEventsForAuthenticatedUserParams struct {
	Username string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActivityListEventsForAuthenticatedUserParams(packed map[string]any) (params ActivityListEventsForAuthenticatedUserParams) {
	params.Username = packed["username"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActivityListEventsForAuthenticatedUserParams(args [1]string, r *http.Request) (params ActivityListEventsForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActivityListNotificationsForAuthenticatedUserParams is parameters of activity/list-notifications-for-authenticated-user operation.
type ActivityListNotificationsForAuthenticatedUserParams struct {
	// If `true`, show notifications marked as read.
	All OptBool `json:",omitempty"`
	// If `true`, only shows notifications in which the user is directly participating or mentioned.
	Participating OptBool `json:",omitempty"`
	// Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Since OptDateTime `json:",omitempty"`
	// Only show notifications updated before the given time. This is a timestamp in [ISO
	// 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Before OptDateTime `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActivityListNotificationsForAuthenticatedUserParams(packed map[string]any) (params ActivityListNotificationsForAuthenticatedUserParams) {
	if v, ok := packed["all"]; ok {
		params.All = v.(OptBool)
	}
	if v, ok := packed["participating"]; ok {
		params.Participating = v.(OptBool)
	}
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptDateTime)
	}
	if v, ok := packed["before"]; ok {
		params.Before = v.(OptDateTime)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActivityListNotificationsForAuthenticatedUserParams(args [0]string, r *http.Request) (params ActivityListNotificationsForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: all.
	{
		val := bool(false)
		params.All.SetTo(val)
	}
	// Decode query: all.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "all",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.All.SetTo(paramsDotAllVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: all: parse")
			}
		}
	}
	// Set default value for query: participating.
	{
		val := bool(false)
		params.Participating.SetTo(val)
	}
	// Decode query: participating.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "participating",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotParticipatingVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotParticipatingVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Participating.SetTo(paramsDotParticipatingVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: participating: parse")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Decode query: before.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsDotBeforeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActivityListOrgEventsForAuthenticatedUserParams is parameters of activity/list-org-events-for-authenticated-user operation.
type ActivityListOrgEventsForAuthenticatedUserParams struct {
	Username string
	Org      string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActivityListOrgEventsForAuthenticatedUserParams(packed map[string]any) (params ActivityListOrgEventsForAuthenticatedUserParams) {
	params.Username = packed["username"].(string)
	params.Org = packed["org"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActivityListOrgEventsForAuthenticatedUserParams(args [2]string, r *http.Request) (params ActivityListOrgEventsForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Decode path: org.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActivityListPublicEventsParams is parameters of activity/list-public-events operation.
type ActivityListPublicEventsParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActivityListPublicEventsParams(packed map[string]any) (params ActivityListPublicEventsParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActivityListPublicEventsParams(args [0]string, r *http.Request) (params ActivityListPublicEventsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActivityListPublicEventsForRepoNetworkParams is parameters of activity/list-public-events-for-repo-network operation.
type ActivityListPublicEventsForRepoNetworkParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActivityListPublicEventsForRepoNetworkParams(packed map[string]any) (params ActivityListPublicEventsForRepoNetworkParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActivityListPublicEventsForRepoNetworkParams(args [2]string, r *http.Request) (params ActivityListPublicEventsForRepoNetworkParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActivityListPublicEventsForUserParams is parameters of activity/list-public-events-for-user operation.
type ActivityListPublicEventsForUserParams struct {
	Username string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActivityListPublicEventsForUserParams(packed map[string]any) (params ActivityListPublicEventsForUserParams) {
	params.Username = packed["username"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActivityListPublicEventsForUserParams(args [1]string, r *http.Request) (params ActivityListPublicEventsForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActivityListPublicOrgEventsParams is parameters of activity/list-public-org-events operation.
type ActivityListPublicOrgEventsParams struct {
	Org string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActivityListPublicOrgEventsParams(packed map[string]any) (params ActivityListPublicOrgEventsParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActivityListPublicOrgEventsParams(args [1]string, r *http.Request) (params ActivityListPublicOrgEventsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActivityListReceivedEventsForUserParams is parameters of activity/list-received-events-for-user operation.
type ActivityListReceivedEventsForUserParams struct {
	Username string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActivityListReceivedEventsForUserParams(packed map[string]any) (params ActivityListReceivedEventsForUserParams) {
	params.Username = packed["username"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActivityListReceivedEventsForUserParams(args [1]string, r *http.Request) (params ActivityListReceivedEventsForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActivityListReceivedPublicEventsForUserParams is parameters of activity/list-received-public-events-for-user operation.
type ActivityListReceivedPublicEventsForUserParams struct {
	Username string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActivityListReceivedPublicEventsForUserParams(packed map[string]any) (params ActivityListReceivedPublicEventsForUserParams) {
	params.Username = packed["username"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActivityListReceivedPublicEventsForUserParams(args [1]string, r *http.Request) (params ActivityListReceivedPublicEventsForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActivityListRepoEventsParams is parameters of activity/list-repo-events operation.
type ActivityListRepoEventsParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActivityListRepoEventsParams(packed map[string]any) (params ActivityListRepoEventsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActivityListRepoEventsParams(args [2]string, r *http.Request) (params ActivityListRepoEventsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActivityListRepoNotificationsForAuthenticatedUserParams is parameters of activity/list-repo-notifications-for-authenticated-user operation.
type ActivityListRepoNotificationsForAuthenticatedUserParams struct {
	Owner string
	Repo  string
	// If `true`, show notifications marked as read.
	All OptBool `json:",omitempty"`
	// If `true`, only shows notifications in which the user is directly participating or mentioned.
	Participating OptBool `json:",omitempty"`
	// Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Since OptDateTime `json:",omitempty"`
	// Only show notifications updated before the given time. This is a timestamp in [ISO
	// 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Before OptDateTime `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActivityListRepoNotificationsForAuthenticatedUserParams(packed map[string]any) (params ActivityListRepoNotificationsForAuthenticatedUserParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["all"]; ok {
		params.All = v.(OptBool)
	}
	if v, ok := packed["participating"]; ok {
		params.Participating = v.(OptBool)
	}
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptDateTime)
	}
	if v, ok := packed["before"]; ok {
		params.Before = v.(OptDateTime)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActivityListRepoNotificationsForAuthenticatedUserParams(args [2]string, r *http.Request) (params ActivityListRepoNotificationsForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: all.
	{
		val := bool(false)
		params.All.SetTo(val)
	}
	// Decode query: all.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "all",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAllVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotAllVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.All.SetTo(paramsDotAllVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: all: parse")
			}
		}
	}
	// Set default value for query: participating.
	{
		val := bool(false)
		params.Participating.SetTo(val)
	}
	// Decode query: participating.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "participating",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotParticipatingVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotParticipatingVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Participating.SetTo(paramsDotParticipatingVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: participating: parse")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Decode query: before.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsDotBeforeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActivityListReposStarredByAuthenticatedUserParams is parameters of activity/list-repos-starred-by-authenticated-user operation.
type ActivityListReposStarredByAuthenticatedUserParams struct {
	// One of `created` (when the repository was starred) or `updated` (when it was last pushed to).
	Sort OptActivityListReposStarredByAuthenticatedUserSort `json:",omitempty"`
	// One of `asc` (ascending) or `desc` (descending).
	Direction OptActivityListReposStarredByAuthenticatedUserDirection `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActivityListReposStarredByAuthenticatedUserParams(packed map[string]any) (params ActivityListReposStarredByAuthenticatedUserParams) {
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptActivityListReposStarredByAuthenticatedUserSort)
	}
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptActivityListReposStarredByAuthenticatedUserDirection)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActivityListReposStarredByAuthenticatedUserParams(args [0]string, r *http.Request) (params ActivityListReposStarredByAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: sort.
	{
		val := ActivityListReposStarredByAuthenticatedUserSort("created")
		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal ActivityListReposStarredByAuthenticatedUserSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = ActivityListReposStarredByAuthenticatedUserSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: direction.
	{
		val := ActivityListReposStarredByAuthenticatedUserDirection("desc")
		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal ActivityListReposStarredByAuthenticatedUserDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = ActivityListReposStarredByAuthenticatedUserDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActivityListReposWatchedByUserParams is parameters of activity/list-repos-watched-by-user operation.
type ActivityListReposWatchedByUserParams struct {
	Username string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActivityListReposWatchedByUserParams(packed map[string]any) (params ActivityListReposWatchedByUserParams) {
	params.Username = packed["username"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActivityListReposWatchedByUserParams(args [1]string, r *http.Request) (params ActivityListReposWatchedByUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActivityListWatchedReposForAuthenticatedUserParams is parameters of activity/list-watched-repos-for-authenticated-user operation.
type ActivityListWatchedReposForAuthenticatedUserParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActivityListWatchedReposForAuthenticatedUserParams(packed map[string]any) (params ActivityListWatchedReposForAuthenticatedUserParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActivityListWatchedReposForAuthenticatedUserParams(args [0]string, r *http.Request) (params ActivityListWatchedReposForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActivityListWatchersForRepoParams is parameters of activity/list-watchers-for-repo operation.
type ActivityListWatchersForRepoParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackActivityListWatchersForRepoParams(packed map[string]any) (params ActivityListWatchersForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeActivityListWatchersForRepoParams(args [2]string, r *http.Request) (params ActivityListWatchersForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ActivityMarkRepoNotificationsAsReadParams is parameters of activity/mark-repo-notifications-as-read operation.
type ActivityMarkRepoNotificationsAsReadParams struct {
	Owner string
	Repo  string
}

func unpackActivityMarkRepoNotificationsAsReadParams(packed map[string]any) (params ActivityMarkRepoNotificationsAsReadParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeActivityMarkRepoNotificationsAsReadParams(args [2]string, r *http.Request) (params ActivityMarkRepoNotificationsAsReadParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ActivityMarkThreadAsReadParams is parameters of activity/mark-thread-as-read operation.
type ActivityMarkThreadAsReadParams struct {
	// Thread_id parameter.
	ThreadID int
}

func unpackActivityMarkThreadAsReadParams(packed map[string]any) (params ActivityMarkThreadAsReadParams) {
	params.ThreadID = packed["thread_id"].(int)
	return params
}

func decodeActivityMarkThreadAsReadParams(args [1]string, r *http.Request) (params ActivityMarkThreadAsReadParams, _ error) {
	// Decode path: thread_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: thread_id: parse")
			}
		} else {
			return params, errors.New("path: thread_id: not specified")
		}
	}
	return params, nil
}

// ActivitySetRepoSubscriptionParams is parameters of activity/set-repo-subscription operation.
type ActivitySetRepoSubscriptionParams struct {
	Owner string
	Repo  string
}

func unpackActivitySetRepoSubscriptionParams(packed map[string]any) (params ActivitySetRepoSubscriptionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeActivitySetRepoSubscriptionParams(args [2]string, r *http.Request) (params ActivitySetRepoSubscriptionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ActivitySetThreadSubscriptionParams is parameters of activity/set-thread-subscription operation.
type ActivitySetThreadSubscriptionParams struct {
	// Thread_id parameter.
	ThreadID int
}

func unpackActivitySetThreadSubscriptionParams(packed map[string]any) (params ActivitySetThreadSubscriptionParams) {
	params.ThreadID = packed["thread_id"].(int)
	return params
}

func decodeActivitySetThreadSubscriptionParams(args [1]string, r *http.Request) (params ActivitySetThreadSubscriptionParams, _ error) {
	// Decode path: thread_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "thread_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ThreadID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: thread_id: parse")
			}
		} else {
			return params, errors.New("path: thread_id: not specified")
		}
	}
	return params, nil
}

// ActivityStarRepoForAuthenticatedUserParams is parameters of activity/star-repo-for-authenticated-user operation.
type ActivityStarRepoForAuthenticatedUserParams struct {
	Owner string
	Repo  string
}

func unpackActivityStarRepoForAuthenticatedUserParams(packed map[string]any) (params ActivityStarRepoForAuthenticatedUserParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeActivityStarRepoForAuthenticatedUserParams(args [2]string, r *http.Request) (params ActivityStarRepoForAuthenticatedUserParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ActivityUnstarRepoForAuthenticatedUserParams is parameters of activity/unstar-repo-for-authenticated-user operation.
type ActivityUnstarRepoForAuthenticatedUserParams struct {
	Owner string
	Repo  string
}

func unpackActivityUnstarRepoForAuthenticatedUserParams(packed map[string]any) (params ActivityUnstarRepoForAuthenticatedUserParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeActivityUnstarRepoForAuthenticatedUserParams(args [2]string, r *http.Request) (params ActivityUnstarRepoForAuthenticatedUserParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// AppsAddRepoToInstallationParams is parameters of apps/add-repo-to-installation operation.
type AppsAddRepoToInstallationParams struct {
	// Installation_id parameter.
	InstallationID int
	RepositoryID   int
}

func unpackAppsAddRepoToInstallationParams(packed map[string]any) (params AppsAddRepoToInstallationParams) {
	params.InstallationID = packed["installation_id"].(int)
	params.RepositoryID = packed["repository_id"].(int)
	return params
}

func decodeAppsAddRepoToInstallationParams(args [2]string, r *http.Request) (params AppsAddRepoToInstallationParams, _ error) {
	// Decode path: installation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: installation_id: parse")
			}
		} else {
			return params, errors.New("path: installation_id: not specified")
		}
	}
	// Decode path: repository_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repository_id: parse")
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	return params, nil
}

// AppsCheckTokenParams is parameters of apps/check-token operation.
type AppsCheckTokenParams struct {
	// The client ID of your GitHub app.
	ClientID string
}

func unpackAppsCheckTokenParams(packed map[string]any) (params AppsCheckTokenParams) {
	params.ClientID = packed["client_id"].(string)
	return params
}

func decodeAppsCheckTokenParams(args [1]string, r *http.Request) (params AppsCheckTokenParams, _ error) {
	// Decode path: client_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: client_id: parse")
			}
		} else {
			return params, errors.New("path: client_id: not specified")
		}
	}
	return params, nil
}

// AppsCreateContentAttachmentParams is parameters of apps/create-content-attachment operation.
type AppsCreateContentAttachmentParams struct {
	// The owner of the repository. Determined from the `repository` `full_name` of the
	// `content_reference` event.
	Owner string
	// The name of the repository. Determined from the `repository` `full_name` of the
	// `content_reference` event.
	Repo string
	// The `id` of the `content_reference` event.
	ContentReferenceID int
}

func unpackAppsCreateContentAttachmentParams(packed map[string]any) (params AppsCreateContentAttachmentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.ContentReferenceID = packed["content_reference_id"].(int)
	return params
}

func decodeAppsCreateContentAttachmentParams(args [3]string, r *http.Request) (params AppsCreateContentAttachmentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: content_reference_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "content_reference_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ContentReferenceID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: content_reference_id: parse")
			}
		} else {
			return params, errors.New("path: content_reference_id: not specified")
		}
	}
	return params, nil
}

// AppsCreateFromManifestParams is parameters of apps/create-from-manifest operation.
type AppsCreateFromManifestParams struct {
	Code string
}

func unpackAppsCreateFromManifestParams(packed map[string]any) (params AppsCreateFromManifestParams) {
	params.Code = packed["code"].(string)
	return params
}

func decodeAppsCreateFromManifestParams(args [1]string, r *http.Request) (params AppsCreateFromManifestParams, _ error) {
	// Decode path: code.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "code",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Code = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: code: parse")
			}
		} else {
			return params, errors.New("path: code: not specified")
		}
	}
	return params, nil
}

// AppsCreateInstallationAccessTokenParams is parameters of apps/create-installation-access-token operation.
type AppsCreateInstallationAccessTokenParams struct {
	// Installation_id parameter.
	InstallationID int
}

func unpackAppsCreateInstallationAccessTokenParams(packed map[string]any) (params AppsCreateInstallationAccessTokenParams) {
	params.InstallationID = packed["installation_id"].(int)
	return params
}

func decodeAppsCreateInstallationAccessTokenParams(args [1]string, r *http.Request) (params AppsCreateInstallationAccessTokenParams, _ error) {
	// Decode path: installation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: installation_id: parse")
			}
		} else {
			return params, errors.New("path: installation_id: not specified")
		}
	}
	return params, nil
}

// AppsDeleteAuthorizationParams is parameters of apps/delete-authorization operation.
type AppsDeleteAuthorizationParams struct {
	// The client ID of your GitHub app.
	ClientID string
}

func unpackAppsDeleteAuthorizationParams(packed map[string]any) (params AppsDeleteAuthorizationParams) {
	params.ClientID = packed["client_id"].(string)
	return params
}

func decodeAppsDeleteAuthorizationParams(args [1]string, r *http.Request) (params AppsDeleteAuthorizationParams, _ error) {
	// Decode path: client_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: client_id: parse")
			}
		} else {
			return params, errors.New("path: client_id: not specified")
		}
	}
	return params, nil
}

// AppsDeleteInstallationParams is parameters of apps/delete-installation operation.
type AppsDeleteInstallationParams struct {
	// Installation_id parameter.
	InstallationID int
}

func unpackAppsDeleteInstallationParams(packed map[string]any) (params AppsDeleteInstallationParams) {
	params.InstallationID = packed["installation_id"].(int)
	return params
}

func decodeAppsDeleteInstallationParams(args [1]string, r *http.Request) (params AppsDeleteInstallationParams, _ error) {
	// Decode path: installation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: installation_id: parse")
			}
		} else {
			return params, errors.New("path: installation_id: not specified")
		}
	}
	return params, nil
}

// AppsDeleteTokenParams is parameters of apps/delete-token operation.
type AppsDeleteTokenParams struct {
	// The client ID of your GitHub app.
	ClientID string
}

func unpackAppsDeleteTokenParams(packed map[string]any) (params AppsDeleteTokenParams) {
	params.ClientID = packed["client_id"].(string)
	return params
}

func decodeAppsDeleteTokenParams(args [1]string, r *http.Request) (params AppsDeleteTokenParams, _ error) {
	// Decode path: client_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: client_id: parse")
			}
		} else {
			return params, errors.New("path: client_id: not specified")
		}
	}
	return params, nil
}

// AppsGetBySlugParams is parameters of apps/get-by-slug operation.
type AppsGetBySlugParams struct {
	AppSlug string
}

func unpackAppsGetBySlugParams(packed map[string]any) (params AppsGetBySlugParams) {
	params.AppSlug = packed["app_slug"].(string)
	return params
}

func decodeAppsGetBySlugParams(args [1]string, r *http.Request) (params AppsGetBySlugParams, _ error) {
	// Decode path: app_slug.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "app_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.AppSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: app_slug: parse")
			}
		} else {
			return params, errors.New("path: app_slug: not specified")
		}
	}
	return params, nil
}

// AppsGetSubscriptionPlanForAccountParams is parameters of apps/get-subscription-plan-for-account operation.
type AppsGetSubscriptionPlanForAccountParams struct {
	// Account_id parameter.
	AccountID int
}

func unpackAppsGetSubscriptionPlanForAccountParams(packed map[string]any) (params AppsGetSubscriptionPlanForAccountParams) {
	params.AccountID = packed["account_id"].(int)
	return params
}

func decodeAppsGetSubscriptionPlanForAccountParams(args [1]string, r *http.Request) (params AppsGetSubscriptionPlanForAccountParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// AppsGetSubscriptionPlanForAccountStubbedParams is parameters of apps/get-subscription-plan-for-account-stubbed operation.
type AppsGetSubscriptionPlanForAccountStubbedParams struct {
	// Account_id parameter.
	AccountID int
}

func unpackAppsGetSubscriptionPlanForAccountStubbedParams(packed map[string]any) (params AppsGetSubscriptionPlanForAccountStubbedParams) {
	params.AccountID = packed["account_id"].(int)
	return params
}

func decodeAppsGetSubscriptionPlanForAccountStubbedParams(args [1]string, r *http.Request) (params AppsGetSubscriptionPlanForAccountStubbedParams, _ error) {
	// Decode path: account_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "account_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AccountID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: account_id: parse")
			}
		} else {
			return params, errors.New("path: account_id: not specified")
		}
	}
	return params, nil
}

// AppsGetWebhookDeliveryParams is parameters of apps/get-webhook-delivery operation.
type AppsGetWebhookDeliveryParams struct {
	DeliveryID int
}

func unpackAppsGetWebhookDeliveryParams(packed map[string]any) (params AppsGetWebhookDeliveryParams) {
	params.DeliveryID = packed["delivery_id"].(int)
	return params
}

func decodeAppsGetWebhookDeliveryParams(args [1]string, r *http.Request) (params AppsGetWebhookDeliveryParams, _ error) {
	// Decode path: delivery_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: delivery_id: parse")
			}
		} else {
			return params, errors.New("path: delivery_id: not specified")
		}
	}
	return params, nil
}

// AppsListAccountsForPlanParams is parameters of apps/list-accounts-for-plan operation.
type AppsListAccountsForPlanParams struct {
	// Plan_id parameter.
	PlanID int
	// One of `created` (when the repository was starred) or `updated` (when it was last pushed to).
	Sort OptAppsListAccountsForPlanSort `json:",omitempty"`
	// To return the oldest accounts first, set to `asc`. Can be one of `asc` or `desc`. Ignored without
	// the `sort` parameter.
	Direction OptAppsListAccountsForPlanDirection `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackAppsListAccountsForPlanParams(packed map[string]any) (params AppsListAccountsForPlanParams) {
	params.PlanID = packed["plan_id"].(int)
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptAppsListAccountsForPlanSort)
	}
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptAppsListAccountsForPlanDirection)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeAppsListAccountsForPlanParams(args [1]string, r *http.Request) (params AppsListAccountsForPlanParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: plan_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "plan_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PlanID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: plan_id: parse")
			}
		} else {
			return params, errors.New("path: plan_id: not specified")
		}
	}
	// Set default value for query: sort.
	{
		val := AppsListAccountsForPlanSort("created")
		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal AppsListAccountsForPlanSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = AppsListAccountsForPlanSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal AppsListAccountsForPlanDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = AppsListAccountsForPlanDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// AppsListAccountsForPlanStubbedParams is parameters of apps/list-accounts-for-plan-stubbed operation.
type AppsListAccountsForPlanStubbedParams struct {
	// Plan_id parameter.
	PlanID int
	// One of `created` (when the repository was starred) or `updated` (when it was last pushed to).
	Sort OptAppsListAccountsForPlanStubbedSort `json:",omitempty"`
	// To return the oldest accounts first, set to `asc`. Can be one of `asc` or `desc`. Ignored without
	// the `sort` parameter.
	Direction OptAppsListAccountsForPlanStubbedDirection `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackAppsListAccountsForPlanStubbedParams(packed map[string]any) (params AppsListAccountsForPlanStubbedParams) {
	params.PlanID = packed["plan_id"].(int)
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptAppsListAccountsForPlanStubbedSort)
	}
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptAppsListAccountsForPlanStubbedDirection)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeAppsListAccountsForPlanStubbedParams(args [1]string, r *http.Request) (params AppsListAccountsForPlanStubbedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: plan_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "plan_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PlanID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: plan_id: parse")
			}
		} else {
			return params, errors.New("path: plan_id: not specified")
		}
	}
	// Set default value for query: sort.
	{
		val := AppsListAccountsForPlanStubbedSort("created")
		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal AppsListAccountsForPlanStubbedSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = AppsListAccountsForPlanStubbedSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal AppsListAccountsForPlanStubbedDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = AppsListAccountsForPlanStubbedDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// AppsListInstallationReposForAuthenticatedUserParams is parameters of apps/list-installation-repos-for-authenticated-user operation.
type AppsListInstallationReposForAuthenticatedUserParams struct {
	// Installation_id parameter.
	InstallationID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackAppsListInstallationReposForAuthenticatedUserParams(packed map[string]any) (params AppsListInstallationReposForAuthenticatedUserParams) {
	params.InstallationID = packed["installation_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeAppsListInstallationReposForAuthenticatedUserParams(args [1]string, r *http.Request) (params AppsListInstallationReposForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: installation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: installation_id: parse")
			}
		} else {
			return params, errors.New("path: installation_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// AppsListPlansParams is parameters of apps/list-plans operation.
type AppsListPlansParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackAppsListPlansParams(packed map[string]any) (params AppsListPlansParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeAppsListPlansParams(args [0]string, r *http.Request) (params AppsListPlansParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// AppsListPlansStubbedParams is parameters of apps/list-plans-stubbed operation.
type AppsListPlansStubbedParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackAppsListPlansStubbedParams(packed map[string]any) (params AppsListPlansStubbedParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeAppsListPlansStubbedParams(args [0]string, r *http.Request) (params AppsListPlansStubbedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// AppsListReposAccessibleToInstallationParams is parameters of apps/list-repos-accessible-to-installation operation.
type AppsListReposAccessibleToInstallationParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackAppsListReposAccessibleToInstallationParams(packed map[string]any) (params AppsListReposAccessibleToInstallationParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeAppsListReposAccessibleToInstallationParams(args [0]string, r *http.Request) (params AppsListReposAccessibleToInstallationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// AppsListSubscriptionsForAuthenticatedUserParams is parameters of apps/list-subscriptions-for-authenticated-user operation.
type AppsListSubscriptionsForAuthenticatedUserParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackAppsListSubscriptionsForAuthenticatedUserParams(packed map[string]any) (params AppsListSubscriptionsForAuthenticatedUserParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeAppsListSubscriptionsForAuthenticatedUserParams(args [0]string, r *http.Request) (params AppsListSubscriptionsForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// AppsListSubscriptionsForAuthenticatedUserStubbedParams is parameters of apps/list-subscriptions-for-authenticated-user-stubbed operation.
type AppsListSubscriptionsForAuthenticatedUserStubbedParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackAppsListSubscriptionsForAuthenticatedUserStubbedParams(packed map[string]any) (params AppsListSubscriptionsForAuthenticatedUserStubbedParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeAppsListSubscriptionsForAuthenticatedUserStubbedParams(args [0]string, r *http.Request) (params AppsListSubscriptionsForAuthenticatedUserStubbedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// AppsListWebhookDeliveriesParams is parameters of apps/list-webhook-deliveries operation.
type AppsListWebhookDeliveriesParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to
	// the `link` header for the next and previous page cursors.
	Cursor OptString `json:",omitempty"`
}

func unpackAppsListWebhookDeliveriesParams(packed map[string]any) (params AppsListWebhookDeliveriesParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["cursor"]; ok {
		params.Cursor = v.(OptString)
	}
	return params
}

func decodeAppsListWebhookDeliveriesParams(args [0]string, r *http.Request) (params AppsListWebhookDeliveriesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode query: cursor.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: cursor: parse")
			}
		}
	}
	return params, nil
}

// AppsRedeliverWebhookDeliveryParams is parameters of apps/redeliver-webhook-delivery operation.
type AppsRedeliverWebhookDeliveryParams struct {
	DeliveryID int
}

func unpackAppsRedeliverWebhookDeliveryParams(packed map[string]any) (params AppsRedeliverWebhookDeliveryParams) {
	params.DeliveryID = packed["delivery_id"].(int)
	return params
}

func decodeAppsRedeliverWebhookDeliveryParams(args [1]string, r *http.Request) (params AppsRedeliverWebhookDeliveryParams, _ error) {
	// Decode path: delivery_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: delivery_id: parse")
			}
		} else {
			return params, errors.New("path: delivery_id: not specified")
		}
	}
	return params, nil
}

// AppsRemoveRepoFromInstallationParams is parameters of apps/remove-repo-from-installation operation.
type AppsRemoveRepoFromInstallationParams struct {
	// Installation_id parameter.
	InstallationID int
	RepositoryID   int
}

func unpackAppsRemoveRepoFromInstallationParams(packed map[string]any) (params AppsRemoveRepoFromInstallationParams) {
	params.InstallationID = packed["installation_id"].(int)
	params.RepositoryID = packed["repository_id"].(int)
	return params
}

func decodeAppsRemoveRepoFromInstallationParams(args [2]string, r *http.Request) (params AppsRemoveRepoFromInstallationParams, _ error) {
	// Decode path: installation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: installation_id: parse")
			}
		} else {
			return params, errors.New("path: installation_id: not specified")
		}
	}
	// Decode path: repository_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repository_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repository_id: parse")
			}
		} else {
			return params, errors.New("path: repository_id: not specified")
		}
	}
	return params, nil
}

// AppsResetTokenParams is parameters of apps/reset-token operation.
type AppsResetTokenParams struct {
	// The client ID of your GitHub app.
	ClientID string
}

func unpackAppsResetTokenParams(packed map[string]any) (params AppsResetTokenParams) {
	params.ClientID = packed["client_id"].(string)
	return params
}

func decodeAppsResetTokenParams(args [1]string, r *http.Request) (params AppsResetTokenParams, _ error) {
	// Decode path: client_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: client_id: parse")
			}
		} else {
			return params, errors.New("path: client_id: not specified")
		}
	}
	return params, nil
}

// AppsScopeTokenParams is parameters of apps/scope-token operation.
type AppsScopeTokenParams struct {
	// The client ID of your GitHub app.
	ClientID string
}

func unpackAppsScopeTokenParams(packed map[string]any) (params AppsScopeTokenParams) {
	params.ClientID = packed["client_id"].(string)
	return params
}

func decodeAppsScopeTokenParams(args [1]string, r *http.Request) (params AppsScopeTokenParams, _ error) {
	// Decode path: client_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: client_id: parse")
			}
		} else {
			return params, errors.New("path: client_id: not specified")
		}
	}
	return params, nil
}

// AppsSuspendInstallationParams is parameters of apps/suspend-installation operation.
type AppsSuspendInstallationParams struct {
	// Installation_id parameter.
	InstallationID int
}

func unpackAppsSuspendInstallationParams(packed map[string]any) (params AppsSuspendInstallationParams) {
	params.InstallationID = packed["installation_id"].(int)
	return params
}

func decodeAppsSuspendInstallationParams(args [1]string, r *http.Request) (params AppsSuspendInstallationParams, _ error) {
	// Decode path: installation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: installation_id: parse")
			}
		} else {
			return params, errors.New("path: installation_id: not specified")
		}
	}
	return params, nil
}

// AppsUnsuspendInstallationParams is parameters of apps/unsuspend-installation operation.
type AppsUnsuspendInstallationParams struct {
	// Installation_id parameter.
	InstallationID int
}

func unpackAppsUnsuspendInstallationParams(packed map[string]any) (params AppsUnsuspendInstallationParams) {
	params.InstallationID = packed["installation_id"].(int)
	return params
}

func decodeAppsUnsuspendInstallationParams(args [1]string, r *http.Request) (params AppsUnsuspendInstallationParams, _ error) {
	// Decode path: installation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "installation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InstallationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: installation_id: parse")
			}
		} else {
			return params, errors.New("path: installation_id: not specified")
		}
	}
	return params, nil
}

// BillingGetGithubActionsBillingGheParams is parameters of billing/get-github-actions-billing-ghe operation.
type BillingGetGithubActionsBillingGheParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
}

func unpackBillingGetGithubActionsBillingGheParams(packed map[string]any) (params BillingGetGithubActionsBillingGheParams) {
	params.Enterprise = packed["enterprise"].(string)
	return params
}

func decodeBillingGetGithubActionsBillingGheParams(args [1]string, r *http.Request) (params BillingGetGithubActionsBillingGheParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

// BillingGetGithubActionsBillingOrgParams is parameters of billing/get-github-actions-billing-org operation.
type BillingGetGithubActionsBillingOrgParams struct {
	Org string
}

func unpackBillingGetGithubActionsBillingOrgParams(packed map[string]any) (params BillingGetGithubActionsBillingOrgParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeBillingGetGithubActionsBillingOrgParams(args [1]string, r *http.Request) (params BillingGetGithubActionsBillingOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// BillingGetGithubActionsBillingUserParams is parameters of billing/get-github-actions-billing-user operation.
type BillingGetGithubActionsBillingUserParams struct {
	Username string
}

func unpackBillingGetGithubActionsBillingUserParams(packed map[string]any) (params BillingGetGithubActionsBillingUserParams) {
	params.Username = packed["username"].(string)
	return params
}

func decodeBillingGetGithubActionsBillingUserParams(args [1]string, r *http.Request) (params BillingGetGithubActionsBillingUserParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// BillingGetGithubPackagesBillingGheParams is parameters of billing/get-github-packages-billing-ghe operation.
type BillingGetGithubPackagesBillingGheParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
}

func unpackBillingGetGithubPackagesBillingGheParams(packed map[string]any) (params BillingGetGithubPackagesBillingGheParams) {
	params.Enterprise = packed["enterprise"].(string)
	return params
}

func decodeBillingGetGithubPackagesBillingGheParams(args [1]string, r *http.Request) (params BillingGetGithubPackagesBillingGheParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

// BillingGetGithubPackagesBillingOrgParams is parameters of billing/get-github-packages-billing-org operation.
type BillingGetGithubPackagesBillingOrgParams struct {
	Org string
}

func unpackBillingGetGithubPackagesBillingOrgParams(packed map[string]any) (params BillingGetGithubPackagesBillingOrgParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeBillingGetGithubPackagesBillingOrgParams(args [1]string, r *http.Request) (params BillingGetGithubPackagesBillingOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// BillingGetGithubPackagesBillingUserParams is parameters of billing/get-github-packages-billing-user operation.
type BillingGetGithubPackagesBillingUserParams struct {
	Username string
}

func unpackBillingGetGithubPackagesBillingUserParams(packed map[string]any) (params BillingGetGithubPackagesBillingUserParams) {
	params.Username = packed["username"].(string)
	return params
}

func decodeBillingGetGithubPackagesBillingUserParams(args [1]string, r *http.Request) (params BillingGetGithubPackagesBillingUserParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// BillingGetSharedStorageBillingGheParams is parameters of billing/get-shared-storage-billing-ghe operation.
type BillingGetSharedStorageBillingGheParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
}

func unpackBillingGetSharedStorageBillingGheParams(packed map[string]any) (params BillingGetSharedStorageBillingGheParams) {
	params.Enterprise = packed["enterprise"].(string)
	return params
}

func decodeBillingGetSharedStorageBillingGheParams(args [1]string, r *http.Request) (params BillingGetSharedStorageBillingGheParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

// BillingGetSharedStorageBillingOrgParams is parameters of billing/get-shared-storage-billing-org operation.
type BillingGetSharedStorageBillingOrgParams struct {
	Org string
}

func unpackBillingGetSharedStorageBillingOrgParams(packed map[string]any) (params BillingGetSharedStorageBillingOrgParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeBillingGetSharedStorageBillingOrgParams(args [1]string, r *http.Request) (params BillingGetSharedStorageBillingOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// BillingGetSharedStorageBillingUserParams is parameters of billing/get-shared-storage-billing-user operation.
type BillingGetSharedStorageBillingUserParams struct {
	Username string
}

func unpackBillingGetSharedStorageBillingUserParams(packed map[string]any) (params BillingGetSharedStorageBillingUserParams) {
	params.Username = packed["username"].(string)
	return params
}

func decodeBillingGetSharedStorageBillingUserParams(args [1]string, r *http.Request) (params BillingGetSharedStorageBillingUserParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// ChecksCreateSuiteParams is parameters of checks/create-suite operation.
type ChecksCreateSuiteParams struct {
	Owner string
	Repo  string
}

func unpackChecksCreateSuiteParams(packed map[string]any) (params ChecksCreateSuiteParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeChecksCreateSuiteParams(args [2]string, r *http.Request) (params ChecksCreateSuiteParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ChecksGetParams is parameters of checks/get operation.
type ChecksGetParams struct {
	Owner string
	Repo  string
	// Check_run_id parameter.
	CheckRunID int
}

func unpackChecksGetParams(packed map[string]any) (params ChecksGetParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CheckRunID = packed["check_run_id"].(int)
	return params
}

func decodeChecksGetParams(args [3]string, r *http.Request) (params ChecksGetParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: check_run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CheckRunID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: check_run_id: parse")
			}
		} else {
			return params, errors.New("path: check_run_id: not specified")
		}
	}
	return params, nil
}

// ChecksGetSuiteParams is parameters of checks/get-suite operation.
type ChecksGetSuiteParams struct {
	Owner string
	Repo  string
	// Check_suite_id parameter.
	CheckSuiteID int
}

func unpackChecksGetSuiteParams(packed map[string]any) (params ChecksGetSuiteParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CheckSuiteID = packed["check_suite_id"].(int)
	return params
}

func decodeChecksGetSuiteParams(args [3]string, r *http.Request) (params ChecksGetSuiteParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: check_suite_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_suite_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CheckSuiteID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: check_suite_id: parse")
			}
		} else {
			return params, errors.New("path: check_suite_id: not specified")
		}
	}
	return params, nil
}

// ChecksListAnnotationsParams is parameters of checks/list-annotations operation.
type ChecksListAnnotationsParams struct {
	Owner string
	Repo  string
	// Check_run_id parameter.
	CheckRunID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackChecksListAnnotationsParams(packed map[string]any) (params ChecksListAnnotationsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CheckRunID = packed["check_run_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeChecksListAnnotationsParams(args [3]string, r *http.Request) (params ChecksListAnnotationsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: check_run_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_run_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CheckRunID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: check_run_id: parse")
			}
		} else {
			return params, errors.New("path: check_run_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ChecksListForRefParams is parameters of checks/list-for-ref operation.
type ChecksListForRefParams struct {
	Owner string
	Repo  string
	// Ref parameter.
	Ref string
	// Returns check runs with the specified `name`.
	CheckName OptString `json:",omitempty"`
	// Returns check runs with the specified `status`. Can be one of `queued`, `in_progress`, or
	// `completed`.
	Status OptChecksListForRefStatus `json:",omitempty"`
	// Filters check runs by their `completed_at` timestamp. Can be one of `latest` (returning the most
	// recent check runs) or `all`.
	Filter OptChecksListForRefFilter `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page  OptInt `json:",omitempty"`
	AppID OptInt `json:",omitempty"`
}

func unpackChecksListForRefParams(packed map[string]any) (params ChecksListForRefParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Ref = packed["ref"].(string)
	if v, ok := packed["check_name"]; ok {
		params.CheckName = v.(OptString)
	}
	if v, ok := packed["status"]; ok {
		params.Status = v.(OptChecksListForRefStatus)
	}
	if v, ok := packed["filter"]; ok {
		params.Filter = v.(OptChecksListForRefFilter)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["app_id"]; ok {
		params.AppID = v.(OptInt)
	}
	return params
}

func decodeChecksListForRefParams(args [3]string, r *http.Request) (params ChecksListForRefParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: ref: parse")
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	// Decode query: check_name.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "check_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCheckNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCheckNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.CheckName.SetTo(paramsDotCheckNameVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: check_name: parse")
			}
		}
	}
	// Decode query: status.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal ChecksListForRefStatus
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = ChecksListForRefStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: status: parse")
			}
			if err := func() error {
				if params.Status.Set {
					if err := func() error {
						if err := params.Status.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: status: invalid")
			}
		}
	}
	// Set default value for query: filter.
	{
		val := ChecksListForRefFilter("latest")
		params.Filter.SetTo(val)
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal ChecksListForRefFilter
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = ChecksListForRefFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: filter: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: app_id.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "app_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAppIDVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotAppIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AppID.SetTo(paramsDotAppIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: app_id: parse")
			}
		}
	}
	return params, nil
}

// ChecksListForSuiteParams is parameters of checks/list-for-suite operation.
type ChecksListForSuiteParams struct {
	Owner string
	Repo  string
	// Check_suite_id parameter.
	CheckSuiteID int
	// Returns check runs with the specified `name`.
	CheckName OptString `json:",omitempty"`
	// Returns check runs with the specified `status`. Can be one of `queued`, `in_progress`, or
	// `completed`.
	Status OptChecksListForSuiteStatus `json:",omitempty"`
	// Filters check runs by their `completed_at` timestamp. Can be one of `latest` (returning the most
	// recent check runs) or `all`.
	Filter OptChecksListForSuiteFilter `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackChecksListForSuiteParams(packed map[string]any) (params ChecksListForSuiteParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CheckSuiteID = packed["check_suite_id"].(int)
	if v, ok := packed["check_name"]; ok {
		params.CheckName = v.(OptString)
	}
	if v, ok := packed["status"]; ok {
		params.Status = v.(OptChecksListForSuiteStatus)
	}
	if v, ok := packed["filter"]; ok {
		params.Filter = v.(OptChecksListForSuiteFilter)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeChecksListForSuiteParams(args [3]string, r *http.Request) (params ChecksListForSuiteParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: check_suite_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_suite_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CheckSuiteID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: check_suite_id: parse")
			}
		} else {
			return params, errors.New("path: check_suite_id: not specified")
		}
	}
	// Decode query: check_name.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "check_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCheckNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCheckNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.CheckName.SetTo(paramsDotCheckNameVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: check_name: parse")
			}
		}
	}
	// Decode query: status.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal ChecksListForSuiteStatus
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = ChecksListForSuiteStatus(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: status: parse")
			}
			if err := func() error {
				if params.Status.Set {
					if err := func() error {
						if err := params.Status.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: status: invalid")
			}
		}
	}
	// Set default value for query: filter.
	{
		val := ChecksListForSuiteFilter("latest")
		params.Filter.SetTo(val)
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal ChecksListForSuiteFilter
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = ChecksListForSuiteFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: filter: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ChecksListSuitesForRefParams is parameters of checks/list-suites-for-ref operation.
type ChecksListSuitesForRefParams struct {
	Owner string
	Repo  string
	// Ref parameter.
	Ref string
	// Filters check suites by GitHub App `id`.
	AppID OptInt `json:",omitempty"`
	// Returns check runs with the specified `name`.
	CheckName OptString `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackChecksListSuitesForRefParams(packed map[string]any) (params ChecksListSuitesForRefParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Ref = packed["ref"].(string)
	if v, ok := packed["app_id"]; ok {
		params.AppID = v.(OptInt)
	}
	if v, ok := packed["check_name"]; ok {
		params.CheckName = v.(OptString)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeChecksListSuitesForRefParams(args [3]string, r *http.Request) (params ChecksListSuitesForRefParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: ref: parse")
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	// Decode query: app_id.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "app_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAppIDVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotAppIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AppID.SetTo(paramsDotAppIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: app_id: parse")
			}
		}
	}
	// Decode query: check_name.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "check_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCheckNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCheckNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.CheckName.SetTo(paramsDotCheckNameVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: check_name: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ChecksRerequestSuiteParams is parameters of checks/rerequest-suite operation.
type ChecksRerequestSuiteParams struct {
	Owner string
	Repo  string
	// Check_suite_id parameter.
	CheckSuiteID int
}

func unpackChecksRerequestSuiteParams(packed map[string]any) (params ChecksRerequestSuiteParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CheckSuiteID = packed["check_suite_id"].(int)
	return params
}

func decodeChecksRerequestSuiteParams(args [3]string, r *http.Request) (params ChecksRerequestSuiteParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: check_suite_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "check_suite_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CheckSuiteID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: check_suite_id: parse")
			}
		} else {
			return params, errors.New("path: check_suite_id: not specified")
		}
	}
	return params, nil
}

// ChecksSetSuitesPreferencesParams is parameters of checks/set-suites-preferences operation.
type ChecksSetSuitesPreferencesParams struct {
	Owner string
	Repo  string
}

func unpackChecksSetSuitesPreferencesParams(packed map[string]any) (params ChecksSetSuitesPreferencesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeChecksSetSuitesPreferencesParams(args [2]string, r *http.Request) (params ChecksSetSuitesPreferencesParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// CodeScanningDeleteAnalysisParams is parameters of code-scanning/delete-analysis operation.
type CodeScanningDeleteAnalysisParams struct {
	Owner string
	Repo  string
	// The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses`
	// operation.
	AnalysisID int
	// Allow deletion if the specified analysis is the last in a set. If you attempt to delete the final
	// analysis in a set without setting this parameter to `true`, you'll get a 400 response with the
	// message: `Analysis is last of its type and deletion may result in the loss of historical alert
	// data. Please specify confirm_delete.`.
	ConfirmDelete OptNilString `json:",omitempty"`
}

func unpackCodeScanningDeleteAnalysisParams(packed map[string]any) (params CodeScanningDeleteAnalysisParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.AnalysisID = packed["analysis_id"].(int)
	if v, ok := packed["confirm_delete"]; ok {
		params.ConfirmDelete = v.(OptNilString)
	}
	return params
}

func decodeCodeScanningDeleteAnalysisParams(args [3]string, r *http.Request) (params CodeScanningDeleteAnalysisParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: analysis_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "analysis_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AnalysisID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: analysis_id: parse")
			}
		} else {
			return params, errors.New("path: analysis_id: not specified")
		}
	}
	// Decode query: confirm_delete.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "confirm_delete",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotConfirmDeleteVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotConfirmDeleteVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ConfirmDelete.SetTo(paramsDotConfirmDeleteVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: confirm_delete: parse")
			}
		}
	}
	return params, nil
}

// CodeScanningGetAlertParams is parameters of code-scanning/get-alert operation.
type CodeScanningGetAlertParams struct {
	Owner string
	Repo  string
	// The number that identifies an alert. You can find this at the end of the URL for a code scanning
	// alert within GitHub, and in the `number` field in the response from the `GET
	// /repos/{owner}/{repo}/code-scanning/alerts` operation.
	AlertNumber AlertNumber
}

func unpackCodeScanningGetAlertParams(packed map[string]any) (params CodeScanningGetAlertParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.AlertNumber = packed["alert_number"].(AlertNumber)
	return params
}

func decodeCodeScanningGetAlertParams(args [3]string, r *http.Request) (params CodeScanningGetAlertParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: alert_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsDotAlertNumberVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsDotAlertNumberVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: alert_number: parse")
			}
		} else {
			return params, errors.New("path: alert_number: not specified")
		}
	}
	return params, nil
}

// CodeScanningGetAnalysisParams is parameters of code-scanning/get-analysis operation.
type CodeScanningGetAnalysisParams struct {
	Owner string
	Repo  string
	// The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses`
	// operation.
	AnalysisID int
}

func unpackCodeScanningGetAnalysisParams(packed map[string]any) (params CodeScanningGetAnalysisParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.AnalysisID = packed["analysis_id"].(int)
	return params
}

func decodeCodeScanningGetAnalysisParams(args [3]string, r *http.Request) (params CodeScanningGetAnalysisParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: analysis_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "analysis_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AnalysisID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: analysis_id: parse")
			}
		} else {
			return params, errors.New("path: analysis_id: not specified")
		}
	}
	return params, nil
}

// CodeScanningGetSarifParams is parameters of code-scanning/get-sarif operation.
type CodeScanningGetSarifParams struct {
	Owner string
	Repo  string
	// The SARIF ID obtained after uploading.
	SarifID string
}

func unpackCodeScanningGetSarifParams(packed map[string]any) (params CodeScanningGetSarifParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.SarifID = packed["sarif_id"].(string)
	return params
}

func decodeCodeScanningGetSarifParams(args [3]string, r *http.Request) (params CodeScanningGetSarifParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: sarif_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "sarif_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SarifID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: sarif_id: parse")
			}
		} else {
			return params, errors.New("path: sarif_id: not specified")
		}
	}
	return params, nil
}

// CodeScanningListAlertInstancesParams is parameters of code-scanning/list-alert-instances operation.
type CodeScanningListAlertInstancesParams struct {
	Owner string
	Repo  string
	// The number that identifies an alert. You can find this at the end of the URL for a code scanning
	// alert within GitHub, and in the `number` field in the response from the `GET
	// /repos/{owner}/{repo}/code-scanning/alerts` operation.
	AlertNumber AlertNumber
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// The Git reference for the results you want to list. The `ref` for a branch can be formatted either
	// as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use
	// `refs/pull/<number>/merge`.
	Ref OptCodeScanningRef `json:",omitempty"`
}

func unpackCodeScanningListAlertInstancesParams(packed map[string]any) (params CodeScanningListAlertInstancesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.AlertNumber = packed["alert_number"].(AlertNumber)
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["ref"]; ok {
		params.Ref = v.(OptCodeScanningRef)
	}
	return params
}

func decodeCodeScanningListAlertInstancesParams(args [3]string, r *http.Request) (params CodeScanningListAlertInstancesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: alert_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsDotAlertNumberVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsDotAlertNumberVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: alert_number: parse")
			}
		} else {
			return params, errors.New("path: alert_number: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode query: ref.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRefVal CodeScanningRef
				if err := func() error {
					var paramsDotRefValVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotRefValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsDotRefVal = CodeScanningRef(paramsDotRefValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsDotRefVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: ref: parse")
			}
		}
	}
	return params, nil
}

// CodeScanningListAlertsForRepoParams is parameters of code-scanning/list-alerts-for-repo operation.
type CodeScanningListAlertsForRepoParams struct {
	Owner string
	Repo  string
	// The name of a code scanning tool. Only results by this tool will be listed. You can specify the
	// tool by using either `tool_name` or `tool_guid`, but not both.
	ToolName OptCodeScanningAnalysisToolName `json:",omitempty"`
	// The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code
	// scanning tools may not include a GUID in their analysis data. You can specify the tool by using
	// either `tool_guid` or `tool_name`, but not both.
	ToolGUID OptNilCodeScanningAnalysisToolGUID `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// The Git reference for the results you want to list. The `ref` for a branch can be formatted either
	// as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use
	// `refs/pull/<number>/merge`.
	Ref OptCodeScanningRef `json:",omitempty"`
	// Set to `open`, `fixed`, or `dismissed` to list code scanning alerts in a specific state.
	State OptCodeScanningAlertState `json:",omitempty"`
}

func unpackCodeScanningListAlertsForRepoParams(packed map[string]any) (params CodeScanningListAlertsForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["tool_name"]; ok {
		params.ToolName = v.(OptCodeScanningAnalysisToolName)
	}
	if v, ok := packed["tool_guid"]; ok {
		params.ToolGUID = v.(OptNilCodeScanningAnalysisToolGUID)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["ref"]; ok {
		params.Ref = v.(OptCodeScanningRef)
	}
	if v, ok := packed["state"]; ok {
		params.State = v.(OptCodeScanningAlertState)
	}
	return params
}

func decodeCodeScanningListAlertsForRepoParams(args [2]string, r *http.Request) (params CodeScanningListAlertsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: tool_name.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tool_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotToolNameVal CodeScanningAnalysisToolName
				if err := func() error {
					var paramsDotToolNameValVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotToolNameValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsDotToolNameVal = CodeScanningAnalysisToolName(paramsDotToolNameValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.ToolName.SetTo(paramsDotToolNameVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: tool_name: parse")
			}
		}
	}
	// Decode query: tool_guid.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tool_guid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotToolGUIDVal CodeScanningAnalysisToolGUID
				if err := func() error {
					var paramsDotToolGUIDValVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotToolGUIDValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsDotToolGUIDVal = CodeScanningAnalysisToolGUID(paramsDotToolGUIDValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.ToolGUID.SetTo(paramsDotToolGUIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: tool_guid: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode query: ref.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRefVal CodeScanningRef
				if err := func() error {
					var paramsDotRefValVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotRefValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsDotRefVal = CodeScanningRef(paramsDotRefValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsDotRefVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: ref: parse")
			}
		}
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal CodeScanningAlertState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = CodeScanningAlertState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	return params, nil
}

// CodeScanningListRecentAnalysesParams is parameters of code-scanning/list-recent-analyses operation.
type CodeScanningListRecentAnalysesParams struct {
	Owner string
	Repo  string
	// The name of a code scanning tool. Only results by this tool will be listed. You can specify the
	// tool by using either `tool_name` or `tool_guid`, but not both.
	ToolName OptCodeScanningAnalysisToolName `json:",omitempty"`
	// The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code
	// scanning tools may not include a GUID in their analysis data. You can specify the tool by using
	// either `tool_guid` or `tool_name`, but not both.
	ToolGUID OptNilCodeScanningAnalysisToolGUID `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// The Git reference for the analyses you want to list. The `ref` for a branch can be formatted
	// either as `refs/heads/<branch name>` or simply `<branch name>`. To reference a pull request use
	// `refs/pull/<number>/merge`.
	Ref OptCodeScanningRef `json:",omitempty"`
	// Filter analyses belonging to the same SARIF upload.
	SarifID OptCodeScanningAnalysisSarifID `json:",omitempty"`
}

func unpackCodeScanningListRecentAnalysesParams(packed map[string]any) (params CodeScanningListRecentAnalysesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["tool_name"]; ok {
		params.ToolName = v.(OptCodeScanningAnalysisToolName)
	}
	if v, ok := packed["tool_guid"]; ok {
		params.ToolGUID = v.(OptNilCodeScanningAnalysisToolGUID)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["ref"]; ok {
		params.Ref = v.(OptCodeScanningRef)
	}
	if v, ok := packed["sarif_id"]; ok {
		params.SarifID = v.(OptCodeScanningAnalysisSarifID)
	}
	return params
}

func decodeCodeScanningListRecentAnalysesParams(args [2]string, r *http.Request) (params CodeScanningListRecentAnalysesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: tool_name.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tool_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotToolNameVal CodeScanningAnalysisToolName
				if err := func() error {
					var paramsDotToolNameValVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotToolNameValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsDotToolNameVal = CodeScanningAnalysisToolName(paramsDotToolNameValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.ToolName.SetTo(paramsDotToolNameVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: tool_name: parse")
			}
		}
	}
	// Decode query: tool_guid.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tool_guid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotToolGUIDVal CodeScanningAnalysisToolGUID
				if err := func() error {
					var paramsDotToolGUIDValVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotToolGUIDValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsDotToolGUIDVal = CodeScanningAnalysisToolGUID(paramsDotToolGUIDValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.ToolGUID.SetTo(paramsDotToolGUIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: tool_guid: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode query: ref.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRefVal CodeScanningRef
				if err := func() error {
					var paramsDotRefValVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotRefValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsDotRefVal = CodeScanningRef(paramsDotRefValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsDotRefVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: ref: parse")
			}
		}
	}
	// Decode query: sarif_id.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sarif_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSarifIDVal CodeScanningAnalysisSarifID
				if err := func() error {
					var paramsDotSarifIDValVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotSarifIDValVal = c
						return nil
					}(); err != nil {
						return err
					}
					paramsDotSarifIDVal = CodeScanningAnalysisSarifID(paramsDotSarifIDValVal)
					return nil
				}(); err != nil {
					return err
				}
				params.SarifID.SetTo(paramsDotSarifIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sarif_id: parse")
			}
		}
	}
	return params, nil
}

// CodeScanningUpdateAlertParams is parameters of code-scanning/update-alert operation.
type CodeScanningUpdateAlertParams struct {
	Owner string
	Repo  string
	// The number that identifies an alert. You can find this at the end of the URL for a code scanning
	// alert within GitHub, and in the `number` field in the response from the `GET
	// /repos/{owner}/{repo}/code-scanning/alerts` operation.
	AlertNumber AlertNumber
}

func unpackCodeScanningUpdateAlertParams(packed map[string]any) (params CodeScanningUpdateAlertParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.AlertNumber = packed["alert_number"].(AlertNumber)
	return params
}

func decodeCodeScanningUpdateAlertParams(args [3]string, r *http.Request) (params CodeScanningUpdateAlertParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: alert_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsDotAlertNumberVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsDotAlertNumberVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: alert_number: parse")
			}
		} else {
			return params, errors.New("path: alert_number: not specified")
		}
	}
	return params, nil
}

// CodeScanningUploadSarifParams is parameters of code-scanning/upload-sarif operation.
type CodeScanningUploadSarifParams struct {
	Owner string
	Repo  string
}

func unpackCodeScanningUploadSarifParams(packed map[string]any) (params CodeScanningUploadSarifParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeCodeScanningUploadSarifParams(args [2]string, r *http.Request) (params CodeScanningUploadSarifParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// CodesOfConductGetConductCodeParams is parameters of codes-of-conduct/get-conduct-code operation.
type CodesOfConductGetConductCodeParams struct {
	Key string
}

func unpackCodesOfConductGetConductCodeParams(packed map[string]any) (params CodesOfConductGetConductCodeParams) {
	params.Key = packed["key"].(string)
	return params
}

func decodeCodesOfConductGetConductCodeParams(args [1]string, r *http.Request) (params CodesOfConductGetConductCodeParams, _ error) {
	// Decode path: key.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Key = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: key: parse")
			}
		} else {
			return params, errors.New("path: key: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams is parameters of enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise operation.
type EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
	// Unique identifier of an organization.
	OrgID int
}

func unpackEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(packed map[string]any) (params EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	params.OrgID = packed["org_id"].(int)
	return params
}

func decodeEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args [3]string, r *http.Request) (params EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Decode path: org_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.OrgID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org_id: parse")
			}
		} else {
			return params, errors.New("path: org_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams is parameters of enterprise-admin/add-self-hosted-runner-to-group-for-enterprise operation.
type EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
	// Unique identifier of the self-hosted runner.
	RunnerID int
}

func unpackEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams(packed map[string]any) (params EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	params.RunnerID = packed["runner_id"].(int)
	return params
}

func decodeEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams(args [3]string, r *http.Request) (params EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_id: parse")
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminCreateRegistrationTokenForEnterpriseParams is parameters of enterprise-admin/create-registration-token-for-enterprise operation.
type EnterpriseAdminCreateRegistrationTokenForEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
}

func unpackEnterpriseAdminCreateRegistrationTokenForEnterpriseParams(packed map[string]any) (params EnterpriseAdminCreateRegistrationTokenForEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	return params
}

func decodeEnterpriseAdminCreateRegistrationTokenForEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminCreateRegistrationTokenForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminCreateRemoveTokenForEnterpriseParams is parameters of enterprise-admin/create-remove-token-for-enterprise operation.
type EnterpriseAdminCreateRemoveTokenForEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
}

func unpackEnterpriseAdminCreateRemoveTokenForEnterpriseParams(packed map[string]any) (params EnterpriseAdminCreateRemoveTokenForEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	return params
}

func decodeEnterpriseAdminCreateRemoveTokenForEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminCreateRemoveTokenForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams is parameters of enterprise-admin/create-self-hosted-runner-group-for-enterprise operation.
type EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
}

func unpackEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams(packed map[string]any) (params EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	return params
}

func decodeEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminDeleteScimGroupFromEnterpriseParams is parameters of enterprise-admin/delete-scim-group-from-enterprise operation.
type EnterpriseAdminDeleteScimGroupFromEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Identifier generated by the GitHub SCIM endpoint.
	ScimGroupID string
}

func unpackEnterpriseAdminDeleteScimGroupFromEnterpriseParams(packed map[string]any) (params EnterpriseAdminDeleteScimGroupFromEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.ScimGroupID = packed["scim_group_id"].(string)
	return params
}

func decodeEnterpriseAdminDeleteScimGroupFromEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminDeleteScimGroupFromEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: scim_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: scim_group_id: parse")
			}
		} else {
			return params, errors.New("path: scim_group_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams is parameters of enterprise-admin/delete-self-hosted-runner-from-enterprise operation.
type EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Unique identifier of the self-hosted runner.
	RunnerID int
}

func unpackEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams(packed map[string]any) (params EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.RunnerID = packed["runner_id"].(int)
	return params
}

func decodeEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_id: parse")
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams is parameters of enterprise-admin/delete-self-hosted-runner-group-from-enterprise operation.
type EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
}

func unpackEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams(packed map[string]any) (params EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	return params
}

func decodeEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminDeleteUserFromEnterpriseParams is parameters of enterprise-admin/delete-user-from-enterprise operation.
type EnterpriseAdminDeleteUserFromEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Scim_user_id parameter.
	ScimUserID string
}

func unpackEnterpriseAdminDeleteUserFromEnterpriseParams(packed map[string]any) (params EnterpriseAdminDeleteUserFromEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.ScimUserID = packed["scim_user_id"].(string)
	return params
}

func decodeEnterpriseAdminDeleteUserFromEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminDeleteUserFromEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: scim_user_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: scim_user_id: parse")
			}
		} else {
			return params, errors.New("path: scim_user_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams is parameters of enterprise-admin/disable-selected-organization-github-actions-enterprise operation.
type EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Unique identifier of an organization.
	OrgID int
}

func unpackEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams(packed map[string]any) (params EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.OrgID = packed["org_id"].(int)
	return params
}

func decodeEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: org_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.OrgID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org_id: parse")
			}
		} else {
			return params, errors.New("path: org_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams is parameters of enterprise-admin/enable-selected-organization-github-actions-enterprise operation.
type EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Unique identifier of an organization.
	OrgID int
}

func unpackEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams(packed map[string]any) (params EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.OrgID = packed["org_id"].(int)
	return params
}

func decodeEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: org_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.OrgID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org_id: parse")
			}
		} else {
			return params, errors.New("path: org_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminGetAllowedActionsEnterpriseParams is parameters of enterprise-admin/get-allowed-actions-enterprise operation.
type EnterpriseAdminGetAllowedActionsEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
}

func unpackEnterpriseAdminGetAllowedActionsEnterpriseParams(packed map[string]any) (params EnterpriseAdminGetAllowedActionsEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	return params
}

func decodeEnterpriseAdminGetAllowedActionsEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminGetAllowedActionsEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminGetAuditLogParams is parameters of enterprise-admin/get-audit-log operation.
type EnterpriseAdminGetAuditLogParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// A search phrase. For more information, see [Searching the audit log](https://docs.github.
	// com/github/setting-up-and-managing-organizations-and-teams/reviewing-the-audit-log-for-your-organization#searching-the-audit-log).
	Phrase OptString `json:",omitempty"`
	// The event types to include:
	// - `web` - returns web (non-Git) events
	// - `git` - returns Git events
	// - `all` - returns both web and Git events
	// The default is `web`.
	Include OptEnterpriseAdminGetAuditLogInclude `json:",omitempty"`
	// A cursor, as given in the [Link header](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#link-header). If specified, the query only searches
	// for events after this cursor.
	After OptString `json:",omitempty"`
	// A cursor, as given in the [Link header](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#link-header). If specified, the query only searches
	// for events before this cursor.
	Before OptString `json:",omitempty"`
	// The order of audit log events. To list newest events first, specify `desc`. To list oldest events
	// first, specify `asc`.
	// The default is `desc`.
	Order OptEnterpriseAdminGetAuditLogOrder `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
}

func unpackEnterpriseAdminGetAuditLogParams(packed map[string]any) (params EnterpriseAdminGetAuditLogParams) {
	params.Enterprise = packed["enterprise"].(string)
	if v, ok := packed["phrase"]; ok {
		params.Phrase = v.(OptString)
	}
	if v, ok := packed["include"]; ok {
		params.Include = v.(OptEnterpriseAdminGetAuditLogInclude)
	}
	if v, ok := packed["after"]; ok {
		params.After = v.(OptString)
	}
	if v, ok := packed["before"]; ok {
		params.Before = v.(OptString)
	}
	if v, ok := packed["order"]; ok {
		params.Order = v.(OptEnterpriseAdminGetAuditLogOrder)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	return params
}

func decodeEnterpriseAdminGetAuditLogParams(args [1]string, r *http.Request) (params EnterpriseAdminGetAuditLogParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode query: phrase.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "phrase",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPhraseVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPhraseVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Phrase.SetTo(paramsDotPhraseVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: phrase: parse")
			}
		}
	}
	// Decode query: include.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIncludeVal EnterpriseAdminGetAuditLogInclude
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotIncludeVal = EnterpriseAdminGetAuditLogInclude(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Include.SetTo(paramsDotIncludeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: include: parse")
			}
			if err := func() error {
				if params.Include.Set {
					if err := func() error {
						if err := params.Include.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: include: invalid")
			}
		}
	}
	// Decode query: after.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAfterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.After.SetTo(paramsDotAfterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: after: parse")
			}
		}
	}
	// Decode query: before.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsDotBeforeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before: parse")
			}
		}
	}
	// Decode query: order.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal EnterpriseAdminGetAuditLogOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = EnterpriseAdminGetAuditLogOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: order: parse")
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: order: invalid")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	return params, nil
}

// EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams is parameters of enterprise-admin/get-github-actions-permissions-enterprise operation.
type EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
}

func unpackEnterpriseAdminGetGithubActionsPermissionsEnterpriseParams(packed map[string]any) (params EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	return params
}

func decodeEnterpriseAdminGetGithubActionsPermissionsEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminGetGithubActionsPermissionsEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams is parameters of enterprise-admin/get-provisioning-information-for-enterprise-group operation.
type EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Identifier generated by the GitHub SCIM endpoint.
	ScimGroupID string
	// Attributes to exclude.
	ExcludedAttributes OptString `json:",omitempty"`
}

func unpackEnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams(packed map[string]any) (params EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.ScimGroupID = packed["scim_group_id"].(string)
	if v, ok := packed["excludedAttributes"]; ok {
		params.ExcludedAttributes = v.(OptString)
	}
	return params
}

func decodeEnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams(args [2]string, r *http.Request) (params EnterpriseAdminGetProvisioningInformationForEnterpriseGroupParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: scim_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: scim_group_id: parse")
			}
		} else {
			return params, errors.New("path: scim_group_id: not specified")
		}
	}
	// Decode query: excludedAttributes.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "excludedAttributes",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotExcludedAttributesVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotExcludedAttributesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ExcludedAttributes.SetTo(paramsDotExcludedAttributesVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: excludedAttributes: parse")
			}
		}
	}
	return params, nil
}

// EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams is parameters of enterprise-admin/get-provisioning-information-for-enterprise-user operation.
type EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Scim_user_id parameter.
	ScimUserID string
}

func unpackEnterpriseAdminGetProvisioningInformationForEnterpriseUserParams(packed map[string]any) (params EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.ScimUserID = packed["scim_user_id"].(string)
	return params
}

func decodeEnterpriseAdminGetProvisioningInformationForEnterpriseUserParams(args [2]string, r *http.Request) (params EnterpriseAdminGetProvisioningInformationForEnterpriseUserParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: scim_user_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: scim_user_id: parse")
			}
		} else {
			return params, errors.New("path: scim_user_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams is parameters of enterprise-admin/get-self-hosted-runner-for-enterprise operation.
type EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Unique identifier of the self-hosted runner.
	RunnerID int
}

func unpackEnterpriseAdminGetSelfHostedRunnerForEnterpriseParams(packed map[string]any) (params EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.RunnerID = packed["runner_id"].(int)
	return params
}

func decodeEnterpriseAdminGetSelfHostedRunnerForEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminGetSelfHostedRunnerForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_id: parse")
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams is parameters of enterprise-admin/get-self-hosted-runner-group-for-enterprise operation.
type EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
}

func unpackEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams(packed map[string]any) (params EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	return params
}

func decodeEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams is parameters of enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise operation.
type EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(packed map[string]any) (params EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// EnterpriseAdminListProvisionedGroupsEnterpriseParams is parameters of enterprise-admin/list-provisioned-groups-enterprise operation.
type EnterpriseAdminListProvisionedGroupsEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Used for pagination: the index of the first result to return.
	StartIndex OptInt `json:",omitempty"`
	// Used for pagination: the number of results to return.
	Count OptInt `json:",omitempty"`
	// Filter results.
	Filter OptString `json:",omitempty"`
	// Attributes to exclude.
	ExcludedAttributes OptString `json:",omitempty"`
}

func unpackEnterpriseAdminListProvisionedGroupsEnterpriseParams(packed map[string]any) (params EnterpriseAdminListProvisionedGroupsEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	if v, ok := packed["startIndex"]; ok {
		params.StartIndex = v.(OptInt)
	}
	if v, ok := packed["count"]; ok {
		params.Count = v.(OptInt)
	}
	if v, ok := packed["filter"]; ok {
		params.Filter = v.(OptString)
	}
	if v, ok := packed["excludedAttributes"]; ok {
		params.ExcludedAttributes = v.(OptString)
	}
	return params
}

func decodeEnterpriseAdminListProvisionedGroupsEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminListProvisionedGroupsEnterpriseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode query: startIndex.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startIndex",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartIndexVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotStartIndexVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartIndex.SetTo(paramsDotStartIndexVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: startIndex: parse")
			}
		}
	}
	// Decode query: count.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCountVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotCountVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Count.SetTo(paramsDotCountVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: count: parse")
			}
		}
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
		}
	}
	// Decode query: excludedAttributes.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "excludedAttributes",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotExcludedAttributesVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotExcludedAttributesVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ExcludedAttributes.SetTo(paramsDotExcludedAttributesVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: excludedAttributes: parse")
			}
		}
	}
	return params, nil
}

// EnterpriseAdminListProvisionedIdentitiesEnterpriseParams is parameters of enterprise-admin/list-provisioned-identities-enterprise operation.
type EnterpriseAdminListProvisionedIdentitiesEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Used for pagination: the index of the first result to return.
	StartIndex OptInt `json:",omitempty"`
	// Used for pagination: the number of results to return.
	Count OptInt `json:",omitempty"`
	// Filter results.
	Filter OptString `json:",omitempty"`
}

func unpackEnterpriseAdminListProvisionedIdentitiesEnterpriseParams(packed map[string]any) (params EnterpriseAdminListProvisionedIdentitiesEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	if v, ok := packed["startIndex"]; ok {
		params.StartIndex = v.(OptInt)
	}
	if v, ok := packed["count"]; ok {
		params.Count = v.(OptInt)
	}
	if v, ok := packed["filter"]; ok {
		params.Filter = v.(OptString)
	}
	return params
}

func decodeEnterpriseAdminListProvisionedIdentitiesEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminListProvisionedIdentitiesEnterpriseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode query: startIndex.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startIndex",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartIndexVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotStartIndexVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartIndex.SetTo(paramsDotStartIndexVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: startIndex: parse")
			}
		}
	}
	// Decode query: count.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCountVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotCountVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Count.SetTo(paramsDotCountVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: count: parse")
			}
		}
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
		}
	}
	return params, nil
}

// EnterpriseAdminListRunnerApplicationsForEnterpriseParams is parameters of enterprise-admin/list-runner-applications-for-enterprise operation.
type EnterpriseAdminListRunnerApplicationsForEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
}

func unpackEnterpriseAdminListRunnerApplicationsForEnterpriseParams(packed map[string]any) (params EnterpriseAdminListRunnerApplicationsForEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	return params
}

func decodeEnterpriseAdminListRunnerApplicationsForEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminListRunnerApplicationsForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams is parameters of enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise operation.
type EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams(packed map[string]any) (params EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams is parameters of enterprise-admin/list-self-hosted-runner-groups-for-enterprise operation.
type EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams(packed map[string]any) (params EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// EnterpriseAdminListSelfHostedRunnersForEnterpriseParams is parameters of enterprise-admin/list-self-hosted-runners-for-enterprise operation.
type EnterpriseAdminListSelfHostedRunnersForEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackEnterpriseAdminListSelfHostedRunnersForEnterpriseParams(packed map[string]any) (params EnterpriseAdminListSelfHostedRunnersForEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeEnterpriseAdminListSelfHostedRunnersForEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminListSelfHostedRunnersForEnterpriseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams is parameters of enterprise-admin/list-self-hosted-runners-in-group-for-enterprise operation.
type EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams(packed map[string]any) (params EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// EnterpriseAdminProvisionAndInviteEnterpriseGroupParams is parameters of enterprise-admin/provision-and-invite-enterprise-group operation.
type EnterpriseAdminProvisionAndInviteEnterpriseGroupParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
}

func unpackEnterpriseAdminProvisionAndInviteEnterpriseGroupParams(packed map[string]any) (params EnterpriseAdminProvisionAndInviteEnterpriseGroupParams) {
	params.Enterprise = packed["enterprise"].(string)
	return params
}

func decodeEnterpriseAdminProvisionAndInviteEnterpriseGroupParams(args [1]string, r *http.Request) (params EnterpriseAdminProvisionAndInviteEnterpriseGroupParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminProvisionAndInviteEnterpriseUserParams is parameters of enterprise-admin/provision-and-invite-enterprise-user operation.
type EnterpriseAdminProvisionAndInviteEnterpriseUserParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
}

func unpackEnterpriseAdminProvisionAndInviteEnterpriseUserParams(packed map[string]any) (params EnterpriseAdminProvisionAndInviteEnterpriseUserParams) {
	params.Enterprise = packed["enterprise"].(string)
	return params
}

func decodeEnterpriseAdminProvisionAndInviteEnterpriseUserParams(args [1]string, r *http.Request) (params EnterpriseAdminProvisionAndInviteEnterpriseUserParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams is parameters of enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise operation.
type EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
	// Unique identifier of an organization.
	OrgID int
}

func unpackEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(packed map[string]any) (params EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	params.OrgID = packed["org_id"].(int)
	return params
}

func decodeEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args [3]string, r *http.Request) (params EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Decode path: org_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.OrgID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org_id: parse")
			}
		} else {
			return params, errors.New("path: org_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams is parameters of enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise operation.
type EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
	// Unique identifier of the self-hosted runner.
	RunnerID int
}

func unpackEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams(packed map[string]any) (params EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	params.RunnerID = packed["runner_id"].(int)
	return params
}

func decodeEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams(args [3]string, r *http.Request) (params EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	// Decode path: runner_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_id: parse")
			}
		} else {
			return params, errors.New("path: runner_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminSetAllowedActionsEnterpriseParams is parameters of enterprise-admin/set-allowed-actions-enterprise operation.
type EnterpriseAdminSetAllowedActionsEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
}

func unpackEnterpriseAdminSetAllowedActionsEnterpriseParams(packed map[string]any) (params EnterpriseAdminSetAllowedActionsEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	return params
}

func decodeEnterpriseAdminSetAllowedActionsEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminSetAllowedActionsEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams is parameters of enterprise-admin/set-github-actions-permissions-enterprise operation.
type EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
}

func unpackEnterpriseAdminSetGithubActionsPermissionsEnterpriseParams(packed map[string]any) (params EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	return params
}

func decodeEnterpriseAdminSetGithubActionsPermissionsEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminSetGithubActionsPermissionsEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams is parameters of enterprise-admin/set-information-for-provisioned-enterprise-group operation.
type EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Identifier generated by the GitHub SCIM endpoint.
	ScimGroupID string
}

func unpackEnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams(packed map[string]any) (params EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.ScimGroupID = packed["scim_group_id"].(string)
	return params
}

func decodeEnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams(args [2]string, r *http.Request) (params EnterpriseAdminSetInformationForProvisionedEnterpriseGroupParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: scim_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: scim_group_id: parse")
			}
		} else {
			return params, errors.New("path: scim_group_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams is parameters of enterprise-admin/set-information-for-provisioned-enterprise-user operation.
type EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Scim_user_id parameter.
	ScimUserID string
}

func unpackEnterpriseAdminSetInformationForProvisionedEnterpriseUserParams(packed map[string]any) (params EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.ScimUserID = packed["scim_user_id"].(string)
	return params
}

func decodeEnterpriseAdminSetInformationForProvisionedEnterpriseUserParams(args [2]string, r *http.Request) (params EnterpriseAdminSetInformationForProvisionedEnterpriseUserParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: scim_user_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: scim_user_id: parse")
			}
		} else {
			return params, errors.New("path: scim_user_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams is parameters of enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise operation.
type EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
}

func unpackEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(packed map[string]any) (params EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	return params
}

func decodeEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams is parameters of enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise operation.
type EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
}

func unpackEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams(packed map[string]any) (params EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	return params
}

func decodeEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams(args [1]string, r *http.Request) (params EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams is parameters of enterprise-admin/set-self-hosted-runners-in-group-for-enterprise operation.
type EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
}

func unpackEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams(packed map[string]any) (params EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	return params
}

func decodeEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminUpdateAttributeForEnterpriseGroupParams is parameters of enterprise-admin/update-attribute-for-enterprise-group operation.
type EnterpriseAdminUpdateAttributeForEnterpriseGroupParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Identifier generated by the GitHub SCIM endpoint.
	ScimGroupID string
}

func unpackEnterpriseAdminUpdateAttributeForEnterpriseGroupParams(packed map[string]any) (params EnterpriseAdminUpdateAttributeForEnterpriseGroupParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.ScimGroupID = packed["scim_group_id"].(string)
	return params
}

func decodeEnterpriseAdminUpdateAttributeForEnterpriseGroupParams(args [2]string, r *http.Request) (params EnterpriseAdminUpdateAttributeForEnterpriseGroupParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: scim_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: scim_group_id: parse")
			}
		} else {
			return params, errors.New("path: scim_group_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminUpdateAttributeForEnterpriseUserParams is parameters of enterprise-admin/update-attribute-for-enterprise-user operation.
type EnterpriseAdminUpdateAttributeForEnterpriseUserParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Scim_user_id parameter.
	ScimUserID string
}

func unpackEnterpriseAdminUpdateAttributeForEnterpriseUserParams(packed map[string]any) (params EnterpriseAdminUpdateAttributeForEnterpriseUserParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.ScimUserID = packed["scim_user_id"].(string)
	return params
}

func decodeEnterpriseAdminUpdateAttributeForEnterpriseUserParams(args [2]string, r *http.Request) (params EnterpriseAdminUpdateAttributeForEnterpriseUserParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: scim_user_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: scim_user_id: parse")
			}
		} else {
			return params, errors.New("path: scim_user_id: not specified")
		}
	}
	return params, nil
}

// EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams is parameters of enterprise-admin/update-self-hosted-runner-group-for-enterprise operation.
type EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams struct {
	// The slug version of the enterprise name. You can also substitute this value with the enterprise id.
	Enterprise string
	// Unique identifier of the self-hosted runner group.
	RunnerGroupID int
}

func unpackEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams(packed map[string]any) (params EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams) {
	params.Enterprise = packed["enterprise"].(string)
	params.RunnerGroupID = packed["runner_group_id"].(int)
	return params
}

func decodeEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams(args [2]string, r *http.Request) (params EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseParams, _ error) {
	// Decode path: enterprise.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "enterprise",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Enterprise = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: enterprise: parse")
			}
		} else {
			return params, errors.New("path: enterprise: not specified")
		}
	}
	// Decode path: runner_group_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "runner_group_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RunnerGroupID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: runner_group_id: parse")
			}
		} else {
			return params, errors.New("path: runner_group_id: not specified")
		}
	}
	return params, nil
}

// GistsCheckIsStarredParams is parameters of gists/check-is-starred operation.
type GistsCheckIsStarredParams struct {
	// Gist_id parameter.
	GistID string
}

func unpackGistsCheckIsStarredParams(packed map[string]any) (params GistsCheckIsStarredParams) {
	params.GistID = packed["gist_id"].(string)
	return params
}

func decodeGistsCheckIsStarredParams(args [1]string, r *http.Request) (params GistsCheckIsStarredParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: gist_id: parse")
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	return params, nil
}

// GistsCreateCommentParams is parameters of gists/create-comment operation.
type GistsCreateCommentParams struct {
	// Gist_id parameter.
	GistID string
}

func unpackGistsCreateCommentParams(packed map[string]any) (params GistsCreateCommentParams) {
	params.GistID = packed["gist_id"].(string)
	return params
}

func decodeGistsCreateCommentParams(args [1]string, r *http.Request) (params GistsCreateCommentParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: gist_id: parse")
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	return params, nil
}

// GistsDeleteParams is parameters of gists/delete operation.
type GistsDeleteParams struct {
	// Gist_id parameter.
	GistID string
}

func unpackGistsDeleteParams(packed map[string]any) (params GistsDeleteParams) {
	params.GistID = packed["gist_id"].(string)
	return params
}

func decodeGistsDeleteParams(args [1]string, r *http.Request) (params GistsDeleteParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: gist_id: parse")
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	return params, nil
}

// GistsDeleteCommentParams is parameters of gists/delete-comment operation.
type GistsDeleteCommentParams struct {
	// Gist_id parameter.
	GistID string
	// Comment_id parameter.
	CommentID int
}

func unpackGistsDeleteCommentParams(packed map[string]any) (params GistsDeleteCommentParams) {
	params.GistID = packed["gist_id"].(string)
	params.CommentID = packed["comment_id"].(int)
	return params
}

func decodeGistsDeleteCommentParams(args [2]string, r *http.Request) (params GistsDeleteCommentParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: gist_id: parse")
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

// GistsForkParams is parameters of gists/fork operation.
type GistsForkParams struct {
	// Gist_id parameter.
	GistID string
}

func unpackGistsForkParams(packed map[string]any) (params GistsForkParams) {
	params.GistID = packed["gist_id"].(string)
	return params
}

func decodeGistsForkParams(args [1]string, r *http.Request) (params GistsForkParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: gist_id: parse")
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	return params, nil
}

// GistsGetParams is parameters of gists/get operation.
type GistsGetParams struct {
	// Gist_id parameter.
	GistID string
}

func unpackGistsGetParams(packed map[string]any) (params GistsGetParams) {
	params.GistID = packed["gist_id"].(string)
	return params
}

func decodeGistsGetParams(args [1]string, r *http.Request) (params GistsGetParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: gist_id: parse")
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	return params, nil
}

// GistsGetCommentParams is parameters of gists/get-comment operation.
type GistsGetCommentParams struct {
	// Gist_id parameter.
	GistID string
	// Comment_id parameter.
	CommentID int
}

func unpackGistsGetCommentParams(packed map[string]any) (params GistsGetCommentParams) {
	params.GistID = packed["gist_id"].(string)
	params.CommentID = packed["comment_id"].(int)
	return params
}

func decodeGistsGetCommentParams(args [2]string, r *http.Request) (params GistsGetCommentParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: gist_id: parse")
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

// GistsGetRevisionParams is parameters of gists/get-revision operation.
type GistsGetRevisionParams struct {
	// Gist_id parameter.
	GistID string
	Sha    string
}

func unpackGistsGetRevisionParams(packed map[string]any) (params GistsGetRevisionParams) {
	params.GistID = packed["gist_id"].(string)
	params.Sha = packed["sha"].(string)
	return params
}

func decodeGistsGetRevisionParams(args [2]string, r *http.Request) (params GistsGetRevisionParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: gist_id: parse")
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	// Decode path: sha.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Sha = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: sha: parse")
			}
		} else {
			return params, errors.New("path: sha: not specified")
		}
	}
	return params, nil
}

// GistsListParams is parameters of gists/list operation.
type GistsListParams struct {
	// Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Since OptDateTime `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackGistsListParams(packed map[string]any) (params GistsListParams) {
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptDateTime)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeGistsListParams(args [0]string, r *http.Request) (params GistsListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// GistsListCommentsParams is parameters of gists/list-comments operation.
type GistsListCommentsParams struct {
	// Gist_id parameter.
	GistID string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackGistsListCommentsParams(packed map[string]any) (params GistsListCommentsParams) {
	params.GistID = packed["gist_id"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeGistsListCommentsParams(args [1]string, r *http.Request) (params GistsListCommentsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: gist_id: parse")
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// GistsListCommitsParams is parameters of gists/list-commits operation.
type GistsListCommitsParams struct {
	// Gist_id parameter.
	GistID string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackGistsListCommitsParams(packed map[string]any) (params GistsListCommitsParams) {
	params.GistID = packed["gist_id"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeGistsListCommitsParams(args [1]string, r *http.Request) (params GistsListCommitsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: gist_id: parse")
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// GistsListForUserParams is parameters of gists/list-for-user operation.
type GistsListForUserParams struct {
	Username string
	// Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Since OptDateTime `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackGistsListForUserParams(packed map[string]any) (params GistsListForUserParams) {
	params.Username = packed["username"].(string)
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptDateTime)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeGistsListForUserParams(args [1]string, r *http.Request) (params GistsListForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// GistsListForksParams is parameters of gists/list-forks operation.
type GistsListForksParams struct {
	// Gist_id parameter.
	GistID string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackGistsListForksParams(packed map[string]any) (params GistsListForksParams) {
	params.GistID = packed["gist_id"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeGistsListForksParams(args [1]string, r *http.Request) (params GistsListForksParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: gist_id: parse")
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// GistsListPublicParams is parameters of gists/list-public operation.
type GistsListPublicParams struct {
	// Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Since OptDateTime `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackGistsListPublicParams(packed map[string]any) (params GistsListPublicParams) {
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptDateTime)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeGistsListPublicParams(args [0]string, r *http.Request) (params GistsListPublicParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// GistsListStarredParams is parameters of gists/list-starred operation.
type GistsListStarredParams struct {
	// Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Since OptDateTime `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackGistsListStarredParams(packed map[string]any) (params GistsListStarredParams) {
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptDateTime)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeGistsListStarredParams(args [0]string, r *http.Request) (params GistsListStarredParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// GistsStarParams is parameters of gists/star operation.
type GistsStarParams struct {
	// Gist_id parameter.
	GistID string
}

func unpackGistsStarParams(packed map[string]any) (params GistsStarParams) {
	params.GistID = packed["gist_id"].(string)
	return params
}

func decodeGistsStarParams(args [1]string, r *http.Request) (params GistsStarParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: gist_id: parse")
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	return params, nil
}

// GistsUnstarParams is parameters of gists/unstar operation.
type GistsUnstarParams struct {
	// Gist_id parameter.
	GistID string
}

func unpackGistsUnstarParams(packed map[string]any) (params GistsUnstarParams) {
	params.GistID = packed["gist_id"].(string)
	return params
}

func decodeGistsUnstarParams(args [1]string, r *http.Request) (params GistsUnstarParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: gist_id: parse")
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	return params, nil
}

// GistsUpdateCommentParams is parameters of gists/update-comment operation.
type GistsUpdateCommentParams struct {
	// Gist_id parameter.
	GistID string
	// Comment_id parameter.
	CommentID int
}

func unpackGistsUpdateCommentParams(packed map[string]any) (params GistsUpdateCommentParams) {
	params.GistID = packed["gist_id"].(string)
	params.CommentID = packed["comment_id"].(int)
	return params
}

func decodeGistsUpdateCommentParams(args [2]string, r *http.Request) (params GistsUpdateCommentParams, _ error) {
	// Decode path: gist_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gist_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.GistID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: gist_id: parse")
			}
		} else {
			return params, errors.New("path: gist_id: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

// GitCreateBlobParams is parameters of git/create-blob operation.
type GitCreateBlobParams struct {
	Owner string
	Repo  string
}

func unpackGitCreateBlobParams(packed map[string]any) (params GitCreateBlobParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeGitCreateBlobParams(args [2]string, r *http.Request) (params GitCreateBlobParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// GitCreateCommitParams is parameters of git/create-commit operation.
type GitCreateCommitParams struct {
	Owner string
	Repo  string
}

func unpackGitCreateCommitParams(packed map[string]any) (params GitCreateCommitParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeGitCreateCommitParams(args [2]string, r *http.Request) (params GitCreateCommitParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// GitCreateRefParams is parameters of git/create-ref operation.
type GitCreateRefParams struct {
	Owner string
	Repo  string
}

func unpackGitCreateRefParams(packed map[string]any) (params GitCreateRefParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeGitCreateRefParams(args [2]string, r *http.Request) (params GitCreateRefParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// GitCreateTagParams is parameters of git/create-tag operation.
type GitCreateTagParams struct {
	Owner string
	Repo  string
}

func unpackGitCreateTagParams(packed map[string]any) (params GitCreateTagParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeGitCreateTagParams(args [2]string, r *http.Request) (params GitCreateTagParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// GitCreateTreeParams is parameters of git/create-tree operation.
type GitCreateTreeParams struct {
	Owner string
	Repo  string
}

func unpackGitCreateTreeParams(packed map[string]any) (params GitCreateTreeParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeGitCreateTreeParams(args [2]string, r *http.Request) (params GitCreateTreeParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// GitDeleteRefParams is parameters of git/delete-ref operation.
type GitDeleteRefParams struct {
	Owner string
	Repo  string
	// Ref parameter.
	Ref string
}

func unpackGitDeleteRefParams(packed map[string]any) (params GitDeleteRefParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Ref = packed["ref"].(string)
	return params
}

func decodeGitDeleteRefParams(args [3]string, r *http.Request) (params GitDeleteRefParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: ref: parse")
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	return params, nil
}

// GitGetBlobParams is parameters of git/get-blob operation.
type GitGetBlobParams struct {
	Owner   string
	Repo    string
	FileSha string
}

func unpackGitGetBlobParams(packed map[string]any) (params GitGetBlobParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.FileSha = packed["file_sha"].(string)
	return params
}

func decodeGitGetBlobParams(args [3]string, r *http.Request) (params GitGetBlobParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: file_sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "file_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.FileSha = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: file_sha: parse")
			}
		} else {
			return params, errors.New("path: file_sha: not specified")
		}
	}
	return params, nil
}

// GitGetCommitParams is parameters of git/get-commit operation.
type GitGetCommitParams struct {
	Owner string
	Repo  string
	// Commit_sha parameter.
	CommitSha string
}

func unpackGitGetCommitParams(packed map[string]any) (params GitGetCommitParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommitSha = packed["commit_sha"].(string)
	return params
}

func decodeGitGetCommitParams(args [3]string, r *http.Request) (params GitGetCommitParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: commit_sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: commit_sha: parse")
			}
		} else {
			return params, errors.New("path: commit_sha: not specified")
		}
	}
	return params, nil
}

// GitGetRefParams is parameters of git/get-ref operation.
type GitGetRefParams struct {
	Owner string
	Repo  string
	// Ref parameter.
	Ref string
}

func unpackGitGetRefParams(packed map[string]any) (params GitGetRefParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Ref = packed["ref"].(string)
	return params
}

func decodeGitGetRefParams(args [3]string, r *http.Request) (params GitGetRefParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: ref: parse")
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	return params, nil
}

// GitGetTagParams is parameters of git/get-tag operation.
type GitGetTagParams struct {
	Owner  string
	Repo   string
	TagSha string
}

func unpackGitGetTagParams(packed map[string]any) (params GitGetTagParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.TagSha = packed["tag_sha"].(string)
	return params
}

func decodeGitGetTagParams(args [3]string, r *http.Request) (params GitGetTagParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: tag_sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tag_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TagSha = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: tag_sha: parse")
			}
		} else {
			return params, errors.New("path: tag_sha: not specified")
		}
	}
	return params, nil
}

// GitGetTreeParams is parameters of git/get-tree operation.
type GitGetTreeParams struct {
	Owner   string
	Repo    string
	TreeSha string
	// Setting this parameter to any value returns the objects or subtrees referenced by the tree
	// specified in `:tree_sha`. For example, setting `recursive` to any of the following will enable
	// returning objects or subtrees: `0`, `1`, `"true"`, and `"false"`. Omit this parameter to prevent
	// recursively returning objects or subtrees.
	Recursive OptString `json:",omitempty"`
}

func unpackGitGetTreeParams(packed map[string]any) (params GitGetTreeParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.TreeSha = packed["tree_sha"].(string)
	if v, ok := packed["recursive"]; ok {
		params.Recursive = v.(OptString)
	}
	return params
}

func decodeGitGetTreeParams(args [3]string, r *http.Request) (params GitGetTreeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: tree_sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tree_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TreeSha = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: tree_sha: parse")
			}
		} else {
			return params, errors.New("path: tree_sha: not specified")
		}
	}
	// Decode query: recursive.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "recursive",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRecursiveVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRecursiveVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Recursive.SetTo(paramsDotRecursiveVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: recursive: parse")
			}
		}
	}
	return params, nil
}

// GitListMatchingRefsParams is parameters of git/list-matching-refs operation.
type GitListMatchingRefsParams struct {
	Owner string
	Repo  string
	// Ref parameter.
	Ref string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackGitListMatchingRefsParams(packed map[string]any) (params GitListMatchingRefsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Ref = packed["ref"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeGitListMatchingRefsParams(args [3]string, r *http.Request) (params GitListMatchingRefsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: ref: parse")
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// GitUpdateRefParams is parameters of git/update-ref operation.
type GitUpdateRefParams struct {
	Owner string
	Repo  string
	// Ref parameter.
	Ref string
}

func unpackGitUpdateRefParams(packed map[string]any) (params GitUpdateRefParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Ref = packed["ref"].(string)
	return params
}

func decodeGitUpdateRefParams(args [3]string, r *http.Request) (params GitUpdateRefParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: ref: parse")
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	return params, nil
}

// GitignoreGetTemplateParams is parameters of gitignore/get-template operation.
type GitignoreGetTemplateParams struct {
	Name string
}

func unpackGitignoreGetTemplateParams(packed map[string]any) (params GitignoreGetTemplateParams) {
	params.Name = packed["name"].(string)
	return params
}

func decodeGitignoreGetTemplateParams(args [1]string, r *http.Request) (params GitignoreGetTemplateParams, _ error) {
	// Decode path: name.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	return params, nil
}

// InteractionsRemoveRestrictionsForOrgParams is parameters of interactions/remove-restrictions-for-org operation.
type InteractionsRemoveRestrictionsForOrgParams struct {
	Org string
}

func unpackInteractionsRemoveRestrictionsForOrgParams(packed map[string]any) (params InteractionsRemoveRestrictionsForOrgParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeInteractionsRemoveRestrictionsForOrgParams(args [1]string, r *http.Request) (params InteractionsRemoveRestrictionsForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// InteractionsRemoveRestrictionsForRepoParams is parameters of interactions/remove-restrictions-for-repo operation.
type InteractionsRemoveRestrictionsForRepoParams struct {
	Owner string
	Repo  string
}

func unpackInteractionsRemoveRestrictionsForRepoParams(packed map[string]any) (params InteractionsRemoveRestrictionsForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeInteractionsRemoveRestrictionsForRepoParams(args [2]string, r *http.Request) (params InteractionsRemoveRestrictionsForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// InteractionsSetRestrictionsForOrgParams is parameters of interactions/set-restrictions-for-org operation.
type InteractionsSetRestrictionsForOrgParams struct {
	Org string
}

func unpackInteractionsSetRestrictionsForOrgParams(packed map[string]any) (params InteractionsSetRestrictionsForOrgParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeInteractionsSetRestrictionsForOrgParams(args [1]string, r *http.Request) (params InteractionsSetRestrictionsForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// InteractionsSetRestrictionsForRepoParams is parameters of interactions/set-restrictions-for-repo operation.
type InteractionsSetRestrictionsForRepoParams struct {
	Owner string
	Repo  string
}

func unpackInteractionsSetRestrictionsForRepoParams(packed map[string]any) (params InteractionsSetRestrictionsForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeInteractionsSetRestrictionsForRepoParams(args [2]string, r *http.Request) (params InteractionsSetRestrictionsForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// IssuesAddAssigneesParams is parameters of issues/add-assignees operation.
type IssuesAddAssigneesParams struct {
	Owner string
	Repo  string
	// Issue_number parameter.
	IssueNumber int
}

func unpackIssuesAddAssigneesParams(packed map[string]any) (params IssuesAddAssigneesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.IssueNumber = packed["issue_number"].(int)
	return params
}

func decodeIssuesAddAssigneesParams(args [3]string, r *http.Request) (params IssuesAddAssigneesParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: issue_number: parse")
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

// IssuesCheckUserCanBeAssignedParams is parameters of issues/check-user-can-be-assigned operation.
type IssuesCheckUserCanBeAssignedParams struct {
	Owner    string
	Repo     string
	Assignee string
}

func unpackIssuesCheckUserCanBeAssignedParams(packed map[string]any) (params IssuesCheckUserCanBeAssignedParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Assignee = packed["assignee"].(string)
	return params
}

func decodeIssuesCheckUserCanBeAssignedParams(args [3]string, r *http.Request) (params IssuesCheckUserCanBeAssignedParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: assignee.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "assignee",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Assignee = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: assignee: parse")
			}
		} else {
			return params, errors.New("path: assignee: not specified")
		}
	}
	return params, nil
}

// IssuesCreateParams is parameters of issues/create operation.
type IssuesCreateParams struct {
	Owner string
	Repo  string
}

func unpackIssuesCreateParams(packed map[string]any) (params IssuesCreateParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeIssuesCreateParams(args [2]string, r *http.Request) (params IssuesCreateParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// IssuesCreateCommentParams is parameters of issues/create-comment operation.
type IssuesCreateCommentParams struct {
	Owner string
	Repo  string
	// Issue_number parameter.
	IssueNumber int
}

func unpackIssuesCreateCommentParams(packed map[string]any) (params IssuesCreateCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.IssueNumber = packed["issue_number"].(int)
	return params
}

func decodeIssuesCreateCommentParams(args [3]string, r *http.Request) (params IssuesCreateCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: issue_number: parse")
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

// IssuesCreateLabelParams is parameters of issues/create-label operation.
type IssuesCreateLabelParams struct {
	Owner string
	Repo  string
}

func unpackIssuesCreateLabelParams(packed map[string]any) (params IssuesCreateLabelParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeIssuesCreateLabelParams(args [2]string, r *http.Request) (params IssuesCreateLabelParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// IssuesCreateMilestoneParams is parameters of issues/create-milestone operation.
type IssuesCreateMilestoneParams struct {
	Owner string
	Repo  string
}

func unpackIssuesCreateMilestoneParams(packed map[string]any) (params IssuesCreateMilestoneParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeIssuesCreateMilestoneParams(args [2]string, r *http.Request) (params IssuesCreateMilestoneParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// IssuesDeleteCommentParams is parameters of issues/delete-comment operation.
type IssuesDeleteCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID int
}

func unpackIssuesDeleteCommentParams(packed map[string]any) (params IssuesDeleteCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	return params
}

func decodeIssuesDeleteCommentParams(args [3]string, r *http.Request) (params IssuesDeleteCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

// IssuesDeleteLabelParams is parameters of issues/delete-label operation.
type IssuesDeleteLabelParams struct {
	Owner string
	Repo  string
	Name  string
}

func unpackIssuesDeleteLabelParams(packed map[string]any) (params IssuesDeleteLabelParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Name = packed["name"].(string)
	return params
}

func decodeIssuesDeleteLabelParams(args [3]string, r *http.Request) (params IssuesDeleteLabelParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	return params, nil
}

// IssuesDeleteMilestoneParams is parameters of issues/delete-milestone operation.
type IssuesDeleteMilestoneParams struct {
	Owner string
	Repo  string
	// Milestone_number parameter.
	MilestoneNumber int
}

func unpackIssuesDeleteMilestoneParams(packed map[string]any) (params IssuesDeleteMilestoneParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.MilestoneNumber = packed["milestone_number"].(int)
	return params
}

func decodeIssuesDeleteMilestoneParams(args [3]string, r *http.Request) (params IssuesDeleteMilestoneParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: milestone_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "milestone_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MilestoneNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: milestone_number: parse")
			}
		} else {
			return params, errors.New("path: milestone_number: not specified")
		}
	}
	return params, nil
}

// IssuesGetParams is parameters of issues/get operation.
type IssuesGetParams struct {
	Owner string
	Repo  string
	// Issue_number parameter.
	IssueNumber int
}

func unpackIssuesGetParams(packed map[string]any) (params IssuesGetParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.IssueNumber = packed["issue_number"].(int)
	return params
}

func decodeIssuesGetParams(args [3]string, r *http.Request) (params IssuesGetParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: issue_number: parse")
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

// IssuesGetCommentParams is parameters of issues/get-comment operation.
type IssuesGetCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID int
}

func unpackIssuesGetCommentParams(packed map[string]any) (params IssuesGetCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	return params
}

func decodeIssuesGetCommentParams(args [3]string, r *http.Request) (params IssuesGetCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

// IssuesGetEventParams is parameters of issues/get-event operation.
type IssuesGetEventParams struct {
	Owner   string
	Repo    string
	EventID int
}

func unpackIssuesGetEventParams(packed map[string]any) (params IssuesGetEventParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.EventID = packed["event_id"].(int)
	return params
}

func decodeIssuesGetEventParams(args [3]string, r *http.Request) (params IssuesGetEventParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: event_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "event_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.EventID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: event_id: parse")
			}
		} else {
			return params, errors.New("path: event_id: not specified")
		}
	}
	return params, nil
}

// IssuesGetLabelParams is parameters of issues/get-label operation.
type IssuesGetLabelParams struct {
	Owner string
	Repo  string
	Name  string
}

func unpackIssuesGetLabelParams(packed map[string]any) (params IssuesGetLabelParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Name = packed["name"].(string)
	return params
}

func decodeIssuesGetLabelParams(args [3]string, r *http.Request) (params IssuesGetLabelParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	return params, nil
}

// IssuesGetMilestoneParams is parameters of issues/get-milestone operation.
type IssuesGetMilestoneParams struct {
	Owner string
	Repo  string
	// Milestone_number parameter.
	MilestoneNumber int
}

func unpackIssuesGetMilestoneParams(packed map[string]any) (params IssuesGetMilestoneParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.MilestoneNumber = packed["milestone_number"].(int)
	return params
}

func decodeIssuesGetMilestoneParams(args [3]string, r *http.Request) (params IssuesGetMilestoneParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: milestone_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "milestone_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MilestoneNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: milestone_number: parse")
			}
		} else {
			return params, errors.New("path: milestone_number: not specified")
		}
	}
	return params, nil
}

// IssuesListParams is parameters of issues/list operation.
type IssuesListParams struct {
	// Indicates which sorts of issues to return. Can be one of:
	// \* `assigned`: Issues assigned to you
	// \* `created`: Issues created by you
	// \* `mentioned`: Issues mentioning you
	// \* `subscribed`: Issues you're subscribed to updates for
	// \* `all` or `repos`: All issues the authenticated user can see, regardless of participation or
	// creation.
	Filter OptIssuesListFilter `json:",omitempty"`
	// Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`.
	State OptIssuesListState `json:",omitempty"`
	// A list of comma separated label names. Example: `bug,ui,@high`.
	Labels OptString `json:",omitempty"`
	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort OptIssuesListSort `json:",omitempty"`
	// One of `asc` (ascending) or `desc` (descending).
	Direction OptIssuesListDirection `json:",omitempty"`
	// Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Since  OptDateTime `json:",omitempty"`
	Collab OptBool     `json:",omitempty"`
	Orgs   OptBool     `json:",omitempty"`
	Owned  OptBool     `json:",omitempty"`
	Pulls  OptBool     `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackIssuesListParams(packed map[string]any) (params IssuesListParams) {
	if v, ok := packed["filter"]; ok {
		params.Filter = v.(OptIssuesListFilter)
	}
	if v, ok := packed["state"]; ok {
		params.State = v.(OptIssuesListState)
	}
	if v, ok := packed["labels"]; ok {
		params.Labels = v.(OptString)
	}
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptIssuesListSort)
	}
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptIssuesListDirection)
	}
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptDateTime)
	}
	if v, ok := packed["collab"]; ok {
		params.Collab = v.(OptBool)
	}
	if v, ok := packed["orgs"]; ok {
		params.Orgs = v.(OptBool)
	}
	if v, ok := packed["owned"]; ok {
		params.Owned = v.(OptBool)
	}
	if v, ok := packed["pulls"]; ok {
		params.Pulls = v.(OptBool)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeIssuesListParams(args [0]string, r *http.Request) (params IssuesListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: filter.
	{
		val := IssuesListFilter("assigned")
		params.Filter.SetTo(val)
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal IssuesListFilter
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = IssuesListFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: filter: invalid")
			}
		}
	}
	// Set default value for query: state.
	{
		val := IssuesListState("open")
		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal IssuesListState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = IssuesListState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Decode query: labels.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelsVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Labels.SetTo(paramsDotLabelsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labels: parse")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := IssuesListSort("created")
		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal IssuesListSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = IssuesListSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: direction.
	{
		val := IssuesListDirection("desc")
		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal IssuesListDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = IssuesListDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Decode query: collab.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "collab",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCollabVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotCollabVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Collab.SetTo(paramsDotCollabVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: collab: parse")
			}
		}
	}
	// Decode query: orgs.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "orgs",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrgsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotOrgsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Orgs.SetTo(paramsDotOrgsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: orgs: parse")
			}
		}
	}
	// Decode query: owned.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "owned",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOwnedVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotOwnedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Owned.SetTo(paramsDotOwnedVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: owned: parse")
			}
		}
	}
	// Decode query: pulls.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pulls",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPullsVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotPullsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pulls.SetTo(paramsDotPullsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pulls: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// IssuesListAssigneesParams is parameters of issues/list-assignees operation.
type IssuesListAssigneesParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackIssuesListAssigneesParams(packed map[string]any) (params IssuesListAssigneesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeIssuesListAssigneesParams(args [2]string, r *http.Request) (params IssuesListAssigneesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// IssuesListCommentsParams is parameters of issues/list-comments operation.
type IssuesListCommentsParams struct {
	Owner string
	Repo  string
	// Issue_number parameter.
	IssueNumber int
	// Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Since OptDateTime `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackIssuesListCommentsParams(packed map[string]any) (params IssuesListCommentsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.IssueNumber = packed["issue_number"].(int)
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptDateTime)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeIssuesListCommentsParams(args [3]string, r *http.Request) (params IssuesListCommentsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: issue_number: parse")
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// IssuesListCommentsForRepoParams is parameters of issues/list-comments-for-repo operation.
type IssuesListCommentsForRepoParams struct {
	Owner string
	Repo  string
	// One of `created` (when the repository was starred) or `updated` (when it was last pushed to).
	Sort OptIssuesListCommentsForRepoSort `json:",omitempty"`
	// Either `asc` or `desc`. Ignored without the `sort` parameter.
	Direction OptIssuesListCommentsForRepoDirection `json:",omitempty"`
	// Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Since OptDateTime `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackIssuesListCommentsForRepoParams(packed map[string]any) (params IssuesListCommentsForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptIssuesListCommentsForRepoSort)
	}
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptIssuesListCommentsForRepoDirection)
	}
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptDateTime)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeIssuesListCommentsForRepoParams(args [2]string, r *http.Request) (params IssuesListCommentsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: sort.
	{
		val := IssuesListCommentsForRepoSort("created")
		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal IssuesListCommentsForRepoSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = IssuesListCommentsForRepoSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal IssuesListCommentsForRepoDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = IssuesListCommentsForRepoDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// IssuesListEventsForRepoParams is parameters of issues/list-events-for-repo operation.
type IssuesListEventsForRepoParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackIssuesListEventsForRepoParams(packed map[string]any) (params IssuesListEventsForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeIssuesListEventsForRepoParams(args [2]string, r *http.Request) (params IssuesListEventsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// IssuesListForAuthenticatedUserParams is parameters of issues/list-for-authenticated-user operation.
type IssuesListForAuthenticatedUserParams struct {
	// Indicates which sorts of issues to return. Can be one of:
	// \* `assigned`: Issues assigned to you
	// \* `created`: Issues created by you
	// \* `mentioned`: Issues mentioning you
	// \* `subscribed`: Issues you're subscribed to updates for
	// \* `all` or `repos`: All issues the authenticated user can see, regardless of participation or
	// creation.
	Filter OptIssuesListForAuthenticatedUserFilter `json:",omitempty"`
	// Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`.
	State OptIssuesListForAuthenticatedUserState `json:",omitempty"`
	// A list of comma separated label names. Example: `bug,ui,@high`.
	Labels OptString `json:",omitempty"`
	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort OptIssuesListForAuthenticatedUserSort `json:",omitempty"`
	// One of `asc` (ascending) or `desc` (descending).
	Direction OptIssuesListForAuthenticatedUserDirection `json:",omitempty"`
	// Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Since OptDateTime `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackIssuesListForAuthenticatedUserParams(packed map[string]any) (params IssuesListForAuthenticatedUserParams) {
	if v, ok := packed["filter"]; ok {
		params.Filter = v.(OptIssuesListForAuthenticatedUserFilter)
	}
	if v, ok := packed["state"]; ok {
		params.State = v.(OptIssuesListForAuthenticatedUserState)
	}
	if v, ok := packed["labels"]; ok {
		params.Labels = v.(OptString)
	}
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptIssuesListForAuthenticatedUserSort)
	}
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptIssuesListForAuthenticatedUserDirection)
	}
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptDateTime)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeIssuesListForAuthenticatedUserParams(args [0]string, r *http.Request) (params IssuesListForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: filter.
	{
		val := IssuesListForAuthenticatedUserFilter("assigned")
		params.Filter.SetTo(val)
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal IssuesListForAuthenticatedUserFilter
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = IssuesListForAuthenticatedUserFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: filter: invalid")
			}
		}
	}
	// Set default value for query: state.
	{
		val := IssuesListForAuthenticatedUserState("open")
		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal IssuesListForAuthenticatedUserState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = IssuesListForAuthenticatedUserState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Decode query: labels.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelsVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Labels.SetTo(paramsDotLabelsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labels: parse")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := IssuesListForAuthenticatedUserSort("created")
		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal IssuesListForAuthenticatedUserSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = IssuesListForAuthenticatedUserSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: direction.
	{
		val := IssuesListForAuthenticatedUserDirection("desc")
		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal IssuesListForAuthenticatedUserDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = IssuesListForAuthenticatedUserDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// IssuesListForOrgParams is parameters of issues/list-for-org operation.
type IssuesListForOrgParams struct {
	Org string
	// Indicates which sorts of issues to return. Can be one of:
	// \* `assigned`: Issues assigned to you
	// \* `created`: Issues created by you
	// \* `mentioned`: Issues mentioning you
	// \* `subscribed`: Issues you're subscribed to updates for
	// \* `all` or `repos`: All issues the authenticated user can see, regardless of participation or
	// creation.
	Filter OptIssuesListForOrgFilter `json:",omitempty"`
	// Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`.
	State OptIssuesListForOrgState `json:",omitempty"`
	// A list of comma separated label names. Example: `bug,ui,@high`.
	Labels OptString `json:",omitempty"`
	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort OptIssuesListForOrgSort `json:",omitempty"`
	// One of `asc` (ascending) or `desc` (descending).
	Direction OptIssuesListForOrgDirection `json:",omitempty"`
	// Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Since OptDateTime `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackIssuesListForOrgParams(packed map[string]any) (params IssuesListForOrgParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["filter"]; ok {
		params.Filter = v.(OptIssuesListForOrgFilter)
	}
	if v, ok := packed["state"]; ok {
		params.State = v.(OptIssuesListForOrgState)
	}
	if v, ok := packed["labels"]; ok {
		params.Labels = v.(OptString)
	}
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptIssuesListForOrgSort)
	}
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptIssuesListForOrgDirection)
	}
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptDateTime)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeIssuesListForOrgParams(args [1]string, r *http.Request) (params IssuesListForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: filter.
	{
		val := IssuesListForOrgFilter("assigned")
		params.Filter.SetTo(val)
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal IssuesListForOrgFilter
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = IssuesListForOrgFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: filter: invalid")
			}
		}
	}
	// Set default value for query: state.
	{
		val := IssuesListForOrgState("open")
		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal IssuesListForOrgState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = IssuesListForOrgState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Decode query: labels.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelsVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Labels.SetTo(paramsDotLabelsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labels: parse")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := IssuesListForOrgSort("created")
		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal IssuesListForOrgSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = IssuesListForOrgSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: direction.
	{
		val := IssuesListForOrgDirection("desc")
		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal IssuesListForOrgDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = IssuesListForOrgDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// IssuesListForRepoParams is parameters of issues/list-for-repo operation.
type IssuesListForRepoParams struct {
	Owner string
	Repo  string
	// If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*`
	// is passed, issues with any milestone are accepted. If the string `none` is passed, issues without
	// milestones are returned.
	Milestone OptString `json:",omitempty"`
	// Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`.
	State OptIssuesListForRepoState `json:",omitempty"`
	// Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues
	// assigned to any user.
	Assignee OptString `json:",omitempty"`
	// The user that created the issue.
	Creator OptString `json:",omitempty"`
	// A user that's mentioned in the issue.
	Mentioned OptString `json:",omitempty"`
	// A list of comma separated label names. Example: `bug,ui,@high`.
	Labels OptString `json:",omitempty"`
	// What to sort results by. Can be either `created`, `updated`, `comments`.
	Sort OptIssuesListForRepoSort `json:",omitempty"`
	// One of `asc` (ascending) or `desc` (descending).
	Direction OptIssuesListForRepoDirection `json:",omitempty"`
	// Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Since OptDateTime `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackIssuesListForRepoParams(packed map[string]any) (params IssuesListForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["milestone"]; ok {
		params.Milestone = v.(OptString)
	}
	if v, ok := packed["state"]; ok {
		params.State = v.(OptIssuesListForRepoState)
	}
	if v, ok := packed["assignee"]; ok {
		params.Assignee = v.(OptString)
	}
	if v, ok := packed["creator"]; ok {
		params.Creator = v.(OptString)
	}
	if v, ok := packed["mentioned"]; ok {
		params.Mentioned = v.(OptString)
	}
	if v, ok := packed["labels"]; ok {
		params.Labels = v.(OptString)
	}
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptIssuesListForRepoSort)
	}
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptIssuesListForRepoDirection)
	}
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptDateTime)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeIssuesListForRepoParams(args [2]string, r *http.Request) (params IssuesListForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: milestone.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "milestone",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMilestoneVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotMilestoneVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Milestone.SetTo(paramsDotMilestoneVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: milestone: parse")
			}
		}
	}
	// Set default value for query: state.
	{
		val := IssuesListForRepoState("open")
		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal IssuesListForRepoState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = IssuesListForRepoState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Decode query: assignee.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "assignee",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAssigneeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAssigneeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Assignee.SetTo(paramsDotAssigneeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: assignee: parse")
			}
		}
	}
	// Decode query: creator.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "creator",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCreatorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCreatorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Creator.SetTo(paramsDotCreatorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: creator: parse")
			}
		}
	}
	// Decode query: mentioned.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mentioned",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMentionedVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotMentionedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Mentioned.SetTo(paramsDotMentionedVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: mentioned: parse")
			}
		}
	}
	// Decode query: labels.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLabelsVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLabelsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Labels.SetTo(paramsDotLabelsVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: labels: parse")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := IssuesListForRepoSort("created")
		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal IssuesListForRepoSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = IssuesListForRepoSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: direction.
	{
		val := IssuesListForRepoDirection("desc")
		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal IssuesListForRepoDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = IssuesListForRepoDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// IssuesListLabelsForMilestoneParams is parameters of issues/list-labels-for-milestone operation.
type IssuesListLabelsForMilestoneParams struct {
	Owner string
	Repo  string
	// Milestone_number parameter.
	MilestoneNumber int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackIssuesListLabelsForMilestoneParams(packed map[string]any) (params IssuesListLabelsForMilestoneParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.MilestoneNumber = packed["milestone_number"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeIssuesListLabelsForMilestoneParams(args [3]string, r *http.Request) (params IssuesListLabelsForMilestoneParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: milestone_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "milestone_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MilestoneNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: milestone_number: parse")
			}
		} else {
			return params, errors.New("path: milestone_number: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// IssuesListLabelsForRepoParams is parameters of issues/list-labels-for-repo operation.
type IssuesListLabelsForRepoParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackIssuesListLabelsForRepoParams(packed map[string]any) (params IssuesListLabelsForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeIssuesListLabelsForRepoParams(args [2]string, r *http.Request) (params IssuesListLabelsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// IssuesListLabelsOnIssueParams is parameters of issues/list-labels-on-issue operation.
type IssuesListLabelsOnIssueParams struct {
	Owner string
	Repo  string
	// Issue_number parameter.
	IssueNumber int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackIssuesListLabelsOnIssueParams(packed map[string]any) (params IssuesListLabelsOnIssueParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.IssueNumber = packed["issue_number"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeIssuesListLabelsOnIssueParams(args [3]string, r *http.Request) (params IssuesListLabelsOnIssueParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: issue_number: parse")
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// IssuesListMilestonesParams is parameters of issues/list-milestones operation.
type IssuesListMilestonesParams struct {
	Owner string
	Repo  string
	// The state of the milestone. Either `open`, `closed`, or `all`.
	State OptIssuesListMilestonesState `json:",omitempty"`
	// What to sort results by. Either `due_on` or `completeness`.
	Sort OptIssuesListMilestonesSort `json:",omitempty"`
	// The direction of the sort. Either `asc` or `desc`.
	Direction OptIssuesListMilestonesDirection `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackIssuesListMilestonesParams(packed map[string]any) (params IssuesListMilestonesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["state"]; ok {
		params.State = v.(OptIssuesListMilestonesState)
	}
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptIssuesListMilestonesSort)
	}
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptIssuesListMilestonesDirection)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeIssuesListMilestonesParams(args [2]string, r *http.Request) (params IssuesListMilestonesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: state.
	{
		val := IssuesListMilestonesState("open")
		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal IssuesListMilestonesState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = IssuesListMilestonesState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := IssuesListMilestonesSort("due_on")
		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal IssuesListMilestonesSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = IssuesListMilestonesSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: direction.
	{
		val := IssuesListMilestonesDirection("asc")
		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal IssuesListMilestonesDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = IssuesListMilestonesDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// IssuesLockParams is parameters of issues/lock operation.
type IssuesLockParams struct {
	Owner string
	Repo  string
	// Issue_number parameter.
	IssueNumber int
}

func unpackIssuesLockParams(packed map[string]any) (params IssuesLockParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.IssueNumber = packed["issue_number"].(int)
	return params
}

func decodeIssuesLockParams(args [3]string, r *http.Request) (params IssuesLockParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: issue_number: parse")
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

// IssuesRemoveAllLabelsParams is parameters of issues/remove-all-labels operation.
type IssuesRemoveAllLabelsParams struct {
	Owner string
	Repo  string
	// Issue_number parameter.
	IssueNumber int
}

func unpackIssuesRemoveAllLabelsParams(packed map[string]any) (params IssuesRemoveAllLabelsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.IssueNumber = packed["issue_number"].(int)
	return params
}

func decodeIssuesRemoveAllLabelsParams(args [3]string, r *http.Request) (params IssuesRemoveAllLabelsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: issue_number: parse")
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

// IssuesRemoveAssigneesParams is parameters of issues/remove-assignees operation.
type IssuesRemoveAssigneesParams struct {
	Owner string
	Repo  string
	// Issue_number parameter.
	IssueNumber int
}

func unpackIssuesRemoveAssigneesParams(packed map[string]any) (params IssuesRemoveAssigneesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.IssueNumber = packed["issue_number"].(int)
	return params
}

func decodeIssuesRemoveAssigneesParams(args [3]string, r *http.Request) (params IssuesRemoveAssigneesParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: issue_number: parse")
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

// IssuesRemoveLabelParams is parameters of issues/remove-label operation.
type IssuesRemoveLabelParams struct {
	Owner string
	Repo  string
	// Issue_number parameter.
	IssueNumber int
	Name        string
}

func unpackIssuesRemoveLabelParams(packed map[string]any) (params IssuesRemoveLabelParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.IssueNumber = packed["issue_number"].(int)
	params.Name = packed["name"].(string)
	return params
}

func decodeIssuesRemoveLabelParams(args [4]string, r *http.Request) (params IssuesRemoveLabelParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: issue_number: parse")
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	// Decode path: name.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	return params, nil
}

// IssuesUnlockParams is parameters of issues/unlock operation.
type IssuesUnlockParams struct {
	Owner string
	Repo  string
	// Issue_number parameter.
	IssueNumber int
}

func unpackIssuesUnlockParams(packed map[string]any) (params IssuesUnlockParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.IssueNumber = packed["issue_number"].(int)
	return params
}

func decodeIssuesUnlockParams(args [3]string, r *http.Request) (params IssuesUnlockParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: issue_number: parse")
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

// IssuesUpdateParams is parameters of issues/update operation.
type IssuesUpdateParams struct {
	Owner string
	Repo  string
	// Issue_number parameter.
	IssueNumber int
}

func unpackIssuesUpdateParams(packed map[string]any) (params IssuesUpdateParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.IssueNumber = packed["issue_number"].(int)
	return params
}

func decodeIssuesUpdateParams(args [3]string, r *http.Request) (params IssuesUpdateParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: issue_number: parse")
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

// IssuesUpdateCommentParams is parameters of issues/update-comment operation.
type IssuesUpdateCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID int
}

func unpackIssuesUpdateCommentParams(packed map[string]any) (params IssuesUpdateCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	return params
}

func decodeIssuesUpdateCommentParams(args [3]string, r *http.Request) (params IssuesUpdateCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

// IssuesUpdateLabelParams is parameters of issues/update-label operation.
type IssuesUpdateLabelParams struct {
	Owner string
	Repo  string
	Name  string
}

func unpackIssuesUpdateLabelParams(packed map[string]any) (params IssuesUpdateLabelParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Name = packed["name"].(string)
	return params
}

func decodeIssuesUpdateLabelParams(args [3]string, r *http.Request) (params IssuesUpdateLabelParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: name: parse")
			}
		} else {
			return params, errors.New("path: name: not specified")
		}
	}
	return params, nil
}

// IssuesUpdateMilestoneParams is parameters of issues/update-milestone operation.
type IssuesUpdateMilestoneParams struct {
	Owner string
	Repo  string
	// Milestone_number parameter.
	MilestoneNumber int
}

func unpackIssuesUpdateMilestoneParams(packed map[string]any) (params IssuesUpdateMilestoneParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.MilestoneNumber = packed["milestone_number"].(int)
	return params
}

func decodeIssuesUpdateMilestoneParams(args [3]string, r *http.Request) (params IssuesUpdateMilestoneParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: milestone_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "milestone_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MilestoneNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: milestone_number: parse")
			}
		} else {
			return params, errors.New("path: milestone_number: not specified")
		}
	}
	return params, nil
}

// LicensesGetParams is parameters of licenses/get operation.
type LicensesGetParams struct {
	License string
}

func unpackLicensesGetParams(packed map[string]any) (params LicensesGetParams) {
	params.License = packed["license"].(string)
	return params
}

func decodeLicensesGetParams(args [1]string, r *http.Request) (params LicensesGetParams, _ error) {
	// Decode path: license.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "license",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.License = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: license: parse")
			}
		} else {
			return params, errors.New("path: license: not specified")
		}
	}
	return params, nil
}

// LicensesGetAllCommonlyUsedParams is parameters of licenses/get-all-commonly-used operation.
type LicensesGetAllCommonlyUsedParams struct {
	Featured OptBool `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackLicensesGetAllCommonlyUsedParams(packed map[string]any) (params LicensesGetAllCommonlyUsedParams) {
	if v, ok := packed["featured"]; ok {
		params.Featured = v.(OptBool)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeLicensesGetAllCommonlyUsedParams(args [0]string, r *http.Request) (params LicensesGetAllCommonlyUsedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: featured.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "featured",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFeaturedVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotFeaturedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Featured.SetTo(paramsDotFeaturedVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: featured: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// LicensesGetForRepoParams is parameters of licenses/get-for-repo operation.
type LicensesGetForRepoParams struct {
	Owner string
	Repo  string
}

func unpackLicensesGetForRepoParams(packed map[string]any) (params LicensesGetForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeLicensesGetForRepoParams(args [2]string, r *http.Request) (params LicensesGetForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// MigrationsCancelImportParams is parameters of migrations/cancel-import operation.
type MigrationsCancelImportParams struct {
	Owner string
	Repo  string
}

func unpackMigrationsCancelImportParams(packed map[string]any) (params MigrationsCancelImportParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeMigrationsCancelImportParams(args [2]string, r *http.Request) (params MigrationsCancelImportParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// MigrationsDeleteArchiveForAuthenticatedUserParams is parameters of migrations/delete-archive-for-authenticated-user operation.
type MigrationsDeleteArchiveForAuthenticatedUserParams struct {
	// Migration_id parameter.
	MigrationID int
}

func unpackMigrationsDeleteArchiveForAuthenticatedUserParams(packed map[string]any) (params MigrationsDeleteArchiveForAuthenticatedUserParams) {
	params.MigrationID = packed["migration_id"].(int)
	return params
}

func decodeMigrationsDeleteArchiveForAuthenticatedUserParams(args [1]string, r *http.Request) (params MigrationsDeleteArchiveForAuthenticatedUserParams, _ error) {
	// Decode path: migration_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: migration_id: parse")
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	return params, nil
}

// MigrationsDeleteArchiveForOrgParams is parameters of migrations/delete-archive-for-org operation.
type MigrationsDeleteArchiveForOrgParams struct {
	Org string
	// Migration_id parameter.
	MigrationID int
}

func unpackMigrationsDeleteArchiveForOrgParams(packed map[string]any) (params MigrationsDeleteArchiveForOrgParams) {
	params.Org = packed["org"].(string)
	params.MigrationID = packed["migration_id"].(int)
	return params
}

func decodeMigrationsDeleteArchiveForOrgParams(args [2]string, r *http.Request) (params MigrationsDeleteArchiveForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: migration_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: migration_id: parse")
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	return params, nil
}

// MigrationsDownloadArchiveForOrgParams is parameters of migrations/download-archive-for-org operation.
type MigrationsDownloadArchiveForOrgParams struct {
	Org string
	// Migration_id parameter.
	MigrationID int
}

func unpackMigrationsDownloadArchiveForOrgParams(packed map[string]any) (params MigrationsDownloadArchiveForOrgParams) {
	params.Org = packed["org"].(string)
	params.MigrationID = packed["migration_id"].(int)
	return params
}

func decodeMigrationsDownloadArchiveForOrgParams(args [2]string, r *http.Request) (params MigrationsDownloadArchiveForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: migration_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: migration_id: parse")
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	return params, nil
}

// MigrationsGetArchiveForAuthenticatedUserParams is parameters of migrations/get-archive-for-authenticated-user operation.
type MigrationsGetArchiveForAuthenticatedUserParams struct {
	// Migration_id parameter.
	MigrationID int
}

func unpackMigrationsGetArchiveForAuthenticatedUserParams(packed map[string]any) (params MigrationsGetArchiveForAuthenticatedUserParams) {
	params.MigrationID = packed["migration_id"].(int)
	return params
}

func decodeMigrationsGetArchiveForAuthenticatedUserParams(args [1]string, r *http.Request) (params MigrationsGetArchiveForAuthenticatedUserParams, _ error) {
	// Decode path: migration_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: migration_id: parse")
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	return params, nil
}

// MigrationsGetCommitAuthorsParams is parameters of migrations/get-commit-authors operation.
type MigrationsGetCommitAuthorsParams struct {
	Owner string
	Repo  string
	// A user ID. Only return users with an ID greater than this ID.
	Since OptInt `json:",omitempty"`
}

func unpackMigrationsGetCommitAuthorsParams(packed map[string]any) (params MigrationsGetCommitAuthorsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptInt)
	}
	return params
}

func decodeMigrationsGetCommitAuthorsParams(args [2]string, r *http.Request) (params MigrationsGetCommitAuthorsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	return params, nil
}

// MigrationsGetImportStatusParams is parameters of migrations/get-import-status operation.
type MigrationsGetImportStatusParams struct {
	Owner string
	Repo  string
}

func unpackMigrationsGetImportStatusParams(packed map[string]any) (params MigrationsGetImportStatusParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeMigrationsGetImportStatusParams(args [2]string, r *http.Request) (params MigrationsGetImportStatusParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// MigrationsGetLargeFilesParams is parameters of migrations/get-large-files operation.
type MigrationsGetLargeFilesParams struct {
	Owner string
	Repo  string
}

func unpackMigrationsGetLargeFilesParams(packed map[string]any) (params MigrationsGetLargeFilesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeMigrationsGetLargeFilesParams(args [2]string, r *http.Request) (params MigrationsGetLargeFilesParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// MigrationsGetStatusForAuthenticatedUserParams is parameters of migrations/get-status-for-authenticated-user operation.
type MigrationsGetStatusForAuthenticatedUserParams struct {
	// Migration_id parameter.
	MigrationID int
	Exclude     []string `json:",omitempty"`
}

func unpackMigrationsGetStatusForAuthenticatedUserParams(packed map[string]any) (params MigrationsGetStatusForAuthenticatedUserParams) {
	params.MigrationID = packed["migration_id"].(int)
	if v, ok := packed["exclude"]; ok {
		params.Exclude = v.([]string)
	}
	return params
}

func decodeMigrationsGetStatusForAuthenticatedUserParams(args [1]string, r *http.Request) (params MigrationsGetStatusForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: migration_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: migration_id: parse")
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	// Decode query: exclude.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "exclude",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotExcludeVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotExcludeVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Exclude = append(params.Exclude, paramsDotExcludeVal)
					return nil
				})
			}); err != nil {
				return params, errors.Wrap(err, "query: exclude: parse")
			}
		}
	}
	return params, nil
}

// MigrationsGetStatusForOrgParams is parameters of migrations/get-status-for-org operation.
type MigrationsGetStatusForOrgParams struct {
	Org string
	// Migration_id parameter.
	MigrationID int
	// Exclude attributes from the API response to improve performance.
	Exclude []MigrationsGetStatusForOrgExcludeItem `json:",omitempty"`
}

func unpackMigrationsGetStatusForOrgParams(packed map[string]any) (params MigrationsGetStatusForOrgParams) {
	params.Org = packed["org"].(string)
	params.MigrationID = packed["migration_id"].(int)
	if v, ok := packed["exclude"]; ok {
		params.Exclude = v.([]MigrationsGetStatusForOrgExcludeItem)
	}
	return params
}

func decodeMigrationsGetStatusForOrgParams(args [2]string, r *http.Request) (params MigrationsGetStatusForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: migration_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: migration_id: parse")
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	// Decode query: exclude.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "exclude",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotExcludeVal MigrationsGetStatusForOrgExcludeItem
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotExcludeVal = MigrationsGetStatusForOrgExcludeItem(c)
						return nil
					}(); err != nil {
						return err
					}
					params.Exclude = append(params.Exclude, paramsDotExcludeVal)
					return nil
				})
			}); err != nil {
				return params, errors.Wrap(err, "query: exclude: parse")
			}
			if err := func() error {
				var failures []validate.FieldError
				for i, elem := range params.Exclude {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: exclude: invalid")
			}
		}
	}
	return params, nil
}

// MigrationsListForAuthenticatedUserParams is parameters of migrations/list-for-authenticated-user operation.
type MigrationsListForAuthenticatedUserParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackMigrationsListForAuthenticatedUserParams(packed map[string]any) (params MigrationsListForAuthenticatedUserParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeMigrationsListForAuthenticatedUserParams(args [0]string, r *http.Request) (params MigrationsListForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// MigrationsListForOrgParams is parameters of migrations/list-for-org operation.
type MigrationsListForOrgParams struct {
	Org string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// Exclude attributes from the API response to improve performance.
	Exclude []MigrationsListForOrgExcludeItem `json:",omitempty"`
}

func unpackMigrationsListForOrgParams(packed map[string]any) (params MigrationsListForOrgParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["exclude"]; ok {
		params.Exclude = v.([]MigrationsListForOrgExcludeItem)
	}
	return params
}

func decodeMigrationsListForOrgParams(args [1]string, r *http.Request) (params MigrationsListForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: exclude.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "exclude",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotExcludeVal MigrationsListForOrgExcludeItem
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotExcludeVal = MigrationsListForOrgExcludeItem(c)
						return nil
					}(); err != nil {
						return err
					}
					params.Exclude = append(params.Exclude, paramsDotExcludeVal)
					return nil
				})
			}); err != nil {
				return params, errors.Wrap(err, "query: exclude: parse")
			}
			if err := func() error {
				var failures []validate.FieldError
				for i, elem := range params.Exclude {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: exclude: invalid")
			}
		}
	}
	return params, nil
}

// MigrationsListReposForOrgParams is parameters of migrations/list-repos-for-org operation.
type MigrationsListReposForOrgParams struct {
	Org string
	// Migration_id parameter.
	MigrationID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackMigrationsListReposForOrgParams(packed map[string]any) (params MigrationsListReposForOrgParams) {
	params.Org = packed["org"].(string)
	params.MigrationID = packed["migration_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeMigrationsListReposForOrgParams(args [2]string, r *http.Request) (params MigrationsListReposForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: migration_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: migration_id: parse")
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// MigrationsListReposForUserParams is parameters of migrations/list-repos-for-user operation.
type MigrationsListReposForUserParams struct {
	// Migration_id parameter.
	MigrationID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackMigrationsListReposForUserParams(packed map[string]any) (params MigrationsListReposForUserParams) {
	params.MigrationID = packed["migration_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeMigrationsListReposForUserParams(args [1]string, r *http.Request) (params MigrationsListReposForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: migration_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: migration_id: parse")
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// MigrationsMapCommitAuthorParams is parameters of migrations/map-commit-author operation.
type MigrationsMapCommitAuthorParams struct {
	Owner    string
	Repo     string
	AuthorID int
}

func unpackMigrationsMapCommitAuthorParams(packed map[string]any) (params MigrationsMapCommitAuthorParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.AuthorID = packed["author_id"].(int)
	return params
}

func decodeMigrationsMapCommitAuthorParams(args [3]string, r *http.Request) (params MigrationsMapCommitAuthorParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: author_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "author_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AuthorID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: author_id: parse")
			}
		} else {
			return params, errors.New("path: author_id: not specified")
		}
	}
	return params, nil
}

// MigrationsSetLfsPreferenceParams is parameters of migrations/set-lfs-preference operation.
type MigrationsSetLfsPreferenceParams struct {
	Owner string
	Repo  string
}

func unpackMigrationsSetLfsPreferenceParams(packed map[string]any) (params MigrationsSetLfsPreferenceParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeMigrationsSetLfsPreferenceParams(args [2]string, r *http.Request) (params MigrationsSetLfsPreferenceParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// MigrationsStartForOrgParams is parameters of migrations/start-for-org operation.
type MigrationsStartForOrgParams struct {
	Org string
}

func unpackMigrationsStartForOrgParams(packed map[string]any) (params MigrationsStartForOrgParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeMigrationsStartForOrgParams(args [1]string, r *http.Request) (params MigrationsStartForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// MigrationsStartImportParams is parameters of migrations/start-import operation.
type MigrationsStartImportParams struct {
	Owner string
	Repo  string
}

func unpackMigrationsStartImportParams(packed map[string]any) (params MigrationsStartImportParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeMigrationsStartImportParams(args [2]string, r *http.Request) (params MigrationsStartImportParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// MigrationsUnlockRepoForAuthenticatedUserParams is parameters of migrations/unlock-repo-for-authenticated-user operation.
type MigrationsUnlockRepoForAuthenticatedUserParams struct {
	// Migration_id parameter.
	MigrationID int
	// Repo_name parameter.
	RepoName string
}

func unpackMigrationsUnlockRepoForAuthenticatedUserParams(packed map[string]any) (params MigrationsUnlockRepoForAuthenticatedUserParams) {
	params.MigrationID = packed["migration_id"].(int)
	params.RepoName = packed["repo_name"].(string)
	return params
}

func decodeMigrationsUnlockRepoForAuthenticatedUserParams(args [2]string, r *http.Request) (params MigrationsUnlockRepoForAuthenticatedUserParams, _ error) {
	// Decode path: migration_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: migration_id: parse")
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	// Decode path: repo_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RepoName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo_name: parse")
			}
		} else {
			return params, errors.New("path: repo_name: not specified")
		}
	}
	return params, nil
}

// MigrationsUnlockRepoForOrgParams is parameters of migrations/unlock-repo-for-org operation.
type MigrationsUnlockRepoForOrgParams struct {
	Org string
	// Migration_id parameter.
	MigrationID int
	// Repo_name parameter.
	RepoName string
}

func unpackMigrationsUnlockRepoForOrgParams(packed map[string]any) (params MigrationsUnlockRepoForOrgParams) {
	params.Org = packed["org"].(string)
	params.MigrationID = packed["migration_id"].(int)
	params.RepoName = packed["repo_name"].(string)
	return params
}

func decodeMigrationsUnlockRepoForOrgParams(args [3]string, r *http.Request) (params MigrationsUnlockRepoForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: migration_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "migration_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.MigrationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: migration_id: parse")
			}
		} else {
			return params, errors.New("path: migration_id: not specified")
		}
	}
	// Decode path: repo_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.RepoName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo_name: parse")
			}
		} else {
			return params, errors.New("path: repo_name: not specified")
		}
	}
	return params, nil
}

// MigrationsUpdateImportParams is parameters of migrations/update-import operation.
type MigrationsUpdateImportParams struct {
	Owner string
	Repo  string
}

func unpackMigrationsUpdateImportParams(packed map[string]any) (params MigrationsUpdateImportParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeMigrationsUpdateImportParams(args [2]string, r *http.Request) (params MigrationsUpdateImportParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// OAuthAuthorizationsDeleteAuthorizationParams is parameters of oauth-authorizations/delete-authorization operation.
type OAuthAuthorizationsDeleteAuthorizationParams struct {
	// Authorization_id parameter.
	AuthorizationID int
}

func unpackOAuthAuthorizationsDeleteAuthorizationParams(packed map[string]any) (params OAuthAuthorizationsDeleteAuthorizationParams) {
	params.AuthorizationID = packed["authorization_id"].(int)
	return params
}

func decodeOAuthAuthorizationsDeleteAuthorizationParams(args [1]string, r *http.Request) (params OAuthAuthorizationsDeleteAuthorizationParams, _ error) {
	// Decode path: authorization_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "authorization_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AuthorizationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: authorization_id: parse")
			}
		} else {
			return params, errors.New("path: authorization_id: not specified")
		}
	}
	return params, nil
}

// OAuthAuthorizationsDeleteGrantParams is parameters of oauth-authorizations/delete-grant operation.
type OAuthAuthorizationsDeleteGrantParams struct {
	// Grant_id parameter.
	GrantID int
}

func unpackOAuthAuthorizationsDeleteGrantParams(packed map[string]any) (params OAuthAuthorizationsDeleteGrantParams) {
	params.GrantID = packed["grant_id"].(int)
	return params
}

func decodeOAuthAuthorizationsDeleteGrantParams(args [1]string, r *http.Request) (params OAuthAuthorizationsDeleteGrantParams, _ error) {
	// Decode path: grant_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "grant_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.GrantID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: grant_id: parse")
			}
		} else {
			return params, errors.New("path: grant_id: not specified")
		}
	}
	return params, nil
}

// OAuthAuthorizationsGetAuthorizationParams is parameters of oauth-authorizations/get-authorization operation.
type OAuthAuthorizationsGetAuthorizationParams struct {
	// Authorization_id parameter.
	AuthorizationID int
}

func unpackOAuthAuthorizationsGetAuthorizationParams(packed map[string]any) (params OAuthAuthorizationsGetAuthorizationParams) {
	params.AuthorizationID = packed["authorization_id"].(int)
	return params
}

func decodeOAuthAuthorizationsGetAuthorizationParams(args [1]string, r *http.Request) (params OAuthAuthorizationsGetAuthorizationParams, _ error) {
	// Decode path: authorization_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "authorization_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AuthorizationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: authorization_id: parse")
			}
		} else {
			return params, errors.New("path: authorization_id: not specified")
		}
	}
	return params, nil
}

// OAuthAuthorizationsGetGrantParams is parameters of oauth-authorizations/get-grant operation.
type OAuthAuthorizationsGetGrantParams struct {
	// Grant_id parameter.
	GrantID int
}

func unpackOAuthAuthorizationsGetGrantParams(packed map[string]any) (params OAuthAuthorizationsGetGrantParams) {
	params.GrantID = packed["grant_id"].(int)
	return params
}

func decodeOAuthAuthorizationsGetGrantParams(args [1]string, r *http.Request) (params OAuthAuthorizationsGetGrantParams, _ error) {
	// Decode path: grant_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "grant_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.GrantID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: grant_id: parse")
			}
		} else {
			return params, errors.New("path: grant_id: not specified")
		}
	}
	return params, nil
}

// OAuthAuthorizationsGetOrCreateAuthorizationForAppParams is parameters of oauth-authorizations/get-or-create-authorization-for-app operation.
type OAuthAuthorizationsGetOrCreateAuthorizationForAppParams struct {
	// The client ID of your GitHub app.
	ClientID string
}

func unpackOAuthAuthorizationsGetOrCreateAuthorizationForAppParams(packed map[string]any) (params OAuthAuthorizationsGetOrCreateAuthorizationForAppParams) {
	params.ClientID = packed["client_id"].(string)
	return params
}

func decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppParams(args [1]string, r *http.Request) (params OAuthAuthorizationsGetOrCreateAuthorizationForAppParams, _ error) {
	// Decode path: client_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: client_id: parse")
			}
		} else {
			return params, errors.New("path: client_id: not specified")
		}
	}
	return params, nil
}

// OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams is parameters of oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint operation.
type OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams struct {
	// The client ID of your GitHub app.
	ClientID    string
	Fingerprint string
}

func unpackOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams(packed map[string]any) (params OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams) {
	params.ClientID = packed["client_id"].(string)
	params.Fingerprint = packed["fingerprint"].(string)
	return params
}

func decodeOAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams(args [2]string, r *http.Request) (params OAuthAuthorizationsGetOrCreateAuthorizationForAppAndFingerprintParams, _ error) {
	// Decode path: client_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "client_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ClientID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: client_id: parse")
			}
		} else {
			return params, errors.New("path: client_id: not specified")
		}
	}
	// Decode path: fingerprint.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "fingerprint",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Fingerprint = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: fingerprint: parse")
			}
		} else {
			return params, errors.New("path: fingerprint: not specified")
		}
	}
	return params, nil
}

// OAuthAuthorizationsListAuthorizationsParams is parameters of oauth-authorizations/list-authorizations operation.
type OAuthAuthorizationsListAuthorizationsParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// The client ID of your GitHub app.
	ClientID OptString `json:",omitempty"`
}

func unpackOAuthAuthorizationsListAuthorizationsParams(packed map[string]any) (params OAuthAuthorizationsListAuthorizationsParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["client_id"]; ok {
		params.ClientID = v.(OptString)
	}
	return params
}

func decodeOAuthAuthorizationsListAuthorizationsParams(args [0]string, r *http.Request) (params OAuthAuthorizationsListAuthorizationsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: client_id.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "client_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotClientIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotClientIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ClientID.SetTo(paramsDotClientIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: client_id: parse")
			}
		}
	}
	return params, nil
}

// OAuthAuthorizationsListGrantsParams is parameters of oauth-authorizations/list-grants operation.
type OAuthAuthorizationsListGrantsParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// The client ID of your GitHub app.
	ClientID OptString `json:",omitempty"`
}

func unpackOAuthAuthorizationsListGrantsParams(packed map[string]any) (params OAuthAuthorizationsListGrantsParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["client_id"]; ok {
		params.ClientID = v.(OptString)
	}
	return params
}

func decodeOAuthAuthorizationsListGrantsParams(args [0]string, r *http.Request) (params OAuthAuthorizationsListGrantsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: client_id.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "client_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotClientIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotClientIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ClientID.SetTo(paramsDotClientIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: client_id: parse")
			}
		}
	}
	return params, nil
}

// OAuthAuthorizationsUpdateAuthorizationParams is parameters of oauth-authorizations/update-authorization operation.
type OAuthAuthorizationsUpdateAuthorizationParams struct {
	// Authorization_id parameter.
	AuthorizationID int
}

func unpackOAuthAuthorizationsUpdateAuthorizationParams(packed map[string]any) (params OAuthAuthorizationsUpdateAuthorizationParams) {
	params.AuthorizationID = packed["authorization_id"].(int)
	return params
}

func decodeOAuthAuthorizationsUpdateAuthorizationParams(args [1]string, r *http.Request) (params OAuthAuthorizationsUpdateAuthorizationParams, _ error) {
	// Decode path: authorization_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "authorization_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AuthorizationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: authorization_id: parse")
			}
		} else {
			return params, errors.New("path: authorization_id: not specified")
		}
	}
	return params, nil
}

// OrgsBlockUserParams is parameters of orgs/block-user operation.
type OrgsBlockUserParams struct {
	Org      string
	Username string
}

func unpackOrgsBlockUserParams(packed map[string]any) (params OrgsBlockUserParams) {
	params.Org = packed["org"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeOrgsBlockUserParams(args [2]string, r *http.Request) (params OrgsBlockUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// OrgsCancelInvitationParams is parameters of orgs/cancel-invitation operation.
type OrgsCancelInvitationParams struct {
	Org string
	// Invitation_id parameter.
	InvitationID int
}

func unpackOrgsCancelInvitationParams(packed map[string]any) (params OrgsCancelInvitationParams) {
	params.Org = packed["org"].(string)
	params.InvitationID = packed["invitation_id"].(int)
	return params
}

func decodeOrgsCancelInvitationParams(args [2]string, r *http.Request) (params OrgsCancelInvitationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: invitation_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: invitation_id: parse")
			}
		} else {
			return params, errors.New("path: invitation_id: not specified")
		}
	}
	return params, nil
}

// OrgsCheckBlockedUserParams is parameters of orgs/check-blocked-user operation.
type OrgsCheckBlockedUserParams struct {
	Org      string
	Username string
}

func unpackOrgsCheckBlockedUserParams(packed map[string]any) (params OrgsCheckBlockedUserParams) {
	params.Org = packed["org"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeOrgsCheckBlockedUserParams(args [2]string, r *http.Request) (params OrgsCheckBlockedUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// OrgsCheckMembershipForUserParams is parameters of orgs/check-membership-for-user operation.
type OrgsCheckMembershipForUserParams struct {
	Org      string
	Username string
}

func unpackOrgsCheckMembershipForUserParams(packed map[string]any) (params OrgsCheckMembershipForUserParams) {
	params.Org = packed["org"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeOrgsCheckMembershipForUserParams(args [2]string, r *http.Request) (params OrgsCheckMembershipForUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// OrgsCheckPublicMembershipForUserParams is parameters of orgs/check-public-membership-for-user operation.
type OrgsCheckPublicMembershipForUserParams struct {
	Org      string
	Username string
}

func unpackOrgsCheckPublicMembershipForUserParams(packed map[string]any) (params OrgsCheckPublicMembershipForUserParams) {
	params.Org = packed["org"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeOrgsCheckPublicMembershipForUserParams(args [2]string, r *http.Request) (params OrgsCheckPublicMembershipForUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// OrgsConvertMemberToOutsideCollaboratorParams is parameters of orgs/convert-member-to-outside-collaborator operation.
type OrgsConvertMemberToOutsideCollaboratorParams struct {
	Org      string
	Username string
}

func unpackOrgsConvertMemberToOutsideCollaboratorParams(packed map[string]any) (params OrgsConvertMemberToOutsideCollaboratorParams) {
	params.Org = packed["org"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeOrgsConvertMemberToOutsideCollaboratorParams(args [2]string, r *http.Request) (params OrgsConvertMemberToOutsideCollaboratorParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// OrgsCreateInvitationParams is parameters of orgs/create-invitation operation.
type OrgsCreateInvitationParams struct {
	Org string
}

func unpackOrgsCreateInvitationParams(packed map[string]any) (params OrgsCreateInvitationParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeOrgsCreateInvitationParams(args [1]string, r *http.Request) (params OrgsCreateInvitationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// OrgsCreateWebhookParams is parameters of orgs/create-webhook operation.
type OrgsCreateWebhookParams struct {
	Org string
}

func unpackOrgsCreateWebhookParams(packed map[string]any) (params OrgsCreateWebhookParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeOrgsCreateWebhookParams(args [1]string, r *http.Request) (params OrgsCreateWebhookParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// OrgsDeleteWebhookParams is parameters of orgs/delete-webhook operation.
type OrgsDeleteWebhookParams struct {
	Org    string
	HookID int
}

func unpackOrgsDeleteWebhookParams(packed map[string]any) (params OrgsDeleteWebhookParams) {
	params.Org = packed["org"].(string)
	params.HookID = packed["hook_id"].(int)
	return params
}

func decodeOrgsDeleteWebhookParams(args [2]string, r *http.Request) (params OrgsDeleteWebhookParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

// OrgsGetParams is parameters of orgs/get operation.
type OrgsGetParams struct {
	Org string
}

func unpackOrgsGetParams(packed map[string]any) (params OrgsGetParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeOrgsGetParams(args [1]string, r *http.Request) (params OrgsGetParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// OrgsGetAuditLogParams is parameters of orgs/get-audit-log operation.
type OrgsGetAuditLogParams struct {
	Org string
	// A search phrase. For more information, see [Searching the audit log](https://docs.github.
	// com/github/setting-up-and-managing-organizations-and-teams/reviewing-the-audit-log-for-your-organization#searching-the-audit-log).
	Phrase OptString `json:",omitempty"`
	// The event types to include:
	// - `web` - returns web (non-Git) events
	// - `git` - returns Git events
	// - `all` - returns both web and Git events
	// The default is `web`.
	Include OptOrgsGetAuditLogInclude `json:",omitempty"`
	// A cursor, as given in the [Link header](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#link-header). If specified, the query only searches
	// for events after this cursor.
	After OptString `json:",omitempty"`
	// A cursor, as given in the [Link header](https://docs.github.
	// com/rest/overview/resources-in-the-rest-api#link-header). If specified, the query only searches
	// for events before this cursor.
	Before OptString `json:",omitempty"`
	// The order of audit log events. To list newest events first, specify `desc`. To list oldest events
	// first, specify `asc`.
	// The default is `desc`.
	Order OptOrgsGetAuditLogOrder `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackOrgsGetAuditLogParams(packed map[string]any) (params OrgsGetAuditLogParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["phrase"]; ok {
		params.Phrase = v.(OptString)
	}
	if v, ok := packed["include"]; ok {
		params.Include = v.(OptOrgsGetAuditLogInclude)
	}
	if v, ok := packed["after"]; ok {
		params.After = v.(OptString)
	}
	if v, ok := packed["before"]; ok {
		params.Before = v.(OptString)
	}
	if v, ok := packed["order"]; ok {
		params.Order = v.(OptOrgsGetAuditLogOrder)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeOrgsGetAuditLogParams(args [1]string, r *http.Request) (params OrgsGetAuditLogParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode query: phrase.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "phrase",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPhraseVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPhraseVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Phrase.SetTo(paramsDotPhraseVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: phrase: parse")
			}
		}
	}
	// Decode query: include.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIncludeVal OrgsGetAuditLogInclude
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotIncludeVal = OrgsGetAuditLogInclude(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Include.SetTo(paramsDotIncludeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: include: parse")
			}
			if err := func() error {
				if params.Include.Set {
					if err := func() error {
						if err := params.Include.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: include: invalid")
			}
		}
	}
	// Decode query: after.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAfterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAfterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.After.SetTo(paramsDotAfterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: after: parse")
			}
		}
	}
	// Decode query: before.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsDotBeforeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before: parse")
			}
		}
	}
	// Decode query: order.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal OrgsGetAuditLogOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = OrgsGetAuditLogOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: order: parse")
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: order: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// OrgsGetMembershipForAuthenticatedUserParams is parameters of orgs/get-membership-for-authenticated-user operation.
type OrgsGetMembershipForAuthenticatedUserParams struct {
	Org string
}

func unpackOrgsGetMembershipForAuthenticatedUserParams(packed map[string]any) (params OrgsGetMembershipForAuthenticatedUserParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeOrgsGetMembershipForAuthenticatedUserParams(args [1]string, r *http.Request) (params OrgsGetMembershipForAuthenticatedUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// OrgsGetMembershipForUserParams is parameters of orgs/get-membership-for-user operation.
type OrgsGetMembershipForUserParams struct {
	Org      string
	Username string
}

func unpackOrgsGetMembershipForUserParams(packed map[string]any) (params OrgsGetMembershipForUserParams) {
	params.Org = packed["org"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeOrgsGetMembershipForUserParams(args [2]string, r *http.Request) (params OrgsGetMembershipForUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// OrgsGetWebhookParams is parameters of orgs/get-webhook operation.
type OrgsGetWebhookParams struct {
	Org    string
	HookID int
}

func unpackOrgsGetWebhookParams(packed map[string]any) (params OrgsGetWebhookParams) {
	params.Org = packed["org"].(string)
	params.HookID = packed["hook_id"].(int)
	return params
}

func decodeOrgsGetWebhookParams(args [2]string, r *http.Request) (params OrgsGetWebhookParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

// OrgsGetWebhookConfigForOrgParams is parameters of orgs/get-webhook-config-for-org operation.
type OrgsGetWebhookConfigForOrgParams struct {
	Org    string
	HookID int
}

func unpackOrgsGetWebhookConfigForOrgParams(packed map[string]any) (params OrgsGetWebhookConfigForOrgParams) {
	params.Org = packed["org"].(string)
	params.HookID = packed["hook_id"].(int)
	return params
}

func decodeOrgsGetWebhookConfigForOrgParams(args [2]string, r *http.Request) (params OrgsGetWebhookConfigForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

// OrgsGetWebhookDeliveryParams is parameters of orgs/get-webhook-delivery operation.
type OrgsGetWebhookDeliveryParams struct {
	Org        string
	HookID     int
	DeliveryID int
}

func unpackOrgsGetWebhookDeliveryParams(packed map[string]any) (params OrgsGetWebhookDeliveryParams) {
	params.Org = packed["org"].(string)
	params.HookID = packed["hook_id"].(int)
	params.DeliveryID = packed["delivery_id"].(int)
	return params
}

func decodeOrgsGetWebhookDeliveryParams(args [3]string, r *http.Request) (params OrgsGetWebhookDeliveryParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	// Decode path: delivery_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: delivery_id: parse")
			}
		} else {
			return params, errors.New("path: delivery_id: not specified")
		}
	}
	return params, nil
}

// OrgsListParams is parameters of orgs/list operation.
type OrgsListParams struct {
	// An organization ID. Only return organizations with an ID greater than this ID.
	Since OptInt `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
}

func unpackOrgsListParams(packed map[string]any) (params OrgsListParams) {
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptInt)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	return params
}

func decodeOrgsListParams(args [0]string, r *http.Request) (params OrgsListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	return params, nil
}

// OrgsListBlockedUsersParams is parameters of orgs/list-blocked-users operation.
type OrgsListBlockedUsersParams struct {
	Org string
}

func unpackOrgsListBlockedUsersParams(packed map[string]any) (params OrgsListBlockedUsersParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeOrgsListBlockedUsersParams(args [1]string, r *http.Request) (params OrgsListBlockedUsersParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// OrgsListFailedInvitationsParams is parameters of orgs/list-failed-invitations operation.
type OrgsListFailedInvitationsParams struct {
	Org string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackOrgsListFailedInvitationsParams(packed map[string]any) (params OrgsListFailedInvitationsParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeOrgsListFailedInvitationsParams(args [1]string, r *http.Request) (params OrgsListFailedInvitationsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// OrgsListForAuthenticatedUserParams is parameters of orgs/list-for-authenticated-user operation.
type OrgsListForAuthenticatedUserParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackOrgsListForAuthenticatedUserParams(packed map[string]any) (params OrgsListForAuthenticatedUserParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeOrgsListForAuthenticatedUserParams(args [0]string, r *http.Request) (params OrgsListForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// OrgsListForUserParams is parameters of orgs/list-for-user operation.
type OrgsListForUserParams struct {
	Username string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackOrgsListForUserParams(packed map[string]any) (params OrgsListForUserParams) {
	params.Username = packed["username"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeOrgsListForUserParams(args [1]string, r *http.Request) (params OrgsListForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// OrgsListInvitationTeamsParams is parameters of orgs/list-invitation-teams operation.
type OrgsListInvitationTeamsParams struct {
	Org string
	// Invitation_id parameter.
	InvitationID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackOrgsListInvitationTeamsParams(packed map[string]any) (params OrgsListInvitationTeamsParams) {
	params.Org = packed["org"].(string)
	params.InvitationID = packed["invitation_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeOrgsListInvitationTeamsParams(args [2]string, r *http.Request) (params OrgsListInvitationTeamsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: invitation_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: invitation_id: parse")
			}
		} else {
			return params, errors.New("path: invitation_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// OrgsListMembersParams is parameters of orgs/list-members operation.
type OrgsListMembersParams struct {
	Org string
	// Filter members returned in the list. Can be one of:
	// \* `2fa_disabled` - Members without [two-factor authentication](https://github.
	// com/blog/1614-two-factor-authentication) enabled. Available for organization owners.
	// \* `all` - All members the authenticated user can see.
	Filter OptOrgsListMembersFilter `json:",omitempty"`
	// Filter members returned by their role. Can be one of:
	// \* `all` - All members of the organization, regardless of role.
	// \* `admin` - Organization owners.
	// \* `member` - Non-owner organization members.
	Role OptOrgsListMembersRole `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackOrgsListMembersParams(packed map[string]any) (params OrgsListMembersParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["filter"]; ok {
		params.Filter = v.(OptOrgsListMembersFilter)
	}
	if v, ok := packed["role"]; ok {
		params.Role = v.(OptOrgsListMembersRole)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeOrgsListMembersParams(args [1]string, r *http.Request) (params OrgsListMembersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: filter.
	{
		val := OrgsListMembersFilter("all")
		params.Filter.SetTo(val)
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal OrgsListMembersFilter
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = OrgsListMembersFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: filter: invalid")
			}
		}
	}
	// Set default value for query: role.
	{
		val := OrgsListMembersRole("all")
		params.Role.SetTo(val)
	}
	// Decode query: role.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "role",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRoleVal OrgsListMembersRole
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRoleVal = OrgsListMembersRole(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Role.SetTo(paramsDotRoleVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: role: parse")
			}
			if err := func() error {
				if params.Role.Set {
					if err := func() error {
						if err := params.Role.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: role: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// OrgsListMembershipsForAuthenticatedUserParams is parameters of orgs/list-memberships-for-authenticated-user operation.
type OrgsListMembershipsForAuthenticatedUserParams struct {
	// Indicates the state of the memberships to return. Can be either `active` or `pending`. If not
	// specified, the API returns both active and pending memberships.
	State OptOrgsListMembershipsForAuthenticatedUserState `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackOrgsListMembershipsForAuthenticatedUserParams(packed map[string]any) (params OrgsListMembershipsForAuthenticatedUserParams) {
	if v, ok := packed["state"]; ok {
		params.State = v.(OptOrgsListMembershipsForAuthenticatedUserState)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeOrgsListMembershipsForAuthenticatedUserParams(args [0]string, r *http.Request) (params OrgsListMembershipsForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal OrgsListMembershipsForAuthenticatedUserState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = OrgsListMembershipsForAuthenticatedUserState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// OrgsListOutsideCollaboratorsParams is parameters of orgs/list-outside-collaborators operation.
type OrgsListOutsideCollaboratorsParams struct {
	Org string
	// Filter the list of outside collaborators. Can be one of:
	// \* `2fa_disabled`: Outside collaborators without [two-factor authentication](https://github.
	// com/blog/1614-two-factor-authentication) enabled.
	// \* `all`: All outside collaborators.
	Filter OptOrgsListOutsideCollaboratorsFilter `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackOrgsListOutsideCollaboratorsParams(packed map[string]any) (params OrgsListOutsideCollaboratorsParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["filter"]; ok {
		params.Filter = v.(OptOrgsListOutsideCollaboratorsFilter)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeOrgsListOutsideCollaboratorsParams(args [1]string, r *http.Request) (params OrgsListOutsideCollaboratorsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: filter.
	{
		val := OrgsListOutsideCollaboratorsFilter("all")
		params.Filter.SetTo(val)
	}
	// Decode query: filter.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal OrgsListOutsideCollaboratorsFilter
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = OrgsListOutsideCollaboratorsFilter(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: filter: parse")
			}
			if err := func() error {
				if params.Filter.Set {
					if err := func() error {
						if err := params.Filter.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: filter: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// OrgsListPendingInvitationsParams is parameters of orgs/list-pending-invitations operation.
type OrgsListPendingInvitationsParams struct {
	Org string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackOrgsListPendingInvitationsParams(packed map[string]any) (params OrgsListPendingInvitationsParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeOrgsListPendingInvitationsParams(args [1]string, r *http.Request) (params OrgsListPendingInvitationsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// OrgsListPublicMembersParams is parameters of orgs/list-public-members operation.
type OrgsListPublicMembersParams struct {
	Org string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackOrgsListPublicMembersParams(packed map[string]any) (params OrgsListPublicMembersParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeOrgsListPublicMembersParams(args [1]string, r *http.Request) (params OrgsListPublicMembersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// OrgsListSamlSSOAuthorizationsParams is parameters of orgs/list-saml-sso-authorizations operation.
type OrgsListSamlSSOAuthorizationsParams struct {
	Org string
}

func unpackOrgsListSamlSSOAuthorizationsParams(packed map[string]any) (params OrgsListSamlSSOAuthorizationsParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeOrgsListSamlSSOAuthorizationsParams(args [1]string, r *http.Request) (params OrgsListSamlSSOAuthorizationsParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// OrgsListWebhookDeliveriesParams is parameters of orgs/list-webhook-deliveries operation.
type OrgsListWebhookDeliveriesParams struct {
	Org    string
	HookID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to
	// the `link` header for the next and previous page cursors.
	Cursor OptString `json:",omitempty"`
}

func unpackOrgsListWebhookDeliveriesParams(packed map[string]any) (params OrgsListWebhookDeliveriesParams) {
	params.Org = packed["org"].(string)
	params.HookID = packed["hook_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["cursor"]; ok {
		params.Cursor = v.(OptString)
	}
	return params
}

func decodeOrgsListWebhookDeliveriesParams(args [2]string, r *http.Request) (params OrgsListWebhookDeliveriesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode query: cursor.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: cursor: parse")
			}
		}
	}
	return params, nil
}

// OrgsListWebhooksParams is parameters of orgs/list-webhooks operation.
type OrgsListWebhooksParams struct {
	Org string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackOrgsListWebhooksParams(packed map[string]any) (params OrgsListWebhooksParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeOrgsListWebhooksParams(args [1]string, r *http.Request) (params OrgsListWebhooksParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// OrgsPingWebhookParams is parameters of orgs/ping-webhook operation.
type OrgsPingWebhookParams struct {
	Org    string
	HookID int
}

func unpackOrgsPingWebhookParams(packed map[string]any) (params OrgsPingWebhookParams) {
	params.Org = packed["org"].(string)
	params.HookID = packed["hook_id"].(int)
	return params
}

func decodeOrgsPingWebhookParams(args [2]string, r *http.Request) (params OrgsPingWebhookParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

// OrgsRedeliverWebhookDeliveryParams is parameters of orgs/redeliver-webhook-delivery operation.
type OrgsRedeliverWebhookDeliveryParams struct {
	Org        string
	HookID     int
	DeliveryID int
}

func unpackOrgsRedeliverWebhookDeliveryParams(packed map[string]any) (params OrgsRedeliverWebhookDeliveryParams) {
	params.Org = packed["org"].(string)
	params.HookID = packed["hook_id"].(int)
	params.DeliveryID = packed["delivery_id"].(int)
	return params
}

func decodeOrgsRedeliverWebhookDeliveryParams(args [3]string, r *http.Request) (params OrgsRedeliverWebhookDeliveryParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	// Decode path: delivery_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: delivery_id: parse")
			}
		} else {
			return params, errors.New("path: delivery_id: not specified")
		}
	}
	return params, nil
}

// OrgsRemoveMemberParams is parameters of orgs/remove-member operation.
type OrgsRemoveMemberParams struct {
	Org      string
	Username string
}

func unpackOrgsRemoveMemberParams(packed map[string]any) (params OrgsRemoveMemberParams) {
	params.Org = packed["org"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeOrgsRemoveMemberParams(args [2]string, r *http.Request) (params OrgsRemoveMemberParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// OrgsRemoveMembershipForUserParams is parameters of orgs/remove-membership-for-user operation.
type OrgsRemoveMembershipForUserParams struct {
	Org      string
	Username string
}

func unpackOrgsRemoveMembershipForUserParams(packed map[string]any) (params OrgsRemoveMembershipForUserParams) {
	params.Org = packed["org"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeOrgsRemoveMembershipForUserParams(args [2]string, r *http.Request) (params OrgsRemoveMembershipForUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// OrgsRemoveOutsideCollaboratorParams is parameters of orgs/remove-outside-collaborator operation.
type OrgsRemoveOutsideCollaboratorParams struct {
	Org      string
	Username string
}

func unpackOrgsRemoveOutsideCollaboratorParams(packed map[string]any) (params OrgsRemoveOutsideCollaboratorParams) {
	params.Org = packed["org"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeOrgsRemoveOutsideCollaboratorParams(args [2]string, r *http.Request) (params OrgsRemoveOutsideCollaboratorParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// OrgsRemovePublicMembershipForAuthenticatedUserParams is parameters of orgs/remove-public-membership-for-authenticated-user operation.
type OrgsRemovePublicMembershipForAuthenticatedUserParams struct {
	Org      string
	Username string
}

func unpackOrgsRemovePublicMembershipForAuthenticatedUserParams(packed map[string]any) (params OrgsRemovePublicMembershipForAuthenticatedUserParams) {
	params.Org = packed["org"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeOrgsRemovePublicMembershipForAuthenticatedUserParams(args [2]string, r *http.Request) (params OrgsRemovePublicMembershipForAuthenticatedUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// OrgsRemoveSamlSSOAuthorizationParams is parameters of orgs/remove-saml-sso-authorization operation.
type OrgsRemoveSamlSSOAuthorizationParams struct {
	Org          string
	CredentialID int
}

func unpackOrgsRemoveSamlSSOAuthorizationParams(packed map[string]any) (params OrgsRemoveSamlSSOAuthorizationParams) {
	params.Org = packed["org"].(string)
	params.CredentialID = packed["credential_id"].(int)
	return params
}

func decodeOrgsRemoveSamlSSOAuthorizationParams(args [2]string, r *http.Request) (params OrgsRemoveSamlSSOAuthorizationParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: credential_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "credential_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CredentialID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: credential_id: parse")
			}
		} else {
			return params, errors.New("path: credential_id: not specified")
		}
	}
	return params, nil
}

// OrgsSetMembershipForUserParams is parameters of orgs/set-membership-for-user operation.
type OrgsSetMembershipForUserParams struct {
	Org      string
	Username string
}

func unpackOrgsSetMembershipForUserParams(packed map[string]any) (params OrgsSetMembershipForUserParams) {
	params.Org = packed["org"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeOrgsSetMembershipForUserParams(args [2]string, r *http.Request) (params OrgsSetMembershipForUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// OrgsSetPublicMembershipForAuthenticatedUserParams is parameters of orgs/set-public-membership-for-authenticated-user operation.
type OrgsSetPublicMembershipForAuthenticatedUserParams struct {
	Org      string
	Username string
}

func unpackOrgsSetPublicMembershipForAuthenticatedUserParams(packed map[string]any) (params OrgsSetPublicMembershipForAuthenticatedUserParams) {
	params.Org = packed["org"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeOrgsSetPublicMembershipForAuthenticatedUserParams(args [2]string, r *http.Request) (params OrgsSetPublicMembershipForAuthenticatedUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// OrgsUnblockUserParams is parameters of orgs/unblock-user operation.
type OrgsUnblockUserParams struct {
	Org      string
	Username string
}

func unpackOrgsUnblockUserParams(packed map[string]any) (params OrgsUnblockUserParams) {
	params.Org = packed["org"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeOrgsUnblockUserParams(args [2]string, r *http.Request) (params OrgsUnblockUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// OrgsUpdateMembershipForAuthenticatedUserParams is parameters of orgs/update-membership-for-authenticated-user operation.
type OrgsUpdateMembershipForAuthenticatedUserParams struct {
	Org string
}

func unpackOrgsUpdateMembershipForAuthenticatedUserParams(packed map[string]any) (params OrgsUpdateMembershipForAuthenticatedUserParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeOrgsUpdateMembershipForAuthenticatedUserParams(args [1]string, r *http.Request) (params OrgsUpdateMembershipForAuthenticatedUserParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// OrgsUpdateWebhookParams is parameters of orgs/update-webhook operation.
type OrgsUpdateWebhookParams struct {
	Org    string
	HookID int
}

func unpackOrgsUpdateWebhookParams(packed map[string]any) (params OrgsUpdateWebhookParams) {
	params.Org = packed["org"].(string)
	params.HookID = packed["hook_id"].(int)
	return params
}

func decodeOrgsUpdateWebhookParams(args [2]string, r *http.Request) (params OrgsUpdateWebhookParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

// OrgsUpdateWebhookConfigForOrgParams is parameters of orgs/update-webhook-config-for-org operation.
type OrgsUpdateWebhookConfigForOrgParams struct {
	Org    string
	HookID int
}

func unpackOrgsUpdateWebhookConfigForOrgParams(packed map[string]any) (params OrgsUpdateWebhookConfigForOrgParams) {
	params.Org = packed["org"].(string)
	params.HookID = packed["hook_id"].(int)
	return params
}

func decodeOrgsUpdateWebhookConfigForOrgParams(args [2]string, r *http.Request) (params OrgsUpdateWebhookConfigForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

// PackagesDeletePackageForAuthenticatedUserParams is parameters of packages/delete-package-for-authenticated-user operation.
type PackagesDeletePackageForAuthenticatedUserParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesDeletePackageForAuthenticatedUserPackageType
	// The name of the package.
	PackageName string
}

func unpackPackagesDeletePackageForAuthenticatedUserParams(packed map[string]any) (params PackagesDeletePackageForAuthenticatedUserParams) {
	params.PackageType = packed["package_type"].(PackagesDeletePackageForAuthenticatedUserPackageType)
	params.PackageName = packed["package_name"].(string)
	return params
}

func decodePackagesDeletePackageForAuthenticatedUserParams(args [2]string, r *http.Request) (params PackagesDeletePackageForAuthenticatedUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	return params, nil
}

// PackagesDeletePackageForOrgParams is parameters of packages/delete-package-for-org operation.
type PackagesDeletePackageForOrgParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesDeletePackageForOrgPackageType
	// The name of the package.
	PackageName string
	Org         string
}

func unpackPackagesDeletePackageForOrgParams(packed map[string]any) (params PackagesDeletePackageForOrgParams) {
	params.PackageType = packed["package_type"].(PackagesDeletePackageForOrgPackageType)
	params.PackageName = packed["package_name"].(string)
	params.Org = packed["org"].(string)
	return params
}

func decodePackagesDeletePackageForOrgParams(args [3]string, r *http.Request) (params PackagesDeletePackageForOrgParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageForOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// PackagesDeletePackageForUserParams is parameters of packages/delete-package-for-user operation.
type PackagesDeletePackageForUserParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesDeletePackageForUserPackageType
	// The name of the package.
	PackageName string
	Username    string
}

func unpackPackagesDeletePackageForUserParams(packed map[string]any) (params PackagesDeletePackageForUserParams) {
	params.PackageType = packed["package_type"].(PackagesDeletePackageForUserPackageType)
	params.PackageName = packed["package_name"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodePackagesDeletePackageForUserParams(args [3]string, r *http.Request) (params PackagesDeletePackageForUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// PackagesDeletePackageVersionForAuthenticatedUserParams is parameters of packages/delete-package-version-for-authenticated-user operation.
type PackagesDeletePackageVersionForAuthenticatedUserParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesDeletePackageVersionForAuthenticatedUserPackageType
	// The name of the package.
	PackageName string
	// Unique identifier of the package version.
	PackageVersionID int
}

func unpackPackagesDeletePackageVersionForAuthenticatedUserParams(packed map[string]any) (params PackagesDeletePackageVersionForAuthenticatedUserParams) {
	params.PackageType = packed["package_type"].(PackagesDeletePackageVersionForAuthenticatedUserPackageType)
	params.PackageName = packed["package_name"].(string)
	params.PackageVersionID = packed["package_version_id"].(int)
	return params
}

func decodePackagesDeletePackageVersionForAuthenticatedUserParams(args [3]string, r *http.Request) (params PackagesDeletePackageVersionForAuthenticatedUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageVersionForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_version_id: parse")
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	return params, nil
}

// PackagesDeletePackageVersionForOrgParams is parameters of packages/delete-package-version-for-org operation.
type PackagesDeletePackageVersionForOrgParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesDeletePackageVersionForOrgPackageType
	// The name of the package.
	PackageName string
	Org         string
	// Unique identifier of the package version.
	PackageVersionID int
}

func unpackPackagesDeletePackageVersionForOrgParams(packed map[string]any) (params PackagesDeletePackageVersionForOrgParams) {
	params.PackageType = packed["package_type"].(PackagesDeletePackageVersionForOrgPackageType)
	params.PackageName = packed["package_name"].(string)
	params.Org = packed["org"].(string)
	params.PackageVersionID = packed["package_version_id"].(int)
	return params
}

func decodePackagesDeletePackageVersionForOrgParams(args [4]string, r *http.Request) (params PackagesDeletePackageVersionForOrgParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageVersionForOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_version_id: parse")
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	return params, nil
}

// PackagesDeletePackageVersionForUserParams is parameters of packages/delete-package-version-for-user operation.
type PackagesDeletePackageVersionForUserParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesDeletePackageVersionForUserPackageType
	// The name of the package.
	PackageName string
	Username    string
	// Unique identifier of the package version.
	PackageVersionID int
}

func unpackPackagesDeletePackageVersionForUserParams(packed map[string]any) (params PackagesDeletePackageVersionForUserParams) {
	params.PackageType = packed["package_type"].(PackagesDeletePackageVersionForUserPackageType)
	params.PackageName = packed["package_name"].(string)
	params.Username = packed["username"].(string)
	params.PackageVersionID = packed["package_version_id"].(int)
	return params
}

func decodePackagesDeletePackageVersionForUserParams(args [4]string, r *http.Request) (params PackagesDeletePackageVersionForUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesDeletePackageVersionForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_version_id: parse")
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	return params, nil
}

// PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams is parameters of packages/get-all-package-versions-for-package-owned-by-authenticated-user operation.
type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType
	// The name of the package.
	PackageName string
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// The state of the package, either active or deleted.
	State OptPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState `json:",omitempty"`
}

func unpackPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams(packed map[string]any) (params PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams) {
	params.PackageType = packed["package_type"].(PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType)
	params.PackageName = packed["package_name"].(string)
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["state"]; ok {
		params.State = v.(OptPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState)
	}
	return params
}

func decodePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams(args [2]string, r *http.Request) (params PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: package_type.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: state.
	{
		val := PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState("active")
		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	return params, nil
}

// PackagesGetAllPackageVersionsForPackageOwnedByOrgParams is parameters of packages/get-all-package-versions-for-package-owned-by-org operation.
type PackagesGetAllPackageVersionsForPackageOwnedByOrgParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType
	// The name of the package.
	PackageName string
	Org         string
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// The state of the package, either active or deleted.
	State OptPackagesGetAllPackageVersionsForPackageOwnedByOrgState `json:",omitempty"`
}

func unpackPackagesGetAllPackageVersionsForPackageOwnedByOrgParams(packed map[string]any) (params PackagesGetAllPackageVersionsForPackageOwnedByOrgParams) {
	params.PackageType = packed["package_type"].(PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType)
	params.PackageName = packed["package_name"].(string)
	params.Org = packed["org"].(string)
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["state"]; ok {
		params.State = v.(OptPackagesGetAllPackageVersionsForPackageOwnedByOrgState)
	}
	return params
}

func decodePackagesGetAllPackageVersionsForPackageOwnedByOrgParams(args [3]string, r *http.Request) (params PackagesGetAllPackageVersionsForPackageOwnedByOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: state.
	{
		val := PackagesGetAllPackageVersionsForPackageOwnedByOrgState("active")
		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal PackagesGetAllPackageVersionsForPackageOwnedByOrgState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = PackagesGetAllPackageVersionsForPackageOwnedByOrgState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	return params, nil
}

// PackagesGetAllPackageVersionsForPackageOwnedByUserParams is parameters of packages/get-all-package-versions-for-package-owned-by-user operation.
type PackagesGetAllPackageVersionsForPackageOwnedByUserParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType
	// The name of the package.
	PackageName string
	Username    string
}

func unpackPackagesGetAllPackageVersionsForPackageOwnedByUserParams(packed map[string]any) (params PackagesGetAllPackageVersionsForPackageOwnedByUserParams) {
	params.PackageType = packed["package_type"].(PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType)
	params.PackageName = packed["package_name"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodePackagesGetAllPackageVersionsForPackageOwnedByUserParams(args [3]string, r *http.Request) (params PackagesGetAllPackageVersionsForPackageOwnedByUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// PackagesGetPackageForAuthenticatedUserParams is parameters of packages/get-package-for-authenticated-user operation.
type PackagesGetPackageForAuthenticatedUserParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesGetPackageForAuthenticatedUserPackageType
	// The name of the package.
	PackageName string
}

func unpackPackagesGetPackageForAuthenticatedUserParams(packed map[string]any) (params PackagesGetPackageForAuthenticatedUserParams) {
	params.PackageType = packed["package_type"].(PackagesGetPackageForAuthenticatedUserPackageType)
	params.PackageName = packed["package_name"].(string)
	return params
}

func decodePackagesGetPackageForAuthenticatedUserParams(args [2]string, r *http.Request) (params PackagesGetPackageForAuthenticatedUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	return params, nil
}

// PackagesGetPackageForOrganizationParams is parameters of packages/get-package-for-organization operation.
type PackagesGetPackageForOrganizationParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesGetPackageForOrganizationPackageType
	// The name of the package.
	PackageName string
	Org         string
}

func unpackPackagesGetPackageForOrganizationParams(packed map[string]any) (params PackagesGetPackageForOrganizationParams) {
	params.PackageType = packed["package_type"].(PackagesGetPackageForOrganizationPackageType)
	params.PackageName = packed["package_name"].(string)
	params.Org = packed["org"].(string)
	return params
}

func decodePackagesGetPackageForOrganizationParams(args [3]string, r *http.Request) (params PackagesGetPackageForOrganizationParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageForOrganizationPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// PackagesGetPackageForUserParams is parameters of packages/get-package-for-user operation.
type PackagesGetPackageForUserParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesGetPackageForUserPackageType
	// The name of the package.
	PackageName string
	Username    string
}

func unpackPackagesGetPackageForUserParams(packed map[string]any) (params PackagesGetPackageForUserParams) {
	params.PackageType = packed["package_type"].(PackagesGetPackageForUserPackageType)
	params.PackageName = packed["package_name"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodePackagesGetPackageForUserParams(args [3]string, r *http.Request) (params PackagesGetPackageForUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// PackagesGetPackageVersionForAuthenticatedUserParams is parameters of packages/get-package-version-for-authenticated-user operation.
type PackagesGetPackageVersionForAuthenticatedUserParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesGetPackageVersionForAuthenticatedUserPackageType
	// The name of the package.
	PackageName string
	// Unique identifier of the package version.
	PackageVersionID int
}

func unpackPackagesGetPackageVersionForAuthenticatedUserParams(packed map[string]any) (params PackagesGetPackageVersionForAuthenticatedUserParams) {
	params.PackageType = packed["package_type"].(PackagesGetPackageVersionForAuthenticatedUserPackageType)
	params.PackageName = packed["package_name"].(string)
	params.PackageVersionID = packed["package_version_id"].(int)
	return params
}

func decodePackagesGetPackageVersionForAuthenticatedUserParams(args [3]string, r *http.Request) (params PackagesGetPackageVersionForAuthenticatedUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageVersionForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_version_id: parse")
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	return params, nil
}

// PackagesGetPackageVersionForOrganizationParams is parameters of packages/get-package-version-for-organization operation.
type PackagesGetPackageVersionForOrganizationParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesGetPackageVersionForOrganizationPackageType
	// The name of the package.
	PackageName string
	Org         string
	// Unique identifier of the package version.
	PackageVersionID int
}

func unpackPackagesGetPackageVersionForOrganizationParams(packed map[string]any) (params PackagesGetPackageVersionForOrganizationParams) {
	params.PackageType = packed["package_type"].(PackagesGetPackageVersionForOrganizationPackageType)
	params.PackageName = packed["package_name"].(string)
	params.Org = packed["org"].(string)
	params.PackageVersionID = packed["package_version_id"].(int)
	return params
}

func decodePackagesGetPackageVersionForOrganizationParams(args [4]string, r *http.Request) (params PackagesGetPackageVersionForOrganizationParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageVersionForOrganizationPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_version_id: parse")
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	return params, nil
}

// PackagesGetPackageVersionForUserParams is parameters of packages/get-package-version-for-user operation.
type PackagesGetPackageVersionForUserParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesGetPackageVersionForUserPackageType
	// The name of the package.
	PackageName string
	// Unique identifier of the package version.
	PackageVersionID int
	Username         string
}

func unpackPackagesGetPackageVersionForUserParams(packed map[string]any) (params PackagesGetPackageVersionForUserParams) {
	params.PackageType = packed["package_type"].(PackagesGetPackageVersionForUserPackageType)
	params.PackageName = packed["package_name"].(string)
	params.PackageVersionID = packed["package_version_id"].(int)
	params.Username = packed["username"].(string)
	return params
}

func decodePackagesGetPackageVersionForUserParams(args [4]string, r *http.Request) (params PackagesGetPackageVersionForUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesGetPackageVersionForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_version_id: parse")
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// PackagesListPackagesForAuthenticatedUserParams is parameters of packages/list-packages-for-authenticated-user operation.
type PackagesListPackagesForAuthenticatedUserParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesListPackagesForAuthenticatedUserPackageType
	// The selected visibility of the packages. Can be one of `public`, `private`, or `internal`. Only
	// `container` package_types currently support `internal` visibility properly. For other ecosystems
	// `internal` is synonymous with `private`. This parameter is optional and only filters an existing
	// result set.
	Visibility OptPackagesListPackagesForAuthenticatedUserVisibility `json:",omitempty"`
}

func unpackPackagesListPackagesForAuthenticatedUserParams(packed map[string]any) (params PackagesListPackagesForAuthenticatedUserParams) {
	params.PackageType = packed["package_type"].(PackagesListPackagesForAuthenticatedUserPackageType)
	if v, ok := packed["visibility"]; ok {
		params.Visibility = v.(OptPackagesListPackagesForAuthenticatedUserVisibility)
	}
	return params
}

func decodePackagesListPackagesForAuthenticatedUserParams(args [0]string, r *http.Request) (params PackagesListPackagesForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: package_type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "package_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesListPackagesForAuthenticatedUserPackageType(c)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: package_type: invalid")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: visibility.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "visibility",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVisibilityVal PackagesListPackagesForAuthenticatedUserVisibility
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVisibilityVal = PackagesListPackagesForAuthenticatedUserVisibility(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Visibility.SetTo(paramsDotVisibilityVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: visibility: parse")
			}
			if err := func() error {
				if params.Visibility.Set {
					if err := func() error {
						if err := params.Visibility.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: visibility: invalid")
			}
		}
	}
	return params, nil
}

// PackagesListPackagesForOrganizationParams is parameters of packages/list-packages-for-organization operation.
type PackagesListPackagesForOrganizationParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesListPackagesForOrganizationPackageType
	Org         string
	// The selected visibility of the packages. Can be one of `public`, `private`, or `internal`. Only
	// `container` package_types currently support `internal` visibility properly. For other ecosystems
	// `internal` is synonymous with `private`. This parameter is optional and only filters an existing
	// result set.
	Visibility OptPackagesListPackagesForOrganizationVisibility `json:",omitempty"`
}

func unpackPackagesListPackagesForOrganizationParams(packed map[string]any) (params PackagesListPackagesForOrganizationParams) {
	params.PackageType = packed["package_type"].(PackagesListPackagesForOrganizationPackageType)
	params.Org = packed["org"].(string)
	if v, ok := packed["visibility"]; ok {
		params.Visibility = v.(OptPackagesListPackagesForOrganizationVisibility)
	}
	return params
}

func decodePackagesListPackagesForOrganizationParams(args [1]string, r *http.Request) (params PackagesListPackagesForOrganizationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: package_type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "package_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesListPackagesForOrganizationPackageType(c)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: package_type: invalid")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode query: visibility.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "visibility",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVisibilityVal PackagesListPackagesForOrganizationVisibility
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVisibilityVal = PackagesListPackagesForOrganizationVisibility(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Visibility.SetTo(paramsDotVisibilityVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: visibility: parse")
			}
			if err := func() error {
				if params.Visibility.Set {
					if err := func() error {
						if err := params.Visibility.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: visibility: invalid")
			}
		}
	}
	return params, nil
}

// PackagesListPackagesForUserParams is parameters of packages/list-packages-for-user operation.
type PackagesListPackagesForUserParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesListPackagesForUserPackageType
	// The selected visibility of the packages. Can be one of `public`, `private`, or `internal`. Only
	// `container` package_types currently support `internal` visibility properly. For other ecosystems
	// `internal` is synonymous with `private`. This parameter is optional and only filters an existing
	// result set.
	Visibility OptPackagesListPackagesForUserVisibility `json:",omitempty"`
	Username   string
}

func unpackPackagesListPackagesForUserParams(packed map[string]any) (params PackagesListPackagesForUserParams) {
	params.PackageType = packed["package_type"].(PackagesListPackagesForUserPackageType)
	if v, ok := packed["visibility"]; ok {
		params.Visibility = v.(OptPackagesListPackagesForUserVisibility)
	}
	params.Username = packed["username"].(string)
	return params
}

func decodePackagesListPackagesForUserParams(args [1]string, r *http.Request) (params PackagesListPackagesForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: package_type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "package_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesListPackagesForUserPackageType(c)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: package_type: invalid")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: visibility.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "visibility",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVisibilityVal PackagesListPackagesForUserVisibility
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVisibilityVal = PackagesListPackagesForUserVisibility(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Visibility.SetTo(paramsDotVisibilityVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: visibility: parse")
			}
			if err := func() error {
				if params.Visibility.Set {
					if err := func() error {
						if err := params.Visibility.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: visibility: invalid")
			}
		}
	}
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// PackagesRestorePackageForAuthenticatedUserParams is parameters of packages/restore-package-for-authenticated-user operation.
type PackagesRestorePackageForAuthenticatedUserParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesRestorePackageForAuthenticatedUserPackageType
	// The name of the package.
	PackageName string
	// Package token.
	Token OptString `json:",omitempty"`
}

func unpackPackagesRestorePackageForAuthenticatedUserParams(packed map[string]any) (params PackagesRestorePackageForAuthenticatedUserParams) {
	params.PackageType = packed["package_type"].(PackagesRestorePackageForAuthenticatedUserPackageType)
	params.PackageName = packed["package_name"].(string)
	if v, ok := packed["token"]; ok {
		params.Token = v.(OptString)
	}
	return params
}

func decodePackagesRestorePackageForAuthenticatedUserParams(args [2]string, r *http.Request) (params PackagesRestorePackageForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: package_type.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode query: token.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Token.SetTo(paramsDotTokenVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: token: parse")
			}
		}
	}
	return params, nil
}

// PackagesRestorePackageForOrgParams is parameters of packages/restore-package-for-org operation.
type PackagesRestorePackageForOrgParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesRestorePackageForOrgPackageType
	// The name of the package.
	PackageName string
	Org         string
	// Package token.
	Token OptString `json:",omitempty"`
}

func unpackPackagesRestorePackageForOrgParams(packed map[string]any) (params PackagesRestorePackageForOrgParams) {
	params.PackageType = packed["package_type"].(PackagesRestorePackageForOrgPackageType)
	params.PackageName = packed["package_name"].(string)
	params.Org = packed["org"].(string)
	if v, ok := packed["token"]; ok {
		params.Token = v.(OptString)
	}
	return params
}

func decodePackagesRestorePackageForOrgParams(args [3]string, r *http.Request) (params PackagesRestorePackageForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageForOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode query: token.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Token.SetTo(paramsDotTokenVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: token: parse")
			}
		}
	}
	return params, nil
}

// PackagesRestorePackageForUserParams is parameters of packages/restore-package-for-user operation.
type PackagesRestorePackageForUserParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesRestorePackageForUserPackageType
	// The name of the package.
	PackageName string
	Username    string
	// Package token.
	Token OptString `json:",omitempty"`
}

func unpackPackagesRestorePackageForUserParams(packed map[string]any) (params PackagesRestorePackageForUserParams) {
	params.PackageType = packed["package_type"].(PackagesRestorePackageForUserPackageType)
	params.PackageName = packed["package_name"].(string)
	params.Username = packed["username"].(string)
	if v, ok := packed["token"]; ok {
		params.Token = v.(OptString)
	}
	return params
}

func decodePackagesRestorePackageForUserParams(args [3]string, r *http.Request) (params PackagesRestorePackageForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Decode query: token.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTokenVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTokenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Token.SetTo(paramsDotTokenVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: token: parse")
			}
		}
	}
	return params, nil
}

// PackagesRestorePackageVersionForAuthenticatedUserParams is parameters of packages/restore-package-version-for-authenticated-user operation.
type PackagesRestorePackageVersionForAuthenticatedUserParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesRestorePackageVersionForAuthenticatedUserPackageType
	// The name of the package.
	PackageName string
	// Unique identifier of the package version.
	PackageVersionID int
}

func unpackPackagesRestorePackageVersionForAuthenticatedUserParams(packed map[string]any) (params PackagesRestorePackageVersionForAuthenticatedUserParams) {
	params.PackageType = packed["package_type"].(PackagesRestorePackageVersionForAuthenticatedUserPackageType)
	params.PackageName = packed["package_name"].(string)
	params.PackageVersionID = packed["package_version_id"].(int)
	return params
}

func decodePackagesRestorePackageVersionForAuthenticatedUserParams(args [3]string, r *http.Request) (params PackagesRestorePackageVersionForAuthenticatedUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageVersionForAuthenticatedUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_version_id: parse")
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	return params, nil
}

// PackagesRestorePackageVersionForOrgParams is parameters of packages/restore-package-version-for-org operation.
type PackagesRestorePackageVersionForOrgParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesRestorePackageVersionForOrgPackageType
	// The name of the package.
	PackageName string
	Org         string
	// Unique identifier of the package version.
	PackageVersionID int
}

func unpackPackagesRestorePackageVersionForOrgParams(packed map[string]any) (params PackagesRestorePackageVersionForOrgParams) {
	params.PackageType = packed["package_type"].(PackagesRestorePackageVersionForOrgPackageType)
	params.PackageName = packed["package_name"].(string)
	params.Org = packed["org"].(string)
	params.PackageVersionID = packed["package_version_id"].(int)
	return params
}

func decodePackagesRestorePackageVersionForOrgParams(args [4]string, r *http.Request) (params PackagesRestorePackageVersionForOrgParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageVersionForOrgPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_version_id: parse")
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	return params, nil
}

// PackagesRestorePackageVersionForUserParams is parameters of packages/restore-package-version-for-user operation.
type PackagesRestorePackageVersionForUserParams struct {
	// The type of supported package. Can be one of `npm`, `maven`, `rubygems`, `nuget`, `docker`, or
	// `container`. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to
	// GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker`
	// to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if
	// these have now been migrated to the Container registry.
	PackageType PackagesRestorePackageVersionForUserPackageType
	// The name of the package.
	PackageName string
	Username    string
	// Unique identifier of the package version.
	PackageVersionID int
}

func unpackPackagesRestorePackageVersionForUserParams(packed map[string]any) (params PackagesRestorePackageVersionForUserParams) {
	params.PackageType = packed["package_type"].(PackagesRestorePackageVersionForUserPackageType)
	params.PackageName = packed["package_name"].(string)
	params.Username = packed["username"].(string)
	params.PackageVersionID = packed["package_version_id"].(int)
	return params
}

func decodePackagesRestorePackageVersionForUserParams(args [4]string, r *http.Request) (params PackagesRestorePackageVersionForUserParams, _ error) {
	// Decode path: package_type.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_type",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageType = PackagesRestorePackageVersionForUserPackageType(c)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: parse")
			}
			if err := func() error {
				if err := params.PackageType.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_type: invalid")
			}
		} else {
			return params, errors.New("path: package_type: not specified")
		}
	}
	// Decode path: package_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.PackageName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_name: parse")
			}
		} else {
			return params, errors.New("path: package_name: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Decode path: package_version_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "package_version_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PackageVersionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: package_version_id: parse")
			}
		} else {
			return params, errors.New("path: package_version_id: not specified")
		}
	}
	return params, nil
}

// ProjectsAddCollaboratorParams is parameters of projects/add-collaborator operation.
type ProjectsAddCollaboratorParams struct {
	ProjectID int
	Username  string
}

func unpackProjectsAddCollaboratorParams(packed map[string]any) (params ProjectsAddCollaboratorParams) {
	params.ProjectID = packed["project_id"].(int)
	params.Username = packed["username"].(string)
	return params
}

func decodeProjectsAddCollaboratorParams(args [2]string, r *http.Request) (params ProjectsAddCollaboratorParams, _ error) {
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: project_id: parse")
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// ProjectsCreateColumnParams is parameters of projects/create-column operation.
type ProjectsCreateColumnParams struct {
	ProjectID int
}

func unpackProjectsCreateColumnParams(packed map[string]any) (params ProjectsCreateColumnParams) {
	params.ProjectID = packed["project_id"].(int)
	return params
}

func decodeProjectsCreateColumnParams(args [1]string, r *http.Request) (params ProjectsCreateColumnParams, _ error) {
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: project_id: parse")
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

// ProjectsCreateForOrgParams is parameters of projects/create-for-org operation.
type ProjectsCreateForOrgParams struct {
	Org string
}

func unpackProjectsCreateForOrgParams(packed map[string]any) (params ProjectsCreateForOrgParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeProjectsCreateForOrgParams(args [1]string, r *http.Request) (params ProjectsCreateForOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// ProjectsCreateForRepoParams is parameters of projects/create-for-repo operation.
type ProjectsCreateForRepoParams struct {
	Owner string
	Repo  string
}

func unpackProjectsCreateForRepoParams(packed map[string]any) (params ProjectsCreateForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeProjectsCreateForRepoParams(args [2]string, r *http.Request) (params ProjectsCreateForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ProjectsDeleteParams is parameters of projects/delete operation.
type ProjectsDeleteParams struct {
	ProjectID int
}

func unpackProjectsDeleteParams(packed map[string]any) (params ProjectsDeleteParams) {
	params.ProjectID = packed["project_id"].(int)
	return params
}

func decodeProjectsDeleteParams(args [1]string, r *http.Request) (params ProjectsDeleteParams, _ error) {
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: project_id: parse")
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

// ProjectsDeleteCardParams is parameters of projects/delete-card operation.
type ProjectsDeleteCardParams struct {
	// Card_id parameter.
	CardID int
}

func unpackProjectsDeleteCardParams(packed map[string]any) (params ProjectsDeleteCardParams) {
	params.CardID = packed["card_id"].(int)
	return params
}

func decodeProjectsDeleteCardParams(args [1]string, r *http.Request) (params ProjectsDeleteCardParams, _ error) {
	// Decode path: card_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "card_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CardID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: card_id: parse")
			}
		} else {
			return params, errors.New("path: card_id: not specified")
		}
	}
	return params, nil
}

// ProjectsDeleteColumnParams is parameters of projects/delete-column operation.
type ProjectsDeleteColumnParams struct {
	// Column_id parameter.
	ColumnID int
}

func unpackProjectsDeleteColumnParams(packed map[string]any) (params ProjectsDeleteColumnParams) {
	params.ColumnID = packed["column_id"].(int)
	return params
}

func decodeProjectsDeleteColumnParams(args [1]string, r *http.Request) (params ProjectsDeleteColumnParams, _ error) {
	// Decode path: column_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: column_id: parse")
			}
		} else {
			return params, errors.New("path: column_id: not specified")
		}
	}
	return params, nil
}

// ProjectsGetParams is parameters of projects/get operation.
type ProjectsGetParams struct {
	ProjectID int
}

func unpackProjectsGetParams(packed map[string]any) (params ProjectsGetParams) {
	params.ProjectID = packed["project_id"].(int)
	return params
}

func decodeProjectsGetParams(args [1]string, r *http.Request) (params ProjectsGetParams, _ error) {
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: project_id: parse")
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

// ProjectsGetCardParams is parameters of projects/get-card operation.
type ProjectsGetCardParams struct {
	// Card_id parameter.
	CardID int
}

func unpackProjectsGetCardParams(packed map[string]any) (params ProjectsGetCardParams) {
	params.CardID = packed["card_id"].(int)
	return params
}

func decodeProjectsGetCardParams(args [1]string, r *http.Request) (params ProjectsGetCardParams, _ error) {
	// Decode path: card_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "card_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CardID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: card_id: parse")
			}
		} else {
			return params, errors.New("path: card_id: not specified")
		}
	}
	return params, nil
}

// ProjectsGetColumnParams is parameters of projects/get-column operation.
type ProjectsGetColumnParams struct {
	// Column_id parameter.
	ColumnID int
}

func unpackProjectsGetColumnParams(packed map[string]any) (params ProjectsGetColumnParams) {
	params.ColumnID = packed["column_id"].(int)
	return params
}

func decodeProjectsGetColumnParams(args [1]string, r *http.Request) (params ProjectsGetColumnParams, _ error) {
	// Decode path: column_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: column_id: parse")
			}
		} else {
			return params, errors.New("path: column_id: not specified")
		}
	}
	return params, nil
}

// ProjectsGetPermissionForUserParams is parameters of projects/get-permission-for-user operation.
type ProjectsGetPermissionForUserParams struct {
	ProjectID int
	Username  string
}

func unpackProjectsGetPermissionForUserParams(packed map[string]any) (params ProjectsGetPermissionForUserParams) {
	params.ProjectID = packed["project_id"].(int)
	params.Username = packed["username"].(string)
	return params
}

func decodeProjectsGetPermissionForUserParams(args [2]string, r *http.Request) (params ProjectsGetPermissionForUserParams, _ error) {
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: project_id: parse")
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// ProjectsListCardsParams is parameters of projects/list-cards operation.
type ProjectsListCardsParams struct {
	// Column_id parameter.
	ColumnID int
	// Filters the project cards that are returned by the card's state. Can be one of `all`,`archived`,
	// or `not_archived`.
	ArchivedState OptProjectsListCardsArchivedState `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackProjectsListCardsParams(packed map[string]any) (params ProjectsListCardsParams) {
	params.ColumnID = packed["column_id"].(int)
	if v, ok := packed["archived_state"]; ok {
		params.ArchivedState = v.(OptProjectsListCardsArchivedState)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeProjectsListCardsParams(args [1]string, r *http.Request) (params ProjectsListCardsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: column_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: column_id: parse")
			}
		} else {
			return params, errors.New("path: column_id: not specified")
		}
	}
	// Set default value for query: archived_state.
	{
		val := ProjectsListCardsArchivedState("not_archived")
		params.ArchivedState.SetTo(val)
	}
	// Decode query: archived_state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "archived_state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotArchivedStateVal ProjectsListCardsArchivedState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotArchivedStateVal = ProjectsListCardsArchivedState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.ArchivedState.SetTo(paramsDotArchivedStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: archived_state: parse")
			}
			if err := func() error {
				if params.ArchivedState.Set {
					if err := func() error {
						if err := params.ArchivedState.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: archived_state: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ProjectsListCollaboratorsParams is parameters of projects/list-collaborators operation.
type ProjectsListCollaboratorsParams struct {
	ProjectID int
	// Filters the collaborators by their affiliation. Can be one of:
	// \* `outside`: Outside collaborators of a project that are not a member of the project's
	// organization.
	// \* `direct`: Collaborators with permissions to a project, regardless of organization membership
	// status.
	// \* `all`: All collaborators the authenticated user can see.
	Affiliation OptProjectsListCollaboratorsAffiliation `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackProjectsListCollaboratorsParams(packed map[string]any) (params ProjectsListCollaboratorsParams) {
	params.ProjectID = packed["project_id"].(int)
	if v, ok := packed["affiliation"]; ok {
		params.Affiliation = v.(OptProjectsListCollaboratorsAffiliation)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeProjectsListCollaboratorsParams(args [1]string, r *http.Request) (params ProjectsListCollaboratorsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: project_id: parse")
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	// Set default value for query: affiliation.
	{
		val := ProjectsListCollaboratorsAffiliation("all")
		params.Affiliation.SetTo(val)
	}
	// Decode query: affiliation.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "affiliation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAffiliationVal ProjectsListCollaboratorsAffiliation
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAffiliationVal = ProjectsListCollaboratorsAffiliation(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Affiliation.SetTo(paramsDotAffiliationVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: affiliation: parse")
			}
			if err := func() error {
				if params.Affiliation.Set {
					if err := func() error {
						if err := params.Affiliation.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: affiliation: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ProjectsListColumnsParams is parameters of projects/list-columns operation.
type ProjectsListColumnsParams struct {
	ProjectID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackProjectsListColumnsParams(packed map[string]any) (params ProjectsListColumnsParams) {
	params.ProjectID = packed["project_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeProjectsListColumnsParams(args [1]string, r *http.Request) (params ProjectsListColumnsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: project_id: parse")
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ProjectsListForOrgParams is parameters of projects/list-for-org operation.
type ProjectsListForOrgParams struct {
	Org string
	// Indicates the state of the projects to return. Can be either `open`, `closed`, or `all`.
	State OptProjectsListForOrgState `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackProjectsListForOrgParams(packed map[string]any) (params ProjectsListForOrgParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["state"]; ok {
		params.State = v.(OptProjectsListForOrgState)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeProjectsListForOrgParams(args [1]string, r *http.Request) (params ProjectsListForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: state.
	{
		val := ProjectsListForOrgState("open")
		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal ProjectsListForOrgState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = ProjectsListForOrgState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ProjectsListForRepoParams is parameters of projects/list-for-repo operation.
type ProjectsListForRepoParams struct {
	Owner string
	Repo  string
	// Indicates the state of the projects to return. Can be either `open`, `closed`, or `all`.
	State OptProjectsListForRepoState `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackProjectsListForRepoParams(packed map[string]any) (params ProjectsListForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["state"]; ok {
		params.State = v.(OptProjectsListForRepoState)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeProjectsListForRepoParams(args [2]string, r *http.Request) (params ProjectsListForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: state.
	{
		val := ProjectsListForRepoState("open")
		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal ProjectsListForRepoState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = ProjectsListForRepoState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ProjectsListForUserParams is parameters of projects/list-for-user operation.
type ProjectsListForUserParams struct {
	Username string
	// Indicates the state of the projects to return. Can be either `open`, `closed`, or `all`.
	State OptProjectsListForUserState `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackProjectsListForUserParams(packed map[string]any) (params ProjectsListForUserParams) {
	params.Username = packed["username"].(string)
	if v, ok := packed["state"]; ok {
		params.State = v.(OptProjectsListForUserState)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeProjectsListForUserParams(args [1]string, r *http.Request) (params ProjectsListForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: state.
	{
		val := ProjectsListForUserState("open")
		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal ProjectsListForUserState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = ProjectsListForUserState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ProjectsMoveCardParams is parameters of projects/move-card operation.
type ProjectsMoveCardParams struct {
	// Card_id parameter.
	CardID int
}

func unpackProjectsMoveCardParams(packed map[string]any) (params ProjectsMoveCardParams) {
	params.CardID = packed["card_id"].(int)
	return params
}

func decodeProjectsMoveCardParams(args [1]string, r *http.Request) (params ProjectsMoveCardParams, _ error) {
	// Decode path: card_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "card_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CardID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: card_id: parse")
			}
		} else {
			return params, errors.New("path: card_id: not specified")
		}
	}
	return params, nil
}

// ProjectsMoveColumnParams is parameters of projects/move-column operation.
type ProjectsMoveColumnParams struct {
	// Column_id parameter.
	ColumnID int
}

func unpackProjectsMoveColumnParams(packed map[string]any) (params ProjectsMoveColumnParams) {
	params.ColumnID = packed["column_id"].(int)
	return params
}

func decodeProjectsMoveColumnParams(args [1]string, r *http.Request) (params ProjectsMoveColumnParams, _ error) {
	// Decode path: column_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: column_id: parse")
			}
		} else {
			return params, errors.New("path: column_id: not specified")
		}
	}
	return params, nil
}

// ProjectsRemoveCollaboratorParams is parameters of projects/remove-collaborator operation.
type ProjectsRemoveCollaboratorParams struct {
	ProjectID int
	Username  string
}

func unpackProjectsRemoveCollaboratorParams(packed map[string]any) (params ProjectsRemoveCollaboratorParams) {
	params.ProjectID = packed["project_id"].(int)
	params.Username = packed["username"].(string)
	return params
}

func decodeProjectsRemoveCollaboratorParams(args [2]string, r *http.Request) (params ProjectsRemoveCollaboratorParams, _ error) {
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: project_id: parse")
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// ProjectsUpdateParams is parameters of projects/update operation.
type ProjectsUpdateParams struct {
	ProjectID int
}

func unpackProjectsUpdateParams(packed map[string]any) (params ProjectsUpdateParams) {
	params.ProjectID = packed["project_id"].(int)
	return params
}

func decodeProjectsUpdateParams(args [1]string, r *http.Request) (params ProjectsUpdateParams, _ error) {
	// Decode path: project_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: project_id: parse")
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

// ProjectsUpdateCardParams is parameters of projects/update-card operation.
type ProjectsUpdateCardParams struct {
	// Card_id parameter.
	CardID int
}

func unpackProjectsUpdateCardParams(packed map[string]any) (params ProjectsUpdateCardParams) {
	params.CardID = packed["card_id"].(int)
	return params
}

func decodeProjectsUpdateCardParams(args [1]string, r *http.Request) (params ProjectsUpdateCardParams, _ error) {
	// Decode path: card_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "card_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CardID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: card_id: parse")
			}
		} else {
			return params, errors.New("path: card_id: not specified")
		}
	}
	return params, nil
}

// ProjectsUpdateColumnParams is parameters of projects/update-column operation.
type ProjectsUpdateColumnParams struct {
	// Column_id parameter.
	ColumnID int
}

func unpackProjectsUpdateColumnParams(packed map[string]any) (params ProjectsUpdateColumnParams) {
	params.ColumnID = packed["column_id"].(int)
	return params
}

func decodeProjectsUpdateColumnParams(args [1]string, r *http.Request) (params ProjectsUpdateColumnParams, _ error) {
	// Decode path: column_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "column_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ColumnID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: column_id: parse")
			}
		} else {
			return params, errors.New("path: column_id: not specified")
		}
	}
	return params, nil
}

// PullsCheckIfMergedParams is parameters of pulls/check-if-merged operation.
type PullsCheckIfMergedParams struct {
	Owner      string
	Repo       string
	PullNumber int
}

func unpackPullsCheckIfMergedParams(packed map[string]any) (params PullsCheckIfMergedParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	return params
}

func decodePullsCheckIfMergedParams(args [3]string, r *http.Request) (params PullsCheckIfMergedParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	return params, nil
}

// PullsCreateParams is parameters of pulls/create operation.
type PullsCreateParams struct {
	Owner string
	Repo  string
}

func unpackPullsCreateParams(packed map[string]any) (params PullsCreateParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodePullsCreateParams(args [2]string, r *http.Request) (params PullsCreateParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// PullsCreateReplyForReviewCommentParams is parameters of pulls/create-reply-for-review-comment operation.
type PullsCreateReplyForReviewCommentParams struct {
	Owner      string
	Repo       string
	PullNumber int
	// Comment_id parameter.
	CommentID int
}

func unpackPullsCreateReplyForReviewCommentParams(packed map[string]any) (params PullsCreateReplyForReviewCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	params.CommentID = packed["comment_id"].(int)
	return params
}

func decodePullsCreateReplyForReviewCommentParams(args [4]string, r *http.Request) (params PullsCreateReplyForReviewCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

// PullsCreateReviewParams is parameters of pulls/create-review operation.
type PullsCreateReviewParams struct {
	Owner      string
	Repo       string
	PullNumber int
}

func unpackPullsCreateReviewParams(packed map[string]any) (params PullsCreateReviewParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	return params
}

func decodePullsCreateReviewParams(args [3]string, r *http.Request) (params PullsCreateReviewParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	return params, nil
}

// PullsCreateReviewCommentParams is parameters of pulls/create-review-comment operation.
type PullsCreateReviewCommentParams struct {
	Owner      string
	Repo       string
	PullNumber int
}

func unpackPullsCreateReviewCommentParams(packed map[string]any) (params PullsCreateReviewCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	return params
}

func decodePullsCreateReviewCommentParams(args [3]string, r *http.Request) (params PullsCreateReviewCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	return params, nil
}

// PullsDeletePendingReviewParams is parameters of pulls/delete-pending-review operation.
type PullsDeletePendingReviewParams struct {
	Owner      string
	Repo       string
	PullNumber int
	// Review_id parameter.
	ReviewID int
}

func unpackPullsDeletePendingReviewParams(packed map[string]any) (params PullsDeletePendingReviewParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	params.ReviewID = packed["review_id"].(int)
	return params
}

func decodePullsDeletePendingReviewParams(args [4]string, r *http.Request) (params PullsDeletePendingReviewParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Decode path: review_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: review_id: parse")
			}
		} else {
			return params, errors.New("path: review_id: not specified")
		}
	}
	return params, nil
}

// PullsDeleteReviewCommentParams is parameters of pulls/delete-review-comment operation.
type PullsDeleteReviewCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID int
}

func unpackPullsDeleteReviewCommentParams(packed map[string]any) (params PullsDeleteReviewCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	return params
}

func decodePullsDeleteReviewCommentParams(args [3]string, r *http.Request) (params PullsDeleteReviewCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

// PullsDismissReviewParams is parameters of pulls/dismiss-review operation.
type PullsDismissReviewParams struct {
	Owner      string
	Repo       string
	PullNumber int
	// Review_id parameter.
	ReviewID int
}

func unpackPullsDismissReviewParams(packed map[string]any) (params PullsDismissReviewParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	params.ReviewID = packed["review_id"].(int)
	return params
}

func decodePullsDismissReviewParams(args [4]string, r *http.Request) (params PullsDismissReviewParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Decode path: review_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: review_id: parse")
			}
		} else {
			return params, errors.New("path: review_id: not specified")
		}
	}
	return params, nil
}

// PullsGetParams is parameters of pulls/get operation.
type PullsGetParams struct {
	Owner      string
	Repo       string
	PullNumber int
}

func unpackPullsGetParams(packed map[string]any) (params PullsGetParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	return params
}

func decodePullsGetParams(args [3]string, r *http.Request) (params PullsGetParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	return params, nil
}

// PullsGetReviewParams is parameters of pulls/get-review operation.
type PullsGetReviewParams struct {
	Owner      string
	Repo       string
	PullNumber int
	// Review_id parameter.
	ReviewID int
}

func unpackPullsGetReviewParams(packed map[string]any) (params PullsGetReviewParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	params.ReviewID = packed["review_id"].(int)
	return params
}

func decodePullsGetReviewParams(args [4]string, r *http.Request) (params PullsGetReviewParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Decode path: review_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: review_id: parse")
			}
		} else {
			return params, errors.New("path: review_id: not specified")
		}
	}
	return params, nil
}

// PullsGetReviewCommentParams is parameters of pulls/get-review-comment operation.
type PullsGetReviewCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID int
}

func unpackPullsGetReviewCommentParams(packed map[string]any) (params PullsGetReviewCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	return params
}

func decodePullsGetReviewCommentParams(args [3]string, r *http.Request) (params PullsGetReviewCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

// PullsListParams is parameters of pulls/list operation.
type PullsListParams struct {
	Owner string
	Repo  string
	// Either `open`, `closed`, or `all` to filter by state.
	State OptPullsListState `json:",omitempty"`
	// Filter pulls by head user or head organization and branch name in the format of `user:ref-name` or
	// `organization:ref-name`. For example: `github:new-script-format` or `octocat:test-branch`.
	Head OptString `json:",omitempty"`
	// Filter pulls by base branch name. Example: `gh-pages`.
	Base OptString `json:",omitempty"`
	// What to sort results by. Can be either `created`, `updated`, `popularity` (comment count) or
	// `long-running` (age, filtering by pulls updated in the last month).
	Sort OptPullsListSort `json:",omitempty"`
	// The direction of the sort. Can be either `asc` or `desc`. Default: `desc` when sort is `created`
	// or sort is not specified, otherwise `asc`.
	Direction OptPullsListDirection `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackPullsListParams(packed map[string]any) (params PullsListParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["state"]; ok {
		params.State = v.(OptPullsListState)
	}
	if v, ok := packed["head"]; ok {
		params.Head = v.(OptString)
	}
	if v, ok := packed["base"]; ok {
		params.Base = v.(OptString)
	}
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptPullsListSort)
	}
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptPullsListDirection)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodePullsListParams(args [2]string, r *http.Request) (params PullsListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: state.
	{
		val := PullsListState("open")
		params.State.SetTo(val)
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal PullsListState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = PullsListState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Decode query: head.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "head",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotHeadVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotHeadVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Head.SetTo(paramsDotHeadVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: head: parse")
			}
		}
	}
	// Decode query: base.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "base",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBaseVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotBaseVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Base.SetTo(paramsDotBaseVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: base: parse")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := PullsListSort("created")
		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal PullsListSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = PullsListSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal PullsListDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = PullsListDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// PullsListCommentsForReviewParams is parameters of pulls/list-comments-for-review operation.
type PullsListCommentsForReviewParams struct {
	Owner      string
	Repo       string
	PullNumber int
	// Review_id parameter.
	ReviewID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackPullsListCommentsForReviewParams(packed map[string]any) (params PullsListCommentsForReviewParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	params.ReviewID = packed["review_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodePullsListCommentsForReviewParams(args [4]string, r *http.Request) (params PullsListCommentsForReviewParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Decode path: review_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: review_id: parse")
			}
		} else {
			return params, errors.New("path: review_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// PullsListCommitsParams is parameters of pulls/list-commits operation.
type PullsListCommitsParams struct {
	Owner      string
	Repo       string
	PullNumber int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackPullsListCommitsParams(packed map[string]any) (params PullsListCommitsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodePullsListCommitsParams(args [3]string, r *http.Request) (params PullsListCommitsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// PullsListFilesParams is parameters of pulls/list-files operation.
type PullsListFilesParams struct {
	Owner      string
	Repo       string
	PullNumber int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackPullsListFilesParams(packed map[string]any) (params PullsListFilesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodePullsListFilesParams(args [3]string, r *http.Request) (params PullsListFilesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// PullsListRequestedReviewersParams is parameters of pulls/list-requested-reviewers operation.
type PullsListRequestedReviewersParams struct {
	Owner      string
	Repo       string
	PullNumber int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackPullsListRequestedReviewersParams(packed map[string]any) (params PullsListRequestedReviewersParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodePullsListRequestedReviewersParams(args [3]string, r *http.Request) (params PullsListRequestedReviewersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// PullsListReviewCommentsParams is parameters of pulls/list-review-comments operation.
type PullsListReviewCommentsParams struct {
	Owner      string
	Repo       string
	PullNumber int
	// One of `created` (when the repository was starred) or `updated` (when it was last pushed to).
	Sort OptPullsListReviewCommentsSort `json:",omitempty"`
	// Can be either `asc` or `desc`. Ignored without `sort` parameter.
	Direction OptPullsListReviewCommentsDirection `json:",omitempty"`
	// Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Since OptDateTime `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackPullsListReviewCommentsParams(packed map[string]any) (params PullsListReviewCommentsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptPullsListReviewCommentsSort)
	}
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptPullsListReviewCommentsDirection)
	}
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptDateTime)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodePullsListReviewCommentsParams(args [3]string, r *http.Request) (params PullsListReviewCommentsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Set default value for query: sort.
	{
		val := PullsListReviewCommentsSort("created")
		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal PullsListReviewCommentsSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = PullsListReviewCommentsSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal PullsListReviewCommentsDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = PullsListReviewCommentsDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// PullsListReviewCommentsForRepoParams is parameters of pulls/list-review-comments-for-repo operation.
type PullsListReviewCommentsForRepoParams struct {
	Owner string
	Repo  string
	Sort  OptPullsListReviewCommentsForRepoSort `json:",omitempty"`
	// Can be either `asc` or `desc`. Ignored without `sort` parameter.
	Direction OptPullsListReviewCommentsForRepoDirection `json:",omitempty"`
	// Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Since OptDateTime `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackPullsListReviewCommentsForRepoParams(packed map[string]any) (params PullsListReviewCommentsForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptPullsListReviewCommentsForRepoSort)
	}
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptPullsListReviewCommentsForRepoDirection)
	}
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptDateTime)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodePullsListReviewCommentsForRepoParams(args [2]string, r *http.Request) (params PullsListReviewCommentsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal PullsListReviewCommentsForRepoSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = PullsListReviewCommentsForRepoSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal PullsListReviewCommentsForRepoDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = PullsListReviewCommentsForRepoDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// PullsListReviewsParams is parameters of pulls/list-reviews operation.
type PullsListReviewsParams struct {
	Owner      string
	Repo       string
	PullNumber int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackPullsListReviewsParams(packed map[string]any) (params PullsListReviewsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodePullsListReviewsParams(args [3]string, r *http.Request) (params PullsListReviewsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// PullsMergeParams is parameters of pulls/merge operation.
type PullsMergeParams struct {
	Owner      string
	Repo       string
	PullNumber int
}

func unpackPullsMergeParams(packed map[string]any) (params PullsMergeParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	return params
}

func decodePullsMergeParams(args [3]string, r *http.Request) (params PullsMergeParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	return params, nil
}

// PullsRemoveRequestedReviewersParams is parameters of pulls/remove-requested-reviewers operation.
type PullsRemoveRequestedReviewersParams struct {
	Owner      string
	Repo       string
	PullNumber int
}

func unpackPullsRemoveRequestedReviewersParams(packed map[string]any) (params PullsRemoveRequestedReviewersParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	return params
}

func decodePullsRemoveRequestedReviewersParams(args [3]string, r *http.Request) (params PullsRemoveRequestedReviewersParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	return params, nil
}

// PullsSubmitReviewParams is parameters of pulls/submit-review operation.
type PullsSubmitReviewParams struct {
	Owner      string
	Repo       string
	PullNumber int
	// Review_id parameter.
	ReviewID int
}

func unpackPullsSubmitReviewParams(packed map[string]any) (params PullsSubmitReviewParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	params.ReviewID = packed["review_id"].(int)
	return params
}

func decodePullsSubmitReviewParams(args [4]string, r *http.Request) (params PullsSubmitReviewParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Decode path: review_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: review_id: parse")
			}
		} else {
			return params, errors.New("path: review_id: not specified")
		}
	}
	return params, nil
}

// PullsUpdateParams is parameters of pulls/update operation.
type PullsUpdateParams struct {
	Owner      string
	Repo       string
	PullNumber int
}

func unpackPullsUpdateParams(packed map[string]any) (params PullsUpdateParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	return params
}

func decodePullsUpdateParams(args [3]string, r *http.Request) (params PullsUpdateParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	return params, nil
}

// PullsUpdateBranchParams is parameters of pulls/update-branch operation.
type PullsUpdateBranchParams struct {
	Owner      string
	Repo       string
	PullNumber int
}

func unpackPullsUpdateBranchParams(packed map[string]any) (params PullsUpdateBranchParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	return params
}

func decodePullsUpdateBranchParams(args [3]string, r *http.Request) (params PullsUpdateBranchParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	return params, nil
}

// PullsUpdateReviewParams is parameters of pulls/update-review operation.
type PullsUpdateReviewParams struct {
	Owner      string
	Repo       string
	PullNumber int
	// Review_id parameter.
	ReviewID int
}

func unpackPullsUpdateReviewParams(packed map[string]any) (params PullsUpdateReviewParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.PullNumber = packed["pull_number"].(int)
	params.ReviewID = packed["review_id"].(int)
	return params
}

func decodePullsUpdateReviewParams(args [4]string, r *http.Request) (params PullsUpdateReviewParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: pull_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "pull_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.PullNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: pull_number: parse")
			}
		} else {
			return params, errors.New("path: pull_number: not specified")
		}
	}
	// Decode path: review_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "review_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReviewID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: review_id: parse")
			}
		} else {
			return params, errors.New("path: review_id: not specified")
		}
	}
	return params, nil
}

// PullsUpdateReviewCommentParams is parameters of pulls/update-review-comment operation.
type PullsUpdateReviewCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID int
}

func unpackPullsUpdateReviewCommentParams(packed map[string]any) (params PullsUpdateReviewCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	return params
}

func decodePullsUpdateReviewCommentParams(args [3]string, r *http.Request) (params PullsUpdateReviewCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

// ReactionsCreateForCommitCommentParams is parameters of reactions/create-for-commit-comment operation.
type ReactionsCreateForCommitCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID int
}

func unpackReactionsCreateForCommitCommentParams(packed map[string]any) (params ReactionsCreateForCommitCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	return params
}

func decodeReactionsCreateForCommitCommentParams(args [3]string, r *http.Request) (params ReactionsCreateForCommitCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

// ReactionsCreateForIssueParams is parameters of reactions/create-for-issue operation.
type ReactionsCreateForIssueParams struct {
	Owner string
	Repo  string
	// Issue_number parameter.
	IssueNumber int
}

func unpackReactionsCreateForIssueParams(packed map[string]any) (params ReactionsCreateForIssueParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.IssueNumber = packed["issue_number"].(int)
	return params
}

func decodeReactionsCreateForIssueParams(args [3]string, r *http.Request) (params ReactionsCreateForIssueParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: issue_number: parse")
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	return params, nil
}

// ReactionsCreateForIssueCommentParams is parameters of reactions/create-for-issue-comment operation.
type ReactionsCreateForIssueCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID int
}

func unpackReactionsCreateForIssueCommentParams(packed map[string]any) (params ReactionsCreateForIssueCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	return params
}

func decodeReactionsCreateForIssueCommentParams(args [3]string, r *http.Request) (params ReactionsCreateForIssueCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

// ReactionsCreateForPullRequestReviewCommentParams is parameters of reactions/create-for-pull-request-review-comment operation.
type ReactionsCreateForPullRequestReviewCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID int
}

func unpackReactionsCreateForPullRequestReviewCommentParams(packed map[string]any) (params ReactionsCreateForPullRequestReviewCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	return params
}

func decodeReactionsCreateForPullRequestReviewCommentParams(args [3]string, r *http.Request) (params ReactionsCreateForPullRequestReviewCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

// ReactionsCreateForReleaseParams is parameters of reactions/create-for-release operation.
type ReactionsCreateForReleaseParams struct {
	Owner string
	Repo  string
	// Release_id parameter.
	ReleaseID int
}

func unpackReactionsCreateForReleaseParams(packed map[string]any) (params ReactionsCreateForReleaseParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.ReleaseID = packed["release_id"].(int)
	return params
}

func decodeReactionsCreateForReleaseParams(args [3]string, r *http.Request) (params ReactionsCreateForReleaseParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: release_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: release_id: parse")
			}
		} else {
			return params, errors.New("path: release_id: not specified")
		}
	}
	return params, nil
}

// ReactionsCreateForTeamDiscussionCommentInOrgParams is parameters of reactions/create-for-team-discussion-comment-in-org operation.
type ReactionsCreateForTeamDiscussionCommentInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug         string
	DiscussionNumber int
	CommentNumber    int
}

func unpackReactionsCreateForTeamDiscussionCommentInOrgParams(packed map[string]any) (params ReactionsCreateForTeamDiscussionCommentInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.DiscussionNumber = packed["discussion_number"].(int)
	params.CommentNumber = packed["comment_number"].(int)
	return params
}

func decodeReactionsCreateForTeamDiscussionCommentInOrgParams(args [4]string, r *http.Request) (params ReactionsCreateForTeamDiscussionCommentInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_number: parse")
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	return params, nil
}

// ReactionsCreateForTeamDiscussionCommentLegacyParams is parameters of reactions/create-for-team-discussion-comment-legacy operation.
type ReactionsCreateForTeamDiscussionCommentLegacyParams struct {
	TeamID           int
	DiscussionNumber int
	CommentNumber    int
}

func unpackReactionsCreateForTeamDiscussionCommentLegacyParams(packed map[string]any) (params ReactionsCreateForTeamDiscussionCommentLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.DiscussionNumber = packed["discussion_number"].(int)
	params.CommentNumber = packed["comment_number"].(int)
	return params
}

func decodeReactionsCreateForTeamDiscussionCommentLegacyParams(args [3]string, r *http.Request) (params ReactionsCreateForTeamDiscussionCommentLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_number: parse")
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	return params, nil
}

// ReactionsCreateForTeamDiscussionInOrgParams is parameters of reactions/create-for-team-discussion-in-org operation.
type ReactionsCreateForTeamDiscussionInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug         string
	DiscussionNumber int
}

func unpackReactionsCreateForTeamDiscussionInOrgParams(packed map[string]any) (params ReactionsCreateForTeamDiscussionInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.DiscussionNumber = packed["discussion_number"].(int)
	return params
}

func decodeReactionsCreateForTeamDiscussionInOrgParams(args [3]string, r *http.Request) (params ReactionsCreateForTeamDiscussionInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

// ReactionsCreateForTeamDiscussionLegacyParams is parameters of reactions/create-for-team-discussion-legacy operation.
type ReactionsCreateForTeamDiscussionLegacyParams struct {
	TeamID           int
	DiscussionNumber int
}

func unpackReactionsCreateForTeamDiscussionLegacyParams(packed map[string]any) (params ReactionsCreateForTeamDiscussionLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.DiscussionNumber = packed["discussion_number"].(int)
	return params
}

func decodeReactionsCreateForTeamDiscussionLegacyParams(args [2]string, r *http.Request) (params ReactionsCreateForTeamDiscussionLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

// ReactionsDeleteForCommitCommentParams is parameters of reactions/delete-for-commit-comment operation.
type ReactionsDeleteForCommitCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID  int
	ReactionID int
}

func unpackReactionsDeleteForCommitCommentParams(packed map[string]any) (params ReactionsDeleteForCommitCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	params.ReactionID = packed["reaction_id"].(int)
	return params
}

func decodeReactionsDeleteForCommitCommentParams(args [4]string, r *http.Request) (params ReactionsDeleteForCommitCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	// Decode path: reaction_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: reaction_id: parse")
			}
		} else {
			return params, errors.New("path: reaction_id: not specified")
		}
	}
	return params, nil
}

// ReactionsDeleteForIssueParams is parameters of reactions/delete-for-issue operation.
type ReactionsDeleteForIssueParams struct {
	Owner string
	Repo  string
	// Issue_number parameter.
	IssueNumber int
	ReactionID  int
}

func unpackReactionsDeleteForIssueParams(packed map[string]any) (params ReactionsDeleteForIssueParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.IssueNumber = packed["issue_number"].(int)
	params.ReactionID = packed["reaction_id"].(int)
	return params
}

func decodeReactionsDeleteForIssueParams(args [4]string, r *http.Request) (params ReactionsDeleteForIssueParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: issue_number: parse")
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	// Decode path: reaction_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: reaction_id: parse")
			}
		} else {
			return params, errors.New("path: reaction_id: not specified")
		}
	}
	return params, nil
}

// ReactionsDeleteForIssueCommentParams is parameters of reactions/delete-for-issue-comment operation.
type ReactionsDeleteForIssueCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID  int
	ReactionID int
}

func unpackReactionsDeleteForIssueCommentParams(packed map[string]any) (params ReactionsDeleteForIssueCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	params.ReactionID = packed["reaction_id"].(int)
	return params
}

func decodeReactionsDeleteForIssueCommentParams(args [4]string, r *http.Request) (params ReactionsDeleteForIssueCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	// Decode path: reaction_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: reaction_id: parse")
			}
		} else {
			return params, errors.New("path: reaction_id: not specified")
		}
	}
	return params, nil
}

// ReactionsDeleteForPullRequestCommentParams is parameters of reactions/delete-for-pull-request-comment operation.
type ReactionsDeleteForPullRequestCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID  int
	ReactionID int
}

func unpackReactionsDeleteForPullRequestCommentParams(packed map[string]any) (params ReactionsDeleteForPullRequestCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	params.ReactionID = packed["reaction_id"].(int)
	return params
}

func decodeReactionsDeleteForPullRequestCommentParams(args [4]string, r *http.Request) (params ReactionsDeleteForPullRequestCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	// Decode path: reaction_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: reaction_id: parse")
			}
		} else {
			return params, errors.New("path: reaction_id: not specified")
		}
	}
	return params, nil
}

// ReactionsDeleteForTeamDiscussionParams is parameters of reactions/delete-for-team-discussion operation.
type ReactionsDeleteForTeamDiscussionParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug         string
	DiscussionNumber int
	ReactionID       int
}

func unpackReactionsDeleteForTeamDiscussionParams(packed map[string]any) (params ReactionsDeleteForTeamDiscussionParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.DiscussionNumber = packed["discussion_number"].(int)
	params.ReactionID = packed["reaction_id"].(int)
	return params
}

func decodeReactionsDeleteForTeamDiscussionParams(args [4]string, r *http.Request) (params ReactionsDeleteForTeamDiscussionParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: reaction_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: reaction_id: parse")
			}
		} else {
			return params, errors.New("path: reaction_id: not specified")
		}
	}
	return params, nil
}

// ReactionsDeleteForTeamDiscussionCommentParams is parameters of reactions/delete-for-team-discussion-comment operation.
type ReactionsDeleteForTeamDiscussionCommentParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug         string
	DiscussionNumber int
	CommentNumber    int
	ReactionID       int
}

func unpackReactionsDeleteForTeamDiscussionCommentParams(packed map[string]any) (params ReactionsDeleteForTeamDiscussionCommentParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.DiscussionNumber = packed["discussion_number"].(int)
	params.CommentNumber = packed["comment_number"].(int)
	params.ReactionID = packed["reaction_id"].(int)
	return params
}

func decodeReactionsDeleteForTeamDiscussionCommentParams(args [5]string, r *http.Request) (params ReactionsDeleteForTeamDiscussionCommentParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_number: parse")
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	// Decode path: reaction_id.
	{
		param := args[4]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: reaction_id: parse")
			}
		} else {
			return params, errors.New("path: reaction_id: not specified")
		}
	}
	return params, nil
}

// ReactionsDeleteLegacyParams is parameters of reactions/delete-legacy operation.
type ReactionsDeleteLegacyParams struct {
	ReactionID int
}

func unpackReactionsDeleteLegacyParams(packed map[string]any) (params ReactionsDeleteLegacyParams) {
	params.ReactionID = packed["reaction_id"].(int)
	return params
}

func decodeReactionsDeleteLegacyParams(args [1]string, r *http.Request) (params ReactionsDeleteLegacyParams, _ error) {
	// Decode path: reaction_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "reaction_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReactionID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: reaction_id: parse")
			}
		} else {
			return params, errors.New("path: reaction_id: not specified")
		}
	}
	return params, nil
}

// ReactionsListForCommitCommentParams is parameters of reactions/list-for-commit-comment operation.
type ReactionsListForCommitCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID int
	// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types).
	// Omit this parameter to list all reactions to a commit comment.
	Content OptReactionsListForCommitCommentContent `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReactionsListForCommitCommentParams(packed map[string]any) (params ReactionsListForCommitCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	if v, ok := packed["content"]; ok {
		params.Content = v.(OptReactionsListForCommitCommentContent)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReactionsListForCommitCommentParams(args [3]string, r *http.Request) (params ReactionsListForCommitCommentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	// Decode query: content.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentVal ReactionsListForCommitCommentContent
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentVal = ReactionsListForCommitCommentContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsDotContentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: content: parse")
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: content: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReactionsListForIssueParams is parameters of reactions/list-for-issue operation.
type ReactionsListForIssueParams struct {
	Owner string
	Repo  string
	// Issue_number parameter.
	IssueNumber int
	// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types).
	// Omit this parameter to list all reactions to an issue.
	Content OptReactionsListForIssueContent `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReactionsListForIssueParams(packed map[string]any) (params ReactionsListForIssueParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.IssueNumber = packed["issue_number"].(int)
	if v, ok := packed["content"]; ok {
		params.Content = v.(OptReactionsListForIssueContent)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReactionsListForIssueParams(args [3]string, r *http.Request) (params ReactionsListForIssueParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: issue_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "issue_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.IssueNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: issue_number: parse")
			}
		} else {
			return params, errors.New("path: issue_number: not specified")
		}
	}
	// Decode query: content.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentVal ReactionsListForIssueContent
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentVal = ReactionsListForIssueContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsDotContentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: content: parse")
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: content: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReactionsListForIssueCommentParams is parameters of reactions/list-for-issue-comment operation.
type ReactionsListForIssueCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID int
	// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types).
	// Omit this parameter to list all reactions to an issue comment.
	Content OptReactionsListForIssueCommentContent `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReactionsListForIssueCommentParams(packed map[string]any) (params ReactionsListForIssueCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	if v, ok := packed["content"]; ok {
		params.Content = v.(OptReactionsListForIssueCommentContent)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReactionsListForIssueCommentParams(args [3]string, r *http.Request) (params ReactionsListForIssueCommentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	// Decode query: content.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentVal ReactionsListForIssueCommentContent
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentVal = ReactionsListForIssueCommentContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsDotContentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: content: parse")
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: content: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReactionsListForPullRequestReviewCommentParams is parameters of reactions/list-for-pull-request-review-comment operation.
type ReactionsListForPullRequestReviewCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID int
	// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types).
	// Omit this parameter to list all reactions to a pull request review comment.
	Content OptReactionsListForPullRequestReviewCommentContent `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReactionsListForPullRequestReviewCommentParams(packed map[string]any) (params ReactionsListForPullRequestReviewCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	if v, ok := packed["content"]; ok {
		params.Content = v.(OptReactionsListForPullRequestReviewCommentContent)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReactionsListForPullRequestReviewCommentParams(args [3]string, r *http.Request) (params ReactionsListForPullRequestReviewCommentParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	// Decode query: content.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentVal ReactionsListForPullRequestReviewCommentContent
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentVal = ReactionsListForPullRequestReviewCommentContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsDotContentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: content: parse")
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: content: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReactionsListForTeamDiscussionCommentInOrgParams is parameters of reactions/list-for-team-discussion-comment-in-org operation.
type ReactionsListForTeamDiscussionCommentInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug         string
	DiscussionNumber int
	CommentNumber    int
	// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types).
	// Omit this parameter to list all reactions to a team discussion comment.
	Content OptReactionsListForTeamDiscussionCommentInOrgContent `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReactionsListForTeamDiscussionCommentInOrgParams(packed map[string]any) (params ReactionsListForTeamDiscussionCommentInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.DiscussionNumber = packed["discussion_number"].(int)
	params.CommentNumber = packed["comment_number"].(int)
	if v, ok := packed["content"]; ok {
		params.Content = v.(OptReactionsListForTeamDiscussionCommentInOrgContent)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReactionsListForTeamDiscussionCommentInOrgParams(args [4]string, r *http.Request) (params ReactionsListForTeamDiscussionCommentInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_number: parse")
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	// Decode query: content.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentVal ReactionsListForTeamDiscussionCommentInOrgContent
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentVal = ReactionsListForTeamDiscussionCommentInOrgContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsDotContentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: content: parse")
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: content: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReactionsListForTeamDiscussionCommentLegacyParams is parameters of reactions/list-for-team-discussion-comment-legacy operation.
type ReactionsListForTeamDiscussionCommentLegacyParams struct {
	TeamID           int
	DiscussionNumber int
	CommentNumber    int
	// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types).
	// Omit this parameter to list all reactions to a team discussion comment.
	Content OptReactionsListForTeamDiscussionCommentLegacyContent `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReactionsListForTeamDiscussionCommentLegacyParams(packed map[string]any) (params ReactionsListForTeamDiscussionCommentLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.DiscussionNumber = packed["discussion_number"].(int)
	params.CommentNumber = packed["comment_number"].(int)
	if v, ok := packed["content"]; ok {
		params.Content = v.(OptReactionsListForTeamDiscussionCommentLegacyContent)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReactionsListForTeamDiscussionCommentLegacyParams(args [3]string, r *http.Request) (params ReactionsListForTeamDiscussionCommentLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_number: parse")
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	// Decode query: content.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentVal ReactionsListForTeamDiscussionCommentLegacyContent
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentVal = ReactionsListForTeamDiscussionCommentLegacyContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsDotContentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: content: parse")
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: content: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReactionsListForTeamDiscussionInOrgParams is parameters of reactions/list-for-team-discussion-in-org operation.
type ReactionsListForTeamDiscussionInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug         string
	DiscussionNumber int
	// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types).
	// Omit this parameter to list all reactions to a team discussion.
	Content OptReactionsListForTeamDiscussionInOrgContent `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReactionsListForTeamDiscussionInOrgParams(packed map[string]any) (params ReactionsListForTeamDiscussionInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.DiscussionNumber = packed["discussion_number"].(int)
	if v, ok := packed["content"]; ok {
		params.Content = v.(OptReactionsListForTeamDiscussionInOrgContent)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReactionsListForTeamDiscussionInOrgParams(args [3]string, r *http.Request) (params ReactionsListForTeamDiscussionInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode query: content.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentVal ReactionsListForTeamDiscussionInOrgContent
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentVal = ReactionsListForTeamDiscussionInOrgContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsDotContentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: content: parse")
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: content: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReactionsListForTeamDiscussionLegacyParams is parameters of reactions/list-for-team-discussion-legacy operation.
type ReactionsListForTeamDiscussionLegacyParams struct {
	TeamID           int
	DiscussionNumber int
	// Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types).
	// Omit this parameter to list all reactions to a team discussion.
	Content OptReactionsListForTeamDiscussionLegacyContent `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReactionsListForTeamDiscussionLegacyParams(packed map[string]any) (params ReactionsListForTeamDiscussionLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.DiscussionNumber = packed["discussion_number"].(int)
	if v, ok := packed["content"]; ok {
		params.Content = v.(OptReactionsListForTeamDiscussionLegacyContent)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReactionsListForTeamDiscussionLegacyParams(args [2]string, r *http.Request) (params ReactionsListForTeamDiscussionLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode query: content.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "content",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotContentVal ReactionsListForTeamDiscussionLegacyContent
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotContentVal = ReactionsListForTeamDiscussionLegacyContent(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Content.SetTo(paramsDotContentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: content: parse")
			}
			if err := func() error {
				if params.Content.Set {
					if err := func() error {
						if err := params.Content.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: content: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposAcceptInvitationParams is parameters of repos/accept-invitation operation.
type ReposAcceptInvitationParams struct {
	// Invitation_id parameter.
	InvitationID int
}

func unpackReposAcceptInvitationParams(packed map[string]any) (params ReposAcceptInvitationParams) {
	params.InvitationID = packed["invitation_id"].(int)
	return params
}

func decodeReposAcceptInvitationParams(args [1]string, r *http.Request) (params ReposAcceptInvitationParams, _ error) {
	// Decode path: invitation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: invitation_id: parse")
			}
		} else {
			return params, errors.New("path: invitation_id: not specified")
		}
	}
	return params, nil
}

// ReposAddAppAccessRestrictionsParams is parameters of repos/add-app-access-restrictions operation.
type ReposAddAppAccessRestrictionsParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposAddAppAccessRestrictionsParams(packed map[string]any) (params ReposAddAppAccessRestrictionsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposAddAppAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposAddAppAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposAddCollaboratorParams is parameters of repos/add-collaborator operation.
type ReposAddCollaboratorParams struct {
	Owner    string
	Repo     string
	Username string
}

func unpackReposAddCollaboratorParams(packed map[string]any) (params ReposAddCollaboratorParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeReposAddCollaboratorParams(args [3]string, r *http.Request) (params ReposAddCollaboratorParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// ReposAddStatusCheckContextsParams is parameters of repos/add-status-check-contexts operation.
type ReposAddStatusCheckContextsParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposAddStatusCheckContextsParams(packed map[string]any) (params ReposAddStatusCheckContextsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposAddStatusCheckContextsParams(args [3]string, r *http.Request) (params ReposAddStatusCheckContextsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposAddTeamAccessRestrictionsParams is parameters of repos/add-team-access-restrictions operation.
type ReposAddTeamAccessRestrictionsParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposAddTeamAccessRestrictionsParams(packed map[string]any) (params ReposAddTeamAccessRestrictionsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposAddTeamAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposAddTeamAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposAddUserAccessRestrictionsParams is parameters of repos/add-user-access-restrictions operation.
type ReposAddUserAccessRestrictionsParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposAddUserAccessRestrictionsParams(packed map[string]any) (params ReposAddUserAccessRestrictionsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposAddUserAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposAddUserAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposCheckCollaboratorParams is parameters of repos/check-collaborator operation.
type ReposCheckCollaboratorParams struct {
	Owner    string
	Repo     string
	Username string
}

func unpackReposCheckCollaboratorParams(packed map[string]any) (params ReposCheckCollaboratorParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeReposCheckCollaboratorParams(args [3]string, r *http.Request) (params ReposCheckCollaboratorParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// ReposCheckVulnerabilityAlertsParams is parameters of repos/check-vulnerability-alerts operation.
type ReposCheckVulnerabilityAlertsParams struct {
	Owner string
	Repo  string
}

func unpackReposCheckVulnerabilityAlertsParams(packed map[string]any) (params ReposCheckVulnerabilityAlertsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposCheckVulnerabilityAlertsParams(args [2]string, r *http.Request) (params ReposCheckVulnerabilityAlertsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposCompareCommitsParams is parameters of repos/compare-commits operation.
type ReposCompareCommitsParams struct {
	Owner string
	Repo  string
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// The base branch and head branch to compare. This parameter expects the format `{base}...{head}`.
	Basehead string
}

func unpackReposCompareCommitsParams(packed map[string]any) (params ReposCompareCommitsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	params.Basehead = packed["basehead"].(string)
	return params
}

func decodeReposCompareCommitsParams(args [3]string, r *http.Request) (params ReposCompareCommitsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode path: basehead.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "basehead",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Basehead = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: basehead: parse")
			}
		} else {
			return params, errors.New("path: basehead: not specified")
		}
	}
	return params, nil
}

// ReposCreateAutolinkParams is parameters of repos/create-autolink operation.
type ReposCreateAutolinkParams struct {
	Owner string
	Repo  string
}

func unpackReposCreateAutolinkParams(packed map[string]any) (params ReposCreateAutolinkParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposCreateAutolinkParams(args [2]string, r *http.Request) (params ReposCreateAutolinkParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposCreateCommitCommentParams is parameters of repos/create-commit-comment operation.
type ReposCreateCommitCommentParams struct {
	Owner string
	Repo  string
	// Commit_sha parameter.
	CommitSha string
}

func unpackReposCreateCommitCommentParams(packed map[string]any) (params ReposCreateCommitCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommitSha = packed["commit_sha"].(string)
	return params
}

func decodeReposCreateCommitCommentParams(args [3]string, r *http.Request) (params ReposCreateCommitCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: commit_sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: commit_sha: parse")
			}
		} else {
			return params, errors.New("path: commit_sha: not specified")
		}
	}
	return params, nil
}

// ReposCreateCommitSignatureProtectionParams is parameters of repos/create-commit-signature-protection operation.
type ReposCreateCommitSignatureProtectionParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposCreateCommitSignatureProtectionParams(packed map[string]any) (params ReposCreateCommitSignatureProtectionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposCreateCommitSignatureProtectionParams(args [3]string, r *http.Request) (params ReposCreateCommitSignatureProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposCreateCommitStatusParams is parameters of repos/create-commit-status operation.
type ReposCreateCommitStatusParams struct {
	Owner string
	Repo  string
	Sha   string
}

func unpackReposCreateCommitStatusParams(packed map[string]any) (params ReposCreateCommitStatusParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Sha = packed["sha"].(string)
	return params
}

func decodeReposCreateCommitStatusParams(args [3]string, r *http.Request) (params ReposCreateCommitStatusParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Sha = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: sha: parse")
			}
		} else {
			return params, errors.New("path: sha: not specified")
		}
	}
	return params, nil
}

// ReposCreateDeployKeyParams is parameters of repos/create-deploy-key operation.
type ReposCreateDeployKeyParams struct {
	Owner string
	Repo  string
}

func unpackReposCreateDeployKeyParams(packed map[string]any) (params ReposCreateDeployKeyParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposCreateDeployKeyParams(args [2]string, r *http.Request) (params ReposCreateDeployKeyParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposCreateDeploymentParams is parameters of repos/create-deployment operation.
type ReposCreateDeploymentParams struct {
	Owner string
	Repo  string
}

func unpackReposCreateDeploymentParams(packed map[string]any) (params ReposCreateDeploymentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposCreateDeploymentParams(args [2]string, r *http.Request) (params ReposCreateDeploymentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposCreateDeploymentStatusParams is parameters of repos/create-deployment-status operation.
type ReposCreateDeploymentStatusParams struct {
	Owner string
	Repo  string
	// Deployment_id parameter.
	DeploymentID int
}

func unpackReposCreateDeploymentStatusParams(packed map[string]any) (params ReposCreateDeploymentStatusParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.DeploymentID = packed["deployment_id"].(int)
	return params
}

func decodeReposCreateDeploymentStatusParams(args [3]string, r *http.Request) (params ReposCreateDeploymentStatusParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: deployment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: deployment_id: parse")
			}
		} else {
			return params, errors.New("path: deployment_id: not specified")
		}
	}
	return params, nil
}

// ReposCreateDispatchEventParams is parameters of repos/create-dispatch-event operation.
type ReposCreateDispatchEventParams struct {
	Owner string
	Repo  string
}

func unpackReposCreateDispatchEventParams(packed map[string]any) (params ReposCreateDispatchEventParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposCreateDispatchEventParams(args [2]string, r *http.Request) (params ReposCreateDispatchEventParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposCreateForkParams is parameters of repos/create-fork operation.
type ReposCreateForkParams struct {
	Owner string
	Repo  string
}

func unpackReposCreateForkParams(packed map[string]any) (params ReposCreateForkParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposCreateForkParams(args [2]string, r *http.Request) (params ReposCreateForkParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposCreateInOrgParams is parameters of repos/create-in-org operation.
type ReposCreateInOrgParams struct {
	Org string
}

func unpackReposCreateInOrgParams(packed map[string]any) (params ReposCreateInOrgParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeReposCreateInOrgParams(args [1]string, r *http.Request) (params ReposCreateInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// ReposCreateOrUpdateFileContentsParams is parameters of repos/create-or-update-file-contents operation.
type ReposCreateOrUpdateFileContentsParams struct {
	Owner string
	Repo  string
	// Path parameter.
	Path string
}

func unpackReposCreateOrUpdateFileContentsParams(packed map[string]any) (params ReposCreateOrUpdateFileContentsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Path = packed["path"].(string)
	return params
}

func decodeReposCreateOrUpdateFileContentsParams(args [3]string, r *http.Request) (params ReposCreateOrUpdateFileContentsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: path.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: path: parse")
			}
		} else {
			return params, errors.New("path: path: not specified")
		}
	}
	return params, nil
}

// ReposCreatePagesSiteParams is parameters of repos/create-pages-site operation.
type ReposCreatePagesSiteParams struct {
	Owner string
	Repo  string
}

func unpackReposCreatePagesSiteParams(packed map[string]any) (params ReposCreatePagesSiteParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposCreatePagesSiteParams(args [2]string, r *http.Request) (params ReposCreatePagesSiteParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposCreateReleaseParams is parameters of repos/create-release operation.
type ReposCreateReleaseParams struct {
	Owner string
	Repo  string
}

func unpackReposCreateReleaseParams(packed map[string]any) (params ReposCreateReleaseParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposCreateReleaseParams(args [2]string, r *http.Request) (params ReposCreateReleaseParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposCreateUsingTemplateParams is parameters of repos/create-using-template operation.
type ReposCreateUsingTemplateParams struct {
	TemplateOwner string
	TemplateRepo  string
}

func unpackReposCreateUsingTemplateParams(packed map[string]any) (params ReposCreateUsingTemplateParams) {
	params.TemplateOwner = packed["template_owner"].(string)
	params.TemplateRepo = packed["template_repo"].(string)
	return params
}

func decodeReposCreateUsingTemplateParams(args [2]string, r *http.Request) (params ReposCreateUsingTemplateParams, _ error) {
	// Decode path: template_owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "template_owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TemplateOwner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: template_owner: parse")
			}
		} else {
			return params, errors.New("path: template_owner: not specified")
		}
	}
	// Decode path: template_repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "template_repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TemplateRepo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: template_repo: parse")
			}
		} else {
			return params, errors.New("path: template_repo: not specified")
		}
	}
	return params, nil
}

// ReposCreateWebhookParams is parameters of repos/create-webhook operation.
type ReposCreateWebhookParams struct {
	Owner string
	Repo  string
}

func unpackReposCreateWebhookParams(packed map[string]any) (params ReposCreateWebhookParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposCreateWebhookParams(args [2]string, r *http.Request) (params ReposCreateWebhookParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposDeclineInvitationParams is parameters of repos/decline-invitation operation.
type ReposDeclineInvitationParams struct {
	// Invitation_id parameter.
	InvitationID int
}

func unpackReposDeclineInvitationParams(packed map[string]any) (params ReposDeclineInvitationParams) {
	params.InvitationID = packed["invitation_id"].(int)
	return params
}

func decodeReposDeclineInvitationParams(args [1]string, r *http.Request) (params ReposDeclineInvitationParams, _ error) {
	// Decode path: invitation_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: invitation_id: parse")
			}
		} else {
			return params, errors.New("path: invitation_id: not specified")
		}
	}
	return params, nil
}

// ReposDeleteParams is parameters of repos/delete operation.
type ReposDeleteParams struct {
	Owner string
	Repo  string
}

func unpackReposDeleteParams(packed map[string]any) (params ReposDeleteParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposDeleteParams(args [2]string, r *http.Request) (params ReposDeleteParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposDeleteAccessRestrictionsParams is parameters of repos/delete-access-restrictions operation.
type ReposDeleteAccessRestrictionsParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposDeleteAccessRestrictionsParams(packed map[string]any) (params ReposDeleteAccessRestrictionsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposDeleteAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposDeleteAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposDeleteAdminBranchProtectionParams is parameters of repos/delete-admin-branch-protection operation.
type ReposDeleteAdminBranchProtectionParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposDeleteAdminBranchProtectionParams(packed map[string]any) (params ReposDeleteAdminBranchProtectionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposDeleteAdminBranchProtectionParams(args [3]string, r *http.Request) (params ReposDeleteAdminBranchProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposDeleteAnEnvironmentParams is parameters of repos/delete-an-environment operation.
type ReposDeleteAnEnvironmentParams struct {
	Owner string
	Repo  string
	// The name of the environment.
	EnvironmentName string
}

func unpackReposDeleteAnEnvironmentParams(packed map[string]any) (params ReposDeleteAnEnvironmentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.EnvironmentName = packed["environment_name"].(string)
	return params
}

func decodeReposDeleteAnEnvironmentParams(args [3]string, r *http.Request) (params ReposDeleteAnEnvironmentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: environment_name.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "environment_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.EnvironmentName = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: environment_name: parse")
			}
		} else {
			return params, errors.New("path: environment_name: not specified")
		}
	}
	return params, nil
}

// ReposDeleteAutolinkParams is parameters of repos/delete-autolink operation.
type ReposDeleteAutolinkParams struct {
	Owner string
	Repo  string
	// Autolink_id parameter.
	AutolinkID int
}

func unpackReposDeleteAutolinkParams(packed map[string]any) (params ReposDeleteAutolinkParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.AutolinkID = packed["autolink_id"].(int)
	return params
}

func decodeReposDeleteAutolinkParams(args [3]string, r *http.Request) (params ReposDeleteAutolinkParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: autolink_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "autolink_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AutolinkID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: autolink_id: parse")
			}
		} else {
			return params, errors.New("path: autolink_id: not specified")
		}
	}
	return params, nil
}

// ReposDeleteBranchProtectionParams is parameters of repos/delete-branch-protection operation.
type ReposDeleteBranchProtectionParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposDeleteBranchProtectionParams(packed map[string]any) (params ReposDeleteBranchProtectionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposDeleteBranchProtectionParams(args [3]string, r *http.Request) (params ReposDeleteBranchProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposDeleteCommitCommentParams is parameters of repos/delete-commit-comment operation.
type ReposDeleteCommitCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID int
}

func unpackReposDeleteCommitCommentParams(packed map[string]any) (params ReposDeleteCommitCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	return params
}

func decodeReposDeleteCommitCommentParams(args [3]string, r *http.Request) (params ReposDeleteCommitCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

// ReposDeleteCommitSignatureProtectionParams is parameters of repos/delete-commit-signature-protection operation.
type ReposDeleteCommitSignatureProtectionParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposDeleteCommitSignatureProtectionParams(packed map[string]any) (params ReposDeleteCommitSignatureProtectionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposDeleteCommitSignatureProtectionParams(args [3]string, r *http.Request) (params ReposDeleteCommitSignatureProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposDeleteDeployKeyParams is parameters of repos/delete-deploy-key operation.
type ReposDeleteDeployKeyParams struct {
	Owner string
	Repo  string
	// Key_id parameter.
	KeyID int
}

func unpackReposDeleteDeployKeyParams(packed map[string]any) (params ReposDeleteDeployKeyParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.KeyID = packed["key_id"].(int)
	return params
}

func decodeReposDeleteDeployKeyParams(args [3]string, r *http.Request) (params ReposDeleteDeployKeyParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: key_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.KeyID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: key_id: parse")
			}
		} else {
			return params, errors.New("path: key_id: not specified")
		}
	}
	return params, nil
}

// ReposDeleteDeploymentParams is parameters of repos/delete-deployment operation.
type ReposDeleteDeploymentParams struct {
	Owner string
	Repo  string
	// Deployment_id parameter.
	DeploymentID int
}

func unpackReposDeleteDeploymentParams(packed map[string]any) (params ReposDeleteDeploymentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.DeploymentID = packed["deployment_id"].(int)
	return params
}

func decodeReposDeleteDeploymentParams(args [3]string, r *http.Request) (params ReposDeleteDeploymentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: deployment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: deployment_id: parse")
			}
		} else {
			return params, errors.New("path: deployment_id: not specified")
		}
	}
	return params, nil
}

// ReposDeleteFileParams is parameters of repos/delete-file operation.
type ReposDeleteFileParams struct {
	Owner string
	Repo  string
	// Path parameter.
	Path string
}

func unpackReposDeleteFileParams(packed map[string]any) (params ReposDeleteFileParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Path = packed["path"].(string)
	return params
}

func decodeReposDeleteFileParams(args [3]string, r *http.Request) (params ReposDeleteFileParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: path.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: path: parse")
			}
		} else {
			return params, errors.New("path: path: not specified")
		}
	}
	return params, nil
}

// ReposDeleteInvitationParams is parameters of repos/delete-invitation operation.
type ReposDeleteInvitationParams struct {
	Owner string
	Repo  string
	// Invitation_id parameter.
	InvitationID int
}

func unpackReposDeleteInvitationParams(packed map[string]any) (params ReposDeleteInvitationParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.InvitationID = packed["invitation_id"].(int)
	return params
}

func decodeReposDeleteInvitationParams(args [3]string, r *http.Request) (params ReposDeleteInvitationParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: invitation_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: invitation_id: parse")
			}
		} else {
			return params, errors.New("path: invitation_id: not specified")
		}
	}
	return params, nil
}

// ReposDeletePagesSiteParams is parameters of repos/delete-pages-site operation.
type ReposDeletePagesSiteParams struct {
	Owner string
	Repo  string
}

func unpackReposDeletePagesSiteParams(packed map[string]any) (params ReposDeletePagesSiteParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposDeletePagesSiteParams(args [2]string, r *http.Request) (params ReposDeletePagesSiteParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposDeletePullRequestReviewProtectionParams is parameters of repos/delete-pull-request-review-protection operation.
type ReposDeletePullRequestReviewProtectionParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposDeletePullRequestReviewProtectionParams(packed map[string]any) (params ReposDeletePullRequestReviewProtectionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposDeletePullRequestReviewProtectionParams(args [3]string, r *http.Request) (params ReposDeletePullRequestReviewProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposDeleteReleaseParams is parameters of repos/delete-release operation.
type ReposDeleteReleaseParams struct {
	Owner string
	Repo  string
	// Release_id parameter.
	ReleaseID int
}

func unpackReposDeleteReleaseParams(packed map[string]any) (params ReposDeleteReleaseParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.ReleaseID = packed["release_id"].(int)
	return params
}

func decodeReposDeleteReleaseParams(args [3]string, r *http.Request) (params ReposDeleteReleaseParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: release_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: release_id: parse")
			}
		} else {
			return params, errors.New("path: release_id: not specified")
		}
	}
	return params, nil
}

// ReposDeleteReleaseAssetParams is parameters of repos/delete-release-asset operation.
type ReposDeleteReleaseAssetParams struct {
	Owner string
	Repo  string
	// Asset_id parameter.
	AssetID int
}

func unpackReposDeleteReleaseAssetParams(packed map[string]any) (params ReposDeleteReleaseAssetParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.AssetID = packed["asset_id"].(int)
	return params
}

func decodeReposDeleteReleaseAssetParams(args [3]string, r *http.Request) (params ReposDeleteReleaseAssetParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: asset_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "asset_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AssetID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: asset_id: parse")
			}
		} else {
			return params, errors.New("path: asset_id: not specified")
		}
	}
	return params, nil
}

// ReposDeleteWebhookParams is parameters of repos/delete-webhook operation.
type ReposDeleteWebhookParams struct {
	Owner  string
	Repo   string
	HookID int
}

func unpackReposDeleteWebhookParams(packed map[string]any) (params ReposDeleteWebhookParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.HookID = packed["hook_id"].(int)
	return params
}

func decodeReposDeleteWebhookParams(args [3]string, r *http.Request) (params ReposDeleteWebhookParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

// ReposDisableAutomatedSecurityFixesParams is parameters of repos/disable-automated-security-fixes operation.
type ReposDisableAutomatedSecurityFixesParams struct {
	Owner string
	Repo  string
}

func unpackReposDisableAutomatedSecurityFixesParams(packed map[string]any) (params ReposDisableAutomatedSecurityFixesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposDisableAutomatedSecurityFixesParams(args [2]string, r *http.Request) (params ReposDisableAutomatedSecurityFixesParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposDisableLfsForRepoParams is parameters of repos/disable-lfs-for-repo operation.
type ReposDisableLfsForRepoParams struct {
	Owner string
	Repo  string
}

func unpackReposDisableLfsForRepoParams(packed map[string]any) (params ReposDisableLfsForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposDisableLfsForRepoParams(args [2]string, r *http.Request) (params ReposDisableLfsForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposDisableVulnerabilityAlertsParams is parameters of repos/disable-vulnerability-alerts operation.
type ReposDisableVulnerabilityAlertsParams struct {
	Owner string
	Repo  string
}

func unpackReposDisableVulnerabilityAlertsParams(packed map[string]any) (params ReposDisableVulnerabilityAlertsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposDisableVulnerabilityAlertsParams(args [2]string, r *http.Request) (params ReposDisableVulnerabilityAlertsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposDownloadTarballArchiveParams is parameters of repos/download-tarball-archive operation.
type ReposDownloadTarballArchiveParams struct {
	Owner string
	Repo  string
	Ref   string
}

func unpackReposDownloadTarballArchiveParams(packed map[string]any) (params ReposDownloadTarballArchiveParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Ref = packed["ref"].(string)
	return params
}

func decodeReposDownloadTarballArchiveParams(args [3]string, r *http.Request) (params ReposDownloadTarballArchiveParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: ref: parse")
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	return params, nil
}

// ReposDownloadZipballArchiveParams is parameters of repos/download-zipball-archive operation.
type ReposDownloadZipballArchiveParams struct {
	Owner string
	Repo  string
	Ref   string
}

func unpackReposDownloadZipballArchiveParams(packed map[string]any) (params ReposDownloadZipballArchiveParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Ref = packed["ref"].(string)
	return params
}

func decodeReposDownloadZipballArchiveParams(args [3]string, r *http.Request) (params ReposDownloadZipballArchiveParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: ref: parse")
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	return params, nil
}

// ReposEnableAutomatedSecurityFixesParams is parameters of repos/enable-automated-security-fixes operation.
type ReposEnableAutomatedSecurityFixesParams struct {
	Owner string
	Repo  string
}

func unpackReposEnableAutomatedSecurityFixesParams(packed map[string]any) (params ReposEnableAutomatedSecurityFixesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposEnableAutomatedSecurityFixesParams(args [2]string, r *http.Request) (params ReposEnableAutomatedSecurityFixesParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposEnableLfsForRepoParams is parameters of repos/enable-lfs-for-repo operation.
type ReposEnableLfsForRepoParams struct {
	Owner string
	Repo  string
}

func unpackReposEnableLfsForRepoParams(packed map[string]any) (params ReposEnableLfsForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposEnableLfsForRepoParams(args [2]string, r *http.Request) (params ReposEnableLfsForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposEnableVulnerabilityAlertsParams is parameters of repos/enable-vulnerability-alerts operation.
type ReposEnableVulnerabilityAlertsParams struct {
	Owner string
	Repo  string
}

func unpackReposEnableVulnerabilityAlertsParams(packed map[string]any) (params ReposEnableVulnerabilityAlertsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposEnableVulnerabilityAlertsParams(args [2]string, r *http.Request) (params ReposEnableVulnerabilityAlertsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposGetParams is parameters of repos/get operation.
type ReposGetParams struct {
	Owner string
	Repo  string
}

func unpackReposGetParams(packed map[string]any) (params ReposGetParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposGetParams(args [2]string, r *http.Request) (params ReposGetParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposGetAccessRestrictionsParams is parameters of repos/get-access-restrictions operation.
type ReposGetAccessRestrictionsParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposGetAccessRestrictionsParams(packed map[string]any) (params ReposGetAccessRestrictionsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposGetAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposGetAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposGetAdminBranchProtectionParams is parameters of repos/get-admin-branch-protection operation.
type ReposGetAdminBranchProtectionParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposGetAdminBranchProtectionParams(packed map[string]any) (params ReposGetAdminBranchProtectionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposGetAdminBranchProtectionParams(args [3]string, r *http.Request) (params ReposGetAdminBranchProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposGetAllStatusCheckContextsParams is parameters of repos/get-all-status-check-contexts operation.
type ReposGetAllStatusCheckContextsParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposGetAllStatusCheckContextsParams(packed map[string]any) (params ReposGetAllStatusCheckContextsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposGetAllStatusCheckContextsParams(args [3]string, r *http.Request) (params ReposGetAllStatusCheckContextsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposGetAllTopicsParams is parameters of repos/get-all-topics operation.
type ReposGetAllTopicsParams struct {
	Owner string
	Repo  string
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
}

func unpackReposGetAllTopicsParams(packed map[string]any) (params ReposGetAllTopicsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	return params
}

func decodeReposGetAllTopicsParams(args [2]string, r *http.Request) (params ReposGetAllTopicsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	return params, nil
}

// ReposGetAppsWithAccessToProtectedBranchParams is parameters of repos/get-apps-with-access-to-protected-branch operation.
type ReposGetAppsWithAccessToProtectedBranchParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposGetAppsWithAccessToProtectedBranchParams(packed map[string]any) (params ReposGetAppsWithAccessToProtectedBranchParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposGetAppsWithAccessToProtectedBranchParams(args [3]string, r *http.Request) (params ReposGetAppsWithAccessToProtectedBranchParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposGetAutolinkParams is parameters of repos/get-autolink operation.
type ReposGetAutolinkParams struct {
	Owner string
	Repo  string
	// Autolink_id parameter.
	AutolinkID int
}

func unpackReposGetAutolinkParams(packed map[string]any) (params ReposGetAutolinkParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.AutolinkID = packed["autolink_id"].(int)
	return params
}

func decodeReposGetAutolinkParams(args [3]string, r *http.Request) (params ReposGetAutolinkParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: autolink_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "autolink_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AutolinkID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: autolink_id: parse")
			}
		} else {
			return params, errors.New("path: autolink_id: not specified")
		}
	}
	return params, nil
}

// ReposGetBranchParams is parameters of repos/get-branch operation.
type ReposGetBranchParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposGetBranchParams(packed map[string]any) (params ReposGetBranchParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposGetBranchParams(args [3]string, r *http.Request) (params ReposGetBranchParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposGetBranchProtectionParams is parameters of repos/get-branch-protection operation.
type ReposGetBranchProtectionParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposGetBranchProtectionParams(packed map[string]any) (params ReposGetBranchProtectionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposGetBranchProtectionParams(args [3]string, r *http.Request) (params ReposGetBranchProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposGetClonesParams is parameters of repos/get-clones operation.
type ReposGetClonesParams struct {
	Owner string
	Repo  string
	// Must be one of: `day`, `week`.
	Per OptReposGetClonesPer `json:",omitempty"`
}

func unpackReposGetClonesParams(packed map[string]any) (params ReposGetClonesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per"]; ok {
		params.Per = v.(OptReposGetClonesPer)
	}
	return params
}

func decodeReposGetClonesParams(args [2]string, r *http.Request) (params ReposGetClonesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per.
	{
		val := ReposGetClonesPer("day")
		params.Per.SetTo(val)
	}
	// Decode query: per.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerVal ReposGetClonesPer
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPerVal = ReposGetClonesPer(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Per.SetTo(paramsDotPerVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per: parse")
			}
			if err := func() error {
				if params.Per.Set {
					if err := func() error {
						if err := params.Per.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: per: invalid")
			}
		}
	}
	return params, nil
}

// ReposGetCodeFrequencyStatsParams is parameters of repos/get-code-frequency-stats operation.
type ReposGetCodeFrequencyStatsParams struct {
	Owner string
	Repo  string
}

func unpackReposGetCodeFrequencyStatsParams(packed map[string]any) (params ReposGetCodeFrequencyStatsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposGetCodeFrequencyStatsParams(args [2]string, r *http.Request) (params ReposGetCodeFrequencyStatsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposGetCollaboratorPermissionLevelParams is parameters of repos/get-collaborator-permission-level operation.
type ReposGetCollaboratorPermissionLevelParams struct {
	Owner    string
	Repo     string
	Username string
}

func unpackReposGetCollaboratorPermissionLevelParams(packed map[string]any) (params ReposGetCollaboratorPermissionLevelParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeReposGetCollaboratorPermissionLevelParams(args [3]string, r *http.Request) (params ReposGetCollaboratorPermissionLevelParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// ReposGetCombinedStatusForRefParams is parameters of repos/get-combined-status-for-ref operation.
type ReposGetCombinedStatusForRefParams struct {
	Owner string
	Repo  string
	// Ref parameter.
	Ref string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposGetCombinedStatusForRefParams(packed map[string]any) (params ReposGetCombinedStatusForRefParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Ref = packed["ref"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposGetCombinedStatusForRefParams(args [3]string, r *http.Request) (params ReposGetCombinedStatusForRefParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: ref: parse")
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposGetCommitParams is parameters of repos/get-commit operation.
type ReposGetCommitParams struct {
	Owner string
	Repo  string
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Ref parameter.
	Ref string
}

func unpackReposGetCommitParams(packed map[string]any) (params ReposGetCommitParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	params.Ref = packed["ref"].(string)
	return params
}

func decodeReposGetCommitParams(args [3]string, r *http.Request) (params ReposGetCommitParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: ref: parse")
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	return params, nil
}

// ReposGetCommitActivityStatsParams is parameters of repos/get-commit-activity-stats operation.
type ReposGetCommitActivityStatsParams struct {
	Owner string
	Repo  string
}

func unpackReposGetCommitActivityStatsParams(packed map[string]any) (params ReposGetCommitActivityStatsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposGetCommitActivityStatsParams(args [2]string, r *http.Request) (params ReposGetCommitActivityStatsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposGetCommitCommentParams is parameters of repos/get-commit-comment operation.
type ReposGetCommitCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID int
}

func unpackReposGetCommitCommentParams(packed map[string]any) (params ReposGetCommitCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	return params
}

func decodeReposGetCommitCommentParams(args [3]string, r *http.Request) (params ReposGetCommitCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

// ReposGetCommitSignatureProtectionParams is parameters of repos/get-commit-signature-protection operation.
type ReposGetCommitSignatureProtectionParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposGetCommitSignatureProtectionParams(packed map[string]any) (params ReposGetCommitSignatureProtectionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposGetCommitSignatureProtectionParams(args [3]string, r *http.Request) (params ReposGetCommitSignatureProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposGetCommunityProfileMetricsParams is parameters of repos/get-community-profile-metrics operation.
type ReposGetCommunityProfileMetricsParams struct {
	Owner string
	Repo  string
}

func unpackReposGetCommunityProfileMetricsParams(packed map[string]any) (params ReposGetCommunityProfileMetricsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposGetCommunityProfileMetricsParams(args [2]string, r *http.Request) (params ReposGetCommunityProfileMetricsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposGetContributorsStatsParams is parameters of repos/get-contributors-stats operation.
type ReposGetContributorsStatsParams struct {
	Owner string
	Repo  string
}

func unpackReposGetContributorsStatsParams(packed map[string]any) (params ReposGetContributorsStatsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposGetContributorsStatsParams(args [2]string, r *http.Request) (params ReposGetContributorsStatsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposGetDeployKeyParams is parameters of repos/get-deploy-key operation.
type ReposGetDeployKeyParams struct {
	Owner string
	Repo  string
	// Key_id parameter.
	KeyID int
}

func unpackReposGetDeployKeyParams(packed map[string]any) (params ReposGetDeployKeyParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.KeyID = packed["key_id"].(int)
	return params
}

func decodeReposGetDeployKeyParams(args [3]string, r *http.Request) (params ReposGetDeployKeyParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: key_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.KeyID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: key_id: parse")
			}
		} else {
			return params, errors.New("path: key_id: not specified")
		}
	}
	return params, nil
}

// ReposGetDeploymentParams is parameters of repos/get-deployment operation.
type ReposGetDeploymentParams struct {
	Owner string
	Repo  string
	// Deployment_id parameter.
	DeploymentID int
}

func unpackReposGetDeploymentParams(packed map[string]any) (params ReposGetDeploymentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.DeploymentID = packed["deployment_id"].(int)
	return params
}

func decodeReposGetDeploymentParams(args [3]string, r *http.Request) (params ReposGetDeploymentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: deployment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: deployment_id: parse")
			}
		} else {
			return params, errors.New("path: deployment_id: not specified")
		}
	}
	return params, nil
}

// ReposGetDeploymentStatusParams is parameters of repos/get-deployment-status operation.
type ReposGetDeploymentStatusParams struct {
	Owner string
	Repo  string
	// Deployment_id parameter.
	DeploymentID int
	StatusID     int
}

func unpackReposGetDeploymentStatusParams(packed map[string]any) (params ReposGetDeploymentStatusParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.DeploymentID = packed["deployment_id"].(int)
	params.StatusID = packed["status_id"].(int)
	return params
}

func decodeReposGetDeploymentStatusParams(args [4]string, r *http.Request) (params ReposGetDeploymentStatusParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: deployment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: deployment_id: parse")
			}
		} else {
			return params, errors.New("path: deployment_id: not specified")
		}
	}
	// Decode path: status_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "status_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.StatusID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: status_id: parse")
			}
		} else {
			return params, errors.New("path: status_id: not specified")
		}
	}
	return params, nil
}

// ReposGetLatestPagesBuildParams is parameters of repos/get-latest-pages-build operation.
type ReposGetLatestPagesBuildParams struct {
	Owner string
	Repo  string
}

func unpackReposGetLatestPagesBuildParams(packed map[string]any) (params ReposGetLatestPagesBuildParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposGetLatestPagesBuildParams(args [2]string, r *http.Request) (params ReposGetLatestPagesBuildParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposGetLatestReleaseParams is parameters of repos/get-latest-release operation.
type ReposGetLatestReleaseParams struct {
	Owner string
	Repo  string
}

func unpackReposGetLatestReleaseParams(packed map[string]any) (params ReposGetLatestReleaseParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposGetLatestReleaseParams(args [2]string, r *http.Request) (params ReposGetLatestReleaseParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposGetPagesParams is parameters of repos/get-pages operation.
type ReposGetPagesParams struct {
	Owner string
	Repo  string
}

func unpackReposGetPagesParams(packed map[string]any) (params ReposGetPagesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposGetPagesParams(args [2]string, r *http.Request) (params ReposGetPagesParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposGetPagesBuildParams is parameters of repos/get-pages-build operation.
type ReposGetPagesBuildParams struct {
	Owner   string
	Repo    string
	BuildID int
}

func unpackReposGetPagesBuildParams(packed map[string]any) (params ReposGetPagesBuildParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.BuildID = packed["build_id"].(int)
	return params
}

func decodeReposGetPagesBuildParams(args [3]string, r *http.Request) (params ReposGetPagesBuildParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: build_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "build_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.BuildID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: build_id: parse")
			}
		} else {
			return params, errors.New("path: build_id: not specified")
		}
	}
	return params, nil
}

// ReposGetPagesHealthCheckParams is parameters of repos/get-pages-health-check operation.
type ReposGetPagesHealthCheckParams struct {
	Owner string
	Repo  string
}

func unpackReposGetPagesHealthCheckParams(packed map[string]any) (params ReposGetPagesHealthCheckParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposGetPagesHealthCheckParams(args [2]string, r *http.Request) (params ReposGetPagesHealthCheckParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposGetParticipationStatsParams is parameters of repos/get-participation-stats operation.
type ReposGetParticipationStatsParams struct {
	Owner string
	Repo  string
}

func unpackReposGetParticipationStatsParams(packed map[string]any) (params ReposGetParticipationStatsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposGetParticipationStatsParams(args [2]string, r *http.Request) (params ReposGetParticipationStatsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposGetPullRequestReviewProtectionParams is parameters of repos/get-pull-request-review-protection operation.
type ReposGetPullRequestReviewProtectionParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposGetPullRequestReviewProtectionParams(packed map[string]any) (params ReposGetPullRequestReviewProtectionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposGetPullRequestReviewProtectionParams(args [3]string, r *http.Request) (params ReposGetPullRequestReviewProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposGetPunchCardStatsParams is parameters of repos/get-punch-card-stats operation.
type ReposGetPunchCardStatsParams struct {
	Owner string
	Repo  string
}

func unpackReposGetPunchCardStatsParams(packed map[string]any) (params ReposGetPunchCardStatsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposGetPunchCardStatsParams(args [2]string, r *http.Request) (params ReposGetPunchCardStatsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposGetReadmeParams is parameters of repos/get-readme operation.
type ReposGetReadmeParams struct {
	Owner string
	Repo  string
	// The name of the commit/branch/tag. Default: the repository’s default branch (usually `master`).
	Ref OptString `json:",omitempty"`
}

func unpackReposGetReadmeParams(packed map[string]any) (params ReposGetReadmeParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["ref"]; ok {
		params.Ref = v.(OptString)
	}
	return params
}

func decodeReposGetReadmeParams(args [2]string, r *http.Request) (params ReposGetReadmeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: ref.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRefVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRefVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsDotRefVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: ref: parse")
			}
		}
	}
	return params, nil
}

// ReposGetReadmeInDirectoryParams is parameters of repos/get-readme-in-directory operation.
type ReposGetReadmeInDirectoryParams struct {
	Owner string
	Repo  string
	// The alternate path to look for a README file.
	Dir string
	// The name of the commit/branch/tag. Default: the repository’s default branch (usually `master`).
	Ref OptString `json:",omitempty"`
}

func unpackReposGetReadmeInDirectoryParams(packed map[string]any) (params ReposGetReadmeInDirectoryParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Dir = packed["dir"].(string)
	if v, ok := packed["ref"]; ok {
		params.Ref = v.(OptString)
	}
	return params
}

func decodeReposGetReadmeInDirectoryParams(args [3]string, r *http.Request) (params ReposGetReadmeInDirectoryParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: dir.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "dir",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Dir = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: dir: parse")
			}
		} else {
			return params, errors.New("path: dir: not specified")
		}
	}
	// Decode query: ref.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRefVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRefVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsDotRefVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: ref: parse")
			}
		}
	}
	return params, nil
}

// ReposGetReleaseParams is parameters of repos/get-release operation.
type ReposGetReleaseParams struct {
	Owner string
	Repo  string
	// Release_id parameter.
	ReleaseID int
}

func unpackReposGetReleaseParams(packed map[string]any) (params ReposGetReleaseParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.ReleaseID = packed["release_id"].(int)
	return params
}

func decodeReposGetReleaseParams(args [3]string, r *http.Request) (params ReposGetReleaseParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: release_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: release_id: parse")
			}
		} else {
			return params, errors.New("path: release_id: not specified")
		}
	}
	return params, nil
}

// ReposGetReleaseAssetParams is parameters of repos/get-release-asset operation.
type ReposGetReleaseAssetParams struct {
	Owner string
	Repo  string
	// Asset_id parameter.
	AssetID int
}

func unpackReposGetReleaseAssetParams(packed map[string]any) (params ReposGetReleaseAssetParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.AssetID = packed["asset_id"].(int)
	return params
}

func decodeReposGetReleaseAssetParams(args [3]string, r *http.Request) (params ReposGetReleaseAssetParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: asset_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "asset_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AssetID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: asset_id: parse")
			}
		} else {
			return params, errors.New("path: asset_id: not specified")
		}
	}
	return params, nil
}

// ReposGetReleaseByTagParams is parameters of repos/get-release-by-tag operation.
type ReposGetReleaseByTagParams struct {
	Owner string
	Repo  string
	// Tag parameter.
	Tag string
}

func unpackReposGetReleaseByTagParams(packed map[string]any) (params ReposGetReleaseByTagParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Tag = packed["tag"].(string)
	return params
}

func decodeReposGetReleaseByTagParams(args [3]string, r *http.Request) (params ReposGetReleaseByTagParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: tag.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tag",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Tag = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: tag: parse")
			}
		} else {
			return params, errors.New("path: tag: not specified")
		}
	}
	return params, nil
}

// ReposGetStatusChecksProtectionParams is parameters of repos/get-status-checks-protection operation.
type ReposGetStatusChecksProtectionParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposGetStatusChecksProtectionParams(packed map[string]any) (params ReposGetStatusChecksProtectionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposGetStatusChecksProtectionParams(args [3]string, r *http.Request) (params ReposGetStatusChecksProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposGetTeamsWithAccessToProtectedBranchParams is parameters of repos/get-teams-with-access-to-protected-branch operation.
type ReposGetTeamsWithAccessToProtectedBranchParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposGetTeamsWithAccessToProtectedBranchParams(packed map[string]any) (params ReposGetTeamsWithAccessToProtectedBranchParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposGetTeamsWithAccessToProtectedBranchParams(args [3]string, r *http.Request) (params ReposGetTeamsWithAccessToProtectedBranchParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposGetTopPathsParams is parameters of repos/get-top-paths operation.
type ReposGetTopPathsParams struct {
	Owner string
	Repo  string
}

func unpackReposGetTopPathsParams(packed map[string]any) (params ReposGetTopPathsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposGetTopPathsParams(args [2]string, r *http.Request) (params ReposGetTopPathsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposGetTopReferrersParams is parameters of repos/get-top-referrers operation.
type ReposGetTopReferrersParams struct {
	Owner string
	Repo  string
}

func unpackReposGetTopReferrersParams(packed map[string]any) (params ReposGetTopReferrersParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposGetTopReferrersParams(args [2]string, r *http.Request) (params ReposGetTopReferrersParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposGetUsersWithAccessToProtectedBranchParams is parameters of repos/get-users-with-access-to-protected-branch operation.
type ReposGetUsersWithAccessToProtectedBranchParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposGetUsersWithAccessToProtectedBranchParams(packed map[string]any) (params ReposGetUsersWithAccessToProtectedBranchParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposGetUsersWithAccessToProtectedBranchParams(args [3]string, r *http.Request) (params ReposGetUsersWithAccessToProtectedBranchParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposGetViewsParams is parameters of repos/get-views operation.
type ReposGetViewsParams struct {
	Owner string
	Repo  string
	// Must be one of: `day`, `week`.
	Per OptReposGetViewsPer `json:",omitempty"`
}

func unpackReposGetViewsParams(packed map[string]any) (params ReposGetViewsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per"]; ok {
		params.Per = v.(OptReposGetViewsPer)
	}
	return params
}

func decodeReposGetViewsParams(args [2]string, r *http.Request) (params ReposGetViewsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per.
	{
		val := ReposGetViewsPer("day")
		params.Per.SetTo(val)
	}
	// Decode query: per.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerVal ReposGetViewsPer
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPerVal = ReposGetViewsPer(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Per.SetTo(paramsDotPerVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per: parse")
			}
			if err := func() error {
				if params.Per.Set {
					if err := func() error {
						if err := params.Per.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: per: invalid")
			}
		}
	}
	return params, nil
}

// ReposGetWebhookParams is parameters of repos/get-webhook operation.
type ReposGetWebhookParams struct {
	Owner  string
	Repo   string
	HookID int
}

func unpackReposGetWebhookParams(packed map[string]any) (params ReposGetWebhookParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.HookID = packed["hook_id"].(int)
	return params
}

func decodeReposGetWebhookParams(args [3]string, r *http.Request) (params ReposGetWebhookParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

// ReposGetWebhookConfigForRepoParams is parameters of repos/get-webhook-config-for-repo operation.
type ReposGetWebhookConfigForRepoParams struct {
	Owner  string
	Repo   string
	HookID int
}

func unpackReposGetWebhookConfigForRepoParams(packed map[string]any) (params ReposGetWebhookConfigForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.HookID = packed["hook_id"].(int)
	return params
}

func decodeReposGetWebhookConfigForRepoParams(args [3]string, r *http.Request) (params ReposGetWebhookConfigForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

// ReposGetWebhookDeliveryParams is parameters of repos/get-webhook-delivery operation.
type ReposGetWebhookDeliveryParams struct {
	Owner      string
	Repo       string
	HookID     int
	DeliveryID int
}

func unpackReposGetWebhookDeliveryParams(packed map[string]any) (params ReposGetWebhookDeliveryParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.HookID = packed["hook_id"].(int)
	params.DeliveryID = packed["delivery_id"].(int)
	return params
}

func decodeReposGetWebhookDeliveryParams(args [4]string, r *http.Request) (params ReposGetWebhookDeliveryParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	// Decode path: delivery_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: delivery_id: parse")
			}
		} else {
			return params, errors.New("path: delivery_id: not specified")
		}
	}
	return params, nil
}

// ReposListAutolinksParams is parameters of repos/list-autolinks operation.
type ReposListAutolinksParams struct {
	Owner string
	Repo  string
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListAutolinksParams(packed map[string]any) (params ReposListAutolinksParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListAutolinksParams(args [2]string, r *http.Request) (params ReposListAutolinksParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListBranchesParams is parameters of repos/list-branches operation.
type ReposListBranchesParams struct {
	Owner string
	Repo  string
	// Setting to `true` returns only protected branches. When set to `false`, only unprotected branches
	// are returned. Omitting this parameter returns all branches.
	Protected OptBool `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListBranchesParams(packed map[string]any) (params ReposListBranchesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["protected"]; ok {
		params.Protected = v.(OptBool)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListBranchesParams(args [2]string, r *http.Request) (params ReposListBranchesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: protected.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "protected",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProtectedVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotProtectedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Protected.SetTo(paramsDotProtectedVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: protected: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListBranchesForHeadCommitParams is parameters of repos/list-branches-for-head-commit operation.
type ReposListBranchesForHeadCommitParams struct {
	Owner string
	Repo  string
	// Commit_sha parameter.
	CommitSha string
}

func unpackReposListBranchesForHeadCommitParams(packed map[string]any) (params ReposListBranchesForHeadCommitParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommitSha = packed["commit_sha"].(string)
	return params
}

func decodeReposListBranchesForHeadCommitParams(args [3]string, r *http.Request) (params ReposListBranchesForHeadCommitParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: commit_sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: commit_sha: parse")
			}
		} else {
			return params, errors.New("path: commit_sha: not specified")
		}
	}
	return params, nil
}

// ReposListCollaboratorsParams is parameters of repos/list-collaborators operation.
type ReposListCollaboratorsParams struct {
	Owner string
	Repo  string
	// Filter collaborators returned by their affiliation. Can be one of:
	// \* `outside`: All outside collaborators of an organization-owned repository.
	// \* `direct`: All collaborators with permissions to an organization-owned repository, regardless of
	// organization membership status.
	// \* `all`: All collaborators the authenticated user can see.
	Affiliation OptReposListCollaboratorsAffiliation `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListCollaboratorsParams(packed map[string]any) (params ReposListCollaboratorsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["affiliation"]; ok {
		params.Affiliation = v.(OptReposListCollaboratorsAffiliation)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListCollaboratorsParams(args [2]string, r *http.Request) (params ReposListCollaboratorsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: affiliation.
	{
		val := ReposListCollaboratorsAffiliation("all")
		params.Affiliation.SetTo(val)
	}
	// Decode query: affiliation.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "affiliation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAffiliationVal ReposListCollaboratorsAffiliation
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAffiliationVal = ReposListCollaboratorsAffiliation(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Affiliation.SetTo(paramsDotAffiliationVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: affiliation: parse")
			}
			if err := func() error {
				if params.Affiliation.Set {
					if err := func() error {
						if err := params.Affiliation.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: affiliation: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListCommentsForCommitParams is parameters of repos/list-comments-for-commit operation.
type ReposListCommentsForCommitParams struct {
	Owner string
	Repo  string
	// Commit_sha parameter.
	CommitSha string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListCommentsForCommitParams(packed map[string]any) (params ReposListCommentsForCommitParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommitSha = packed["commit_sha"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListCommentsForCommitParams(args [3]string, r *http.Request) (params ReposListCommentsForCommitParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: commit_sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: commit_sha: parse")
			}
		} else {
			return params, errors.New("path: commit_sha: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListCommitCommentsForRepoParams is parameters of repos/list-commit-comments-for-repo operation.
type ReposListCommitCommentsForRepoParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListCommitCommentsForRepoParams(packed map[string]any) (params ReposListCommitCommentsForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListCommitCommentsForRepoParams(args [2]string, r *http.Request) (params ReposListCommitCommentsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListCommitStatusesForRefParams is parameters of repos/list-commit-statuses-for-ref operation.
type ReposListCommitStatusesForRefParams struct {
	Owner string
	Repo  string
	// Ref parameter.
	Ref string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListCommitStatusesForRefParams(packed map[string]any) (params ReposListCommitStatusesForRefParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Ref = packed["ref"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListCommitStatusesForRefParams(args [3]string, r *http.Request) (params ReposListCommitStatusesForRefParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: ref.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "ref",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Ref = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: ref: parse")
			}
		} else {
			return params, errors.New("path: ref: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListCommitsParams is parameters of repos/list-commits operation.
type ReposListCommitsParams struct {
	Owner string
	Repo  string
	// SHA or branch to start listing commits from. Default: the repository’s default branch (usually
	// `master`).
	Sha OptString `json:",omitempty"`
	// Only commits containing this file path will be returned.
	Path OptString `json:",omitempty"`
	// GitHub login or email address by which to filter by commit author.
	Author OptString `json:",omitempty"`
	// Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Since OptDateTime `json:",omitempty"`
	// Only commits before this date will be returned. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Until OptDateTime `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListCommitsParams(packed map[string]any) (params ReposListCommitsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["sha"]; ok {
		params.Sha = v.(OptString)
	}
	if v, ok := packed["path"]; ok {
		params.Path = v.(OptString)
	}
	if v, ok := packed["author"]; ok {
		params.Author = v.(OptString)
	}
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptDateTime)
	}
	if v, ok := packed["until"]; ok {
		params.Until = v.(OptDateTime)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListCommitsParams(args [2]string, r *http.Request) (params ReposListCommitsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: sha.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sha",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotShaVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotShaVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sha.SetTo(paramsDotShaVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sha: parse")
			}
		}
	}
	// Decode query: path.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPathVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPathVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Path.SetTo(paramsDotPathVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: path: parse")
			}
		}
	}
	// Decode query: author.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "author",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAuthorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAuthorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Author.SetTo(paramsDotAuthorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: author: parse")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Decode query: until.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "until",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotUntilVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotUntilVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Until.SetTo(paramsDotUntilVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: until: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListContributorsParams is parameters of repos/list-contributors operation.
type ReposListContributorsParams struct {
	Owner string
	Repo  string
	// Set to `1` or `true` to include anonymous contributors in results.
	Anon OptString `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListContributorsParams(packed map[string]any) (params ReposListContributorsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["anon"]; ok {
		params.Anon = v.(OptString)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListContributorsParams(args [2]string, r *http.Request) (params ReposListContributorsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: anon.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "anon",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAnonVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAnonVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Anon.SetTo(paramsDotAnonVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: anon: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListDeployKeysParams is parameters of repos/list-deploy-keys operation.
type ReposListDeployKeysParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListDeployKeysParams(packed map[string]any) (params ReposListDeployKeysParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListDeployKeysParams(args [2]string, r *http.Request) (params ReposListDeployKeysParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListDeploymentStatusesParams is parameters of repos/list-deployment-statuses operation.
type ReposListDeploymentStatusesParams struct {
	Owner string
	Repo  string
	// Deployment_id parameter.
	DeploymentID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListDeploymentStatusesParams(packed map[string]any) (params ReposListDeploymentStatusesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.DeploymentID = packed["deployment_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListDeploymentStatusesParams(args [3]string, r *http.Request) (params ReposListDeploymentStatusesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: deployment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "deployment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeploymentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: deployment_id: parse")
			}
		} else {
			return params, errors.New("path: deployment_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListDeploymentsParams is parameters of repos/list-deployments operation.
type ReposListDeploymentsParams struct {
	Owner string
	Repo  string
	// The SHA recorded at creation time.
	Sha OptString `json:",omitempty"`
	// The name of the ref. This can be a branch, tag, or SHA.
	Ref OptString `json:",omitempty"`
	// The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).
	Task OptString `json:",omitempty"`
	// The name of the environment that was deployed to (e.g., `staging` or `production`).
	Environment OptNilString `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListDeploymentsParams(packed map[string]any) (params ReposListDeploymentsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["sha"]; ok {
		params.Sha = v.(OptString)
	}
	if v, ok := packed["ref"]; ok {
		params.Ref = v.(OptString)
	}
	if v, ok := packed["task"]; ok {
		params.Task = v.(OptString)
	}
	if v, ok := packed["environment"]; ok {
		params.Environment = v.(OptNilString)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListDeploymentsParams(args [2]string, r *http.Request) (params ReposListDeploymentsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: sha.
	{
		val := string("none")
		params.Sha.SetTo(val)
	}
	// Decode query: sha.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sha",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotShaVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotShaVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sha.SetTo(paramsDotShaVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sha: parse")
			}
		}
	}
	// Set default value for query: ref.
	{
		val := string("none")
		params.Ref.SetTo(val)
	}
	// Decode query: ref.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "ref",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRefVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRefVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Ref.SetTo(paramsDotRefVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: ref: parse")
			}
		}
	}
	// Set default value for query: task.
	{
		val := string("none")
		params.Task.SetTo(val)
	}
	// Decode query: task.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "task",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTaskVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTaskVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Task.SetTo(paramsDotTaskVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: task: parse")
			}
		}
	}
	// Set default value for query: environment.
	{
		val := string("none")
		params.Environment.SetTo(val)
	}
	// Decode query: environment.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "environment",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEnvironmentVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotEnvironmentVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Environment.SetTo(paramsDotEnvironmentVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: environment: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListForAuthenticatedUserParams is parameters of repos/list-for-authenticated-user operation.
type ReposListForAuthenticatedUserParams struct {
	// Can be one of `all`, `public`, or `private`. Note: For GitHub AE, can be one of `all`, `internal`,
	// or `private`.
	Visibility OptReposListForAuthenticatedUserVisibility `json:",omitempty"`
	// Comma-separated list of values. Can include:
	// \* `owner`: Repositories that are owned by the authenticated user.
	// \* `collaborator`: Repositories that the user has been added to as a collaborator.
	// \* `organization_member`: Repositories that the user has access to through being a member of an
	// organization. This includes every repository on every team that the user is on.
	Affiliation OptString `json:",omitempty"`
	// Can be one of `all`, `owner`, `public`, `private`, `member`. Note: For GitHub AE, can be one of
	// `all`, `owner`, `internal`, `private`, `member`. Default: `all`
	// Will cause a `422` error if used in the same request as **visibility** or **affiliation**. Will
	// cause a `422` error if used in the same request as **visibility** or **affiliation**.
	Type OptReposListForAuthenticatedUserType `json:",omitempty"`
	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort OptReposListForAuthenticatedUserSort `json:",omitempty"`
	// Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise `desc`.
	Direction OptReposListForAuthenticatedUserDirection `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.
	// wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Since OptDateTime `json:",omitempty"`
	// Only show notifications updated before the given time. This is a timestamp in [ISO
	// 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
	Before OptDateTime `json:",omitempty"`
}

func unpackReposListForAuthenticatedUserParams(packed map[string]any) (params ReposListForAuthenticatedUserParams) {
	if v, ok := packed["visibility"]; ok {
		params.Visibility = v.(OptReposListForAuthenticatedUserVisibility)
	}
	if v, ok := packed["affiliation"]; ok {
		params.Affiliation = v.(OptString)
	}
	if v, ok := packed["type"]; ok {
		params.Type = v.(OptReposListForAuthenticatedUserType)
	}
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptReposListForAuthenticatedUserSort)
	}
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptReposListForAuthenticatedUserDirection)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptDateTime)
	}
	if v, ok := packed["before"]; ok {
		params.Before = v.(OptDateTime)
	}
	return params
}

func decodeReposListForAuthenticatedUserParams(args [0]string, r *http.Request) (params ReposListForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: visibility.
	{
		val := ReposListForAuthenticatedUserVisibility("all")
		params.Visibility.SetTo(val)
	}
	// Decode query: visibility.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "visibility",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotVisibilityVal ReposListForAuthenticatedUserVisibility
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotVisibilityVal = ReposListForAuthenticatedUserVisibility(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Visibility.SetTo(paramsDotVisibilityVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: visibility: parse")
			}
			if err := func() error {
				if params.Visibility.Set {
					if err := func() error {
						if err := params.Visibility.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: visibility: invalid")
			}
		}
	}
	// Set default value for query: affiliation.
	{
		val := string("owner,collaborator,organization_member")
		params.Affiliation.SetTo(val)
	}
	// Decode query: affiliation.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "affiliation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotAffiliationVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotAffiliationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Affiliation.SetTo(paramsDotAffiliationVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: affiliation: parse")
			}
		}
	}
	// Set default value for query: type.
	{
		val := ReposListForAuthenticatedUserType("all")
		params.Type.SetTo(val)
	}
	// Decode query: type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTypeVal ReposListForAuthenticatedUserType
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTypeVal = ReposListForAuthenticatedUserType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsDotTypeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: type: parse")
			}
			if err := func() error {
				if params.Type.Set {
					if err := func() error {
						if err := params.Type.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: type: invalid")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := ReposListForAuthenticatedUserSort("full_name")
		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal ReposListForAuthenticatedUserSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = ReposListForAuthenticatedUserSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal ReposListForAuthenticatedUserDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = ReposListForAuthenticatedUserDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Decode query: before.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotBeforeVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDateTime(val)
					if err != nil {
						return err
					}

					paramsDotBeforeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Before.SetTo(paramsDotBeforeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: before: parse")
			}
		}
	}
	return params, nil
}

// ReposListForOrgParams is parameters of repos/list-for-org operation.
type ReposListForOrgParams struct {
	Org string
	// Specifies the types of repositories you want returned. Can be one of `all`, `public`, `private`,
	// `forks`, `sources`, `member`, `internal`. Note: For GitHub AE, can be one of `all`, `private`,
	// `forks`, `sources`, `member`, `internal`. Default: `all`. If your organization is associated with
	// an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+, `type` can
	// also be `internal`. However, the `internal` value is not yet supported when a GitHub App calls
	// this API with an installation access token.
	Type OptReposListForOrgType `json:",omitempty"`
	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort OptReposListForOrgSort `json:",omitempty"`
	// Can be one of `asc` or `desc`. Default: when using `full_name`: `asc`, otherwise `desc`.
	Direction OptReposListForOrgDirection `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListForOrgParams(packed map[string]any) (params ReposListForOrgParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["type"]; ok {
		params.Type = v.(OptReposListForOrgType)
	}
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptReposListForOrgSort)
	}
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptReposListForOrgDirection)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListForOrgParams(args [1]string, r *http.Request) (params ReposListForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode query: type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTypeVal ReposListForOrgType
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTypeVal = ReposListForOrgType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsDotTypeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: type: parse")
			}
			if err := func() error {
				if params.Type.Set {
					if err := func() error {
						if err := params.Type.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: type: invalid")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := ReposListForOrgSort("created")
		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal ReposListForOrgSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = ReposListForOrgSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal ReposListForOrgDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = ReposListForOrgDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListForUserParams is parameters of repos/list-for-user operation.
type ReposListForUserParams struct {
	Username string
	// Can be one of `all`, `owner`, `member`.
	Type OptReposListForUserType `json:",omitempty"`
	// Can be one of `created`, `updated`, `pushed`, `full_name`.
	Sort OptReposListForUserSort `json:",omitempty"`
	// Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise `desc`.
	Direction OptReposListForUserDirection `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListForUserParams(packed map[string]any) (params ReposListForUserParams) {
	params.Username = packed["username"].(string)
	if v, ok := packed["type"]; ok {
		params.Type = v.(OptReposListForUserType)
	}
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptReposListForUserSort)
	}
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptReposListForUserDirection)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListForUserParams(args [1]string, r *http.Request) (params ReposListForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: type.
	{
		val := ReposListForUserType("owner")
		params.Type.SetTo(val)
	}
	// Decode query: type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTypeVal ReposListForUserType
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTypeVal = ReposListForUserType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Type.SetTo(paramsDotTypeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: type: parse")
			}
			if err := func() error {
				if params.Type.Set {
					if err := func() error {
						if err := params.Type.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: type: invalid")
			}
		}
	}
	// Set default value for query: sort.
	{
		val := ReposListForUserSort("full_name")
		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal ReposListForUserSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = ReposListForUserSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal ReposListForUserDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = ReposListForUserDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListForksParams is parameters of repos/list-forks operation.
type ReposListForksParams struct {
	Owner string
	Repo  string
	// The sort order. Can be either `newest`, `oldest`, or `stargazers`.
	Sort OptReposListForksSort `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListForksParams(packed map[string]any) (params ReposListForksParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptReposListForksSort)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListForksParams(args [2]string, r *http.Request) (params ReposListForksParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: sort.
	{
		val := ReposListForksSort("newest")
		params.Sort.SetTo(val)
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal ReposListForksSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = ReposListForksSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListInvitationsParams is parameters of repos/list-invitations operation.
type ReposListInvitationsParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListInvitationsParams(packed map[string]any) (params ReposListInvitationsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListInvitationsParams(args [2]string, r *http.Request) (params ReposListInvitationsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListInvitationsForAuthenticatedUserParams is parameters of repos/list-invitations-for-authenticated-user operation.
type ReposListInvitationsForAuthenticatedUserParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListInvitationsForAuthenticatedUserParams(packed map[string]any) (params ReposListInvitationsForAuthenticatedUserParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListInvitationsForAuthenticatedUserParams(args [0]string, r *http.Request) (params ReposListInvitationsForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListLanguagesParams is parameters of repos/list-languages operation.
type ReposListLanguagesParams struct {
	Owner string
	Repo  string
}

func unpackReposListLanguagesParams(packed map[string]any) (params ReposListLanguagesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposListLanguagesParams(args [2]string, r *http.Request) (params ReposListLanguagesParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposListPagesBuildsParams is parameters of repos/list-pages-builds operation.
type ReposListPagesBuildsParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListPagesBuildsParams(packed map[string]any) (params ReposListPagesBuildsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListPagesBuildsParams(args [2]string, r *http.Request) (params ReposListPagesBuildsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListPublicParams is parameters of repos/list-public operation.
type ReposListPublicParams struct {
	// A repository ID. Only return repositories with an ID greater than this ID.
	Since OptInt `json:",omitempty"`
}

func unpackReposListPublicParams(packed map[string]any) (params ReposListPublicParams) {
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptInt)
	}
	return params
}

func decodeReposListPublicParams(args [0]string, r *http.Request) (params ReposListPublicParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	return params, nil
}

// ReposListPullRequestsAssociatedWithCommitParams is parameters of repos/list-pull-requests-associated-with-commit operation.
type ReposListPullRequestsAssociatedWithCommitParams struct {
	Owner string
	Repo  string
	// Commit_sha parameter.
	CommitSha string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListPullRequestsAssociatedWithCommitParams(packed map[string]any) (params ReposListPullRequestsAssociatedWithCommitParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommitSha = packed["commit_sha"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListPullRequestsAssociatedWithCommitParams(args [3]string, r *http.Request) (params ReposListPullRequestsAssociatedWithCommitParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: commit_sha.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "commit_sha",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.CommitSha = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: commit_sha: parse")
			}
		} else {
			return params, errors.New("path: commit_sha: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListReleaseAssetsParams is parameters of repos/list-release-assets operation.
type ReposListReleaseAssetsParams struct {
	Owner string
	Repo  string
	// Release_id parameter.
	ReleaseID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListReleaseAssetsParams(packed map[string]any) (params ReposListReleaseAssetsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.ReleaseID = packed["release_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListReleaseAssetsParams(args [3]string, r *http.Request) (params ReposListReleaseAssetsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: release_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: release_id: parse")
			}
		} else {
			return params, errors.New("path: release_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListReleasesParams is parameters of repos/list-releases operation.
type ReposListReleasesParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListReleasesParams(packed map[string]any) (params ReposListReleasesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListReleasesParams(args [2]string, r *http.Request) (params ReposListReleasesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListTagsParams is parameters of repos/list-tags operation.
type ReposListTagsParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListTagsParams(packed map[string]any) (params ReposListTagsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListTagsParams(args [2]string, r *http.Request) (params ReposListTagsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListTeamsParams is parameters of repos/list-teams operation.
type ReposListTeamsParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListTeamsParams(packed map[string]any) (params ReposListTeamsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListTeamsParams(args [2]string, r *http.Request) (params ReposListTeamsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposListWebhookDeliveriesParams is parameters of repos/list-webhook-deliveries operation.
type ReposListWebhookDeliveriesParams struct {
	Owner  string
	Repo   string
	HookID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to
	// the `link` header for the next and previous page cursors.
	Cursor OptString `json:",omitempty"`
}

func unpackReposListWebhookDeliveriesParams(packed map[string]any) (params ReposListWebhookDeliveriesParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.HookID = packed["hook_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["cursor"]; ok {
		params.Cursor = v.(OptString)
	}
	return params
}

func decodeReposListWebhookDeliveriesParams(args [3]string, r *http.Request) (params ReposListWebhookDeliveriesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode query: cursor.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCursorVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotCursorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Cursor.SetTo(paramsDotCursorVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: cursor: parse")
			}
		}
	}
	return params, nil
}

// ReposListWebhooksParams is parameters of repos/list-webhooks operation.
type ReposListWebhooksParams struct {
	Owner string
	Repo  string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackReposListWebhooksParams(packed map[string]any) (params ReposListWebhooksParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeReposListWebhooksParams(args [2]string, r *http.Request) (params ReposListWebhooksParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// ReposMergeParams is parameters of repos/merge operation.
type ReposMergeParams struct {
	Owner string
	Repo  string
}

func unpackReposMergeParams(packed map[string]any) (params ReposMergeParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposMergeParams(args [2]string, r *http.Request) (params ReposMergeParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposMergeUpstreamParams is parameters of repos/merge-upstream operation.
type ReposMergeUpstreamParams struct {
	Owner string
	Repo  string
}

func unpackReposMergeUpstreamParams(packed map[string]any) (params ReposMergeUpstreamParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposMergeUpstreamParams(args [2]string, r *http.Request) (params ReposMergeUpstreamParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposPingWebhookParams is parameters of repos/ping-webhook operation.
type ReposPingWebhookParams struct {
	Owner  string
	Repo   string
	HookID int
}

func unpackReposPingWebhookParams(packed map[string]any) (params ReposPingWebhookParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.HookID = packed["hook_id"].(int)
	return params
}

func decodeReposPingWebhookParams(args [3]string, r *http.Request) (params ReposPingWebhookParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

// ReposRedeliverWebhookDeliveryParams is parameters of repos/redeliver-webhook-delivery operation.
type ReposRedeliverWebhookDeliveryParams struct {
	Owner      string
	Repo       string
	HookID     int
	DeliveryID int
}

func unpackReposRedeliverWebhookDeliveryParams(packed map[string]any) (params ReposRedeliverWebhookDeliveryParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.HookID = packed["hook_id"].(int)
	params.DeliveryID = packed["delivery_id"].(int)
	return params
}

func decodeReposRedeliverWebhookDeliveryParams(args [4]string, r *http.Request) (params ReposRedeliverWebhookDeliveryParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	// Decode path: delivery_id.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "delivery_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DeliveryID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: delivery_id: parse")
			}
		} else {
			return params, errors.New("path: delivery_id: not specified")
		}
	}
	return params, nil
}

// ReposRemoveAppAccessRestrictionsParams is parameters of repos/remove-app-access-restrictions operation.
type ReposRemoveAppAccessRestrictionsParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposRemoveAppAccessRestrictionsParams(packed map[string]any) (params ReposRemoveAppAccessRestrictionsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposRemoveAppAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposRemoveAppAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposRemoveCollaboratorParams is parameters of repos/remove-collaborator operation.
type ReposRemoveCollaboratorParams struct {
	Owner    string
	Repo     string
	Username string
}

func unpackReposRemoveCollaboratorParams(packed map[string]any) (params ReposRemoveCollaboratorParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeReposRemoveCollaboratorParams(args [3]string, r *http.Request) (params ReposRemoveCollaboratorParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// ReposRemoveStatusCheckContextsParams is parameters of repos/remove-status-check-contexts operation.
type ReposRemoveStatusCheckContextsParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposRemoveStatusCheckContextsParams(packed map[string]any) (params ReposRemoveStatusCheckContextsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposRemoveStatusCheckContextsParams(args [3]string, r *http.Request) (params ReposRemoveStatusCheckContextsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposRemoveStatusCheckProtectionParams is parameters of repos/remove-status-check-protection operation.
type ReposRemoveStatusCheckProtectionParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposRemoveStatusCheckProtectionParams(packed map[string]any) (params ReposRemoveStatusCheckProtectionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposRemoveStatusCheckProtectionParams(args [3]string, r *http.Request) (params ReposRemoveStatusCheckProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposRemoveTeamAccessRestrictionsParams is parameters of repos/remove-team-access-restrictions operation.
type ReposRemoveTeamAccessRestrictionsParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposRemoveTeamAccessRestrictionsParams(packed map[string]any) (params ReposRemoveTeamAccessRestrictionsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposRemoveTeamAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposRemoveTeamAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposRemoveUserAccessRestrictionsParams is parameters of repos/remove-user-access-restrictions operation.
type ReposRemoveUserAccessRestrictionsParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposRemoveUserAccessRestrictionsParams(packed map[string]any) (params ReposRemoveUserAccessRestrictionsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposRemoveUserAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposRemoveUserAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposRenameBranchParams is parameters of repos/rename-branch operation.
type ReposRenameBranchParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposRenameBranchParams(packed map[string]any) (params ReposRenameBranchParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposRenameBranchParams(args [3]string, r *http.Request) (params ReposRenameBranchParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposReplaceAllTopicsParams is parameters of repos/replace-all-topics operation.
type ReposReplaceAllTopicsParams struct {
	Owner string
	Repo  string
}

func unpackReposReplaceAllTopicsParams(packed map[string]any) (params ReposReplaceAllTopicsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposReplaceAllTopicsParams(args [2]string, r *http.Request) (params ReposReplaceAllTopicsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposRequestPagesBuildParams is parameters of repos/request-pages-build operation.
type ReposRequestPagesBuildParams struct {
	Owner string
	Repo  string
}

func unpackReposRequestPagesBuildParams(packed map[string]any) (params ReposRequestPagesBuildParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposRequestPagesBuildParams(args [2]string, r *http.Request) (params ReposRequestPagesBuildParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposSetAdminBranchProtectionParams is parameters of repos/set-admin-branch-protection operation.
type ReposSetAdminBranchProtectionParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposSetAdminBranchProtectionParams(packed map[string]any) (params ReposSetAdminBranchProtectionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposSetAdminBranchProtectionParams(args [3]string, r *http.Request) (params ReposSetAdminBranchProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposSetAppAccessRestrictionsParams is parameters of repos/set-app-access-restrictions operation.
type ReposSetAppAccessRestrictionsParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposSetAppAccessRestrictionsParams(packed map[string]any) (params ReposSetAppAccessRestrictionsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposSetAppAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposSetAppAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposSetStatusCheckContextsParams is parameters of repos/set-status-check-contexts operation.
type ReposSetStatusCheckContextsParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposSetStatusCheckContextsParams(packed map[string]any) (params ReposSetStatusCheckContextsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposSetStatusCheckContextsParams(args [3]string, r *http.Request) (params ReposSetStatusCheckContextsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposSetTeamAccessRestrictionsParams is parameters of repos/set-team-access-restrictions operation.
type ReposSetTeamAccessRestrictionsParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposSetTeamAccessRestrictionsParams(packed map[string]any) (params ReposSetTeamAccessRestrictionsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposSetTeamAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposSetTeamAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposSetUserAccessRestrictionsParams is parameters of repos/set-user-access-restrictions operation.
type ReposSetUserAccessRestrictionsParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposSetUserAccessRestrictionsParams(packed map[string]any) (params ReposSetUserAccessRestrictionsParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposSetUserAccessRestrictionsParams(args [3]string, r *http.Request) (params ReposSetUserAccessRestrictionsParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposTestPushWebhookParams is parameters of repos/test-push-webhook operation.
type ReposTestPushWebhookParams struct {
	Owner  string
	Repo   string
	HookID int
}

func unpackReposTestPushWebhookParams(packed map[string]any) (params ReposTestPushWebhookParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.HookID = packed["hook_id"].(int)
	return params
}

func decodeReposTestPushWebhookParams(args [3]string, r *http.Request) (params ReposTestPushWebhookParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

// ReposTransferParams is parameters of repos/transfer operation.
type ReposTransferParams struct {
	Owner string
	Repo  string
}

func unpackReposTransferParams(packed map[string]any) (params ReposTransferParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposTransferParams(args [2]string, r *http.Request) (params ReposTransferParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposUpdateParams is parameters of repos/update operation.
type ReposUpdateParams struct {
	Owner string
	Repo  string
}

func unpackReposUpdateParams(packed map[string]any) (params ReposUpdateParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeReposUpdateParams(args [2]string, r *http.Request) (params ReposUpdateParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// ReposUpdateBranchProtectionParams is parameters of repos/update-branch-protection operation.
type ReposUpdateBranchProtectionParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposUpdateBranchProtectionParams(packed map[string]any) (params ReposUpdateBranchProtectionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposUpdateBranchProtectionParams(args [3]string, r *http.Request) (params ReposUpdateBranchProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposUpdateCommitCommentParams is parameters of repos/update-commit-comment operation.
type ReposUpdateCommitCommentParams struct {
	Owner string
	Repo  string
	// Comment_id parameter.
	CommentID int
}

func unpackReposUpdateCommitCommentParams(packed map[string]any) (params ReposUpdateCommitCommentParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.CommentID = packed["comment_id"].(int)
	return params
}

func decodeReposUpdateCommitCommentParams(args [3]string, r *http.Request) (params ReposUpdateCommitCommentParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: comment_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_id: parse")
			}
		} else {
			return params, errors.New("path: comment_id: not specified")
		}
	}
	return params, nil
}

// ReposUpdateInvitationParams is parameters of repos/update-invitation operation.
type ReposUpdateInvitationParams struct {
	Owner string
	Repo  string
	// Invitation_id parameter.
	InvitationID int
}

func unpackReposUpdateInvitationParams(packed map[string]any) (params ReposUpdateInvitationParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.InvitationID = packed["invitation_id"].(int)
	return params
}

func decodeReposUpdateInvitationParams(args [3]string, r *http.Request) (params ReposUpdateInvitationParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: invitation_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "invitation_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.InvitationID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: invitation_id: parse")
			}
		} else {
			return params, errors.New("path: invitation_id: not specified")
		}
	}
	return params, nil
}

// ReposUpdatePullRequestReviewProtectionParams is parameters of repos/update-pull-request-review-protection operation.
type ReposUpdatePullRequestReviewProtectionParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposUpdatePullRequestReviewProtectionParams(packed map[string]any) (params ReposUpdatePullRequestReviewProtectionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposUpdatePullRequestReviewProtectionParams(args [3]string, r *http.Request) (params ReposUpdatePullRequestReviewProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposUpdateReleaseParams is parameters of repos/update-release operation.
type ReposUpdateReleaseParams struct {
	Owner string
	Repo  string
	// Release_id parameter.
	ReleaseID int
}

func unpackReposUpdateReleaseParams(packed map[string]any) (params ReposUpdateReleaseParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.ReleaseID = packed["release_id"].(int)
	return params
}

func decodeReposUpdateReleaseParams(args [3]string, r *http.Request) (params ReposUpdateReleaseParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: release_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "release_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ReleaseID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: release_id: parse")
			}
		} else {
			return params, errors.New("path: release_id: not specified")
		}
	}
	return params, nil
}

// ReposUpdateReleaseAssetParams is parameters of repos/update-release-asset operation.
type ReposUpdateReleaseAssetParams struct {
	Owner string
	Repo  string
	// Asset_id parameter.
	AssetID int
}

func unpackReposUpdateReleaseAssetParams(packed map[string]any) (params ReposUpdateReleaseAssetParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.AssetID = packed["asset_id"].(int)
	return params
}

func decodeReposUpdateReleaseAssetParams(args [3]string, r *http.Request) (params ReposUpdateReleaseAssetParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: asset_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "asset_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.AssetID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: asset_id: parse")
			}
		} else {
			return params, errors.New("path: asset_id: not specified")
		}
	}
	return params, nil
}

// ReposUpdateStatusCheckProtectionParams is parameters of repos/update-status-check-protection operation.
type ReposUpdateStatusCheckProtectionParams struct {
	Owner string
	Repo  string
	// The name of the branch.
	Branch string
}

func unpackReposUpdateStatusCheckProtectionParams(packed map[string]any) (params ReposUpdateStatusCheckProtectionParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.Branch = packed["branch"].(string)
	return params
}

func decodeReposUpdateStatusCheckProtectionParams(args [3]string, r *http.Request) (params ReposUpdateStatusCheckProtectionParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: branch.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "branch",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Branch = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: branch: parse")
			}
		} else {
			return params, errors.New("path: branch: not specified")
		}
	}
	return params, nil
}

// ReposUpdateWebhookParams is parameters of repos/update-webhook operation.
type ReposUpdateWebhookParams struct {
	Owner  string
	Repo   string
	HookID int
}

func unpackReposUpdateWebhookParams(packed map[string]any) (params ReposUpdateWebhookParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.HookID = packed["hook_id"].(int)
	return params
}

func decodeReposUpdateWebhookParams(args [3]string, r *http.Request) (params ReposUpdateWebhookParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

// ReposUpdateWebhookConfigForRepoParams is parameters of repos/update-webhook-config-for-repo operation.
type ReposUpdateWebhookConfigForRepoParams struct {
	Owner  string
	Repo   string
	HookID int
}

func unpackReposUpdateWebhookConfigForRepoParams(packed map[string]any) (params ReposUpdateWebhookConfigForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.HookID = packed["hook_id"].(int)
	return params
}

func decodeReposUpdateWebhookConfigForRepoParams(args [3]string, r *http.Request) (params ReposUpdateWebhookConfigForRepoParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: hook_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hook_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.HookID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: hook_id: parse")
			}
		} else {
			return params, errors.New("path: hook_id: not specified")
		}
	}
	return params, nil
}

// ScimDeleteUserFromOrgParams is parameters of scim/delete-user-from-org operation.
type ScimDeleteUserFromOrgParams struct {
	Org string
	// Scim_user_id parameter.
	ScimUserID string
}

func unpackScimDeleteUserFromOrgParams(packed map[string]any) (params ScimDeleteUserFromOrgParams) {
	params.Org = packed["org"].(string)
	params.ScimUserID = packed["scim_user_id"].(string)
	return params
}

func decodeScimDeleteUserFromOrgParams(args [2]string, r *http.Request) (params ScimDeleteUserFromOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: scim_user_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "scim_user_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ScimUserID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: scim_user_id: parse")
			}
		} else {
			return params, errors.New("path: scim_user_id: not specified")
		}
	}
	return params, nil
}

// SearchCodeParams is parameters of search/code operation.
type SearchCodeParams struct {
	// The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your
	// search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To
	// learn more about the format of the query, see [Constructing a search query](https://docs.github.
	// com/rest/reference/search#constructing-a-search-query). See "[Searching code](https://help.github.
	// com/articles/searching-code/)" for a detailed list of qualifiers.
	Q string
	// Sorts the results of your query. Can only be `indexed`, which indicates how recently a file has
	// been indexed by the GitHub search infrastructure. Default: [best match](https://docs.github.
	// com/rest/reference/search#ranking-search-results).
	Sort OptSearchCodeSort `json:",omitempty"`
	// Determines whether the first search result returned is the highest number of matches (`desc`) or
	// lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
	Order OptSearchCodeOrder `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackSearchCodeParams(packed map[string]any) (params SearchCodeParams) {
	params.Q = packed["q"].(string)
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptSearchCodeSort)
	}
	if v, ok := packed["order"]; ok {
		params.Order = v.(OptSearchCodeOrder)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeSearchCodeParams(args [0]string, r *http.Request) (params SearchCodeParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: q.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: q: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal SearchCodeSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = SearchCodeSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: order.
	{
		val := SearchCodeOrder("desc")
		params.Order.SetTo(val)
	}
	// Decode query: order.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal SearchCodeOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = SearchCodeOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: order: parse")
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: order: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// SearchCommitsParams is parameters of search/commits operation.
type SearchCommitsParams struct {
	// The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your
	// search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To
	// learn more about the format of the query, see [Constructing a search query](https://docs.github.
	// com/rest/reference/search#constructing-a-search-query). See "[Searching commits](https://help.
	// github.com/articles/searching-commits/)" for a detailed list of qualifiers.
	Q string
	// Sorts the results of your query by `author-date` or `committer-date`. Default: [best
	// match](https://docs.github.com/rest/reference/search#ranking-search-results).
	Sort OptSearchCommitsSort `json:",omitempty"`
	// Determines whether the first search result returned is the highest number of matches (`desc`) or
	// lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
	Order OptSearchCommitsOrder `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackSearchCommitsParams(packed map[string]any) (params SearchCommitsParams) {
	params.Q = packed["q"].(string)
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptSearchCommitsSort)
	}
	if v, ok := packed["order"]; ok {
		params.Order = v.(OptSearchCommitsOrder)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeSearchCommitsParams(args [0]string, r *http.Request) (params SearchCommitsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: q.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: q: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal SearchCommitsSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = SearchCommitsSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: order.
	{
		val := SearchCommitsOrder("desc")
		params.Order.SetTo(val)
	}
	// Decode query: order.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal SearchCommitsOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = SearchCommitsOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: order: parse")
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: order: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// SearchIssuesAndPullRequestsParams is parameters of search/issues-and-pull-requests operation.
type SearchIssuesAndPullRequestsParams struct {
	// The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your
	// search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To
	// learn more about the format of the query, see [Constructing a search query](https://docs.github.
	// com/rest/reference/search#constructing-a-search-query). See "[Searching issues and pull
	// requests](https://help.github.com/articles/searching-issues-and-pull-requests/)" for a detailed
	// list of qualifiers.
	Q string
	// Sorts the results of your query by the number of `comments`, `reactions`, `reactions-+1`,
	// `reactions--1`, `reactions-smile`, `reactions-thinking_face`, `reactions-heart`, `reactions-tada`,
	// or `interactions`. You can also sort results by how recently the items were `created` or `updated`,
	//  Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results).
	Sort OptSearchIssuesAndPullRequestsSort `json:",omitempty"`
	// Determines whether the first search result returned is the highest number of matches (`desc`) or
	// lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
	Order OptSearchIssuesAndPullRequestsOrder `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackSearchIssuesAndPullRequestsParams(packed map[string]any) (params SearchIssuesAndPullRequestsParams) {
	params.Q = packed["q"].(string)
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptSearchIssuesAndPullRequestsSort)
	}
	if v, ok := packed["order"]; ok {
		params.Order = v.(OptSearchIssuesAndPullRequestsOrder)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeSearchIssuesAndPullRequestsParams(args [0]string, r *http.Request) (params SearchIssuesAndPullRequestsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: q.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: q: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal SearchIssuesAndPullRequestsSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = SearchIssuesAndPullRequestsSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: order.
	{
		val := SearchIssuesAndPullRequestsOrder("desc")
		params.Order.SetTo(val)
	}
	// Decode query: order.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal SearchIssuesAndPullRequestsOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = SearchIssuesAndPullRequestsOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: order: parse")
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: order: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// SearchLabelsParams is parameters of search/labels operation.
type SearchLabelsParams struct {
	// The id of the repository.
	RepositoryID int
	// The search keywords. This endpoint does not accept qualifiers in the query. To learn more about
	// the format of the query, see [Constructing a search query](https://docs.github.
	// com/rest/reference/search#constructing-a-search-query).
	Q string
	// Sorts the results of your query by when the label was `created` or `updated`. Default: [best
	// match](https://docs.github.com/rest/reference/search#ranking-search-results).
	Sort OptSearchLabelsSort `json:",omitempty"`
	// Determines whether the first search result returned is the highest number of matches (`desc`) or
	// lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
	Order OptSearchLabelsOrder `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackSearchLabelsParams(packed map[string]any) (params SearchLabelsParams) {
	params.RepositoryID = packed["repository_id"].(int)
	params.Q = packed["q"].(string)
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptSearchLabelsSort)
	}
	if v, ok := packed["order"]; ok {
		params.Order = v.(OptSearchLabelsOrder)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeSearchLabelsParams(args [0]string, r *http.Request) (params SearchLabelsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: repository_id.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "repository_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.RepositoryID = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: repository_id: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: q.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: q: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal SearchLabelsSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = SearchLabelsSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: order.
	{
		val := SearchLabelsOrder("desc")
		params.Order.SetTo(val)
	}
	// Decode query: order.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal SearchLabelsOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = SearchLabelsOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: order: parse")
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: order: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// SearchReposParams is parameters of search/repos operation.
type SearchReposParams struct {
	// The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your
	// search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To
	// learn more about the format of the query, see [Constructing a search query](https://docs.github.
	// com/rest/reference/search#constructing-a-search-query). See "[Searching for
	// repositories](https://help.github.com/articles/searching-for-repositories/)" for a detailed list
	// of qualifiers.
	Q string
	// Sorts the results of your query by number of `stars`, `forks`, or `help-wanted-issues` or how
	// recently the items were `updated`. Default: [best match](https://docs.github.
	// com/rest/reference/search#ranking-search-results).
	Sort OptSearchReposSort `json:",omitempty"`
	// Determines whether the first search result returned is the highest number of matches (`desc`) or
	// lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
	Order OptSearchReposOrder `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackSearchReposParams(packed map[string]any) (params SearchReposParams) {
	params.Q = packed["q"].(string)
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptSearchReposSort)
	}
	if v, ok := packed["order"]; ok {
		params.Order = v.(OptSearchReposOrder)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeSearchReposParams(args [0]string, r *http.Request) (params SearchReposParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: q.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: q: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal SearchReposSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = SearchReposSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: order.
	{
		val := SearchReposOrder("desc")
		params.Order.SetTo(val)
	}
	// Decode query: order.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal SearchReposOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = SearchReposOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: order: parse")
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: order: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// SearchTopicsParams is parameters of search/topics operation.
type SearchTopicsParams struct {
	// The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your
	// search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To
	// learn more about the format of the query, see [Constructing a search query](https://docs.github.
	// com/rest/reference/search#constructing-a-search-query).
	Q string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackSearchTopicsParams(packed map[string]any) (params SearchTopicsParams) {
	params.Q = packed["q"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeSearchTopicsParams(args [0]string, r *http.Request) (params SearchTopicsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: q.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: q: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// SearchUsersParams is parameters of search/users operation.
type SearchUsersParams struct {
	// The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your
	// search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To
	// learn more about the format of the query, see [Constructing a search query](https://docs.github.
	// com/rest/reference/search#constructing-a-search-query). See "[Searching users](https://help.github.
	// com/articles/searching-users/)" for a detailed list of qualifiers.
	Q string
	// Sorts the results of your query by number of `followers` or `repositories`, or when the person
	// `joined` GitHub. Default: [best match](https://docs.github.
	// com/rest/reference/search#ranking-search-results).
	Sort OptSearchUsersSort `json:",omitempty"`
	// Determines whether the first search result returned is the highest number of matches (`desc`) or
	// lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.
	Order OptSearchUsersOrder `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackSearchUsersParams(packed map[string]any) (params SearchUsersParams) {
	params.Q = packed["q"].(string)
	if v, ok := packed["sort"]; ok {
		params.Sort = v.(OptSearchUsersSort)
	}
	if v, ok := packed["order"]; ok {
		params.Order = v.(OptSearchUsersOrder)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeSearchUsersParams(args [0]string, r *http.Request) (params SearchUsersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: q.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Q = c
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: q: parse")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode query: sort.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortVal SearchUsersSort
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortVal = SearchUsersSort(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Sort.SetTo(paramsDotSortVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: sort: parse")
			}
			if err := func() error {
				if params.Sort.Set {
					if err := func() error {
						if err := params.Sort.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: sort: invalid")
			}
		}
	}
	// Set default value for query: order.
	{
		val := SearchUsersOrder("desc")
		params.Order.SetTo(val)
	}
	// Decode query: order.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderVal SearchUsersOrder
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderVal = SearchUsersOrder(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Order.SetTo(paramsDotOrderVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: order: parse")
			}
			if err := func() error {
				if params.Order.Set {
					if err := func() error {
						if err := params.Order.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: order: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// SecretScanningGetAlertParams is parameters of secret-scanning/get-alert operation.
type SecretScanningGetAlertParams struct {
	Owner string
	Repo  string
	// The number that identifies an alert. You can find this at the end of the URL for a code scanning
	// alert within GitHub, and in the `number` field in the response from the `GET
	// /repos/{owner}/{repo}/code-scanning/alerts` operation.
	AlertNumber AlertNumber
}

func unpackSecretScanningGetAlertParams(packed map[string]any) (params SecretScanningGetAlertParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.AlertNumber = packed["alert_number"].(AlertNumber)
	return params
}

func decodeSecretScanningGetAlertParams(args [3]string, r *http.Request) (params SecretScanningGetAlertParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: alert_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsDotAlertNumberVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsDotAlertNumberVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: alert_number: parse")
			}
		} else {
			return params, errors.New("path: alert_number: not specified")
		}
	}
	return params, nil
}

// SecretScanningListAlertsForOrgParams is parameters of secret-scanning/list-alerts-for-org operation.
type SecretScanningListAlertsForOrgParams struct {
	Org string
	// Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
	State OptSecretScanningListAlertsForOrgState `json:",omitempty"`
	// A comma separated list of secret types to return. By default all secret types are returned.
	SecretType OptString `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
}

func unpackSecretScanningListAlertsForOrgParams(packed map[string]any) (params SecretScanningListAlertsForOrgParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["state"]; ok {
		params.State = v.(OptSecretScanningListAlertsForOrgState)
	}
	if v, ok := packed["secret_type"]; ok {
		params.SecretType = v.(OptString)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	return params
}

func decodeSecretScanningListAlertsForOrgParams(args [1]string, r *http.Request) (params SecretScanningListAlertsForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal SecretScanningListAlertsForOrgState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = SecretScanningListAlertsForOrgState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Decode query: secret_type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "secret_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSecretTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSecretTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SecretType.SetTo(paramsDotSecretTypeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: secret_type: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	return params, nil
}

// SecretScanningListAlertsForRepoParams is parameters of secret-scanning/list-alerts-for-repo operation.
type SecretScanningListAlertsForRepoParams struct {
	Owner string
	Repo  string
	// Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
	State OptSecretScanningListAlertsForRepoState `json:",omitempty"`
	// A comma separated list of secret types to return. By default all secret types are returned. See
	// "[About secret scanning for private repositories](https://docs.github.
	// com/code-security/secret-security/about-secret-scanning#about-secret-scanning-for-private-repositories)" for a complete list of secret types (API slug).
	SecretType OptString `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
}

func unpackSecretScanningListAlertsForRepoParams(packed map[string]any) (params SecretScanningListAlertsForRepoParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	if v, ok := packed["state"]; ok {
		params.State = v.(OptSecretScanningListAlertsForRepoState)
	}
	if v, ok := packed["secret_type"]; ok {
		params.SecretType = v.(OptString)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	return params
}

func decodeSecretScanningListAlertsForRepoParams(args [2]string, r *http.Request) (params SecretScanningListAlertsForRepoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode query: state.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStateVal SecretScanningListAlertsForRepoState
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStateVal = SecretScanningListAlertsForRepoState(c)
					return nil
				}(); err != nil {
					return err
				}
				params.State.SetTo(paramsDotStateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: state: parse")
			}
			if err := func() error {
				if params.State.Set {
					if err := func() error {
						if err := params.State.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: state: invalid")
			}
		}
	}
	// Decode query: secret_type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "secret_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSecretTypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSecretTypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SecretType.SetTo(paramsDotSecretTypeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: secret_type: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	return params, nil
}

// SecretScanningUpdateAlertParams is parameters of secret-scanning/update-alert operation.
type SecretScanningUpdateAlertParams struct {
	Owner string
	Repo  string
	// The number that identifies an alert. You can find this at the end of the URL for a code scanning
	// alert within GitHub, and in the `number` field in the response from the `GET
	// /repos/{owner}/{repo}/code-scanning/alerts` operation.
	AlertNumber AlertNumber
}

func unpackSecretScanningUpdateAlertParams(packed map[string]any) (params SecretScanningUpdateAlertParams) {
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	params.AlertNumber = packed["alert_number"].(AlertNumber)
	return params
}

func decodeSecretScanningUpdateAlertParams(args [3]string, r *http.Request) (params SecretScanningUpdateAlertParams, _ error) {
	// Decode path: owner.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	// Decode path: alert_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "alert_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				var paramsDotAlertNumberVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotAlertNumberVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.AlertNumber = AlertNumber(paramsDotAlertNumberVal)
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: alert_number: parse")
			}
		} else {
			return params, errors.New("path: alert_number: not specified")
		}
	}
	return params, nil
}

// TeamsAddMemberLegacyParams is parameters of teams/add-member-legacy operation.
type TeamsAddMemberLegacyParams struct {
	TeamID   int
	Username string
}

func unpackTeamsAddMemberLegacyParams(packed map[string]any) (params TeamsAddMemberLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.Username = packed["username"].(string)
	return params
}

func decodeTeamsAddMemberLegacyParams(args [2]string, r *http.Request) (params TeamsAddMemberLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// TeamsAddOrUpdateMembershipForUserInOrgParams is parameters of teams/add-or-update-membership-for-user-in-org operation.
type TeamsAddOrUpdateMembershipForUserInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
	Username string
}

func unpackTeamsAddOrUpdateMembershipForUserInOrgParams(packed map[string]any) (params TeamsAddOrUpdateMembershipForUserInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeTeamsAddOrUpdateMembershipForUserInOrgParams(args [3]string, r *http.Request) (params TeamsAddOrUpdateMembershipForUserInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// TeamsAddOrUpdateMembershipForUserLegacyParams is parameters of teams/add-or-update-membership-for-user-legacy operation.
type TeamsAddOrUpdateMembershipForUserLegacyParams struct {
	TeamID   int
	Username string
}

func unpackTeamsAddOrUpdateMembershipForUserLegacyParams(packed map[string]any) (params TeamsAddOrUpdateMembershipForUserLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.Username = packed["username"].(string)
	return params
}

func decodeTeamsAddOrUpdateMembershipForUserLegacyParams(args [2]string, r *http.Request) (params TeamsAddOrUpdateMembershipForUserLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// TeamsAddOrUpdateProjectPermissionsInOrgParams is parameters of teams/add-or-update-project-permissions-in-org operation.
type TeamsAddOrUpdateProjectPermissionsInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug  string
	ProjectID int
}

func unpackTeamsAddOrUpdateProjectPermissionsInOrgParams(packed map[string]any) (params TeamsAddOrUpdateProjectPermissionsInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.ProjectID = packed["project_id"].(int)
	return params
}

func decodeTeamsAddOrUpdateProjectPermissionsInOrgParams(args [3]string, r *http.Request) (params TeamsAddOrUpdateProjectPermissionsInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: project_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: project_id: parse")
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

// TeamsAddOrUpdateProjectPermissionsLegacyParams is parameters of teams/add-or-update-project-permissions-legacy operation.
type TeamsAddOrUpdateProjectPermissionsLegacyParams struct {
	TeamID    int
	ProjectID int
}

func unpackTeamsAddOrUpdateProjectPermissionsLegacyParams(packed map[string]any) (params TeamsAddOrUpdateProjectPermissionsLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.ProjectID = packed["project_id"].(int)
	return params
}

func decodeTeamsAddOrUpdateProjectPermissionsLegacyParams(args [2]string, r *http.Request) (params TeamsAddOrUpdateProjectPermissionsLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: project_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: project_id: parse")
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

// TeamsAddOrUpdateRepoPermissionsInOrgParams is parameters of teams/add-or-update-repo-permissions-in-org operation.
type TeamsAddOrUpdateRepoPermissionsInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
	Owner    string
	Repo     string
}

func unpackTeamsAddOrUpdateRepoPermissionsInOrgParams(packed map[string]any) (params TeamsAddOrUpdateRepoPermissionsInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeTeamsAddOrUpdateRepoPermissionsInOrgParams(args [4]string, r *http.Request) (params TeamsAddOrUpdateRepoPermissionsInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: owner.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// TeamsAddOrUpdateRepoPermissionsLegacyParams is parameters of teams/add-or-update-repo-permissions-legacy operation.
type TeamsAddOrUpdateRepoPermissionsLegacyParams struct {
	TeamID int
	Owner  string
	Repo   string
}

func unpackTeamsAddOrUpdateRepoPermissionsLegacyParams(packed map[string]any) (params TeamsAddOrUpdateRepoPermissionsLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeTeamsAddOrUpdateRepoPermissionsLegacyParams(args [3]string, r *http.Request) (params TeamsAddOrUpdateRepoPermissionsLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: owner.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// TeamsCheckPermissionsForProjectInOrgParams is parameters of teams/check-permissions-for-project-in-org operation.
type TeamsCheckPermissionsForProjectInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug  string
	ProjectID int
}

func unpackTeamsCheckPermissionsForProjectInOrgParams(packed map[string]any) (params TeamsCheckPermissionsForProjectInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.ProjectID = packed["project_id"].(int)
	return params
}

func decodeTeamsCheckPermissionsForProjectInOrgParams(args [3]string, r *http.Request) (params TeamsCheckPermissionsForProjectInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: project_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: project_id: parse")
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

// TeamsCheckPermissionsForProjectLegacyParams is parameters of teams/check-permissions-for-project-legacy operation.
type TeamsCheckPermissionsForProjectLegacyParams struct {
	TeamID    int
	ProjectID int
}

func unpackTeamsCheckPermissionsForProjectLegacyParams(packed map[string]any) (params TeamsCheckPermissionsForProjectLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.ProjectID = packed["project_id"].(int)
	return params
}

func decodeTeamsCheckPermissionsForProjectLegacyParams(args [2]string, r *http.Request) (params TeamsCheckPermissionsForProjectLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: project_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: project_id: parse")
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

// TeamsCheckPermissionsForRepoInOrgParams is parameters of teams/check-permissions-for-repo-in-org operation.
type TeamsCheckPermissionsForRepoInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
	Owner    string
	Repo     string
}

func unpackTeamsCheckPermissionsForRepoInOrgParams(packed map[string]any) (params TeamsCheckPermissionsForRepoInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeTeamsCheckPermissionsForRepoInOrgParams(args [4]string, r *http.Request) (params TeamsCheckPermissionsForRepoInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: owner.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// TeamsCheckPermissionsForRepoLegacyParams is parameters of teams/check-permissions-for-repo-legacy operation.
type TeamsCheckPermissionsForRepoLegacyParams struct {
	TeamID int
	Owner  string
	Repo   string
}

func unpackTeamsCheckPermissionsForRepoLegacyParams(packed map[string]any) (params TeamsCheckPermissionsForRepoLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeTeamsCheckPermissionsForRepoLegacyParams(args [3]string, r *http.Request) (params TeamsCheckPermissionsForRepoLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: owner.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// TeamsCreateParams is parameters of teams/create operation.
type TeamsCreateParams struct {
	Org string
}

func unpackTeamsCreateParams(packed map[string]any) (params TeamsCreateParams) {
	params.Org = packed["org"].(string)
	return params
}

func decodeTeamsCreateParams(args [1]string, r *http.Request) (params TeamsCreateParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	return params, nil
}

// TeamsCreateDiscussionCommentInOrgParams is parameters of teams/create-discussion-comment-in-org operation.
type TeamsCreateDiscussionCommentInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug         string
	DiscussionNumber int
}

func unpackTeamsCreateDiscussionCommentInOrgParams(packed map[string]any) (params TeamsCreateDiscussionCommentInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.DiscussionNumber = packed["discussion_number"].(int)
	return params
}

func decodeTeamsCreateDiscussionCommentInOrgParams(args [3]string, r *http.Request) (params TeamsCreateDiscussionCommentInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

// TeamsCreateDiscussionCommentLegacyParams is parameters of teams/create-discussion-comment-legacy operation.
type TeamsCreateDiscussionCommentLegacyParams struct {
	TeamID           int
	DiscussionNumber int
}

func unpackTeamsCreateDiscussionCommentLegacyParams(packed map[string]any) (params TeamsCreateDiscussionCommentLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.DiscussionNumber = packed["discussion_number"].(int)
	return params
}

func decodeTeamsCreateDiscussionCommentLegacyParams(args [2]string, r *http.Request) (params TeamsCreateDiscussionCommentLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

// TeamsCreateDiscussionInOrgParams is parameters of teams/create-discussion-in-org operation.
type TeamsCreateDiscussionInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
}

func unpackTeamsCreateDiscussionInOrgParams(packed map[string]any) (params TeamsCreateDiscussionInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	return params
}

func decodeTeamsCreateDiscussionInOrgParams(args [2]string, r *http.Request) (params TeamsCreateDiscussionInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	return params, nil
}

// TeamsCreateDiscussionLegacyParams is parameters of teams/create-discussion-legacy operation.
type TeamsCreateDiscussionLegacyParams struct {
	TeamID int
}

func unpackTeamsCreateDiscussionLegacyParams(packed map[string]any) (params TeamsCreateDiscussionLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	return params
}

func decodeTeamsCreateDiscussionLegacyParams(args [1]string, r *http.Request) (params TeamsCreateDiscussionLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	return params, nil
}

// TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams is parameters of teams/create-or-update-idp-group-connections-in-org operation.
type TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
}

func unpackTeamsCreateOrUpdateIdpGroupConnectionsInOrgParams(packed map[string]any) (params TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	return params
}

func decodeTeamsCreateOrUpdateIdpGroupConnectionsInOrgParams(args [2]string, r *http.Request) (params TeamsCreateOrUpdateIdpGroupConnectionsInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	return params, nil
}

// TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams is parameters of teams/create-or-update-idp-group-connections-legacy operation.
type TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams struct {
	TeamID int
}

func unpackTeamsCreateOrUpdateIdpGroupConnectionsLegacyParams(packed map[string]any) (params TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	return params
}

func decodeTeamsCreateOrUpdateIdpGroupConnectionsLegacyParams(args [1]string, r *http.Request) (params TeamsCreateOrUpdateIdpGroupConnectionsLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	return params, nil
}

// TeamsDeleteDiscussionCommentInOrgParams is parameters of teams/delete-discussion-comment-in-org operation.
type TeamsDeleteDiscussionCommentInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug         string
	DiscussionNumber int
	CommentNumber    int
}

func unpackTeamsDeleteDiscussionCommentInOrgParams(packed map[string]any) (params TeamsDeleteDiscussionCommentInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.DiscussionNumber = packed["discussion_number"].(int)
	params.CommentNumber = packed["comment_number"].(int)
	return params
}

func decodeTeamsDeleteDiscussionCommentInOrgParams(args [4]string, r *http.Request) (params TeamsDeleteDiscussionCommentInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_number: parse")
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	return params, nil
}

// TeamsDeleteDiscussionCommentLegacyParams is parameters of teams/delete-discussion-comment-legacy operation.
type TeamsDeleteDiscussionCommentLegacyParams struct {
	TeamID           int
	DiscussionNumber int
	CommentNumber    int
}

func unpackTeamsDeleteDiscussionCommentLegacyParams(packed map[string]any) (params TeamsDeleteDiscussionCommentLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.DiscussionNumber = packed["discussion_number"].(int)
	params.CommentNumber = packed["comment_number"].(int)
	return params
}

func decodeTeamsDeleteDiscussionCommentLegacyParams(args [3]string, r *http.Request) (params TeamsDeleteDiscussionCommentLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_number: parse")
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	return params, nil
}

// TeamsDeleteDiscussionInOrgParams is parameters of teams/delete-discussion-in-org operation.
type TeamsDeleteDiscussionInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug         string
	DiscussionNumber int
}

func unpackTeamsDeleteDiscussionInOrgParams(packed map[string]any) (params TeamsDeleteDiscussionInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.DiscussionNumber = packed["discussion_number"].(int)
	return params
}

func decodeTeamsDeleteDiscussionInOrgParams(args [3]string, r *http.Request) (params TeamsDeleteDiscussionInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

// TeamsDeleteDiscussionLegacyParams is parameters of teams/delete-discussion-legacy operation.
type TeamsDeleteDiscussionLegacyParams struct {
	TeamID           int
	DiscussionNumber int
}

func unpackTeamsDeleteDiscussionLegacyParams(packed map[string]any) (params TeamsDeleteDiscussionLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.DiscussionNumber = packed["discussion_number"].(int)
	return params
}

func decodeTeamsDeleteDiscussionLegacyParams(args [2]string, r *http.Request) (params TeamsDeleteDiscussionLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

// TeamsDeleteInOrgParams is parameters of teams/delete-in-org operation.
type TeamsDeleteInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
}

func unpackTeamsDeleteInOrgParams(packed map[string]any) (params TeamsDeleteInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	return params
}

func decodeTeamsDeleteInOrgParams(args [2]string, r *http.Request) (params TeamsDeleteInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	return params, nil
}

// TeamsDeleteLegacyParams is parameters of teams/delete-legacy operation.
type TeamsDeleteLegacyParams struct {
	TeamID int
}

func unpackTeamsDeleteLegacyParams(packed map[string]any) (params TeamsDeleteLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	return params
}

func decodeTeamsDeleteLegacyParams(args [1]string, r *http.Request) (params TeamsDeleteLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	return params, nil
}

// TeamsGetByNameParams is parameters of teams/get-by-name operation.
type TeamsGetByNameParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
}

func unpackTeamsGetByNameParams(packed map[string]any) (params TeamsGetByNameParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	return params
}

func decodeTeamsGetByNameParams(args [2]string, r *http.Request) (params TeamsGetByNameParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	return params, nil
}

// TeamsGetDiscussionCommentInOrgParams is parameters of teams/get-discussion-comment-in-org operation.
type TeamsGetDiscussionCommentInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug         string
	DiscussionNumber int
	CommentNumber    int
}

func unpackTeamsGetDiscussionCommentInOrgParams(packed map[string]any) (params TeamsGetDiscussionCommentInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.DiscussionNumber = packed["discussion_number"].(int)
	params.CommentNumber = packed["comment_number"].(int)
	return params
}

func decodeTeamsGetDiscussionCommentInOrgParams(args [4]string, r *http.Request) (params TeamsGetDiscussionCommentInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_number: parse")
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	return params, nil
}

// TeamsGetDiscussionCommentLegacyParams is parameters of teams/get-discussion-comment-legacy operation.
type TeamsGetDiscussionCommentLegacyParams struct {
	TeamID           int
	DiscussionNumber int
	CommentNumber    int
}

func unpackTeamsGetDiscussionCommentLegacyParams(packed map[string]any) (params TeamsGetDiscussionCommentLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.DiscussionNumber = packed["discussion_number"].(int)
	params.CommentNumber = packed["comment_number"].(int)
	return params
}

func decodeTeamsGetDiscussionCommentLegacyParams(args [3]string, r *http.Request) (params TeamsGetDiscussionCommentLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_number: parse")
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	return params, nil
}

// TeamsGetDiscussionInOrgParams is parameters of teams/get-discussion-in-org operation.
type TeamsGetDiscussionInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug         string
	DiscussionNumber int
}

func unpackTeamsGetDiscussionInOrgParams(packed map[string]any) (params TeamsGetDiscussionInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.DiscussionNumber = packed["discussion_number"].(int)
	return params
}

func decodeTeamsGetDiscussionInOrgParams(args [3]string, r *http.Request) (params TeamsGetDiscussionInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

// TeamsGetDiscussionLegacyParams is parameters of teams/get-discussion-legacy operation.
type TeamsGetDiscussionLegacyParams struct {
	TeamID           int
	DiscussionNumber int
}

func unpackTeamsGetDiscussionLegacyParams(packed map[string]any) (params TeamsGetDiscussionLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.DiscussionNumber = packed["discussion_number"].(int)
	return params
}

func decodeTeamsGetDiscussionLegacyParams(args [2]string, r *http.Request) (params TeamsGetDiscussionLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

// TeamsGetLegacyParams is parameters of teams/get-legacy operation.
type TeamsGetLegacyParams struct {
	TeamID int
}

func unpackTeamsGetLegacyParams(packed map[string]any) (params TeamsGetLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	return params
}

func decodeTeamsGetLegacyParams(args [1]string, r *http.Request) (params TeamsGetLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	return params, nil
}

// TeamsGetMemberLegacyParams is parameters of teams/get-member-legacy operation.
type TeamsGetMemberLegacyParams struct {
	TeamID   int
	Username string
}

func unpackTeamsGetMemberLegacyParams(packed map[string]any) (params TeamsGetMemberLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.Username = packed["username"].(string)
	return params
}

func decodeTeamsGetMemberLegacyParams(args [2]string, r *http.Request) (params TeamsGetMemberLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// TeamsGetMembershipForUserInOrgParams is parameters of teams/get-membership-for-user-in-org operation.
type TeamsGetMembershipForUserInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
	Username string
}

func unpackTeamsGetMembershipForUserInOrgParams(packed map[string]any) (params TeamsGetMembershipForUserInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeTeamsGetMembershipForUserInOrgParams(args [3]string, r *http.Request) (params TeamsGetMembershipForUserInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// TeamsGetMembershipForUserLegacyParams is parameters of teams/get-membership-for-user-legacy operation.
type TeamsGetMembershipForUserLegacyParams struct {
	TeamID   int
	Username string
}

func unpackTeamsGetMembershipForUserLegacyParams(packed map[string]any) (params TeamsGetMembershipForUserLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.Username = packed["username"].(string)
	return params
}

func decodeTeamsGetMembershipForUserLegacyParams(args [2]string, r *http.Request) (params TeamsGetMembershipForUserLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// TeamsListParams is parameters of teams/list operation.
type TeamsListParams struct {
	Org string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackTeamsListParams(packed map[string]any) (params TeamsListParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeTeamsListParams(args [1]string, r *http.Request) (params TeamsListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// TeamsListChildInOrgParams is parameters of teams/list-child-in-org operation.
type TeamsListChildInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackTeamsListChildInOrgParams(packed map[string]any) (params TeamsListChildInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeTeamsListChildInOrgParams(args [2]string, r *http.Request) (params TeamsListChildInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// TeamsListChildLegacyParams is parameters of teams/list-child-legacy operation.
type TeamsListChildLegacyParams struct {
	TeamID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackTeamsListChildLegacyParams(packed map[string]any) (params TeamsListChildLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeTeamsListChildLegacyParams(args [1]string, r *http.Request) (params TeamsListChildLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// TeamsListDiscussionCommentsInOrgParams is parameters of teams/list-discussion-comments-in-org operation.
type TeamsListDiscussionCommentsInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug         string
	DiscussionNumber int
	// One of `asc` (ascending) or `desc` (descending).
	Direction OptTeamsListDiscussionCommentsInOrgDirection `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackTeamsListDiscussionCommentsInOrgParams(packed map[string]any) (params TeamsListDiscussionCommentsInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.DiscussionNumber = packed["discussion_number"].(int)
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptTeamsListDiscussionCommentsInOrgDirection)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeTeamsListDiscussionCommentsInOrgParams(args [3]string, r *http.Request) (params TeamsListDiscussionCommentsInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Set default value for query: direction.
	{
		val := TeamsListDiscussionCommentsInOrgDirection("desc")
		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal TeamsListDiscussionCommentsInOrgDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = TeamsListDiscussionCommentsInOrgDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// TeamsListDiscussionCommentsLegacyParams is parameters of teams/list-discussion-comments-legacy operation.
type TeamsListDiscussionCommentsLegacyParams struct {
	TeamID           int
	DiscussionNumber int
	// One of `asc` (ascending) or `desc` (descending).
	Direction OptTeamsListDiscussionCommentsLegacyDirection `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackTeamsListDiscussionCommentsLegacyParams(packed map[string]any) (params TeamsListDiscussionCommentsLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.DiscussionNumber = packed["discussion_number"].(int)
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptTeamsListDiscussionCommentsLegacyDirection)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeTeamsListDiscussionCommentsLegacyParams(args [2]string, r *http.Request) (params TeamsListDiscussionCommentsLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Set default value for query: direction.
	{
		val := TeamsListDiscussionCommentsLegacyDirection("desc")
		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal TeamsListDiscussionCommentsLegacyDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = TeamsListDiscussionCommentsLegacyDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// TeamsListDiscussionsInOrgParams is parameters of teams/list-discussions-in-org operation.
type TeamsListDiscussionsInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
	// One of `asc` (ascending) or `desc` (descending).
	Direction OptTeamsListDiscussionsInOrgDirection `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
	// Pinned discussions only filter.
	Pinned OptString `json:",omitempty"`
}

func unpackTeamsListDiscussionsInOrgParams(packed map[string]any) (params TeamsListDiscussionsInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptTeamsListDiscussionsInOrgDirection)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["pinned"]; ok {
		params.Pinned = v.(OptString)
	}
	return params
}

func decodeTeamsListDiscussionsInOrgParams(args [2]string, r *http.Request) (params TeamsListDiscussionsInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Set default value for query: direction.
	{
		val := TeamsListDiscussionsInOrgDirection("desc")
		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal TeamsListDiscussionsInOrgDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = TeamsListDiscussionsInOrgDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: pinned.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "pinned",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPinnedVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPinnedVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Pinned.SetTo(paramsDotPinnedVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: pinned: parse")
			}
		}
	}
	return params, nil
}

// TeamsListDiscussionsLegacyParams is parameters of teams/list-discussions-legacy operation.
type TeamsListDiscussionsLegacyParams struct {
	TeamID int
	// One of `asc` (ascending) or `desc` (descending).
	Direction OptTeamsListDiscussionsLegacyDirection `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackTeamsListDiscussionsLegacyParams(packed map[string]any) (params TeamsListDiscussionsLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	if v, ok := packed["direction"]; ok {
		params.Direction = v.(OptTeamsListDiscussionsLegacyDirection)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeTeamsListDiscussionsLegacyParams(args [1]string, r *http.Request) (params TeamsListDiscussionsLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Set default value for query: direction.
	{
		val := TeamsListDiscussionsLegacyDirection("desc")
		params.Direction.SetTo(val)
	}
	// Decode query: direction.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDirectionVal TeamsListDiscussionsLegacyDirection
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotDirectionVal = TeamsListDiscussionsLegacyDirection(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Direction.SetTo(paramsDotDirectionVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: direction: parse")
			}
			if err := func() error {
				if params.Direction.Set {
					if err := func() error {
						if err := params.Direction.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: direction: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// TeamsListForAuthenticatedUserParams is parameters of teams/list-for-authenticated-user operation.
type TeamsListForAuthenticatedUserParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackTeamsListForAuthenticatedUserParams(packed map[string]any) (params TeamsListForAuthenticatedUserParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeTeamsListForAuthenticatedUserParams(args [0]string, r *http.Request) (params TeamsListForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// TeamsListIdpGroupsForLegacyParams is parameters of teams/list-idp-groups-for-legacy operation.
type TeamsListIdpGroupsForLegacyParams struct {
	TeamID int
}

func unpackTeamsListIdpGroupsForLegacyParams(packed map[string]any) (params TeamsListIdpGroupsForLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	return params
}

func decodeTeamsListIdpGroupsForLegacyParams(args [1]string, r *http.Request) (params TeamsListIdpGroupsForLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	return params, nil
}

// TeamsListIdpGroupsForOrgParams is parameters of teams/list-idp-groups-for-org operation.
type TeamsListIdpGroupsForOrgParams struct {
	Org string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page token.
	Page OptString `json:",omitempty"`
}

func unpackTeamsListIdpGroupsForOrgParams(packed map[string]any) (params TeamsListIdpGroupsForOrgParams) {
	params.Org = packed["org"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptString)
	}
	return params
}

func decodeTeamsListIdpGroupsForOrgParams(args [1]string, r *http.Request) (params TeamsListIdpGroupsForOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// TeamsListIdpGroupsInOrgParams is parameters of teams/list-idp-groups-in-org operation.
type TeamsListIdpGroupsInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
}

func unpackTeamsListIdpGroupsInOrgParams(packed map[string]any) (params TeamsListIdpGroupsInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	return params
}

func decodeTeamsListIdpGroupsInOrgParams(args [2]string, r *http.Request) (params TeamsListIdpGroupsInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	return params, nil
}

// TeamsListMembersInOrgParams is parameters of teams/list-members-in-org operation.
type TeamsListMembersInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
	// Filters members returned by their role in the team. Can be one of:
	// \* `member` - normal members of the team.
	// \* `maintainer` - team maintainers.
	// \* `all` - all members of the team.
	Role OptTeamsListMembersInOrgRole `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackTeamsListMembersInOrgParams(packed map[string]any) (params TeamsListMembersInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	if v, ok := packed["role"]; ok {
		params.Role = v.(OptTeamsListMembersInOrgRole)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeTeamsListMembersInOrgParams(args [2]string, r *http.Request) (params TeamsListMembersInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Set default value for query: role.
	{
		val := TeamsListMembersInOrgRole("all")
		params.Role.SetTo(val)
	}
	// Decode query: role.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "role",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRoleVal TeamsListMembersInOrgRole
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRoleVal = TeamsListMembersInOrgRole(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Role.SetTo(paramsDotRoleVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: role: parse")
			}
			if err := func() error {
				if params.Role.Set {
					if err := func() error {
						if err := params.Role.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: role: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// TeamsListMembersLegacyParams is parameters of teams/list-members-legacy operation.
type TeamsListMembersLegacyParams struct {
	TeamID int
	// Filters members returned by their role in the team. Can be one of:
	// \* `member` - normal members of the team.
	// \* `maintainer` - team maintainers.
	// \* `all` - all members of the team.
	Role OptTeamsListMembersLegacyRole `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackTeamsListMembersLegacyParams(packed map[string]any) (params TeamsListMembersLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	if v, ok := packed["role"]; ok {
		params.Role = v.(OptTeamsListMembersLegacyRole)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeTeamsListMembersLegacyParams(args [1]string, r *http.Request) (params TeamsListMembersLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Set default value for query: role.
	{
		val := TeamsListMembersLegacyRole("all")
		params.Role.SetTo(val)
	}
	// Decode query: role.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "role",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRoleVal TeamsListMembersLegacyRole
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRoleVal = TeamsListMembersLegacyRole(c)
					return nil
				}(); err != nil {
					return err
				}
				params.Role.SetTo(paramsDotRoleVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: role: parse")
			}
			if err := func() error {
				if params.Role.Set {
					if err := func() error {
						if err := params.Role.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: role: invalid")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// TeamsListPendingInvitationsInOrgParams is parameters of teams/list-pending-invitations-in-org operation.
type TeamsListPendingInvitationsInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackTeamsListPendingInvitationsInOrgParams(packed map[string]any) (params TeamsListPendingInvitationsInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeTeamsListPendingInvitationsInOrgParams(args [2]string, r *http.Request) (params TeamsListPendingInvitationsInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// TeamsListPendingInvitationsLegacyParams is parameters of teams/list-pending-invitations-legacy operation.
type TeamsListPendingInvitationsLegacyParams struct {
	TeamID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackTeamsListPendingInvitationsLegacyParams(packed map[string]any) (params TeamsListPendingInvitationsLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeTeamsListPendingInvitationsLegacyParams(args [1]string, r *http.Request) (params TeamsListPendingInvitationsLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// TeamsListProjectsInOrgParams is parameters of teams/list-projects-in-org operation.
type TeamsListProjectsInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackTeamsListProjectsInOrgParams(packed map[string]any) (params TeamsListProjectsInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeTeamsListProjectsInOrgParams(args [2]string, r *http.Request) (params TeamsListProjectsInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// TeamsListProjectsLegacyParams is parameters of teams/list-projects-legacy operation.
type TeamsListProjectsLegacyParams struct {
	TeamID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackTeamsListProjectsLegacyParams(packed map[string]any) (params TeamsListProjectsLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeTeamsListProjectsLegacyParams(args [1]string, r *http.Request) (params TeamsListProjectsLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// TeamsListReposInOrgParams is parameters of teams/list-repos-in-org operation.
type TeamsListReposInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackTeamsListReposInOrgParams(packed map[string]any) (params TeamsListReposInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeTeamsListReposInOrgParams(args [2]string, r *http.Request) (params TeamsListReposInOrgParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// TeamsListReposLegacyParams is parameters of teams/list-repos-legacy operation.
type TeamsListReposLegacyParams struct {
	TeamID int
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackTeamsListReposLegacyParams(packed map[string]any) (params TeamsListReposLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeTeamsListReposLegacyParams(args [1]string, r *http.Request) (params TeamsListReposLegacyParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// TeamsRemoveMemberLegacyParams is parameters of teams/remove-member-legacy operation.
type TeamsRemoveMemberLegacyParams struct {
	TeamID   int
	Username string
}

func unpackTeamsRemoveMemberLegacyParams(packed map[string]any) (params TeamsRemoveMemberLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.Username = packed["username"].(string)
	return params
}

func decodeTeamsRemoveMemberLegacyParams(args [2]string, r *http.Request) (params TeamsRemoveMemberLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// TeamsRemoveMembershipForUserInOrgParams is parameters of teams/remove-membership-for-user-in-org operation.
type TeamsRemoveMembershipForUserInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
	Username string
}

func unpackTeamsRemoveMembershipForUserInOrgParams(packed map[string]any) (params TeamsRemoveMembershipForUserInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.Username = packed["username"].(string)
	return params
}

func decodeTeamsRemoveMembershipForUserInOrgParams(args [3]string, r *http.Request) (params TeamsRemoveMembershipForUserInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// TeamsRemoveMembershipForUserLegacyParams is parameters of teams/remove-membership-for-user-legacy operation.
type TeamsRemoveMembershipForUserLegacyParams struct {
	TeamID   int
	Username string
}

func unpackTeamsRemoveMembershipForUserLegacyParams(packed map[string]any) (params TeamsRemoveMembershipForUserLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.Username = packed["username"].(string)
	return params
}

func decodeTeamsRemoveMembershipForUserLegacyParams(args [2]string, r *http.Request) (params TeamsRemoveMembershipForUserLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: username.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// TeamsRemoveProjectInOrgParams is parameters of teams/remove-project-in-org operation.
type TeamsRemoveProjectInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug  string
	ProjectID int
}

func unpackTeamsRemoveProjectInOrgParams(packed map[string]any) (params TeamsRemoveProjectInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.ProjectID = packed["project_id"].(int)
	return params
}

func decodeTeamsRemoveProjectInOrgParams(args [3]string, r *http.Request) (params TeamsRemoveProjectInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: project_id.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: project_id: parse")
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

// TeamsRemoveProjectLegacyParams is parameters of teams/remove-project-legacy operation.
type TeamsRemoveProjectLegacyParams struct {
	TeamID    int
	ProjectID int
}

func unpackTeamsRemoveProjectLegacyParams(packed map[string]any) (params TeamsRemoveProjectLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.ProjectID = packed["project_id"].(int)
	return params
}

func decodeTeamsRemoveProjectLegacyParams(args [2]string, r *http.Request) (params TeamsRemoveProjectLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: project_id.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "project_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ProjectID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: project_id: parse")
			}
		} else {
			return params, errors.New("path: project_id: not specified")
		}
	}
	return params, nil
}

// TeamsRemoveRepoInOrgParams is parameters of teams/remove-repo-in-org operation.
type TeamsRemoveRepoInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
	Owner    string
	Repo     string
}

func unpackTeamsRemoveRepoInOrgParams(packed map[string]any) (params TeamsRemoveRepoInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeTeamsRemoveRepoInOrgParams(args [4]string, r *http.Request) (params TeamsRemoveRepoInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: owner.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// TeamsRemoveRepoLegacyParams is parameters of teams/remove-repo-legacy operation.
type TeamsRemoveRepoLegacyParams struct {
	TeamID int
	Owner  string
	Repo   string
}

func unpackTeamsRemoveRepoLegacyParams(packed map[string]any) (params TeamsRemoveRepoLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.Owner = packed["owner"].(string)
	params.Repo = packed["repo"].(string)
	return params
}

func decodeTeamsRemoveRepoLegacyParams(args [3]string, r *http.Request) (params TeamsRemoveRepoLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: owner.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "owner",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Owner = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: owner: parse")
			}
		} else {
			return params, errors.New("path: owner: not specified")
		}
	}
	// Decode path: repo.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "repo",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Repo = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: repo: parse")
			}
		} else {
			return params, errors.New("path: repo: not specified")
		}
	}
	return params, nil
}

// TeamsUpdateDiscussionCommentInOrgParams is parameters of teams/update-discussion-comment-in-org operation.
type TeamsUpdateDiscussionCommentInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug         string
	DiscussionNumber int
	CommentNumber    int
}

func unpackTeamsUpdateDiscussionCommentInOrgParams(packed map[string]any) (params TeamsUpdateDiscussionCommentInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.DiscussionNumber = packed["discussion_number"].(int)
	params.CommentNumber = packed["comment_number"].(int)
	return params
}

func decodeTeamsUpdateDiscussionCommentInOrgParams(args [4]string, r *http.Request) (params TeamsUpdateDiscussionCommentInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[3]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_number: parse")
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	return params, nil
}

// TeamsUpdateDiscussionCommentLegacyParams is parameters of teams/update-discussion-comment-legacy operation.
type TeamsUpdateDiscussionCommentLegacyParams struct {
	TeamID           int
	DiscussionNumber int
	CommentNumber    int
}

func unpackTeamsUpdateDiscussionCommentLegacyParams(packed map[string]any) (params TeamsUpdateDiscussionCommentLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.DiscussionNumber = packed["discussion_number"].(int)
	params.CommentNumber = packed["comment_number"].(int)
	return params
}

func decodeTeamsUpdateDiscussionCommentLegacyParams(args [3]string, r *http.Request) (params TeamsUpdateDiscussionCommentLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	// Decode path: comment_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "comment_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.CommentNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: comment_number: parse")
			}
		} else {
			return params, errors.New("path: comment_number: not specified")
		}
	}
	return params, nil
}

// TeamsUpdateDiscussionInOrgParams is parameters of teams/update-discussion-in-org operation.
type TeamsUpdateDiscussionInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug         string
	DiscussionNumber int
}

func unpackTeamsUpdateDiscussionInOrgParams(packed map[string]any) (params TeamsUpdateDiscussionInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	params.DiscussionNumber = packed["discussion_number"].(int)
	return params
}

func decodeTeamsUpdateDiscussionInOrgParams(args [3]string, r *http.Request) (params TeamsUpdateDiscussionInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[2]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

// TeamsUpdateDiscussionLegacyParams is parameters of teams/update-discussion-legacy operation.
type TeamsUpdateDiscussionLegacyParams struct {
	TeamID           int
	DiscussionNumber int
}

func unpackTeamsUpdateDiscussionLegacyParams(packed map[string]any) (params TeamsUpdateDiscussionLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	params.DiscussionNumber = packed["discussion_number"].(int)
	return params
}

func decodeTeamsUpdateDiscussionLegacyParams(args [2]string, r *http.Request) (params TeamsUpdateDiscussionLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	// Decode path: discussion_number.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "discussion_number",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.DiscussionNumber = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: discussion_number: parse")
			}
		} else {
			return params, errors.New("path: discussion_number: not specified")
		}
	}
	return params, nil
}

// TeamsUpdateInOrgParams is parameters of teams/update-in-org operation.
type TeamsUpdateInOrgParams struct {
	Org string
	// Team_slug parameter.
	TeamSlug string
}

func unpackTeamsUpdateInOrgParams(packed map[string]any) (params TeamsUpdateInOrgParams) {
	params.Org = packed["org"].(string)
	params.TeamSlug = packed["team_slug"].(string)
	return params
}

func decodeTeamsUpdateInOrgParams(args [2]string, r *http.Request) (params TeamsUpdateInOrgParams, _ error) {
	// Decode path: org.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "org",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Org = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: org: parse")
			}
		} else {
			return params, errors.New("path: org: not specified")
		}
	}
	// Decode path: team_slug.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_slug",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TeamSlug = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_slug: parse")
			}
		} else {
			return params, errors.New("path: team_slug: not specified")
		}
	}
	return params, nil
}

// TeamsUpdateLegacyParams is parameters of teams/update-legacy operation.
type TeamsUpdateLegacyParams struct {
	TeamID int
}

func unpackTeamsUpdateLegacyParams(packed map[string]any) (params TeamsUpdateLegacyParams) {
	params.TeamID = packed["team_id"].(int)
	return params
}

func decodeTeamsUpdateLegacyParams(args [1]string, r *http.Request) (params TeamsUpdateLegacyParams, _ error) {
	// Decode path: team_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "team_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TeamID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: team_id: parse")
			}
		} else {
			return params, errors.New("path: team_id: not specified")
		}
	}
	return params, nil
}

// UsersBlockParams is parameters of users/block operation.
type UsersBlockParams struct {
	Username string
}

func unpackUsersBlockParams(packed map[string]any) (params UsersBlockParams) {
	params.Username = packed["username"].(string)
	return params
}

func decodeUsersBlockParams(args [1]string, r *http.Request) (params UsersBlockParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// UsersCheckBlockedParams is parameters of users/check-blocked operation.
type UsersCheckBlockedParams struct {
	Username string
}

func unpackUsersCheckBlockedParams(packed map[string]any) (params UsersCheckBlockedParams) {
	params.Username = packed["username"].(string)
	return params
}

func decodeUsersCheckBlockedParams(args [1]string, r *http.Request) (params UsersCheckBlockedParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// UsersCheckFollowingForUserParams is parameters of users/check-following-for-user operation.
type UsersCheckFollowingForUserParams struct {
	Username   string
	TargetUser string
}

func unpackUsersCheckFollowingForUserParams(packed map[string]any) (params UsersCheckFollowingForUserParams) {
	params.Username = packed["username"].(string)
	params.TargetUser = packed["target_user"].(string)
	return params
}

func decodeUsersCheckFollowingForUserParams(args [2]string, r *http.Request) (params UsersCheckFollowingForUserParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Decode path: target_user.
	{
		param := args[1]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "target_user",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TargetUser = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: target_user: parse")
			}
		} else {
			return params, errors.New("path: target_user: not specified")
		}
	}
	return params, nil
}

// UsersCheckPersonIsFollowedByAuthenticatedParams is parameters of users/check-person-is-followed-by-authenticated operation.
type UsersCheckPersonIsFollowedByAuthenticatedParams struct {
	Username string
}

func unpackUsersCheckPersonIsFollowedByAuthenticatedParams(packed map[string]any) (params UsersCheckPersonIsFollowedByAuthenticatedParams) {
	params.Username = packed["username"].(string)
	return params
}

func decodeUsersCheckPersonIsFollowedByAuthenticatedParams(args [1]string, r *http.Request) (params UsersCheckPersonIsFollowedByAuthenticatedParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// UsersDeleteGpgKeyForAuthenticatedParams is parameters of users/delete-gpg-key-for-authenticated operation.
type UsersDeleteGpgKeyForAuthenticatedParams struct {
	// Gpg_key_id parameter.
	GpgKeyID int
}

func unpackUsersDeleteGpgKeyForAuthenticatedParams(packed map[string]any) (params UsersDeleteGpgKeyForAuthenticatedParams) {
	params.GpgKeyID = packed["gpg_key_id"].(int)
	return params
}

func decodeUsersDeleteGpgKeyForAuthenticatedParams(args [1]string, r *http.Request) (params UsersDeleteGpgKeyForAuthenticatedParams, _ error) {
	// Decode path: gpg_key_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gpg_key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.GpgKeyID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: gpg_key_id: parse")
			}
		} else {
			return params, errors.New("path: gpg_key_id: not specified")
		}
	}
	return params, nil
}

// UsersDeletePublicSSHKeyForAuthenticatedParams is parameters of users/delete-public-ssh-key-for-authenticated operation.
type UsersDeletePublicSSHKeyForAuthenticatedParams struct {
	// Key_id parameter.
	KeyID int
}

func unpackUsersDeletePublicSSHKeyForAuthenticatedParams(packed map[string]any) (params UsersDeletePublicSSHKeyForAuthenticatedParams) {
	params.KeyID = packed["key_id"].(int)
	return params
}

func decodeUsersDeletePublicSSHKeyForAuthenticatedParams(args [1]string, r *http.Request) (params UsersDeletePublicSSHKeyForAuthenticatedParams, _ error) {
	// Decode path: key_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.KeyID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: key_id: parse")
			}
		} else {
			return params, errors.New("path: key_id: not specified")
		}
	}
	return params, nil
}

// UsersFollowParams is parameters of users/follow operation.
type UsersFollowParams struct {
	Username string
}

func unpackUsersFollowParams(packed map[string]any) (params UsersFollowParams) {
	params.Username = packed["username"].(string)
	return params
}

func decodeUsersFollowParams(args [1]string, r *http.Request) (params UsersFollowParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// UsersGetByUsernameParams is parameters of users/get-by-username operation.
type UsersGetByUsernameParams struct {
	Username string
}

func unpackUsersGetByUsernameParams(packed map[string]any) (params UsersGetByUsernameParams) {
	params.Username = packed["username"].(string)
	return params
}

func decodeUsersGetByUsernameParams(args [1]string, r *http.Request) (params UsersGetByUsernameParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// UsersGetContextForUserParams is parameters of users/get-context-for-user operation.
type UsersGetContextForUserParams struct {
	Username string
	// Identifies which additional information you'd like to receive about the person's hovercard. Can be
	// `organization`, `repository`, `issue`, `pull_request`. **Required** when using `subject_id`.
	SubjectType OptUsersGetContextForUserSubjectType `json:",omitempty"`
	// Uses the ID for the `subject_type` you specified. **Required** when using `subject_type`.
	SubjectID OptString `json:",omitempty"`
}

func unpackUsersGetContextForUserParams(packed map[string]any) (params UsersGetContextForUserParams) {
	params.Username = packed["username"].(string)
	if v, ok := packed["subject_type"]; ok {
		params.SubjectType = v.(OptUsersGetContextForUserSubjectType)
	}
	if v, ok := packed["subject_id"]; ok {
		params.SubjectID = v.(OptString)
	}
	return params
}

func decodeUsersGetContextForUserParams(args [1]string, r *http.Request) (params UsersGetContextForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Decode query: subject_type.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "subject_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSubjectTypeVal UsersGetContextForUserSubjectType
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSubjectTypeVal = UsersGetContextForUserSubjectType(c)
					return nil
				}(); err != nil {
					return err
				}
				params.SubjectType.SetTo(paramsDotSubjectTypeVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: subject_type: parse")
			}
			if err := func() error {
				if params.SubjectType.Set {
					if err := func() error {
						if err := params.SubjectType.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: subject_type: invalid")
			}
		}
	}
	// Decode query: subject_id.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "subject_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSubjectIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSubjectIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SubjectID.SetTo(paramsDotSubjectIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: subject_id: parse")
			}
		}
	}
	return params, nil
}

// UsersGetGpgKeyForAuthenticatedParams is parameters of users/get-gpg-key-for-authenticated operation.
type UsersGetGpgKeyForAuthenticatedParams struct {
	// Gpg_key_id parameter.
	GpgKeyID int
}

func unpackUsersGetGpgKeyForAuthenticatedParams(packed map[string]any) (params UsersGetGpgKeyForAuthenticatedParams) {
	params.GpgKeyID = packed["gpg_key_id"].(int)
	return params
}

func decodeUsersGetGpgKeyForAuthenticatedParams(args [1]string, r *http.Request) (params UsersGetGpgKeyForAuthenticatedParams, _ error) {
	// Decode path: gpg_key_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "gpg_key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.GpgKeyID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: gpg_key_id: parse")
			}
		} else {
			return params, errors.New("path: gpg_key_id: not specified")
		}
	}
	return params, nil
}

// UsersGetPublicSSHKeyForAuthenticatedParams is parameters of users/get-public-ssh-key-for-authenticated operation.
type UsersGetPublicSSHKeyForAuthenticatedParams struct {
	// Key_id parameter.
	KeyID int
}

func unpackUsersGetPublicSSHKeyForAuthenticatedParams(packed map[string]any) (params UsersGetPublicSSHKeyForAuthenticatedParams) {
	params.KeyID = packed["key_id"].(int)
	return params
}

func decodeUsersGetPublicSSHKeyForAuthenticatedParams(args [1]string, r *http.Request) (params UsersGetPublicSSHKeyForAuthenticatedParams, _ error) {
	// Decode path: key_id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "key_id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.KeyID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: key_id: parse")
			}
		} else {
			return params, errors.New("path: key_id: not specified")
		}
	}
	return params, nil
}

// UsersListParams is parameters of users/list operation.
type UsersListParams struct {
	// A user ID. Only return users with an ID greater than this ID.
	Since OptInt `json:",omitempty"`
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
}

func unpackUsersListParams(packed map[string]any) (params UsersListParams) {
	if v, ok := packed["since"]; ok {
		params.Since = v.(OptInt)
	}
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	return params
}

func decodeUsersListParams(args [0]string, r *http.Request) (params UsersListParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: since.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSinceVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotSinceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Since.SetTo(paramsDotSinceVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: since: parse")
			}
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	return params, nil
}

// UsersListEmailsForAuthenticatedParams is parameters of users/list-emails-for-authenticated operation.
type UsersListEmailsForAuthenticatedParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackUsersListEmailsForAuthenticatedParams(packed map[string]any) (params UsersListEmailsForAuthenticatedParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeUsersListEmailsForAuthenticatedParams(args [0]string, r *http.Request) (params UsersListEmailsForAuthenticatedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// UsersListFollowedByAuthenticatedParams is parameters of users/list-followed-by-authenticated operation.
type UsersListFollowedByAuthenticatedParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackUsersListFollowedByAuthenticatedParams(packed map[string]any) (params UsersListFollowedByAuthenticatedParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeUsersListFollowedByAuthenticatedParams(args [0]string, r *http.Request) (params UsersListFollowedByAuthenticatedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// UsersListFollowersForAuthenticatedUserParams is parameters of users/list-followers-for-authenticated-user operation.
type UsersListFollowersForAuthenticatedUserParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackUsersListFollowersForAuthenticatedUserParams(packed map[string]any) (params UsersListFollowersForAuthenticatedUserParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeUsersListFollowersForAuthenticatedUserParams(args [0]string, r *http.Request) (params UsersListFollowersForAuthenticatedUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// UsersListFollowersForUserParams is parameters of users/list-followers-for-user operation.
type UsersListFollowersForUserParams struct {
	Username string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackUsersListFollowersForUserParams(packed map[string]any) (params UsersListFollowersForUserParams) {
	params.Username = packed["username"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeUsersListFollowersForUserParams(args [1]string, r *http.Request) (params UsersListFollowersForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// UsersListFollowingForUserParams is parameters of users/list-following-for-user operation.
type UsersListFollowingForUserParams struct {
	Username string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackUsersListFollowingForUserParams(packed map[string]any) (params UsersListFollowingForUserParams) {
	params.Username = packed["username"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeUsersListFollowingForUserParams(args [1]string, r *http.Request) (params UsersListFollowingForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// UsersListGpgKeysForAuthenticatedParams is parameters of users/list-gpg-keys-for-authenticated operation.
type UsersListGpgKeysForAuthenticatedParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackUsersListGpgKeysForAuthenticatedParams(packed map[string]any) (params UsersListGpgKeysForAuthenticatedParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeUsersListGpgKeysForAuthenticatedParams(args [0]string, r *http.Request) (params UsersListGpgKeysForAuthenticatedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// UsersListGpgKeysForUserParams is parameters of users/list-gpg-keys-for-user operation.
type UsersListGpgKeysForUserParams struct {
	Username string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackUsersListGpgKeysForUserParams(packed map[string]any) (params UsersListGpgKeysForUserParams) {
	params.Username = packed["username"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeUsersListGpgKeysForUserParams(args [1]string, r *http.Request) (params UsersListGpgKeysForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// UsersListPublicEmailsForAuthenticatedParams is parameters of users/list-public-emails-for-authenticated operation.
type UsersListPublicEmailsForAuthenticatedParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackUsersListPublicEmailsForAuthenticatedParams(packed map[string]any) (params UsersListPublicEmailsForAuthenticatedParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeUsersListPublicEmailsForAuthenticatedParams(args [0]string, r *http.Request) (params UsersListPublicEmailsForAuthenticatedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// UsersListPublicKeysForUserParams is parameters of users/list-public-keys-for-user operation.
type UsersListPublicKeysForUserParams struct {
	Username string
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackUsersListPublicKeysForUserParams(packed map[string]any) (params UsersListPublicKeysForUserParams) {
	params.Username = packed["username"].(string)
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeUsersListPublicKeysForUserParams(args [1]string, r *http.Request) (params UsersListPublicKeysForUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// UsersListPublicSSHKeysForAuthenticatedParams is parameters of users/list-public-ssh-keys-for-authenticated operation.
type UsersListPublicSSHKeysForAuthenticatedParams struct {
	// Results per page (max 100).
	PerPage OptInt `json:",omitempty"`
	// Page number of the results to fetch.
	Page OptInt `json:",omitempty"`
}

func unpackUsersListPublicSSHKeysForAuthenticatedParams(packed map[string]any) (params UsersListPublicSSHKeysForAuthenticatedParams) {
	if v, ok := packed["per_page"]; ok {
		params.PerPage = v.(OptInt)
	}
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	return params
}

func decodeUsersListPublicSSHKeysForAuthenticatedParams(args [0]string, r *http.Request) (params UsersListPublicSSHKeysForAuthenticatedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: per_page.
	{
		val := int(30)
		params.PerPage.SetTo(val)
	}
	// Decode query: per_page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.PerPage.SetTo(paramsDotPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: per_page: parse")
			}
		}
	}
	// Set default value for query: page.
	{
		val := int(1)
		params.Page.SetTo(val)
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	return params, nil
}

// UsersUnblockParams is parameters of users/unblock operation.
type UsersUnblockParams struct {
	Username string
}

func unpackUsersUnblockParams(packed map[string]any) (params UsersUnblockParams) {
	params.Username = packed["username"].(string)
	return params
}

func decodeUsersUnblockParams(args [1]string, r *http.Request) (params UsersUnblockParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}

// UsersUnfollowParams is parameters of users/unfollow operation.
type UsersUnfollowParams struct {
	Username string
}

func unpackUsersUnfollowParams(packed map[string]any) (params UsersUnfollowParams) {
	params.Username = packed["username"].(string)
	return params
}

func decodeUsersUnfollowParams(args [1]string, r *http.Request) (params UsersUnfollowParams, _ error) {
	// Decode path: username.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "username",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Username = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: username: parse")
			}
		} else {
			return params, errors.New("path: username: not specified")
		}
	}
	return params, nil
}
